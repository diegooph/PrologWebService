CREATE OR REPLACE FUNCTION FUNC_MARCACAO_CALCULA_TOTAL_SEGUNDOS_EM_HORAS_NOTURNAS(
  F_DATA_HORA_INICIO      TIMESTAMPTZ,
  F_DATA_HORA_FIM         TIMESTAMPTZ,
  F_TIMEZONE_PARA_CALCULO TEXT)
  RETURNS BIGINT
LANGUAGE PLPGSQL
AS $$
DECLARE
  RANGE_INICIO_FIM     TSTZRANGE;
  TOTAL_HORAS_NOTURNAS BIGINT;
  DATA_HORA_INICIO_TZ  TIMESTAMPTZ := F_DATA_HORA_INICIO AT TIME ZONE F_TIMEZONE_PARA_CALCULO;
  DATA_HORA_FIM_TZ     TIMESTAMPTZ := F_DATA_HORA_FIM AT TIME ZONE F_TIMEZONE_PARA_CALCULO;
BEGIN
  -- O range não pode ter o lower bound após o upper bound, por isso essa verificação.
  IF F_DATA_HORA_INICIO < F_DATA_HORA_FIM
  THEN
    RANGE_INICIO_FIM := TSTZRANGE(DATA_HORA_INICIO_TZ, DATA_HORA_FIM_TZ);
  ELSE
    RANGE_INICIO_FIM := TSTZRANGE(DATA_HORA_FIM_TZ, DATA_HORA_INICIO_TZ);
  END IF;

  WITH DIAS AS (
      SELECT GENERATE_SERIES(DATA_HORA_INICIO_TZ :: DATE,
                             DATA_HORA_FIM_TZ :: DATE + '1 DAY' :: INTERVAL,
                             '1 DAY') :: DATE AS DIA
  ), RANGES AS (
      SELECT *
      FROM DIAS
        CROSS JOIN TSTZRANGE(((DIAS.DIA :: DATE || ' 22:00:00') :: TIMESTAMP) AT TIME ZONE
                             F_TIMEZONE_PARA_CALCULO - '1 DAY' :: INTERVAL,
                             ((DIAS.DIA :: DATE || ' 05:00:00') :: TIMESTAMP) AT TIME ZONE
                             F_TIMEZONE_PARA_CALCULO) AS RANGE_VERIFICACAO_DIA
  )

  SELECT SUM(TO_SECONDS(COALESCE(UPPER(R.I) - LOWER(R.I), '0' :: INTERVAL)))
  FROM
    (SELECT
       *,
       RANGE_INICIO_FIM * R.RANGE_VERIFICACAO_DIA AS I
     FROM RANGES R) R
  INTO TOTAL_HORAS_NOTURNAS;

  RETURN TOTAL_HORAS_NOTURNAS;
END;
$$;