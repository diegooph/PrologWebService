create sequence public.query_progress_1;

create sequence public.query_progress_2;

-- Unknown how to generate base type type

create type public.prolog_impacto_permissao_type as enum ('BAIXO', 'MEDIO', 'ALTO', 'CRITICO');

create type public.pneu_desgaste_irregular_type as enum ('DESGASTE_DIAGONAL', 'DESGASTE_ASSIMETRICO', 'DESGASTE_OMBROS_BANDA_RODAGEM', 'DESGASTE_CENTRALIZADO', 'DESGASTE_IRREGULAR_BLOCOS', 'DESGASTE_ACENTUADO_UM_OMBRO_PNEU', 'DESGASTE_DEGRAUS');

create type public.pneu_status_type as enum ('ESTOQUE', 'EM_USO', 'ANALISE', 'DESCARTE');

create type public.pneu_desgaste_irregular_nivel_type as enum ('BAIXO', 'MODERADO', 'ACENTUADO');

create type public.tipo_processo_transferencia_pneu as enum ('TRANSFERENCIA_APENAS_PNEUS', 'TRANSFERENCIA_JUNTO_A_VEICULO');

-- Unknown how to generate base type type

create type messaging.aplicacao_referencia_token_type as enum ('PROLOG_ANDROID_DEBUG', 'PROLOG_ANDROID_PROD', 'PROLOG_WEB', 'AFERE_FACIL_ANDROID_DEBUG', 'AFERE_FACIL_ANDROID_PROD');

create type messaging.push_message_type as enum ('MULTICAST');

create type messaging.push_plataform_destination as enum ('ANDROID');

create type public.socorro_rota_status_type as enum ('ABERTO', 'EM_ATENDIMENTO', 'INVALIDO', 'FINALIZADO');

create domain public.email as citext
    constraint email_check check (VALUE ~
                                  '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$'::citext);

create or replace function public.format_timestamp(ts_tz timestamp without time zone, ts_fortmat text,
                                                   value_if_null text DEFAULT NULL::text) returns text
    immutable
    language plpgsql
as
$$
BEGIN
    RETURN COALESCE(TO_CHAR(TS_TZ, TS_FORTMAT), VALUE_IF_NULL);
END;
$$;    

create or replace function public.f_if(boolean, anyelement, anyelement) returns anyelement
    language plpgsql
as
$$
BEGIN
    CASE WHEN ($1)
        THEN
            RETURN ($2);
        ELSE
            RETURN ($3);
        END CASE;
END;
$$;    

create or replace function public.tz_date(timestamp with time zone, text) returns date
    stable
    strict
    language plpgsql
as
$$
BEGIN
    RETURN ($1 AT TIME ZONE $2) :: DATE;
END;
$$;    

create or replace function public.tz_unidade(f_cod_unidade bigint) returns text
    stable
    strict
    language plpgsql
as
$$
DECLARE
    TZ TEXT;
BEGIN
    SELECT TIMEZONE FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE INTO TZ;
    RETURN TZ;
END;
$$;

create or replace function public.func_pneu_calcula_sulco_restante(f_vida_atual_pneu integer,
                                                                   f_vidas_total_pneu integer, f_sulco_1 real,
                                                                   f_sulco_2 real, f_sulco_3 real, f_sulco_4 real,
                                                                   f_sulco_minimo_recapagem real,
                                                                   f_sulco_minimo_descarte real) returns real
    language plpgsql
as
$$
DECLARE
    SULCO_MININO REAL;
BEGIN
    IF F_VIDA_ATUAL_PNEU > F_VIDAS_TOTAL_PNEU
    THEN
        RAISE EXCEPTION 'A vida atual do pneu não pode ser maior do que o total de vidas';
    END IF;

    SULCO_MININO := CASE
                        WHEN F_VIDA_ATUAL_PNEU < F_VIDAS_TOTAL_PNEU
                            THEN F_SULCO_MINIMO_RECAPAGEM
                        WHEN F_VIDA_ATUAL_PNEU = F_VIDAS_TOTAL_PNEU
                            THEN F_SULCO_MINIMO_DESCARTE
        END;
    RETURN LEAST(F_SULCO_1, F_SULCO_2, F_SULCO_3, F_SULCO_4) - SULCO_MININO;
END;
$$;

create or replace function public.to_minutes_trunc(t interval) returns bigint
    language plpgsql
as
$$
DECLARE
    _MINUTES BIGINT;
BEGIN
    SELECT ((EXTRACT(EPOCH FROM T)) / 60) :: BIGINT
    INTO _MINUTES;
    RETURN _MINUTES;
END;
$$;

create or replace function public.to_seconds(t interval) returns bigint
    language plpgsql
as
$$
DECLARE
    seconds INTEGER;
BEGIN
    SELECT (EXTRACT(EPOCH from t))::BIGINT INTO seconds;
    RETURN seconds;
END;
$$;

create or replace function public.to_seconds(t text) returns integer
    language plpgsql
as
$$
DECLARE
    hs INTEGER;
    ms INTEGER;
    s  INTEGER;
BEGIN
    SELECT (EXTRACT(HOUR FROM t::time) * 60 * 60)::INTEGER INTO hs;
    SELECT (EXTRACT(MINUTES FROM t::time) * 60)::INTEGER INTO ms;
    SELECT (EXTRACT(SECONDS from t::time))::INTEGER INTO s;
    SELECT (hs + ms + s) INTO s;
    RETURN s;
END;
$$;

create or replace function public.to_seconds_trunc(t interval) returns bigint
    language plpgsql
as
$$
DECLARE
    _SECONDS BIGINT;
BEGIN
    SELECT (EXTRACT(EPOCH FROM T)) :: BIGINT
    INTO _SECONDS;
    RETURN _SECONDS;
END;
$$;

create table if not exists public.afericao_alternativa_manutencao_inspecao
(
    codigo       bigserial    not null
        constraint pk_afericao_afericao_alternativa_manutencao_inspecao
            primary key,
    alternativa  varchar(255) not null,
    status_ativo boolean      not null
);

comment on table public.afericao_alternativa_manutencao_inspecao is 'Alternativas para selecionar quando for consertar um item de inspeção';

create table if not exists public.app_version
(
    version_code   integer      not null
        constraint pk_app_version
            primary key,
    version_name   varchar(255) not null,
    data_liberacao date         not null
);

comment on table public.app_version is 'Armazena as versões do app';

create table if not exists public.dimensao_pneu
(
    codigo  bigserial not null
        constraint pk_dimensao_pneu
            primary key,
    altura  integer   not null,
    largura integer   not null,
    aro     real      not null,
    constraint unique_dimensao_pneu
        unique (altura, largura, aro)
);

comment on table public.dimensao_pneu is 'Dimensão (ou medidas) do pneu Ex.: 195/50 R15  195 = largura | 50 = altura | 15 = aro';

create table if not exists public.eixos_veiculo
(
    codigo    bigserial    not null
        constraint pk_eixos_veiculo
            primary key,
    nome      varchar(255) not null,
    dianteiro integer      not null,
    traseiro  integer      not null
);

comment on table public.eixos_veiculo is 'Tipos de carrocerias e suas quantidades de eixos';

comment on column public.eixos_veiculo.dianteiro is 'Quantidade de eixos dianteiros';

comment on column public.eixos_veiculo.traseiro is 'Quantidade de eixos traseiros';

create table if not exists public.empresa
(
    codigo             bigserial    not null
        constraint pk_empresa
            primary key,
    nome               varchar(255) not null,
    logo_thumbnail_url text,
    data_hora_cadastro timestamp with time zone default now()
);

comment on table public.empresa is 'Empresas clientes';

create table if not exists public.gsd_perguntas
(
    codigo   bigserial    not null
        constraint pk_gsd_perguntas
            primary key,
    pergunta text         not null,
    tipo     varchar(255) not null
);

comment on table public.gsd_perguntas is 'Perguntas de um GSD';

create table if not exists public.marca_pneu
(
    codigo bigserial    not null
        constraint pk_marca_pneu
            primary key,
    nome   varchar(255) not null
        constraint unique_nome_marca_pneu
            unique
);

comment on table public.marca_pneu is 'Marca do pneu Ex.: Michelin, Bridgestone ...';

create table if not exists public.marca_veiculo
(
    codigo bigserial    not null
        constraint pk_marca_veiculo
            primary key,
    nome   varchar(255) not null
);

comment on table public.marca_veiculo is 'Marca do veículo Ex.: Scania, Volvo, VW ...';

create table if not exists public.meta
(
    codigo bigserial    not null
        constraint pk_meta
            primary key,
    nome   varchar(255) not null
);

comment on table public.meta is 'DEPRECATED';

create table if not exists public.modelo_pneu
(
    codigo        bigserial          not null
        constraint pk_modelo_pneu
            primary key,
    nome          varchar(255)       not null,
    cod_marca     bigint             not null
        constraint fk_modelo_pneu_marca_pneu
            references public.marca_pneu,
    cod_empresa   bigint
        constraint fk_modelo_pneu_empresa
            references public.empresa,
    qt_sulcos     smallint default 4 not null
        constraint check_qtd_sulcos_modelo_pneu
            check ((qt_sulcos >= 1) AND (qt_sulcos <= 6)),
    altura_sulcos real               not null,
    constraint unique_modelo_pneu_empresa
        unique (cod_empresa, codigo)
);

comment on table public.modelo_pneu is 'Modelo do pneu Ex.: G685, HSR ...';

create table if not exists public.modelo_veiculo
(
    codigo      bigserial not null
        constraint pk_modelo_veiculo
            primary key,
    nome        citext    not null,
    cod_marca   bigint    not null
        constraint fk_modelo_veiculo_marca_veiculo
            references public.marca_veiculo,
    cod_empresa bigint
        constraint fk_modelo_veiculo_empresa
            references public.empresa,
    constraint nomes_unicos_por_empresa_e_marca
        unique (nome, cod_empresa, cod_marca),
    constraint unique_modelo_veiculo_empresa
        unique (codigo, cod_empresa)
);

comment on table public.modelo_veiculo is 'Modelo do veículo Ex.: 24220, Titan, 17180 ...';

create table if not exists public.pdv
(
    codigo bigserial    not null
        constraint pk_pdv
            primary key,
    nome   varchar(255) not null
        constraint unique_pdv_nome
            unique
);

comment on table public.pdv is 'Ponto de venda, cliente ambev';

create table if not exists public.permissao
(
    codigo    bigint       not null
        constraint pk_permissao
            primary key,
    permissao varchar(255) not null,
    descricao varchar(255) not null
);

comment on table public.permissao is 'Permissões de acesso as Regionais / Unidades / Salas';

create table if not exists public.pilar_prolog
(
    codigo bigint       not null
        constraint pk_pilar_prolog
            primary key,
    pilar  varchar(255) not null
);

comment on table public.pilar_prolog is 'Pilares do sistema, baseado no DPO';

create table if not exists public.checklist_alternativa_prioridade
(
    prioridade varchar(255) not null
        constraint pk_prioridade_pergunta_checklist
            primary key,
    prazo      integer      not null
);

comment on table public.checklist_alternativa_prioridade is 'Prioridade da pergunta, podendo ser alta, média ou baixa';

comment on column public.checklist_alternativa_prioridade.prazo is 'Prazo para resolução do item. Armazenado em horas';

create table if not exists public.regional
(
    codigo bigserial    not null
        constraint pk_regional
            primary key,
    regiao varchar(255) not null
);

comment on table public.regional is 'Regionais geográficas, separando as unidades de uma empresa';

create table if not exists public.unidade
(
    codigo              bigserial                              not null
        constraint pk_unidade
            primary key,
    nome                varchar(40)                            not null,
    total_colaboradores integer,
    cod_regional        bigint                                 not null
        constraint fk_unidade_regional
            references public.regional,
    cod_empresa         bigint                                 not null
        constraint fk_unidade_empresa
            references public.empresa,
    timezone            text                                   not null,
    data_hora_cadastro  timestamp with time zone default now() not null,
    status_ativo        boolean                  default true  not null,
    cod_auxiliar        text,
    latitude_unidade    text,
    longitude_unidade   text,
    constraint unica_unidade_empresa
        unique (codigo, cod_empresa)
);

comment on table public.unidade is 'Unidade de uma Empresa';

create or replace function public.func_get_time_zone_unidade(f_cod_unidade bigint)
    returns TABLE
            (
                timezone text
            )
    language sql
as
$$
SELECT TIMEZONE
FROM UNIDADE U
WHERE U.CODIGO = F_COD_UNIDADE;
$$;

create table if not exists public.checklist_modelo_data
(
    cod_unidade         bigint                not null
        constraint fk_checklist_modelo_unidade
            references public.unidade,
    codigo              bigserial             not null
        constraint pk_checklist_modelo
            primary key,
    nome                citext                not null,
    status_ativo        boolean               not null,
    deletado            boolean default false not null,
    data_hora_deletado  timestamp with time zone,
    pg_username_delecao text,
    cod_versao_atual    bigint                not null,
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.checklist_modelo_data is 'Modelos de checklist';

create unique index if not exists checklist_modelo_data_nome_index
    on public.checklist_modelo_data (cod_unidade, nome)
    where (status_ativo AND (NOT deletado));

create table if not exists public.equipe
(
    codigo      bigserial    not null
        constraint fk_equipe
            primary key,
    nome        varchar(255) not null,
    cod_unidade bigint       not null
        constraint fk_equipe_unidade
            references public.unidade,
    constraint unica_equipe_unidade
        unique (codigo, cod_unidade)
);

comment on table public.equipe is 'Equipe de uma unidade';

create table if not exists public.mapa
(
    data                           date,
    transp                         integer,
    entrega                        varchar(20),
    cargaatual                     varchar(20),
    frota                          varchar(20),
    custospot                      real,
    regiao                         integer,
    veiculo                        integer,
    placa                          varchar(7),
    veiculoindisp                  real,
    placaindisp                    real,
    frotaindisp                    real,
    tipoindisp                     integer,
    mapa                           integer not null,
    entregas                       integer,
    cxcarreg                       real,
    cxentreg                       real,
    ocupacao                       real,
    cxrota                         real,
    cxas                           real,
    veicbm                         real,
    rshow                          integer,
    entrvol                        varchar(20),
    hrsai                          timestamp,
    hrentr                         timestamp,
    kmsai                          integer,
    kmentr                         integer,
    custovariavel                  real,
    lucro                          real,
    lucrounit                      real,
    valorfrete                     real,
    tipoimposto                    varchar(20),
    percimposto                    real,
    valorimposto                   real,
    valorfaturado                  real,
    valorunitcxentregue            real,
    valorpgcxentregsemimp          real,
    valorpgcxentregcomimp          real,
    tempoprevistoroad              time,
    kmprevistoroad                 real,
    valorunitpontomot              real,
    valorunitpontoajd              real,
    valorequipeentrmot             real,
    valorequipeentrajd             real,
    custovariavelcedbz             real,
    lucrounitcedbz                 real,
    lucrovariavelcxentregueffcedbz real,
    tempointerno                   time,
    valordropdown                  real,
    veiccaddd                      varchar(20),
    kmlaco                         real,
    kmdeslocamento                 real,
    tempolaco                      time,
    tempodeslocamento              time,
    sitmulticdd                    real,
    unborigem                      integer,
    matricmotorista                integer,
    matricajud1                    integer,
    matricajud2                    integer,
    valorctedifere                 varchar(20),
    qtnfcarregadas                 integer,
    qtnfentregues                  integer,
    inddevcx                       real,
    inddevnf                       real,
    fator                          real,
    recarga                        varchar(20),
    hrmatinal                      time,
    hrjornadaliq                   time,
    hrmetajornada                  time,
    vlbateujornmot                 real,
    vlnaobateujornmot              real,
    vlrecargamot                   real,
    vlbateujornaju                 real,
    vlnaobateujornaju              real,
    vlrecargaaju                   real,
    vltotalmapa                    real,
    qthlcarregados                 real,
    qthlentregues                  real,
    indicedevhl                    real,
    regiao2                        varchar(20),
    qtnfcarreggeral                integer,
    qtnfentreggeral                integer,
    capacidadeveiculokg            real,
    pesocargakg                    real,
    cod_unidade                    bigint  not null
        constraint fk_mapa_unidade
            references public.unidade,
    data_hora_import               timestamp default now(),
    capacveiculocx                 integer,
    entregascompletas              integer,
    entregasparciais               integer,
    entregasnaorealizadas          integer,
    codfilial                      integer,
    nomefilial                     varchar(255),
    codsupervtrs                   integer,
    nomesupervtrs                  varchar(255),
    codspot                        integer,
    nomespot                       varchar(255),
    equipcarregados                integer,
    equipdevolvidos                integer,
    equiprecolhidos                integer,
    cxentregtracking               real,
    hrcarreg                       timestamp,
    hrpcfisica                     timestamp,
    hrpcfinanceira                 timestamp,
    stmapa                         varchar(255),
    classificacao_roadshow         text,
    data_entrega                   date,
    qt_entregas_carreg_rv          integer,
    qt_entregas_entreg_rv          integer,
    indice_dev_entregas            real,
    cpf_motorista                  bigint,
    cpf_ajudante_1                 bigint,
    cpf_ajudante_2                 bigint,
    inicio_rota                    timestamp,
    termino_rota                   timestamp,
    motorista_jt_12x36             varchar(255),
    retira                         varchar(255),
    constraint pk_mapa
        primary key (mapa, cod_unidade)
);

comment on table public.mapa is 'Mapas coletados da planilha ambev (2art). Contém todos os dados necessários para geração dos indicadores, produtividade, relatórios ...';

create index if not exists idx_mapa_cod_unidade
    on public.mapa (cod_unidade);

create table if not exists public.mapa_colaborador
(
    mapa        integer not null,
    cod_unidade integer not null
        constraint fk_mapa_unidade
            references public.unidade,
    cod_ambev   integer not null,
    constraint pk_mapa_colaborador
        primary key (mapa, cod_unidade, cod_ambev)
);

comment on table public.mapa_colaborador is 'Relaciona os mapas com os colaboradores que o realizaram';

comment on column public.mapa_colaborador.cod_ambev is 'Matricula ambev do colaborador';

create table if not exists public.relato_alternativa
(
    cod_unidade  bigint    not null
        constraint fk_relato_alternativa_unidade
            references public.unidade,
    codigo       bigserial not null,
    alternativa  varchar(255),
    status_ativo boolean   not null,
    cod_setor    bigint,
    constraint pk_relato_alternativa
        primary key (cod_unidade, codigo)
);

comment on table public.relato_alternativa is 'Alternativas para selecionar quando reportar um relato';

comment on column public.relato_alternativa.cod_setor is 'Código do setor que a alternativa estará disponível';

create table if not exists public.tracking
(
    classe                        integer,
    data                          date       not null,
    mapa                          integer    not null,
    placa                         varchar(7) not null,
    cod_cliente                   integer    not null,
    seq_real                      integer,
    seq_plan                      integer,
    inicio_rota                   time,
    "horário_matinal"             time,
    "saída_cdd"                   time,
    chegada_ao_pdv                time,
    tempo_prev_retorno            time,
    tempo_retorno                 time,
    dist_prev_retorno             real,
    dist_perc_retorno             real,
    inicio_entrega                time,
    fim_entrega                   time,
    fim_rota                      time,
    entrada_cdd                   time,
    caixas_carregadas             real,
    caixas_devolvidas             real,
    repasse                       real,
    tempo_de_entrega              time,
    tempo_descarga                time,
    tempo_espera                  time,
    "tempo_almoço"                time,
    tempo_total_de_rota           time,
    disp_apont_cadastrado         real,
    lat_entrega                   varchar(255),
    lon_entrega                   varchar(255),
    "unidade_negócio"             integer,
    transportadora                varchar(255),
    lat_cliente_apontamento       varchar(255),
    lon_cliente_apontamento       varchar(255),
    lat_atual_cliente             varchar(255),
    lon_atual_cliente             varchar(255),
    "distância_prev"              real,
    tempo_deslocamento            time,
    "vel_média_km_h"              real,
    "distância_perc_apontamento"  real,
    "aderência_sequencia_entrega" varchar(3),
    "aderência_janela_entrega"    varchar(3),
    pdv_lacrado                   varchar(3),
    "código_transportadora"       integer
        constraint fk_tracking_unidade
            references public.unidade,
    data_hora_import              timestamp default now(),
    constraint pk_tracking
        primary key (mapa, data, placa, cod_cliente)
);

comment on table public.tracking is 'Dados coletados da planilha ambev (aderência), usados para calcular o indicador tracking';

create table if not exists public.setor
(
    codigo      bigserial    not null,
    cod_unidade bigint       not null
        constraint fk_setor_unidade
            references public.unidade,
    nome        varchar(255) not null,
    constraint pk_setor
        primary key (codigo, cod_unidade)
);

comment on table public.setor is 'Setores que uma unidade possui. Ex.: Administrativo, Operacional, Armazém, Puxada ...';

create table if not exists public.colaborador_data
(
    cpf                  bigint                                 not null
        constraint pk_colaborador
            primary key,
    matricula_ambev      integer,
    matricula_trans      integer,
    data_nascimento      date                                   not null,
    data_admissao        date                                   not null,
    data_demissao        date,
    status_ativo         boolean                  default true  not null,
    nome                 varchar(255)                           not null,
    cod_equipe           bigint                                 not null,
    cod_funcao           integer                                not null,
    cod_unidade          integer                                not null,
    cod_permissao        bigint                                 not null
        constraint fk_colaborador_permissao
            references public.permissao,
    cod_empresa          bigint                                 not null
        constraint fk_colaborador_empresa
            references public.empresa,
    cod_setor            bigint                                 not null,
    pis                  varchar(11),
    data_hora_cadastro   timestamp with time zone default now(),
    codigo               bigserial                              not null
        constraint unique_codigo_colaborador
            unique,
    cod_unidade_cadastro integer                                not null
        constraint fk_colaborador_unidade_cadastro
            references public.unidade,
    deletado             boolean                  default false not null,
    data_hora_deletado   timestamp with time zone,
    pg_username_delecao  text,
    constraint fk_colaborador_equipe
        foreign key (cod_unidade, cod_equipe) references public.equipe (cod_unidade, codigo),
    constraint fk_colaborador_setor
        foreign key (cod_unidade, cod_setor) references public.setor (cod_unidade, codigo),
    constraint fk_colaborador_unidade
        foreign key (cod_empresa, cod_unidade) references public.unidade (cod_empresa, codigo),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.colaborador_data is 'Cadastro dos olaboradores que utilizam o sistema';

comment on column public.colaborador_data.matricula_ambev is 'Matrícula utilizada no sistema Promax da ambev';

comment on column public.colaborador_data.matricula_trans is 'Matrícula utilizada no sistema do cliente';

comment on column public.colaborador_data.cod_unidade_cadastro is 'O código da unidade onde o colaborador foi primeiramente cadastrado.
Essa coluna é sempre preenchida no insert com o valor de cod_unidade e ela não utiliza FK composta com unidade usando
cod_empresa pois um colaborador pode trocar de empresa.';

create index if not exists idx_colaborador_cod_unidade
    on public.colaborador_data (cod_unidade);

create table if not exists public.pneu_restricao_unidade
(
    cod_empresa                        bigint                   not null
        constraint fk_empresa_restricao_empresa
            references public.empresa,
    cod_unidade                        bigint                   not null
        constraint fk_empresa_restricao_unidade
            references public.unidade,
    tolerancia_calibragem              real                     not null,
    sulco_minimo_recapagem             real                     not null,
    sulco_minimo_descarte              real                     not null,
    tolerancia_inspecao                real                     not null,
    periodo_afericao_pressao           integer                  not null,
    periodo_afericao_sulco             integer                  not null,
    codigo                             bigserial                not null
        constraint pk_pneu_restricao_unidade
            primary key,
    cod_colaborador_ultima_atualizacao bigint
        constraint fk_pneu_restricao_unidade_colaborador_codigo
            references public.colaborador_data (codigo),
    data_hora_ultima_atualizacao       timestamp with time zone not null,
    constraint unique_restricao_unidade_empresa
        unique (cod_empresa, cod_unidade)
);

comment on table public.pneu_restricao_unidade is 'Parâmetros para configurar a parte de pneus';

comment on column public.pneu_restricao_unidade.tolerancia_calibragem is 'Tolerância para abrir um serviço de calibragem';

comment on column public.pneu_restricao_unidade.sulco_minimo_recapagem is 'Sulco mínimo para recapar um pneu, utilizado quando o mesmo ainda não chegou na última vida';

comment on column public.pneu_restricao_unidade.sulco_minimo_descarte is 'Sulco mínimo para descartar um pneu, utilizado quando o mesmo está na última vida';

comment on column public.pneu_restricao_unidade.tolerancia_inspecao is 'Tolerância para abrir um serviço de inspeção';

comment on column public.pneu_restricao_unidade.periodo_afericao_pressao is 'Período entre aferições de uma mesma placa, utilizado para montar o cronograma';

create table if not exists public.funcao_data
(
    codigo                 bigserial             not null
        constraint pk_funcao
            primary key,
    nome                   citext                not null
        constraint nome_limite_caracteres
            check (char_length((nome)::text) <= 40),
    cod_empresa            bigint                not null
        constraint funcao_empresa_codigo_fk
            references public.empresa,
    deletado               boolean default false not null,
    data_hora_deletado     timestamp with time zone,
    data_hora_update       timestamp with time zone,
    cod_colaborador_update bigint
        constraint fk_funcao_data_cod_colaborador_update
            references public.colaborador_data (codigo),
    pg_username_delecao    text,
    constraint unica_funcao_empresa
        unique (codigo, cod_empresa),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.funcao_data is 'Cargos que uma empresa possui';

create table if not exists public.checklist_modelo_funcao
(
    cod_unidade          bigint not null,
    cod_checklist_modelo bigint not null
        constraint fk_checklist_modelo_funcao_modelo
            references public.checklist_modelo_data,
    cod_funcao           bigint not null
        constraint fk_checklist_modelo_funcao_funcao
            references public.funcao_data,
    constraint pk_checklist_modelo_funcao
        primary key (cod_unidade, cod_checklist_modelo, cod_funcao)
);

comment on table public.checklist_modelo_funcao is 'Relaciona funções (cargos) a um modelo de checklist';

alter table public.colaborador_data
    add constraint fk_colaborador_funcao
        foreign key (cod_empresa, cod_funcao) references public.funcao_data (cod_empresa, codigo);

create unique index if not exists unique_cargo_empresa
    on public.funcao_data (nome, cod_empresa)
    where (deletado IS FALSE);

create table if not exists public.relato
(
    codigo                  bigserial                not null
        constraint pk_relato
            primary key,
    data_hora_local         timestamp with time zone not null,
    data_hora_database      timestamp with time zone not null,
    latitude                varchar(255)             not null,
    longitude               varchar(255)             not null,
    url_foto_1              text                     not null,
    url_foto_2              text,
    url_foto_3              text,
    cpf_colaborador         bigint                   not null
        constraint fk_relato_colaborador
            references public.colaborador_data,
    cpf_classificacao       bigint
        constraint fk_relato_colaborador_classificacao
            references public.colaborador_data,
    data_hora_classificacao timestamp with time zone,
    cpf_fechamento          bigint
        constraint fk_relato_colaborador_fechamento
            references public.colaborador_data,
    data_hora_fechamento    timestamp with time zone,
    feedback_fechamento     text,
    status                  varchar(255)             not null,
    cod_unidade             bigint                   not null
        constraint fk_relato_unidade
            references public.unidade,
    cod_setor               bigint                   not null,
    cod_alternativa         bigint                   not null,
    resposta_outros         text,
    cod_pdv                 integer,
    versao_app              integer,
    constraint fk_relato_relato_alternativa
        foreign key (cod_alternativa, cod_unidade) references public.relato_alternativa (codigo, cod_unidade),
    constraint fk_relato_setor
        foreign key (cod_setor, cod_unidade) references public.setor
);

comment on table public.relato is 'Relatos de segurança';

comment on column public.relato.data_hora_local is 'Data e hora do smartphone no momento do envio';

comment on column public.relato.data_hora_database is 'Data e hora do servidor no momento do recebimento';

comment on column public.relato.resposta_outros is 'Resposta descritiva quando a alternativa selecionada é "Outros"';

comment on column public.relato.versao_app is 'Optamos por não colocar FK para a tabela APP_VERSION para não correr o risco de algum relato não sincronizar por conta disso';

create table if not exists public.solicitacao_folga
(
    codigo                 serial       not null
        constraint pk_solicitacao_folga
            primary key,
    cpf_colaborador        bigint       not null
        constraint fk_solicitacao_folga_colaborador
            references public.colaborador_data,
    cpf_feedback           bigint
        constraint fk_solicitacao_folga_colaborador_feedback
            references public.colaborador_data,
    data_solicitacao       date         not null,
    data_folga             date         not null,
    data_feedback          date,
    motivo_folga           text         not null,
    justificativa_feedback text,
    status                 varchar(255) not null,
    periodo                varchar(255) not null
);

comment on table public.solicitacao_folga is 'Solicitação de folga';

comment on column public.solicitacao_folga.periodo is 'Período da folga solicitada';

create table if not exists public.token_autenticacao
(
    cpf_colaborador bigint       not null
        constraint fk_token_autenticacao_colaborador
            references public.colaborador_data
            on update cascade on delete cascade,
    token           varchar(255) not null
        constraint pk_token_autenticacao
            primary key,
    data_hora       timestamp with time zone,
    cod_colaborador bigint       not null
        constraint fk_token_autenticacao_cod_colaborador
            references public.colaborador_data (codigo)
            on update cascade on delete cascade,
    constraint unique_colaborador_token
        unique (cod_colaborador, token)
);

comment on table public.token_autenticacao is 'Tokens de acesso, gerado quando o usuário loga em alguma das plataformas, deletado quando o mesmo realiza logout';

comment on column public.token_autenticacao.data_hora is 'Data e hora que o token foi gerado';

create table if not exists public.treinamento
(
    codigo             bigserial not null
        constraint pk_treinamento
            primary key,
    titulo             text      not null,
    descricao          text      not null,
    url_arquivo        text      not null,
    data_liberacao     date      not null,
    cod_unidade        bigint    not null
        constraint fk_treinamento_unidade
            references public.unidade,
    data_hora_cadastro timestamp with time zone,
    data_fechamento    date
);

comment on table public.treinamento is 'Treinamentos';

comment on column public.treinamento.data_liberacao is 'Data que o treinamento será disponibilizado para visualização';

comment on column public.treinamento.data_fechamento is 'A data a partir da qual esse treinamento não estará mais disponível para visualização.';

create table if not exists public.restricao_treinamento
(
    cod_treinamento bigint not null
        constraint fk_restricao_treinamento_treinamento
            references public.treinamento,
    cod_funcao      bigint not null
        constraint fk_restricao_treinamento_funcao
            references public.funcao_data,
    constraint pk_restricao_treinamento
        primary key (cod_treinamento, cod_funcao)
);

comment on table public.restricao_treinamento is 'Restrições aplicadas a cada treinamento. Permite que um treinamento seja visualizado apenas por determinadas funções (cargos)';

create table if not exists public.unidade_pilar_prolog
(
    cod_unidade bigint not null
        constraint fk_unidade_pilar_prolog_unidade
            references public.unidade,
    cod_pilar   bigint not null
        constraint fk_unidade_pilar_prolog_pilar_prolog
            references public.pilar_prolog,
    constraint pk_unidade_pilar_prolog
        primary key (cod_unidade, cod_pilar)
);

comment on table public.unidade_pilar_prolog is 'Relaciona a unidade com os pilares do ProLog';

create table if not exists public.log_json
(
    json          text,
    codigo        bigserial not null
        constraint log_json_pkey
            primary key,
    data_hora     timestamp with time zone default now(),
    identificador varchar(255)
);

create table if not exists public.calendario
(
    codigo      bigserial                not null
        constraint pk_calendario
            primary key,
    data        timestamp with time zone not null,
    descricao   varchar(255)             not null,
    cod_unidade bigint
        constraint fk_calendario_unidade
            references public.unidade,
    cod_funcao  bigint
        constraint fk_calendario_funcao
            references public.funcao_data,
    cod_equipe  bigint
        constraint fk_calendario_equipe
            references public.equipe,
    local       varchar(255)
);

comment on table public.calendario is 'Calendário, contém os eventos';

comment on column public.calendario.descricao is 'Descrição do evento';

comment on column public.calendario.cod_funcao is 'Funçao (cargo) que o evento estará visível';

comment on column public.calendario.cod_equipe is 'Equipe que o evento estará visível';

comment on column public.calendario.local is 'Local do evento';

create table if not exists public.aux_data
(
    data date
);

comment on table public.aux_data is 'Tabela auxiliar, contém todos os dias do ano';

create table if not exists public.fale_conosco
(
    codigo             bigserial                not null,
    cod_unidade        bigint                   not null
        constraint fk_fale_conosco_unidade
            references public.unidade,
    data_hora          timestamp with time zone not null,
    descricao          text                     not null,
    categoria          varchar(255)             not null,
    cpf_colaborador    bigint                   not null
        constraint fk_fale_conosco_colaborador
            references public.colaborador_data,
    data_hora_feedback timestamp with time zone,
    cpf_feedback       bigint
        constraint fk_fale_conosco_colaborador_feedback
            references public.colaborador_data,
    feedback           text,
    status             varchar(255),
    constraint pk_fale_conosco
        primary key (codigo, cod_unidade)
);

comment on table public.fale_conosco is 'Fale conosco enviados pelos colaboradores';

comment on column public.fale_conosco.categoria is 'Categoria que o fale conosco pode pertencer (sugestão ou reclamação)';

comment on column public.fale_conosco.data_hora_feedback is 'Data e hora que foi realizado o feedback';

comment on column public.fale_conosco.cpf_feedback is 'Cpf do colaborador que respondeu ao fale conosco';

comment on column public.fale_conosco.feedback is 'Retorno do conteúdo do fale conosco';

comment on column public.fale_conosco.status is 'Status que um fale conosco pode possuir (pendente ou respondido)';

create table if not exists public.unidade_valores_rm
(
    cod_unidade                            bigint not null
        constraint fk_unidade_valores_unidade
            references public.unidade,
    rm_motorista_valor_as_1_entrega        real,
    rm_motorista_valor_as_2_entregas       real,
    rm_ajudante_valor_as_1_entrega         real,
    rm_ajudante_valor_as_2_entregas        real,
    rm_motorista_valor_as_maior_2_entregas real,
    rm_ajudante_valor_as_maior_2_entregas  real,
    rm_motorista_valor_as_3_entregas       real,
    rm_ajudante_valor_as_3_entregas        real,
    rm_motorista_valor_as_maior_3_entregas real,
    rm_ajudante_valor_as_maior_3_entregas  real,
    rm_motorista_valor_as_recarga          real,
    rm_ajudante_valor_as_recarga           real,
    rm_motorista_valor_as_sem_ajudante     real
);

comment on table public.unidade_valores_rm is 'Valores de remuneração variável para os mapas de AS';

create table if not exists public.unidade_metas
(
    cod_unidade                bigint not null
        constraint pk_unidade_metas
            primary key
        constraint fk_unidade_valores_unidade
            references public.unidade,
    meta_dev_hl                real,
    meta_dev_pdv               real,
    meta_tracking              real,
    meta_raio_tracking         real,
    meta_tempo_largada_mapas   real,
    meta_tempo_rota_mapas      real,
    meta_tempo_interno_mapas   real,
    meta_jornada_liquida_mapas real,
    meta_tempo_largada_horas   time,
    meta_tempo_rota_horas      time,
    meta_tempo_interno_horas   time,
    meta_jornada_liquida_horas time,
    meta_caixa_viagem          real,
    meta_dispersao_km          real,
    meta_dispersao_tempo       real,
    meta_dev_nf                real
);

comment on table public.unidade_metas is 'Metas de uma unidade';

comment on column public.unidade_metas.meta_raio_tracking is 'A meta de raio do tracking, um valor em KM.';

create table if not exists public.acessos_produtividade
(
    cod_unidade        bigint                   not null
        constraint fk_acessos_produtividade_unidade
            references public.unidade,
    cpf_colaborador    bigint                   not null
        constraint fk_acessos_produtividade_colaborador
            references public.colaborador_data,
    data_hora_consulta timestamp with time zone not null,
    mes_ano_consultado varchar(255)             not null,
    constraint pk_acessos_produtividade
        primary key (cpf_colaborador, data_hora_consulta)
);

comment on table public.acessos_produtividade is 'Loga os acessos a produtividade';

comment on column public.acessos_produtividade.cpf_colaborador is 'Colaborador que realizou a consulta';

comment on column public.acessos_produtividade.data_hora_consulta is 'Data e hora que o colaborador realizou a consulta';

comment on column public.acessos_produtividade.mes_ano_consultado is 'Período buscado';

create table if not exists public.pre_contracheque_informacoes
(
    cod_unidade          bigint               not null
        constraint pk_pre_contracheque_informacoes
            primary key
        constraint fk_pre_contracheque_informacoes_unidade
            references public.unidade,
    cod_cargo_ajudante   bigint               not null,
    cod_cargo_motorista  bigint               not null,
    bonus_ajudante       real                 not null,
    bonus_motorista      real                 not null,
    indicador            varchar(255)         not null,
    recarga_parte_premio boolean default true not null
);

comment on table public.pre_contracheque_informacoes is 'Parâmetros do pré contracheque';

comment on column public.pre_contracheque_informacoes.cod_cargo_ajudante is 'Código do cargo de ajudante';

comment on column public.pre_contracheque_informacoes.cod_cargo_motorista is 'Código do cargo de motorista';

comment on column public.pre_contracheque_informacoes.bonus_ajudante is 'Bônus por nível de serviço';

comment on column public.pre_contracheque_informacoes.bonus_motorista is 'Bônus por nível de serviço';

comment on column public.pre_contracheque_informacoes.indicador is 'Indicador a ser utilizado para calcular o bônus por nível de serviço';

create table if not exists public.pre_contracheque_itens
(
    cod_unidade     bigint       not null
        constraint fk_pre_contracheque_itens_unidade
            references public.unidade,
    cpf_colaborador bigint       not null,
    mes_referencia  integer      not null,
    ano_referencia  integer      not null,
    codigo_item     varchar(255) not null,
    descricao       varchar(255) not null,
    sub_descricao   varchar(255),
    valor           real         not null,
    codigo          bigserial    not null
        constraint pk_pre_contracheque_itens
            primary key,
    constraint unique_item_pre_contracheque
        unique (cod_unidade, cpf_colaborador, mes_referencia, ano_referencia, codigo_item)
);

comment on table public.pre_contracheque_itens is 'Itens do pré contracheque';

create table if not exists public.quiz_modelo
(
    codigo                bigserial                not null,
    cod_unidade           bigint                   not null
        constraint fk_quiz_modelo_unidade
            references public.unidade
            on update cascade,
    nome                  varchar(255)             not null,
    descricao             text                     not null,
    data_hora_abertura    timestamp with time zone not null,
    data_hora_fechamento  timestamp with time zone not null,
    porcentagem_aprovacao real                     not null,
    constraint pk_quiz_modelo
        primary key (codigo, cod_unidade),
    constraint quiz_modelo_check
        check (data_hora_fechamento >= data_hora_abertura)
);

comment on table public.quiz_modelo is 'Modelos de quiz vínculados a uma unidade';

comment on column public.quiz_modelo.data_hora_abertura is 'Data e hora que o quiz será aberto para realização';

comment on column public.quiz_modelo.data_hora_fechamento is 'Data e hora que o quiz será fechado';

comment on column public.quiz_modelo.porcentagem_aprovacao is 'Porcentagem de perguntas que devem ser acertadas sobre o total';

create table if not exists public.quiz_perguntas
(
    cod_modelo  bigint default 92 not null,
    cod_unidade bigint default 95 not null,
    codigo      bigserial         not null,
    pergunta    text              not null,
    ordem       integer           not null,
    tipo        varchar(255)      not null,
    url_imagem  text,
    constraint pk_quiz_perguntas
        primary key (cod_modelo, cod_unidade, codigo),
    constraint fk_quiz_perguntas_quiz_modelo
        foreign key (cod_modelo, cod_unidade) references public.quiz_modelo
            on update cascade
);

comment on table public.quiz_perguntas is 'Perguntas de um quiz';

comment on column public.quiz_perguntas.cod_modelo is 'Modelo ao qual as perguntas pertencem';

comment on column public.quiz_perguntas.ordem is 'Ordem de exibição da pergunta';

comment on column public.quiz_perguntas.tipo is 'Tipo da pergunta, podendo ser de única escolha, múltipla escolha ou ordenamento';

create table if not exists public.quiz_alternativa_pergunta
(
    cod_modelo   bigint default 92 not null,
    cod_unidade  bigint default 95 not null,
    cod_pergunta bigint            not null,
    codigo       bigserial         not null,
    alternativa  text              not null,
    ordem        integer           not null,
    correta      boolean           not null,
    constraint pk_quiz_alternativa_perguntas
        primary key (cod_modelo, cod_unidade, cod_pergunta, codigo),
    constraint fk_quiz_alternativa_perguntas_quiz_perguntas
        foreign key (cod_modelo, cod_unidade, cod_pergunta) references public.quiz_perguntas
            on update cascade
);

comment on table public.quiz_alternativa_pergunta is 'Alternativas das perguntas de um quiz';

comment on column public.quiz_alternativa_pergunta.ordem is 'Ordem de exibição da alternativa';

comment on column public.quiz_alternativa_pergunta.correta is 'Flag que indica se essa é a alternativa correta';

create table if not exists public.quiz
(
    cod_modelo       bigint                   not null,
    cod_unidade      bigint                   not null,
    codigo           bigserial                not null,
    cpf_colaborador  bigint                   not null
        constraint fk_quiz_colaborador
            references public.colaborador_data
            on update cascade,
    data_hora        timestamp with time zone not null,
    tempo_realizacao bigint                   not null,
    qt_corretas      integer                  not null,
    qt_erradas       integer                  not null,
    constraint pk_quiz
        primary key (cod_modelo, cod_unidade, codigo),
    constraint fk_quiz_quiz_modelo
        foreign key (cod_unidade, cod_modelo) references public.quiz_modelo (cod_unidade, codigo)
            on update cascade
);

comment on table public.quiz is 'Quiz com perguntas e respostas';

comment on column public.quiz.data_hora is 'Data e hora da realização do quiz';

comment on column public.quiz.tempo_realizacao is 'Tempo de realização do quiz';

comment on column public.quiz.qt_corretas is 'Quantidade de respostas corretas que o usuário marcou';

comment on column public.quiz.qt_erradas is 'Quantidade de respostas erradas que o usuário marcou';

create table if not exists public.quiz_modelo_funcao
(
    cod_unidade            bigint not null,
    cod_modelo             bigint not null,
    cod_funcao_colaborador bigint not null
        constraint fk_quiz_modelo_funcao_funcao
            references public.funcao_data,
    constraint pk_quiz_modelo_funcao
        primary key (cod_unidade, cod_modelo, cod_funcao_colaborador),
    constraint fk_quiz_modelo_funcao_quiz_modelo
        foreign key (cod_unidade, cod_modelo) references public.quiz_modelo (cod_unidade, codigo)
            on update cascade
);

comment on table public.quiz_modelo_funcao is 'Relaciona um modelo de quiz com as funções (cargos) que podem acessar o mesmo';

create table if not exists public.quiz_respostas
(
    cod_modelo        bigint not null,
    cod_unidade       bigint not null,
    cod_quiz          bigint not null,
    cod_pergunta      bigint not null,
    cod_alternativa   bigint not null,
    ordem_selecionada integer,
    selecionada       boolean,
    constraint pk_quiz_respostas
        primary key (cod_modelo, cod_unidade, cod_quiz, cod_pergunta, cod_alternativa),
    constraint fk_quiz_respostas_quiz
        foreign key (cod_modelo, cod_unidade, cod_quiz) references public.quiz,
    constraint fk_quiz_respostas_quiz_alternativa_pergunta
        foreign key (cod_modelo, cod_unidade, cod_pergunta, cod_alternativa) references public.quiz_alternativa_pergunta
            on update cascade
);

comment on table public.quiz_respostas is 'Respostas de um quiz';

comment on column public.quiz_respostas.ordem_selecionada is 'Ordem que a alternativa foi colocada, usado em perguntas de ordenamento';

comment on column public.quiz_respostas.selecionada is 'Boolean que indica se a alternativa foi selecionada, usado em perguntas de única ou múltipla escolha';

create table if not exists public.quiz_modelo_treinamento
(
    cod_modelo_quiz bigint not null,
    cod_unidade     bigint not null
        constraint fk_quiz_modelo_treinamento_unidade
            references public.unidade
            on update cascade,
    cod_treinamento bigint not null
        constraint fk_quiz_modelo_treinamento_treinamento
            references public.treinamento,
    constraint pk_quiz_modelo_treinamento
        primary key (cod_modelo_quiz, cod_unidade, cod_treinamento),
    constraint fk_quiz_modelo_treinamento_quiz_modelo
        foreign key (cod_unidade, cod_modelo_quiz) references public.quiz_modelo (cod_unidade, codigo)
            on update cascade
);

comment on table public.quiz_modelo_treinamento is 'Relaciona um quiz com o treinamento do seu conteúdo';

create table if not exists public.treinamento_url_paginas
(
    cod_treinamento bigint       not null
        constraint fk_treinamento_url_paginas_treinamento
            references public.treinamento
            on update cascade,
    url             varchar(255) not null,
    ordem           integer      not null,
    cod_unidade     bigint,
    constraint pk_treinamento_url_paginas
        primary key (cod_treinamento, url)
);

comment on table public.treinamento_url_paginas is 'Url das páginas de um treinamento';

comment on column public.treinamento_url_paginas.url is 'Url da imagem da página';

comment on column public.treinamento_url_paginas.ordem is 'Ordem de exibição da página';

create table if not exists public.treinamento_colaborador
(
    cod_treinamento   bigint                   not null
        constraint fk_treinamento_colaborador_treinamento
            references public.treinamento,
    cpf_colaborador   bigint                   not null
        constraint fk_treinamento_colaborador_colaborador
            references public.colaborador_data,
    data_visualizacao timestamp with time zone not null,
    constraint pk_treinamento_colaborador
        primary key (cod_treinamento, cpf_colaborador, data_visualizacao)
);

comment on table public.treinamento_colaborador is 'Log de visualização de um treinamento';

comment on column public.treinamento_colaborador.data_visualizacao is 'Data e hora que o colaborador abriu o treinamento';

create table if not exists public.unidade_funcao_produtividade
(
    cod_unidade              bigint not null
        constraint fk_unidade_funcao_produtividade_unidade
            references public.unidade,
    cod_funcao_motorista     bigint not null,
    cod_funcao_ajudante      bigint not null,
    dia_inicio_produtividade integer
        constraint unidade_funcao_produtividade_check_dia
            check ((dia_inicio_produtividade >= 1) AND (dia_inicio_produtividade <= 28)),
    constraint pk_unidade_funcao_produtividade
        primary key (cod_unidade, cod_funcao_motorista, cod_funcao_ajudante),
    constraint unidade_funcao_produtividade_cod_unidade_cod_funcao_ajudant_key
        unique (cod_unidade, cod_funcao_ajudante),
    constraint unidade_funcao_produtividade_cod_unidade_cod_funcao_motoris_key
        unique (cod_unidade, cod_funcao_motorista)
);

comment on table public.unidade_funcao_produtividade is 'Indica quais os códigos dos cargos de motorista e ajudante de cada unidade. Usada em conjunto com a view MAPA_COLABORADOR para calcular a produtividade, indicadores e relatórios';

comment on column public.unidade_funcao_produtividade.cod_funcao_motorista is 'Código da funçao (cargo) de motorista';

comment on column public.unidade_funcao_produtividade.cod_funcao_ajudante is 'Código da funçao (cargo) de ajudante';

comment on column public.unidade_funcao_produtividade.dia_inicio_produtividade is 'Dia em que inicia um novo período de remuneração variável';

create table if not exists public.amazon_credentials
(
    access_key_id varchar(255) not null,
    secret_key    varchar(255) not null,
    user_id       varchar(255) not null
);

comment on table public.amazon_credentials is 'Armazena as credenciais do S3, usados para enviar fotos do android para a AWS';

create table if not exists public.marca_banda
(
    codigo      bigserial    not null,
    nome        varchar(255) not null,
    cod_empresa bigint       not null
        constraint fk_marca_banda_empresa
            references public.empresa,
    constraint pk_marca_banda
        primary key (codigo, cod_empresa),
    constraint unique_marca_banda
        unique (cod_empresa, nome)
);

comment on table public.marca_banda is 'Marca da banda Ex.: Tipler, Vipal ...';

create table if not exists public.modelo_banda
(
    codigo        bigserial          not null
        constraint pk_modelo_banda
            primary key,
    nome          varchar(255)       not null,
    cod_marca     bigint             not null,
    cod_empresa   bigint             not null
        constraint fk_modelo_banda_empresa
            references public.empresa,
    qt_sulcos     smallint default 4 not null
        constraint check_qtd_sulcos_modelo_banda
            check ((qt_sulcos >= 1) AND (qt_sulcos <= 6)),
    altura_sulcos real               not null,
    constraint unique_nome_modelo_banda_por_marca
        unique (cod_empresa, cod_marca, nome),
    constraint unique_modelo_banda_empresa
        unique (cod_empresa, codigo),
    constraint fk_modelo_banda_marca_banda
        foreign key (cod_marca, cod_empresa) references public.marca_banda
);

comment on table public.modelo_banda is 'Modelo da banda Ex.: G685, HSR ...';

create table if not exists public.pneu_data
(
    codigo_cliente               varchar(255)                           not null,
    cod_modelo                   bigint                                 not null,
    cod_dimensao                 bigint                                 not null
        constraint fk_pneu_dimensao
            references public.dimensao_pneu,
    pressao_recomendada          real                                   not null,
    pressao_atual                real,
    altura_sulco_interno         real,
    altura_sulco_central_interno real,
    altura_sulco_externo         real,
    cod_unidade                  bigint                                 not null
        constraint fk_pneu_unidade
            references public.unidade,
    status                       varchar(255)                           not null
        constraint check_status_validos
            check ((status)::text = ANY
                   (ARRAY [('EM_USO'::character varying)::text, ('ESTOQUE'::character varying)::text, ('ANALISE'::character varying)::text, ('DESCARTE'::character varying)::text])),
    vida_atual                   integer,
    vida_total                   integer,
    cod_modelo_banda             bigint,
    altura_sulco_central_externo real,
    dot                          varchar(20),
    valor                        real                                   not null,
    data_hora_cadastro           timestamp with time zone default now(),
    pneu_novo_nunca_rodado       boolean                  default false not null,
    codigo                       bigserial                              not null
        constraint pk_pneu
            primary key,
    cod_empresa                  bigint                                 not null
        constraint fk_pneu_empresa
            references public.empresa,
    cod_unidade_cadastro         integer                                not null
        constraint fk_pneu_unidade_cadastro
            references public.unidade,
    deletado                     boolean                  default false not null,
    data_hora_deletado           timestamp with time zone,
    pg_username_delecao          text,
    constraint unique_pneu_unidade
        unique (codigo, cod_unidade),
    constraint unique_pneu_status
        unique (codigo, status, cod_unidade),
    constraint fk_pneu_modelo_banda
        foreign key (cod_empresa, cod_modelo_banda) references public.modelo_banda (cod_empresa, codigo),
    constraint fk_pneu_modelo
        foreign key (cod_empresa, cod_modelo) references public.modelo_pneu (cod_empresa, codigo),
    constraint check_banda_nula_primeira_vida
        check ((vida_atual <> 1) OR (cod_modelo_banda IS NULL)),
    constraint check_banda_setada_acima_primeira_vida
        check ((vida_atual = 1) OR (cod_modelo_banda IS NOT NULL)),
    constraint check_vida_atual_menor_igual_vida_total
        check (vida_atual <= vida_total),
    constraint todos_sulcos_null_ou_todos_not_null
        check ((ROW (altura_sulco_externo, altura_sulco_central_externo, altura_sulco_central_interno, altura_sulco_interno) IS NOT NULL) OR
               (ROW (altura_sulco_externo, altura_sulco_central_externo, altura_sulco_central_interno, altura_sulco_interno) IS NULL)),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.pneu_data is 'Pneu';

comment on column public.pneu_data.pressao_recomendada is 'Pressão recomendada pelo fabricante ou pela unidade';

comment on column public.pneu_data.status is 'Status atual do pneu, pode ser: estoque, em_uso, descarte ou recapagem';

comment on column public.pneu_data.vida_atual is 'Vida atual que o pneu se encontra';

comment on column public.pneu_data.vida_total is 'Vidas que o cliente pretende rodar com o pneu';

comment on column public.pneu_data.dot is 'O código DOT gravado na lateral do pneu indica sua conformidade com os padrões de segurança e fornece dados sobre a fabricação do pneu.';

comment on column public.pneu_data.valor is 'O valor pago pelo pneu como um todo (estrutura + banda) em sua primeira vida.';

create unique index if not exists unique_pneu_empresa
    on public.pneu_data (codigo_cliente, cod_empresa)
    where (deletado IS FALSE);

create index if not exists idx_pneu_cod_unidade
    on public.pneu_data (cod_unidade);

create table if not exists public.movimentacao_processo
(
    codigo          bigserial                not null,
    cod_unidade     bigint                   not null
        constraint fk_movimentacao_processo_unidade
            references public.unidade,
    data_hora       timestamp with time zone not null,
    cpf_responsavel bigint
        constraint fk_movimentacao_processo_colaborador
            references public.colaborador_data,
    observacao      text,
    constraint pk_movimentacao_processo
        primary key (codigo, cod_unidade)
);

comment on table public.movimentacao_processo is 'Registra as movimentações';

create table if not exists public.movimentacao
(
    codigo                    bigserial not null
        constraint pk_movimentacao
            primary key,
    cod_movimentacao_processo bigserial not null,
    cod_unidade               bigint    not null
        constraint fk_movimentacao_unidade
            references public.unidade,
    cod_pneu                  bigint    not null
        constraint fk_movimentacao_pneu
            references public.pneu_data,
    sulco_interno             real,
    sulco_central_interno     real,
    sulco_externo             real,
    vida                      integer,
    observacao                text,
    sulco_central_externo     real,
    constraint fk_movimentacao_movimentacao_procecsso
        foreign key (cod_movimentacao_processo, cod_unidade) references public.movimentacao_processo
);

comment on table public.movimentacao is 'Registra os pneus movimentados em uma movimentação';

comment on column public.movimentacao.sulco_interno is 'Profundidade do sulco no momento da movimentação';

comment on column public.movimentacao.sulco_central_interno is 'Profundidade do sulco no momento da movimentação';

comment on column public.movimentacao.sulco_externo is 'Profundidade do sulco no momento da movimentação';

create index if not exists idx_movimentacao_cod_pneu
    on public.movimentacao (cod_pneu);

create table if not exists public.veiculo_diagrama
(
    codigo     smallint     not null
        constraint pk_veiculo_diagrama
            primary key,
    nome       varchar(255) not null,
    url_imagem text
);

comment on table public.veiculo_diagrama is 'Armazena os tipos de diagramas usados no Prolog';

create table if not exists public.veiculo_tipo
(
    codigo       bigserial    not null
        constraint pk_veiculo_tipo
            primary key,
    nome         varchar(255) not null,
    status_ativo boolean      not null,
    cod_diagrama smallint
        constraint fk_veiculo_tipo_veiculo_diagrama
            references public.veiculo_diagrama,
    cod_empresa  bigint       not null
        constraint fk_veiculo_tipo_empresa
            references public.empresa,
    constraint unique_veiculo_tipo_empresa
        unique (codigo, cod_empresa)
);

comment on table public.veiculo_tipo is 'Tipos de veículo Ex.: Truck, Toco, Carreta ...';

create table if not exists public.checklist_modelo_veiculo_tipo
(
    cod_unidade      bigint not null
        constraint fk_checklist_modelo_veiculo_tipo_unidade
            references public.unidade,
    cod_modelo       bigint not null
        constraint fk_checklist_modelo_veiculo_tipo_checklist_modelo
            references public.checklist_modelo_data,
    cod_tipo_veiculo bigint not null
        constraint fk_checklist_modelo_checklist_veiculo_tipo
            references public.veiculo_tipo,
    constraint pk_checklist_modelo_veiculo_tipo
        primary key (cod_unidade, cod_modelo, cod_tipo_veiculo)
);

comment on table public.checklist_modelo_veiculo_tipo is 'Relaciona tipos de veículo a um modelo de checklist';

create table if not exists public.veiculo_data
(
    placa                varchar(7)                             not null
        constraint pk_placa
            primary key,
    cod_unidade          integer                                not null
        constraint fk_placa_unidade
            references public.unidade,
    km                   bigint                                 not null,
    status_ativo         boolean                                not null,
    cod_tipo             bigint                                 not null,
    cod_modelo           bigint                                 not null,
    cod_eixos            bigint                   default 1     not null
        constraint fk_veiculo_eixos_veiculo
            references public.eixos_veiculo,
    data_hora_cadastro   timestamp with time zone default now(),
    cod_unidade_cadastro integer                                not null
        constraint fk_veiculo_unidade_cadastro
            references public.unidade,
    codigo               bigserial                              not null
        constraint veiculo_codigo_key
            unique,
    deletado             boolean                  default false not null,
    data_hora_deletado   timestamp with time zone,
    pg_username_delecao  text,
    cod_empresa          bigint                                 not null
        constraint fk_veiculo_empresa
            references public.empresa,
    constraint unique_veiculo_unidade
        unique (placa, cod_unidade),
    constraint fk_veiculo_tipo
        foreign key (cod_tipo, cod_empresa) references public.veiculo_tipo (codigo, cod_empresa),
    constraint fk_veiculo_modelo_veiculo
        foreign key (cod_modelo, cod_empresa) references public.modelo_veiculo (codigo, cod_empresa),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.veiculo_data is 'Veículos';

comment on column public.veiculo_data.status_ativo is 'Flag que indica se o veículo está ativo ou não';

create table if not exists public.afericao_data
(
    codigo                bigserial                not null
        constraint pk_afericao
            primary key,
    data_hora             timestamp with time zone not null,
    placa_veiculo         varchar(255)
        constraint fk_afericao_veiculo
            references public.veiculo_data,
    cpf_aferidor          bigint                   not null
        constraint fk_afericao_colaborador
            references public.colaborador_data,
    km_veiculo            bigint,
    tempo_realizacao      bigint,
    tipo_medicao_coletada varchar(13)
        constraint check_tipo_medicao_coletada
            check ((tipo_medicao_coletada)::text = ANY
                   (ARRAY [('SULCO'::character varying)::text, ('PRESSAO'::character varying)::text, ('SULCO_PRESSAO'::character varying)::text])),
    cod_unidade           bigint                   not null
        constraint fk_afericao_unidade
            references public.unidade,
    tipo_processo_coleta  varchar(11)              not null
        constraint check_tipo_processo_coleta
            check ((tipo_processo_coleta)::text = ANY
                   (ARRAY [('PLACA'::character varying)::text, ('PNEU_AVULSO'::character varying)::text])),
    deletado              boolean default false    not null,
    data_hora_deletado    timestamp with time zone,
    pg_username_delecao   text,
    cod_diagrama          bigint
        constraint afericao_data_cod_diagrama_fkey
            references public.veiculo_diagrama,
    constraint check_estado_placa_km
        check (CASE
                   WHEN ((tipo_processo_coleta)::text = 'PLACA'::text)
                       THEN ((placa_veiculo IS NOT NULL) AND (km_veiculo IS NOT NULL))
                   WHEN ((tipo_processo_coleta)::text = 'PNEU_AVULSO'::text)
                       THEN ((placa_veiculo IS NULL) AND (km_veiculo IS NULL))
                   ELSE NULL::boolean END),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL))),
    constraint check_diagrama_not_null
        check ((((tipo_processo_coleta)::text = 'PLACA'::text) AND (cod_diagrama IS NOT NULL)) OR
               (((tipo_processo_coleta)::text = 'PNEU_AVULSO'::text) AND (cod_diagrama IS NULL)))
);

comment on table public.afericao_data is 'Aferição - Coleta dos dados de sulcos e pressão de cada pneu de um veículo';

comment on column public.afericao_data.placa_veiculo is 'Placa do veículo aferido';

comment on column public.afericao_data.cpf_aferidor is 'Colaborador que realizou a aferição';

comment on column public.afericao_data.km_veiculo is 'Km do veículo no momento da aferição';

comment on column public.afericao_data.tempo_realizacao is 'Tempo que a aferição de todos os pneus levou';

create index if not exists idx_afericao_placa_veiculo
    on public.afericao_data (placa_veiculo);

create table if not exists public.afericao_manutencao_data
(
    cod_afericao                         bigint                not null
        constraint fk_afericao_manutencao_afericao
            references public.afericao_data
            on delete cascade,
    cod_pneu                             bigint                not null
        constraint fk_afericao_manutencao_pneu
            references public.pneu_data,
    cod_unidade                          bigint                not null,
    tipo_servico                         varchar(255)          not null,
    data_hora_resolucao                  timestamp with time zone,
    cpf_mecanico                         bigint
        constraint fk_afericao_manutencao
            references public.colaborador_data,
    qt_apontamentos                      integer default 1,
    psi_apos_conserto                    real,
    km_momento_conserto                  bigint,
    cod_alternativa                      bigint,
    cod_pneu_inserido                    bigint
        constraint fk_afericao_manutencao_pneu_inserido
            references public.pneu_data,
    codigo                               bigserial             not null,
    cod_processo_movimentacao            bigint,
    tempo_realizacao_millis              bigint,
    fechado_automaticamente_movimentacao boolean default false not null,
    deletado                             boolean default false not null,
    data_hora_deletado                   timestamp with time zone,
    pg_username_delecao                  text,
    fechado_automaticamente_integracao   boolean default false not null,
    constraint pk_afericao_manutencao
        primary key (codigo, cod_afericao, cod_pneu, cod_unidade, tipo_servico),
    constraint unique_codigo_deletado_afericao_manutencao
        unique (codigo, deletado),
    constraint fk_afericao_manutencao_movimentacao_processo
        foreign key (cod_unidade, cod_processo_movimentacao) references public.movimentacao_processo (cod_unidade, codigo),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL))),
    constraint check_estados_servicos
        check (CASE
                   WHEN ((tipo_servico)::text = 'movimentacao'::text) THEN (
                           ((ROW (data_hora_resolucao, cpf_mecanico, psi_apos_conserto, km_momento_conserto, cod_pneu_inserido, cod_processo_movimentacao, tempo_realizacao_millis) IS NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((ROW (data_hora_resolucao, cpf_mecanico, psi_apos_conserto, km_momento_conserto, cod_pneu_inserido, cod_processo_movimentacao, tempo_realizacao_millis) IS NOT NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((ROW (data_hora_resolucao, cod_processo_movimentacao) IS NOT NULL) AND
                            (fechado_automaticamente_movimentacao IS TRUE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((data_hora_resolucao IS NOT NULL) AND (cod_processo_movimentacao IS NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS TRUE)))
                   WHEN ((tipo_servico)::text = 'calibragem'::text) THEN (
                           ((ROW (data_hora_resolucao, cpf_mecanico, psi_apos_conserto, km_momento_conserto, cod_pneu_inserido, cod_processo_movimentacao, tempo_realizacao_millis) IS NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((ROW (data_hora_resolucao, cpf_mecanico, psi_apos_conserto, km_momento_conserto, tempo_realizacao_millis) IS NOT NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((ROW (data_hora_resolucao, cod_processo_movimentacao) IS NOT NULL) AND
                            (fechado_automaticamente_movimentacao IS TRUE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((data_hora_resolucao IS NOT NULL) AND (cod_processo_movimentacao IS NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS TRUE)))
                   WHEN ((tipo_servico)::text = 'inspecao'::text) THEN (
                           ((ROW (data_hora_resolucao, cpf_mecanico, psi_apos_conserto, km_momento_conserto, cod_pneu_inserido, cod_processo_movimentacao, tempo_realizacao_millis) IS NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((ROW (data_hora_resolucao, cpf_mecanico, psi_apos_conserto, km_momento_conserto, cod_alternativa, tempo_realizacao_millis) IS NOT NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((ROW (data_hora_resolucao, cod_processo_movimentacao) IS NOT NULL) AND
                            (fechado_automaticamente_movimentacao IS TRUE) AND
                            (fechado_automaticamente_integracao IS FALSE)) OR
                           ((data_hora_resolucao IS NOT NULL) AND (cod_processo_movimentacao IS NULL) AND
                            (fechado_automaticamente_movimentacao IS FALSE) AND
                            (fechado_automaticamente_integracao IS TRUE)))
                   ELSE NULL::boolean END)
);

comment on table public.afericao_manutencao_data is 'Pneus com problemas identificados em uma aferição';

comment on column public.afericao_manutencao_data.tipo_servico is 'Tipo do serviço, podendo ser calibragem, inspeção ou movimentação';

comment on column public.afericao_manutencao_data.data_hora_resolucao is 'A data e hora são setados sempre, independente do
processo que foi utilizado (integração, movimentação ou por mecânico)';

comment on column public.afericao_manutencao_data.cod_pneu_inserido is 'Usado apenas para o tipo de serviço movimentação';

create index if not exists idx_afericao_manutencao_cod_pneu
    on public.afericao_manutencao_data (cod_pneu);

create table if not exists public.afericao_valores_data
(
    cod_afericao                 bigint                not null
        constraint fk_afericao_valores_afericao
            references public.afericao_data
            on delete cascade,
    cod_pneu                     bigint                not null
        constraint fk_afericao_valores_pneu
            references public.pneu_data,
    cod_unidade                  bigint                not null
        constraint fk_afericao_valores_unidade
            references public.unidade,
    altura_sulco_central_interno real,
    altura_sulco_externo         real,
    altura_sulco_interno         real,
    psi                          real,
    posicao                      integer,
    vida_momento_afericao        integer,
    altura_sulco_central_externo real,
    deletado                     boolean default false not null,
    data_hora_deletado           timestamp with time zone,
    pg_username_delecao          text,
    constraint pk_afericao_valores
        primary key (cod_afericao, cod_pneu),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.afericao_valores_data is 'Valores coletados nas aferições';

comment on column public.afericao_valores_data.altura_sulco_central_interno is 'Altura coletada do sulco central';

comment on column public.afericao_valores_data.altura_sulco_externo is 'Altura coletada do sulco externo';

comment on column public.afericao_valores_data.altura_sulco_interno is 'Altura coletada do sulco interno';

comment on column public.afericao_valores_data.psi is 'Pressão coletada';

comment on column public.afericao_valores_data.vida_momento_afericao is 'Vida do pneu no momento da aferição';

create index if not exists idx_afericao_valores_cod_pneu
    on public.afericao_valores_data (cod_pneu);

create table if not exists public.gsd
(
    codigo         bigserial    not null
        constraint pk_gsd
            primary key,
    data_hora      timestamp with time zone,
    url_foto       text,
    cpf_avaliador  bigint
        constraint fk_gsd_cpf_avaliador
            references public.colaborador_data,
    cpf_motorista  bigint
        constraint fk_gsd_cpf_motorista
            references public.colaborador_data,
    cpf_ajudante_1 bigint
        constraint fk_gsd_cpf_ajudante_1
            references public.colaborador_data,
    cpf_ajudante_2 bigint
        constraint fk_gsd_cpf_ajudante_2
            references public.colaborador_data,
    placa_veiculo  varchar(7)
        constraint fk_gsd_placa
            references public.veiculo_data,
    latitude       varchar(255) not null,
    longitude      varchar(255) not null
);

comment on table public.gsd is 'Gabarito de segurança em distribuição';

create table if not exists public.gsd_respostas
(
    cod_gsd         bigint not null
        constraint fk_gsd_respostas_gsd
            references public.gsd,
    cpf_colaborador bigint not null
        constraint fk_gsd_respostas_colaborador
            references public.colaborador_data,
    cod_pergunta    bigint not null
        constraint fk_gsd_respostas_gsd_perguntas
            references public.gsd_perguntas,
    resposta        text,
    constraint pk_gsd_respostas
        primary key (cod_gsd, cpf_colaborador, cod_pergunta)
);

comment on table public.gsd_respostas is 'Respostas de um GSD';

create table if not exists public.pdv_gsd
(
    cod_gsd bigint not null
        constraint fk_pdv_gsd_gsd
            references public.gsd,
    cod_pdv bigint not null
        constraint fk_pdv_gsd_pdv
            references public.pdv,
    constraint pk_pdv_gsd
        primary key (cod_gsd, cod_pdv)
);

comment on table public.pdv_gsd is 'Relaciona pdvs a um GSD';

create table if not exists public.veiculo_pneu
(
    placa              varchar(255)                                                 not null,
    cod_pneu           bigint                                                       not null
        constraint unico_vinculo_pneu
            unique,
    cod_unidade        bigint                                                       not null,
    posicao            integer                                                      not null,
    data_hora_cadastro timestamp with time zone default now(),
    status_pneu        varchar(255)             default 'EM_USO'::character varying not null
        constraint check_status_valido
            check ((status_pneu)::text = 'EM_USO'::text),
    constraint pk_veiculo_pneu
        primary key (placa, cod_pneu),
    constraint veiculo_pneu_placa_posicao_key
        unique (placa, posicao),
    constraint fk_veiculo_pneu_veiculo
        foreign key (placa, cod_unidade) references public.veiculo_data (placa, cod_unidade)
            deferrable,
    constraint fk_veiculo_pneu_status_pneu
        foreign key (status_pneu, cod_unidade, cod_pneu) references public.pneu_data (status, cod_unidade, codigo)
            deferrable initially deferred
);

comment on table public.veiculo_pneu is 'Víncula pneus ao veiculo';

comment on column public.veiculo_pneu.posicao is 'Posição que o pneu se encontra no veículo';

create table if not exists public.veiculo_pneu_inconsistencia
(
    data_hora            timestamp with time zone not null,
    cod_afericao         bigint                   not null
        constraint fk_veiculo_pneu_inconsistencia_afericao
            references public.afericao_data,
    placa                varchar(7)               not null
        constraint fk_veiculo_pneu_inconsistencia_placa
            references public.veiculo_data,
    cod_pneu_correto     bigint                   not null
        constraint fk_veiculo_pneu_inconsistencia_pneu_correto
            references public.pneu_data,
    cod_pneu_incorreto   bigint                   not null
        constraint fk_veiculo_pneu_inconsistencia_pneu_incorreto
            references public.pneu_data,
    posicao              integer                  not null,
    cod_unidade          bigint                   not null
        constraint fk_veiculo_pneu_inconsistencia_unidade
            references public.unidade,
    data_hora_fechamento timestamp with time zone,
    cpf_fechamento       bigint
        constraint fk_veiculo_pneu_inconsistencia_colaborador
            references public.colaborador_data,
    constraint pk_veiculo_pneu_inconsistencia
        primary key (placa, posicao)
);

comment on table public.veiculo_pneu_inconsistencia is 'Inconsistência entre os pneus aplicados fisicamente (veículo real) e virtualmente (sistema)';

comment on column public.veiculo_pneu_inconsistencia.cod_afericao is 'Aferição onde foi identificada a inconsistência';

comment on column public.veiculo_pneu_inconsistencia.cod_pneu_correto is 'Código do pneu que está aplicado no veículo';

comment on column public.veiculo_pneu_inconsistencia.cod_pneu_incorreto is 'Código do pneu que está aplicado no sistema';

comment on column public.veiculo_pneu_inconsistencia.posicao is 'Posição do pneu com código incorreto';

comment on column public.veiculo_pneu_inconsistencia.data_hora_fechamento is 'Data que a inconsistência foi resolvida';

comment on column public.veiculo_pneu_inconsistencia.cpf_fechamento is 'Colaborador que resolveu a inconsistência';

create table if not exists public.movimentacao_origem
(
    cod_movimentacao    bigint       not null
        constraint pk_movimentacao_origem
            primary key
        constraint fk_movimentacao_origem_movimentacao
            references public.movimentacao
            on update cascade on delete cascade,
    tipo_origem         varchar(255) not null
        constraint check_movimentacao_origem_tipo_origem
            check (((tipo_origem)::text = 'ESTOQUE'::text) OR ((tipo_origem)::text = 'RECAPAGEM'::text) OR
                   ((tipo_origem)::text = 'EM_USO'::text) OR ((tipo_origem)::text = 'ANALISE'::text)),
    placa               varchar(7)
        constraint fk_movimentacao_origem_veiculo
            references public.veiculo_data,
    km_veiculo          integer,
    posicao_pneu_origem integer,
    cod_diagrama        bigint
        constraint movimentacao_origem_cod_diagrama_fkey
            references public.veiculo_diagrama,
    constraint check_diagrama_not_null
        check ((((tipo_origem)::text = 'EM_USO'::text) AND (cod_diagrama IS NOT NULL)) OR
               (((tipo_origem)::text = 'ESTOQUE'::text) AND (cod_diagrama IS NULL)) OR
               (((tipo_origem)::text = 'ANALISE'::text) AND (cod_diagrama IS NULL)) OR
               (((tipo_origem)::text = 'DESCARTE'::text) AND (cod_diagrama IS NULL)))
);

comment on table public.movimentacao_origem is 'Destino do pneu que foi movimentado';

comment on column public.movimentacao_origem.tipo_origem is 'Tipo do destino, deve ser ESTOQUE, RECAPAGEM, VEICULO ou DESCARTE';

comment on column public.movimentacao_origem.placa is 'Placa do veículo que o pneu foi inserido';

comment on column public.movimentacao_origem.km_veiculo is 'Km do veículo no momento da movimentação';

comment on column public.movimentacao_origem.posicao_pneu_origem is 'Posição em que o pneu foi inserido';

create index if not exists idx_movimentacao_origem_placa_veiculo
    on public.movimentacao_origem (placa);

create table if not exists public.veiculo_diagrama_eixos
(
    cod_diagrama    smallint not null
        constraint fk_veiculo_diagrama_eixos_veiculo_diagrama
            references public.veiculo_diagrama,
    tipo_eixo       char     not null
        constraint check_veiculo_diagrama_eixos_tipo_eixo
            check ((tipo_eixo = 'D'::bpchar) OR (tipo_eixo = 'T'::bpchar)),
    posicao         smallint not null,
    qt_pneus        smallint not null,
    eixo_direcional boolean  not null,
    constraint pk_veiculo_diagrama_eixos
        primary key (cod_diagrama, posicao)
);

comment on table public.veiculo_diagrama_eixos is 'Armazena os detalhes de cada tipo de diagrama';

create table if not exists public.pre_contracheque_calculo_premio
(
    cod_unidade bigint       not null
        constraint fk_pre_contracheque_calculo_premio_unidade
            references public.unidade,
    cod_item    varchar(255) not null,
    constraint pk_pre_contracheque_calculo_premio
        primary key (cod_unidade, cod_item)
);

create table if not exists public.prontuario_condutor_consolidado
(
    cpf_colaborador          bigint                   not null
        constraint pk_prontuario_condutor_consolidado
            primary key,
    status                   varchar(255)             not null,
    motivo                   text,
    pontuacao                integer                  not null,
    vencimento_cnh           date                     not null,
    documentos_rs            varchar(255),
    documentos_ec            varchar(255),
    documentos_it            varchar(255),
    pontuacao_ponderada      real                     not null,
    acidentes_fai            integer                  not null,
    acidentes_lti            integer                  not null,
    acidentes_mdi            integer                  not null,
    acidentes_mti            integer                  not null,
    capotamentos             integer                  not null,
    colisoes                 integer                  not null,
    tombamentos              integer                  not null,
    multas_leve              integer                  not null,
    multas_media             integer                  not null,
    multas_grave             integer                  not null,
    multas_gravissima        integer                  not null,
    sac_impericia            integer                  not null,
    sac_imprudencia          integer                  not null,
    sav_impericia            integer                  not null,
    sav_imprudencia          integer                  not null,
    advertencias             integer                  not null,
    suspensoes               integer                  not null,
    excesso_velocidade_1     integer                  not null,
    excesso_velocidade_2     integer                  not null,
    excesso_velocidade_3     integer                  not null,
    forca_g                  integer                  not null,
    frenagem_brusca          integer                  not null,
    data_atualizacao         timestamp with time zone not null,
    power_on                 integer                  not null,
    fadigas_celular          integer                  not null,
    fadigas_consumo_alimento integer                  not null,
    fadigas_fumando          integer                  not null,
    fadigas_oclusao          integer                  not null,
    fadigas_sem_cinto        integer                  not null
);

create table if not exists public.intervalo_tipo
(
    cod_unidade               bigint    not null
        constraint fk_intervalo_tipo_unidade
            references public.unidade,
    codigo                    bigserial not null
        constraint pk_intervalo_tipo
            primary key,
    nome                      citext    not null,
    icone                     varchar(255),
    tempo_recomendado_minutos bigint,
    tempo_estouro_minutos     bigint,
    horario_sugerido          time,
    ativo                     boolean   not null,
    cod_auxiliar              text,
    constraint nomes_unicos_por_unidade
        unique (nome, cod_unidade, ativo),
    constraint unique_tipo_unidade
        unique (cod_unidade, codigo)
);

create table if not exists public.intervalo_tipo_cargo
(
    cod_unidade        bigint not null
        constraint fk_intervalo_tipo_cargo_unidade
            references public.unidade,
    cod_tipo_intervalo bigint not null,
    cod_cargo          bigint not null,
    constraint pk_intervalo_tipo_cargo
        primary key (cod_unidade, cod_tipo_intervalo, cod_cargo),
    constraint fk_intervalo_tipo_cargo_intervalo_tipo
        foreign key (cod_unidade, cod_tipo_intervalo) references public.intervalo_tipo (cod_unidade, codigo)
);

create table if not exists public.intervalo_unidade
(
    cod_unidade                  bigint       not null
        constraint pk_intervalo_unidade
            primary key
        constraint fk_intervalo_unidade_unidade
            references public.unidade,
    versao_dados                 bigint       not null,
    token_sincronizacao_marcacao varchar(255) not null
        constraint unique_token_sincronizacao_marcacao
            unique
);

create table if not exists public.pneu_posicao
(
    posicao_pneu      smallint not null
        constraint pk_pneu_posicao
            primary key,
    descricao_posicao varchar(255)
);

create table if not exists public.pneu_ordem
(
    posicao_prolog integer not null
        constraint pk_pneu_ordem
            primary key
        constraint fk_pneu_ordem_pneu_posicao
            references public.pneu_posicao,
    ordem_exibicao integer not null,
    constraint unique_pneu_ordem
        unique (posicao_prolog, ordem_exibicao)
);

create table if not exists public.pneu_ordem_nomenclatura_antiga
(
    cod_tipo_veiculo bigint       not null
        constraint fk_pneu_nomenclatura_tipo_veiculo
            references public.veiculo_tipo,
    cod_unidade      bigint       not null
        constraint fk_pneu_ordem_nomenclatura_unidade_unidade
            references public.unidade,
    posicao_prolog   integer      not null
        constraint fk_pneu_ordem_nomenclatura_unidade_pneu_posicao
            references public.pneu_posicao,
    nomenclatura     varchar(255) not null,
    constraint pk_pneu_ordem_nomenclatura_unidade
        primary key (cod_unidade, cod_tipo_veiculo, posicao_prolog)
);

comment on table public.pneu_ordem_nomenclatura_antiga is 'Armazena a nomenclatura que cada posição de pneu deve ter para cada unidade, EX: 111 / DD';

create table if not exists avilan.veiculo_tipo
(
    codigo     varchar(5)  not null
        constraint pk_veiculo_tipo
            primary key,
    descricao  varchar(50) not null,
    cod_prolog smallserial not null,
    constraint unique_veiculo_tipo
        unique (codigo, cod_prolog)
);

comment on table avilan.veiculo_tipo is 'Essa tabela mapeia os tipos de veículo da Avilan para um código numérico
    que será utilizado pelo ProLog. Ela é necessária pois o código de um tipo de veículo no ProLog é um número,
    porém, no ERP da Avilan é uma String.Para cada tipo de veículo que a Avilan possua, será criado um código
    númerico equivalente.';

create table if not exists avilan.filial
(
    codigo             smallint not null
        constraint pk_filial
            primary key,
    cod_unidade_prolog bigint   not null
        constraint fk_filial_avilan_unidade_prolog
            references public.unidade,
    constraint unique_filial
        unique (codigo, cod_unidade_prolog)
);

comment on table avilan.filial is 'Representa uma filial no banco de dados da Avilan. Uma filial pode ter várias
 unidades (AVILAN.UNIDADE) associadas a ela. Filial é o equivalente a uma unidade no ProLog. Por exemplo: Santa
 Maria é uma filial no ERP da Avilan mas uma  unidade no ProLog.';

create table if not exists avilan.unidade
(
    codigo     smallint not null,
    cod_filial smallint not null
        constraint fk_unidade_filial
            references avilan.filial,
    constraint pk_unidade
        primary key (codigo, cod_filial)
);

comment on table avilan.unidade is 'Representa uma unidade no banco de dados da Avilan. Uma unidade pertence a uma filial.';

create table if not exists avilan.veiculo_tipo_veiculo_diagrama
(
    cod_veiculo_tipo            varchar(5) not null
        constraint fk_veiculo_tipo_veiculo_diagrama_veiculo_tipo
            references avilan.veiculo_tipo,
    cod_veiculo_diagrama_prolog smallint   not null
        constraint fk_veiculo_tipo_veiculo_diagrama_veiculo_diagrama
            references public.veiculo_diagrama,
    constraint pk_veiculo_tipo_veiculo_diagrama
        primary key (cod_veiculo_tipo, cod_veiculo_diagrama_prolog)
);

comment on table avilan.veiculo_tipo_veiculo_diagrama is 'Associa um tipo de veículo da Avilan a um diagrama de veículo existente no ProLog.';

create table if not exists avilan.pneu_posicao
(
    posicao_pneu      varchar(10) not null
        constraint pk_pneu_posicao
            primary key,
    descricao_posicao varchar(255)
);

comment on table avilan.pneu_posicao is 'Salva as posições que a Avilan usa para os pneus e a descrição de cada posição.';

create table if not exists avilan.pneu_posicao_avilan_prolog
(
    posicao_pneu_avilan varchar(10) not null
        constraint fk_pneu_posicao_avilan_prolog_pneu_posicao_avilan
            references avilan.pneu_posicao,
    posicao_pneu_prolog smallint    not null
        constraint fk_pneu_posicao_avilan_prolog_pneu_posicao_prolog
            references public.pneu_posicao,
    cod_veiculo_tipo    varchar(5)  not null
        constraint fk_pneu_posicao_avilan_prolog_veiculo_tipo_avilan
            references avilan.veiculo_tipo,
    constraint pk_pneu_posicao_avilan_prolog
        primary key (posicao_pneu_avilan, posicao_pneu_prolog, cod_veiculo_tipo)
);

comment on table avilan.pneu_posicao_avilan_prolog is 'Mapeia uma posição de pneu na Avilan para uma do ProLog levando em conta o tipo do veículo.';

create table if not exists avilan.checklist_pergunta_url_imagem
(
    cod_questionario   bigint not null,
    cod_pergunta       bigint not null,
    descricao_pergunta text   not null,
    url_imagem         text   not null,
    constraint pk_checklist_pergunta_url_imagem
        primary key (cod_questionario, cod_pergunta)
);

comment on table avilan.checklist_pergunta_url_imagem is 'Mapeia uma url de imagem para cada pergunta de um questionário';

create table if not exists public.movimentacao_motivo_descarte_empresa
(
    cod_empresa                bigint               not null
        constraint fk_cod_empresa
            references public.empresa,
    codigo                     serial               not null
        constraint pk_movimentacao_motivo_descarte_empresa
            primary key,
    motivo                     text                 not null,
    ativo                      boolean default true not null,
    data_hora_insercao         timestamp with time zone,
    data_hora_ultima_alteracao timestamp with time zone
);

create table if not exists public.dashboard_componente_tipo
(
    codigo                     smallint                 not null
        constraint pk_dashboard_componente_tipo
            primary key,
    identificador_tipo         varchar(255)             not null
        constraint dashboard_componente_tipo_identificador_tipo_key
            unique,
    nome                       varchar(255)             not null,
    descricao                  text                     not null,
    maximo_blocos_horizontais  smallint                 not null,
    maximo_blocos_verticais    smallint                 not null,
    minimo_blocos_horizontais  smallint                 not null,
    minimo_blocos_verticais    smallint                 not null,
    data_hora_criacao          timestamp with time zone not null,
    data_hora_ultima_alteracao timestamp with time zone not null
);

create table if not exists public.dashboard_componente
(
    codigo                      smallint                 not null
        constraint pk_dashboard_componente
            primary key,
    titulo                      varchar(255)             not null,
    subtitulo                   varchar(255),
    descricao                   text                     not null,
    qtd_blocos_horizontais      smallint                 not null,
    qtd_blocos_verticais        smallint                 not null,
    data_hora_criacao           timestamp with time zone not null,
    data_hora_ultima_alteracao  timestamp with time zone not null,
    cod_pilar_prolog_componente smallint                 not null
        constraint fk_dashboard_componente_pilar_prolog
            references public.pilar_prolog,
    cod_tipo_componente         smallint                 not null
        constraint fk_dashboard_componente_dashboard_componente_tipo
            references public.dashboard_componente_tipo,
    url_endpoint_dados          text                     not null,
    cor_background_hex          varchar(9),
    url_icone                   text,
    label_eixo_x                varchar(255),
    label_eixo_y                varchar(255),
    ativo                       boolean default true
);

create table if not exists public.dashboard_componente_personalizacao
(
    cpf_colaborador           bigint                not null
        constraint fk_dashboard_componente_personalizacao_colaborador
            references public.colaborador_data,
    cod_componente            smallint              not null
        constraint fk_dashboard_componente_personalizacao_dashboard_componente
            references public.dashboard_componente,
    qtd_blocos_horizontais    smallint              not null,
    qtd_blocos_verticais      smallint              not null,
    ordem_exibicao_componente smallint              not null,
    ocultar_componente        boolean default false not null,
    constraint pk_dashboard_componente_personalizacao
        primary key (cpf_colaborador, cod_componente)
);

create table if not exists public.intervalo
(
    codigo                             bigserial                not null
        constraint pk_intervalo
            primary key,
    cod_unidade                        bigint                   not null
        constraint fk_intervalo_unidade
            references public.unidade,
    cod_tipo_intervalo                 bigint                   not null,
    cpf_colaborador                    bigint                   not null
        constraint fk_intervalo_colaborador
            references public.colaborador_data
            on update cascade on delete cascade,
    data_hora                          timestamp with time zone not null,
    tipo_marcacao                      varchar(255)
        constraint tipo_marcacao
            check ((tipo_marcacao)::text = ANY
                   (ARRAY [('MARCACAO_INICIO'::character varying)::text, ('MARCACAO_FIM'::character varying)::text])),
    fonte_data_hora                    varchar(255)
        constraint fonte_data_hora
            check ((fonte_data_hora)::text = ANY
                   (ARRAY [('REDE_CELULAR'::character varying)::text, ('LOCAL_CELULAR'::character varying)::text, ('SERVIDOR'::character varying)::text])),
    justificativa_tempo_recomendado    text,
    justificativa_estouro              text,
    latitude_marcacao                  text,
    longitude_marcacao                 text,
    valido                             boolean default true,
    data_hora_sincronizacao            timestamp with time zone,
    versao_app_momento_marcacao        integer,
    versao_app_momento_sincronizacao   integer,
    foi_ajustado                       boolean default false,
    cod_colaborador_insercao           bigint
        constraint fk_intervalo_colaborador_insercao
            references public.colaborador_data (codigo),
    status_ativo                       boolean default true,
    device_id                          text,
    device_imei                        text,
    device_uptime_realizacao_millis    bigint,
    device_uptime_sincronizacao_millis bigint,
    android_api_version                integer,
    marca_device                       text,
    modelo_device                      text,
    constraint unique_data_hora_marcacao_intervalo
        unique (cod_unidade, cod_tipo_intervalo, cpf_colaborador, tipo_marcacao, data_hora),
    constraint fk_intervalo_intervalo_tipo
        foreign key (cod_unidade, cod_tipo_intervalo) references public.intervalo_tipo (cod_unidade, codigo)
);

comment on column public.intervalo.cod_colaborador_insercao is 'Esta coluna estará preenchida apenas se a marcação tiver sido inserida através do processo de Ajuste de Marcação';

comment on column public.intervalo.status_ativo is 'Está flag serva para identificar se a marcação encontra-se ativa ou intavida. Somente será setada como inativa caso for inativada por algum supervisor';

create table if not exists public.checklist_galeria_imagens
(
    cod_imagem         bigserial               not null
        constraint pk_checklist_galeria_imagens
            primary key,
    url_imagem         text                    not null,
    cod_empresa        bigint
        constraint fk_checklist_galeria_imagens_empresa
            references public.empresa,
    data_hora_cadastro timestamp default now() not null,
    status_ativo       boolean   default true  not null
);

create table if not exists public.checklist_modelo_prolog
(
    codigo       smallserial          not null
        constraint pk_check_modelo_prolog
            primary key,
    nome         text                 not null,
    status_ativo boolean default true not null
);

create table if not exists public.checklist_perguntas_prolog
(
    codigo                      bigserial            not null
        constraint pk_check_perguntas_prolog
            primary key,
    cod_checklist_modelo_prolog smallint             not null
        constraint fk_check_perguntas_prolog_check_modelo_prolog
            references public.checklist_modelo_prolog,
    ordem                       smallint             not null,
    pergunta                    text                 not null,
    single_choice               boolean              not null,
    status_ativo                boolean default true not null,
    cod_imagem                  bigint
        constraint fk_check_perguntas_prolog_check_galeria_imagens
            references public.checklist_galeria_imagens
);

create table if not exists public.checklist_alternativa_pergunta_prolog
(
    codigo                      bigserial             not null
        constraint pk_check_alternativa_pergunta_prolog
            primary key,
    cod_checklist_modelo_prolog smallint              not null
        constraint fk_check_alternativa_prolog_check_modelo_prolog
            references public.checklist_modelo_prolog,
    cod_pergunta_prolog         bigint                not null
        constraint fk_check_alternativa_prolog_check_perguntas_prolog
            references public.checklist_perguntas_prolog,
    ordem                       smallint              not null,
    alternativa                 text                  not null,
    status_ativo                boolean default true  not null,
    alternativa_tipo_outros     boolean default false not null,
    prioridade                  varchar(7)            not null
        constraint fk_checklist_alternativa_prioridade
            references public.checklist_alternativa_prioridade,
    deve_abrir_ordem_servico    boolean default true  not null
);

comment on column public.checklist_alternativa_pergunta_prolog.prioridade is 'Salva a prioridade que essa alternativa possui, podendo ser: CRITICA, ALTA ou BAIXA';

create table if not exists public.pneu_vida_nomenclatura
(
    cod_vida bigint  not null
        constraint pk_pneu_vida_nomenclatura
            primary key,
    nome     varchar not null
);

create table if not exists public.pneu_recapagem_nomenclatura
(
    cod_total_vida bigint  not null
        constraint pk_pneu_recapagem_nomenclatura
            primary key,
    nome           varchar not null
);

create table if not exists public.pneu_foto_cadastro
(
    codigo                       bigserial             not null
        constraint pk_pneu_foto_cadastro
            primary key,
    cod_pneu                     bigint                not null
        constraint fk_pneu_foto_cadastro_pneu
            references public.pneu_data,
    url_foto                     text                  not null
        constraint pneu_foto_cadastro_url_foto_key
            unique,
    foto_sincronizada            boolean default false not null,
    data_hora_sincronizacao_foto timestamp with time zone
);

comment on table public.pneu_foto_cadastro is 'Tabela que contém as fotos dos pneus capturadas no momento do cadastro';

create table if not exists public.escala_diaria
(
    codigo                     bigserial                not null
        constraint pk_escala_diaria
            primary key,
    cod_unidade                bigint                   not null,
    data                       date                     not null,
    placa                      varchar(7)               not null,
    mapa                       bigint,
    cpf_motorista              bigint                   not null,
    cpf_ajudante_1             bigint,
    cpf_ajudante_2             bigint,
    data_hora_cadastro         timestamp with time zone not null,
    data_hora_ultima_alteracao timestamp with time zone not null,
    cpf_cadastro               bigint                   not null,
    cpf_ultima_alteracao       bigint                   not null
);

comment on table public.escala_diaria is 'Tabela de veículos e colaboradores que saíram para rota em suas devidas datas';

create table if not exists public.recapadora
(
    codigo               bigserial            not null
        constraint pk_recapadora
            primary key,
    nome                 text                 not null,
    cod_empresa          bigint               not null
        constraint fk_recapadora_empresa
            references public.empresa,
    ativa                boolean default true not null,
    data_hora_cadastro   timestamp with time zone,
    cpf_cadastro         bigint,
    cpf_alteracao_status bigint,
    constraint nome_recapadora_unique
        unique (nome, cod_empresa)
);

comment on table public.recapadora is 'Tabela de recapadoras associadas a cada empresa';

create table if not exists public.movimentacao_destino
(
    cod_movimentacao       bigint       not null
        constraint pk_movimentacao_destino
            primary key
        constraint fk_movimentacao_destino_movimentacao_pneu
            references public.movimentacao
            on update cascade on delete cascade,
    tipo_destino           varchar(255) not null
        constraint check_movimentacao_destino_tipo_destino
            check (((tipo_destino)::text = 'ESTOQUE'::text) OR ((tipo_destino)::text = 'RECAPAGEM'::text) OR
                   ((tipo_destino)::text = 'EM_USO'::text) OR ((tipo_destino)::text = 'DESCARTE'::text) OR
                   ((tipo_destino)::text = 'ANALISE'::text)),
    placa                  varchar(7)
        constraint fk_movimentacao_destino_veiculo
            references public.veiculo_data,
    km_veiculo             integer,
    posicao_pneu_destino   integer,
    cod_motivo_descarte    integer
        constraint fk_cod_motivo_descarte
            references public.movimentacao_motivo_descarte_empresa,
    url_imagem_descarte_1  text,
    url_imagem_descarte_2  text,
    url_imagem_descarte_3  text,
    cod_recapadora_destino bigint
        constraint fk_movimentacao_destino_recapadora
            references public.recapadora,
    cod_coleta             varchar(255),
    cod_diagrama           bigint
        constraint movimentacao_destino_cod_diagrama_fkey
            references public.veiculo_diagrama,
    constraint check_diagrama_not_null
        check ((((tipo_destino)::text = 'EM_USO'::text) AND (cod_diagrama IS NOT NULL)) OR
               (((tipo_destino)::text = 'ESTOQUE'::text) AND (cod_diagrama IS NULL)) OR
               (((tipo_destino)::text = 'ANALISE'::text) AND (cod_diagrama IS NULL)) OR
               (((tipo_destino)::text = 'DESCARTE'::text) AND (cod_diagrama IS NULL)))
);

create index if not exists idx_movimentacao_destino_placa_veiculo
    on public.movimentacao_destino (placa);

create table if not exists public.afericao_configuracao_tipo_afericao_veiculo
(
    codigo                    bigserial not null
        constraint pk_afericao_configuracao_tipo_afericao_veiculo
            primary key,
    cod_unidade               bigint    not null
        constraint fk_afericao_configuracao_tipo_afericao_veiculo_unidade
            references public.unidade,
    cod_tipo_veiculo          bigint    not null
        constraint fk_afericao_configuracao_tipo_afericao_veiculo_tipo_veiculo
            references public.veiculo_tipo,
    pode_aferir_sulco         boolean   not null,
    pode_aferir_pressao       boolean   not null,
    pode_aferir_sulco_pressao boolean   not null,
    pode_aferir_estepe        boolean   not null,
    constraint unique_config_afericao_tipo_veiculo_unidade
        unique (cod_tipo_veiculo, cod_unidade)
);

comment on table public.afericao_configuracao_tipo_afericao_veiculo is 'Tipos de veículos que possuem alguma configuração de aferição setada';

create table if not exists backup.mapa
(
    data                           date,
    transp                         integer,
    entrega                        varchar(20),
    cargaatual                     varchar(20),
    frota                          varchar(20),
    custospot                      real,
    regiao                         integer,
    veiculo                        integer,
    placa                          varchar(7),
    veiculoindisp                  real,
    placaindisp                    real,
    frotaindisp                    real,
    tipoindisp                     integer,
    mapa                           integer not null,
    entregas                       integer,
    cxcarreg                       real,
    cxentreg                       real,
    ocupacao                       real,
    cxrota                         real,
    cxas                           real,
    veicbm                         real,
    rshow                          integer,
    entrvol                        varchar(20),
    hrsai                          timestamp,
    hrentr                         timestamp,
    kmsai                          integer,
    kmentr                         integer,
    custovariavel                  real,
    lucro                          real,
    lucrounit                      real,
    valorfrete                     real,
    tipoimposto                    varchar(20),
    percimposto                    real,
    valorimposto                   real,
    valorfaturado                  real,
    valorunitcxentregue            real,
    valorpgcxentregsemimp          real,
    valorpgcxentregcomimp          real,
    tempoprevistoroad              time,
    kmprevistoroad                 real,
    valorunitpontomot              real,
    valorunitpontoajd              real,
    valorequipeentrmot             real,
    valorequipeentrajd             real,
    custovariavelcedbz             real,
    lucrounitcedbz                 real,
    lucrovariavelcxentregueffcedbz real,
    tempointerno                   time,
    valordropdown                  real,
    veiccaddd                      varchar(20),
    kmlaco                         real,
    kmdeslocamento                 real,
    tempolaco                      time,
    tempodeslocamento              time,
    sitmulticdd                    real,
    unborigem                      integer,
    matricmotorista                integer,
    matricajud1                    integer,
    matricajud2                    integer,
    valorctedifere                 varchar(20),
    qtnfcarregadas                 integer,
    qtnfentregues                  integer,
    inddevcx                       real,
    inddevnf                       real,
    fator                          real,
    recarga                        varchar(20),
    hrmatinal                      time,
    hrjornadaliq                   time,
    hrmetajornada                  time,
    vlbateujornmot                 real,
    vlnaobateujornmot              real,
    vlrecargamot                   real,
    vlbateujornaju                 real,
    vlnaobateujornaju              real,
    vlrecargaaju                   real,
    vltotalmapa                    real,
    qthlcarregados                 real,
    qthlentregues                  real,
    indicedevhl                    real,
    regiao2                        varchar(20),
    qtnfcarreggeral                integer,
    qtnfentreggeral                integer,
    capacidadeveiculokg            real,
    pesocargakg                    real,
    cod_unidade                    bigint  not null,
    data_hora_import               timestamp default now(),
    capacveiculocx                 integer,
    entregascompletas              integer,
    entregasparciais               integer,
    entregasnaorealizadas          integer,
    codfilial                      integer,
    nomefilial                     varchar(255),
    codsupervtrs                   integer,
    nomesupervtrs                  varchar(255),
    codspot                        integer,
    nomespot                       varchar(255),
    equipcarregados                integer,
    equipdevolvidos                integer,
    equiprecolhidos                integer,
    cxentregtracking               real,
    hrcarreg                       timestamp,
    hrpcfisica                     timestamp,
    hrpcfinanceira                 timestamp,
    stmapa                         varchar(255),
    classificacao_roadshow         text,
    data_entrega                   date,
    qt_entregas_carreg_rv          integer,
    qt_entregas_entreg_rv          integer,
    indice_dev_entregas            real,
    cpf_motorista                  bigint,
    cpf_ajudante_1                 bigint,
    cpf_ajudante_2                 bigint,
    inicio_rota                    timestamp,
    termino_rota                   timestamp,
    motorista_jt_12x36             varchar(255),
    retira                         varchar(255),
    constraint pk_mapa
        primary key (mapa, cod_unidade),
    constraint unique_mapa_unidade_backup
        unique (mapa, cod_unidade)
);

create table if not exists comercial.mensagem_contato
(
    codigo            bigserial not null
        constraint pk_mensagem_contato
            primary key,
    nome              text      not null,
    email             text      not null,
    telefone          text,
    empresa           text,
    mensagem          text      not null,
    data_hora_criacao timestamp default now()
);

create table if not exists public.pneu_tipo_servico
(
    codigo                  bigserial             not null
        constraint pk_pneu_tipo_servico
            primary key,
    cod_empresa             bigint
        constraint fk_pneu_tipo_servico_empresa
            references public.empresa,
    nome                    varchar(255)          not null,
    incrementa_vida         boolean               not null,
    status_ativo            boolean default true  not null,
    editavel                boolean default true  not null,
    utilizado_cadastro_pneu boolean default false not null,
    cod_colaborador_criacao bigint
        constraint fk_pneu_tipo_servico_colaborador_criacao
            references public.colaborador_data (codigo),
    data_hora_criacao       timestamp,
    cod_colaborador_edicao  bigint
        constraint fk_pneu_tipo_servico_colaborador_edicao
            references public.colaborador_data (codigo),
    data_hora_edicao        timestamp,
    constraint unique_pneu_tipo_servico
        unique (cod_empresa, nome)
);

comment on table public.pneu_tipo_servico is 'Tipos de serviços que podem ser executados em um pneu';

comment on column public.pneu_tipo_servico.cod_empresa is 'Para os Tipos de Serviços que o COD_EMPRESA é null, significa que eles são de nível ProLog, disponíveis para todas as empresas';

create table if not exists public.pneu_servico_realizado_data
(
    codigo                  bigserial             not null,
    cod_tipo_servico        bigint                not null
        constraint fk_pneu_servico_realizado_pneu_tipo_servico
            references public.pneu_tipo_servico,
    cod_unidade             bigint                not null
        constraint fk_pneu_servico_realizado_unidade
            references public.unidade,
    cod_pneu                bigint                not null
        constraint fk_pneu_servico_realizado_pneu
            references public.pneu_data,
    custo                   real                  not null
        constraint check_custo_numero_positivo
            check (custo >= (0)::double precision),
    vida                    smallint              not null,
    fonte_servico_realizado varchar(20)           not null
        constraint check_fonte_servico_realizado
            check (((fonte_servico_realizado)::text = 'FONTE_MOVIMENTACAO'::text) OR
                   ((fonte_servico_realizado)::text = 'FONTE_CADASTRO'::text)),
    deletado                boolean default false not null,
    data_hora_deletado      timestamp with time zone,
    pg_username_delecao     text,
    constraint pk_pneu_servico_realizado
        primary key (codigo, fonte_servico_realizado),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.pneu_servico_realizado_data is 'Serviços que foram realizados no pneu';

create index if not exists idx_pneu_servico_realizado_cod_pneu
    on public.pneu_servico_realizado_data (cod_pneu);

create table if not exists public.pneu_servico_realizado_incrementa_vida_data
(
    cod_servico_realizado   bigint                not null,
    cod_modelo_banda        bigint                not null
        constraint fk_pneu_servico_realizado_incrementa_vida_modelo_banda
            references public.modelo_banda,
    vida_nova_pneu          smallint              not null,
    fonte_servico_realizado varchar(20)           not null
        constraint check_fonte_pneu_servico_realizado_incrementa_vida
            check (((fonte_servico_realizado)::text = 'FONTE_MOVIMENTACAO'::text) OR
                   ((fonte_servico_realizado)::text = 'FONTE_CADASTRO'::text)),
    deletado                boolean default false not null,
    data_hora_deletado      timestamp with time zone,
    pg_username_delecao     text,
    constraint fk_servico_realizado_incrementa_vida_pneu
        foreign key (cod_servico_realizado, fonte_servico_realizado) references public.pneu_servico_realizado_data,
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.pneu_servico_realizado_incrementa_vida_data is 'Tabela para quando o serviço realizado for especificamente um serviço que incrementa a vida do pneu';

create table if not exists public.movimentacao_pneu_servico_realizado_data
(
    cod_movimentacao        bigint                                                      not null
        constraint fk_movimentacao_pneu_servico_realizado_movimentacao
            references public.movimentacao,
    cod_servico_realizado   bigint                                                      not null,
    fonte_servico_realizado varchar(20) default 'FONTE_MOVIMENTACAO'::character varying not null
        constraint check_fonte_servico_realizado_fonte_movimentacao
            check ((fonte_servico_realizado)::text = 'FONTE_MOVIMENTACAO'::text),
    deletado                boolean     default false                                   not null,
    data_hora_deletado      timestamp with time zone,
    pg_username_delecao     text,
    constraint pk_movimentacao_pneu_servico_realizado
        primary key (cod_movimentacao, cod_servico_realizado),
    constraint fk_movimentacao_pneu_servico_realizado_pneu_servico_realizado
        foreign key (cod_servico_realizado, fonte_servico_realizado) references public.pneu_servico_realizado_data,
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.movimentacao_pneu_servico_realizado_data is 'Tabela de relacionamento entre movimentação e o serviço realizado no pneu';

create table if not exists public.movimentacao_pneu_servico_realizado_recapadora_data
(
    cod_movimentacao                   bigint                not null,
    cod_servico_realizado_movimentacao bigint                not null,
    cod_recapadora                     bigint                not null
        constraint fk_movimentacao_pneu_servico_realizado_recapadora_recapadora
            references public.recapadora,
    deletado                           boolean default false not null,
    data_hora_deletado                 timestamp with time zone,
    pg_username_delecao                text,
    constraint pk_movimentacao_pneu_servico_realizado_recapadora
        primary key (cod_movimentacao, cod_servico_realizado_movimentacao, cod_recapadora),
    constraint fk_servico_realizado_recapadora_movimentacao_servico
        foreign key (cod_movimentacao, cod_servico_realizado_movimentacao) references public.movimentacao_pneu_servico_realizado_data,
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.movimentacao_pneu_servico_realizado_recapadora_data is 'Tabela de relacionamento entre movimentação e a recapadora onde os serviços aconteceram';

create table if not exists public.pneu_servico_cadastro_data
(
    cod_pneu                bigint                                                  not null
        constraint fk_pneu_servico_cadastro_pneu
            references public.pneu_data,
    cod_servico_realizado   bigint                                                  not null,
    fonte_servico_realizado varchar(20) default 'FONTE_CADASTRO'::character varying not null
        constraint check_fonte_servico_realizado_fonte_cadastro
            check ((fonte_servico_realizado)::text = 'FONTE_CADASTRO'::text),
    deletado                boolean     default false                               not null,
    data_hora_deletado      timestamp with time zone,
    pg_username_delecao     text,
    constraint pk_pneu_servico_cadastro
        primary key (cod_pneu, cod_servico_realizado),
    constraint fk_pneu_servico_cadastro_pneu_servico_realizado
        foreign key (cod_servico_realizado, fonte_servico_realizado) references public.pneu_servico_realizado_data,
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.pneu_servico_cadastro_data is 'Pneus cadastrados que não são novos terão um serviço associado para mapear a troca de banda que o pneu sofreu';

create index if not exists idx_pneu_servico_cadastro_cod_pneu
    on public.pneu_servico_cadastro_data (cod_pneu);

create table if not exists raizen.produtividade
(
    codigo                    bigserial  not null
        constraint pk_produtividade
            primary key,
    cpf_motorista             bigint     not null,
    placa                     varchar(7) not null,
    data_viagem               date       not null,
    valor                     numeric    not null,
    usina                     varchar    not null,
    fazenda                   varchar    not null,
    raio_km                   numeric    not null,
    toneladas                 numeric    not null,
    cod_colaborador_cadastro  bigint     not null,
    cod_colaborador_alteracao bigint     not null,
    cod_unidade               bigint     not null
        constraint fk_produtividade_unidae
            references public.unidade,
    constraint entrada_nao_duplicada
        unique (cpf_motorista, placa, data_viagem, valor, usina, fazenda, raio_km, toneladas, cod_unidade)
);

comment on table raizen.produtividade is 'Tabela de produtividade Raízen';

create table if not exists public.afericao_configuracao_alerta_sulco
(
    codigo                                 bigserial             not null
        constraint pk_afericao_configuracao_alerta_sulco
            primary key,
    cod_unidade                            bigint                not null
        constraint unica_config_unidade
            unique
        constraint fk_afericao_configuracao_alerta_sulco_unidade
            references public.unidade,
    variacao_aceita_sulco_menor_milimetros double precision      not null,
    variacao_aceita_sulco_maior_milimetros double precision      not null,
    bloquear_valores_menores               boolean default false not null,
    bloquear_valores_maiores               boolean default false not null
);

create table if not exists public.afericao_configuracao_prolog
(
    variacao_aceita_sulco_menor_milimetros double precision      not null,
    variacao_aceita_sulco_maior_milimetros double precision      not null,
    bloquear_valores_menores               boolean default false not null,
    bloquear_valores_maiores               boolean default false not null
);

comment on table public.afericao_configuracao_prolog is 'Configurações de aferição que são definidas a nível ProLog. Para algumas parametrizações, esses valores são utilizados caso o cliente não defina algo específico para sua operação.';

create table if not exists public.marcacao_inicio
(
    cod_marcacao_inicio bigint not null
        constraint unique_cod_marcacao_inicio
            unique
        constraint fk_marcacao_inicio_intervalo
            references public.intervalo
);

comment on table public.marcacao_inicio is 'Armazena apenas marcações de início';

create table if not exists public.marcacao_fim
(
    cod_marcacao_fim bigint not null
        constraint unique_cod_marcacao_fim
            unique
        constraint fk_marcacao_fim_intervalo
            references public.intervalo
);

comment on table public.marcacao_fim is 'Armazena apenas marcações de fim';

create table if not exists public.marcacao_vinculo_inicio_fim
(
    codigo                bigserial not null
        constraint pk_marcacao_vinculo_inicio_fim
            primary key,
    cod_marcacao_inicio   bigint    not null
        constraint unico_codigo_inicio
            unique
        constraint fk_marcacao_vinculo_marcacao_inicio
            references public.marcacao_inicio (cod_marcacao_inicio),
    cod_marcacao_fim      bigint    not null
        constraint unico_codigo_fim
            unique
        constraint fk_marcacao_vinculo_marcacao_fim
            references public.marcacao_fim (cod_marcacao_fim),
    possui_inconsistencia boolean default false,
    constraint unico_vinculo_inicio_fim
        unique (cod_marcacao_inicio, cod_marcacao_fim)
);

comment on table public.marcacao_vinculo_inicio_fim is 'Armazena o código da marcação de início vinculando a uma marcação de fim';

create table if not exists public.marcacao_justificativa_ajuste
(
    codigo                        bigserial            not null
        constraint pk_marcacao_justificativa_ajuste
            primary key,
    nome                          text                 not null,
    cod_empresa                   bigint
        constraint fk_marcacao_justificativa_ajuste_empresa
            references public.empresa,
    obriga_observacao             boolean default true not null,
    status_ativo                  boolean default true not null,
    editavel                      boolean default true not null,
    cod_colaborador_criacao       bigint
        constraint fk_marcacao_justificativa_ajuste_colaborador_criacao
            references public.colaborador_data (codigo),
    data_hora_criacao             timestamp,
    cod_colaborador_ultima_edicao bigint
        constraint fk_marcacao_justificativa_ajuste_colaborador_edicao
            references public.colaborador_data (codigo),
    data_hora_ultima_edicao       timestamp,
    constraint unique_nome_justificativa_edicao
        unique (cod_empresa, nome),
    constraint check_editavel_empresa
        check (NOT ((cod_empresa IS NULL) AND (editavel IS TRUE)))
);

comment on table public.marcacao_justificativa_ajuste is 'Contém as possíveis justificativas que os ajustes de marcações poderão ter';

comment on column public.marcacao_justificativa_ajuste.cod_empresa is 'Se o COD_EMPRESA for null, então essa justificativa é a nível ProLog, disponível para todas as empresas';

create table if not exists public.marcacao_ajuste
(
    codigo                   bigserial                not null
        constraint pk_marcacao_ajuste
            primary key,
    cod_justificativa_ajuste bigint                   not null
        constraint fk_marcacao_ajuste_marcacao_justificativa_ajuste
            references public.marcacao_justificativa_ajuste,
    observacao_ajuste        text,
    acao_ajuste              varchar(25)              not null
        constraint check_achao_edicao
            check ((acao_ajuste)::text = ANY
                   (ARRAY [('ADICAO'::character varying)::text, ('EDICAO'::character varying)::text, ('ATIVACAO'::character varying)::text, ('INATIVACAO'::character varying)::text, ('ADICAO_INICIO_FIM'::character varying)::text])),
    cod_unidade_ajuste       bigint                   not null
        constraint fk_marcacao_ajuste_unidade
            references public.unidade,
    cod_colaborador_ajuste   bigint                   not null
        constraint fk_marcacao_ajuste_colaborador
            references public.colaborador_data (codigo),
    data_hora_ajuste         timestamp with time zone not null
);

comment on table public.marcacao_ajuste is 'Salva metadados sobre o ajuste da marcação';

comment on column public.marcacao_ajuste.cod_unidade_ajuste is 'Salva o código da unidade onde em que o colaborador que fez o ajuste estava alocado ao realizar a ação. Também é útil para sabermos qual Time Zone aplicar nos timestamps.';

create table if not exists public.marcacao_historico
(
    codigo           bigserial                not null
        constraint pk_marcacao_historico
            primary key,
    cod_marcacao     bigint                   not null
        constraint fk_marcacao_historico_marcacao
            references public.intervalo,
    cod_ajuste       bigint                   not null
        constraint fk_marcacao_historico_marcacao_ajuste
            references public.marcacao_ajuste,
    data_hora_antiga timestamp with time zone not null
);

comment on table public.marcacao_historico is 'Salva os históricos de uma marcação, cada ajuste realizado deverá gerar uma nova entrada nessa tabela';

create table if not exists public.marcacao_inconsistencia
(
    codigo                          bigserial not null
        constraint pk_marcacao_inconsistencia
            primary key,
    cod_marcacao_vinculo_inicio_fim bigint    not null
        constraint fk_marcacao_vinculo_inicio_fim
            references public.marcacao_vinculo_inicio_fim,
    cod_marcacao_inconsistente      bigint    not null
        constraint fk_marcacao_inconsistencia_marcacao
            references public.intervalo
);

comment on table public.marcacao_inconsistencia is 'Vincula os códigos das marcações que foram sincronizadas para o mesmo início';

create table if not exists integracao.token_integracao
(
    cod_empresa      bigint not null
        constraint unique_empresa_token_integracao
            unique
        constraint fk_token_integracao_empresa
            references public.empresa,
    token_integracao text   not null
        constraint unique_token_token_integracao
            unique
);

comment on table integracao.token_integracao is 'Tabela para armazenar o token utilizado por cada empresa para a autenticação da integração';

create table if not exists integracao.old_log_requisicao
(
    codigo               bigserial not null
        constraint pk_log_integracao
            primary key,
    cod_empresa          bigint    not null
        constraint fk_log_requisicao_empresa
            references public.empresa,
    class_resource       text,
    method_resource      text,
    http_method          text,
    url_acesso           text,
    headers              text,
    path_parameters      text,
    query_parameters     text,
    body_request         text,
    data_hora_requisicao timestamp
);

comment on table integracao.old_log_requisicao is 'Tabela para armazenar o log de informações de cada requisição realizada nos endpoints de integração';

create table if not exists public.pneu_transferencia_processo
(
    codigo                           bigserial                        not null
        constraint pk_pneu_transferencia_processo
            primary key,
    cod_unidade_origem               bigint                           not null
        constraint fk_pneu_transferencia_processo_unidade_origem
            references public.unidade,
    cod_unidade_destino              bigint                           not null
        constraint fk_pneu_transferencia_processo_unidade_destino
            references public.unidade,
    cod_unidade_colaborador          bigint                           not null
        constraint fk_pneu_transferencia_processo_unidade_colaborador
            references public.unidade,
    cod_colaborador                  bigint                           not null
        constraint fk_pneu_transferencia_processo_colaborador
            references public.colaborador_data (codigo),
    data_hora_transferencia_processo timestamp with time zone         not null,
    observacao                       varchar,
    tipo_processo_transferencia      tipo_processo_transferencia_pneu not null,
    constraint unidade_origem_destino_diferentes
        check (cod_unidade_origem <> cod_unidade_destino)
);

create table if not exists public.pneu_transferencia_informacoes
(
    codigo                       bigserial not null
        constraint pk_pneu_transferencia_informacoes
            primary key,
    cod_processo_transferencia   bigint    not null
        constraint fk_pneu_transferencia_informacoes_pneu_transferencia_processo
            references public.pneu_transferencia_processo,
    cod_pneu                     bigint    not null
        constraint fk_pneu_transferencia_informacoes_pneu
            references public.pneu_data,
    altura_sulco_interno         real,
    altura_sulco_central_interno real,
    altura_sulco_central_externo real,
    altura_sulco_externo         real,
    psi                          real      not null,
    vida_momento_transferencia   integer   not null,
    posicao_pneu_transferencia   integer,
    constraint todos_sulcos_null_ou_todos_not_null
        check ((ROW (altura_sulco_externo, altura_sulco_central_externo, altura_sulco_central_interno, altura_sulco_interno) IS NOT NULL) OR
               (ROW (altura_sulco_externo, altura_sulco_central_externo, altura_sulco_central_interno, altura_sulco_interno) IS NULL))
);

create table if not exists public.marcacao_tipo_jornada
(
    cod_unidade      bigint not null
        constraint um_tipo_jornada_por_unidade
            unique,
    cod_tipo_jornada bigint not null
        constraint tipo_usado_apenas_uma_vez
            unique,
    constraint pk_marcacao_tipo_jornada
        primary key (cod_unidade, cod_tipo_jornada),
    constraint fk_tipo_jornada_calculo_jornada_bruta
        foreign key (cod_unidade, cod_tipo_jornada) references public.intervalo_tipo (cod_unidade, codigo)
);

create table if not exists public.marcacao_tipos_descontados_calculo_jornada_bruta_liquida
(
    cod_unidade              bigint  not null,
    cod_tipo_jornada         bigint  not null,
    cod_tipo_descontado      bigint  not null
        constraint tipo_descontado_jornada_bruta_apenas_uma_vez
            unique,
    desconta_jornada_bruta   boolean not null,
    desconta_jornada_liquida boolean not null,
    constraint pk_marcacao_tipos_calculo_jornada_bruta_liquida
        primary key (cod_unidade, cod_tipo_jornada, cod_tipo_descontado),
    constraint fk_tipo_descontado_jornada_calculo_jornada_bruta_liquida
        foreign key (cod_unidade, cod_tipo_descontado) references public.intervalo_tipo (cod_unidade, codigo),
    constraint fk_tipo_jornada_calculo_jornada_bruta_liquida
        foreign key (cod_unidade, cod_tipo_jornada) references public.marcacao_tipo_jornada,
    constraint desconta_bruta_ou_liquida_nao_ambos
        check ((desconta_jornada_bruta AND (NOT desconta_jornada_liquida)) OR
               (desconta_jornada_liquida AND (NOT desconta_jornada_bruta)))
);

create table if not exists prolog_analises.veiculo_alteracao_km
(
    codigo              bigserial                              not null
        constraint veiculo_alteracao_km_pkey
            primary key,
    placa               varchar(7)                             not null,
    cod_unidade_alocado bigint                                 not null
        constraint fk_veiculo_alteracao_km_unidade
            references public.unidade,
    km_antigo           bigint                                 not null,
    km_novo             bigint                                 not null,
    data_hora_edicao    timestamp with time zone default now() not null
);

create table if not exists public.prolog_sql_error_code
(
    codigo            bigserial    not null,
    sql_error_code    varchar(5)   not null
        constraint unique_sql_error_code
            unique
        constraint check_cod_erro_size
            check (length((sql_error_code)::text) = 5)
        constraint check_cod_erro_uppercase
            check (upper((sql_error_code)::text) = (sql_error_code)::text),
    prolog_error_code varchar(255) not null
        constraint unique_prolog_error_code
            unique,
    descricao         text         not null
);

comment on table public.prolog_sql_error_code is 'Tabela utilizada para armazenar os códigos que pode ser lançados em exceptions no banco de dados';

create table if not exists public.veiculo_tipo_backup
(
    codigo       bigserial    not null,
    cod_unidade  bigint       not null
        constraint veiculo_tipo_backup_cod_unidade_fkey
            references public.unidade,
    nome         varchar(255) not null,
    status_ativo boolean      not null,
    cod_diagrama smallint
        constraint veiculo_tipo_backup_cod_diagrama_fkey
            references public.veiculo_diagrama,
    constraint unique_tipo_veiculo_backup_unidade
        primary key (codigo, cod_unidade)
);

create table if not exists public.veiculo_backup
(
    placa                varchar(7) not null,
    cod_unidade          integer    not null,
    km                   bigint,
    status_ativo         boolean    not null,
    cod_tipo             bigint,
    cod_modelo           bigint
        constraint veiculo_backup_cod_modelo_fkey
            references public.modelo_veiculo,
    cod_eixos            bigint,
    data_hora_cadastro   timestamp with time zone default now(),
    cod_unidade_cadastro integer    not null,
    codigo               bigserial  not null,
    constraint unique_veiculo_unidade_backup
        primary key (placa, cod_unidade),
    constraint veiculo_backup_cod_tipo_fkey
        foreign key (cod_tipo, cod_unidade) references public.veiculo_tipo_backup
);

create table if not exists public.afericao_configuracao_tipo_afericao_veiculo_backup
(
    codigo                    bigserial not null
        constraint afericao_configuracao_tipo_afericao_veiculo_backup_pkey
            primary key,
    cod_unidade               bigint    not null
        constraint afericao_configuracao_tipo_afericao_veiculo_ba_cod_unidade_fkey
            references public.unidade,
    cod_tipo_veiculo          bigint    not null,
    pode_aferir_sulco         boolean   not null,
    pode_aferir_pressao       boolean   not null,
    pode_aferir_sulco_pressao boolean   not null,
    pode_aferir_estepe        boolean   not null,
    constraint unique_tipo_veiculo_unidade_backup
        unique (cod_tipo_veiculo, cod_unidade),
    constraint afericao_configuracao_tipo_afericao_veicu_cod_tipo_veiculo_fkey
        foreign key (cod_tipo_veiculo, cod_unidade) references public.veiculo_tipo_backup
);

create table if not exists public.checklist_modelo_veiculo_tipo_backup
(
    cod_unidade      bigint not null
        constraint checklist_modelo_veiculo_tipo_backup_cod_unidade_fkey
            references public.unidade,
    cod_modelo       bigint not null
        constraint checklist_modelo_veiculo_tipo_backup_cod_modelo_fkey
            references public.checklist_modelo_data,
    cod_tipo_veiculo bigint not null,
    constraint checklist_modelo_veiculo_tipo_backup_pkey
        primary key (cod_unidade, cod_modelo, cod_tipo_veiculo),
    constraint checklist_modelo_veiculo_tipo_backup_cod_tipo_veiculo_fkey
        foreign key (cod_tipo_veiculo, cod_unidade) references public.veiculo_tipo_backup
);

create table if not exists public.pneu_ordem_nomenclatura_unidade_backup
(
    cod_tipo_veiculo bigint       not null,
    cod_unidade      bigint       not null
        constraint fk_pneu_ordem_nomenclatura_unidade_unidade_backup
            references public.unidade,
    posicao_prolog   integer      not null
        constraint fk_pneu_ordem_nomenclatura_unidade_pneu_posicao_backup
            references public.pneu_posicao,
    nomenclatura     varchar(255) not null,
    constraint pk_pneu_ordem_nomenclatura_unidade_backup
        primary key (cod_tipo_veiculo, cod_unidade, posicao_prolog),
    constraint fk_pneu_nomenclatura_tipo_veiculo_backup
        foreign key (cod_tipo_veiculo, cod_unidade) references public.veiculo_tipo_backup
);

create table if not exists public.checklist_offline_dados_unidade
(
    cod_unidade                   bigint           not null
        constraint pk_checklist_offline_dados_unidade
            primary key
        constraint fk_checklist_offline_dados_unidade
            references public.unidade,
    versao_dados                  bigint default 1 not null,
    token_sincronizacao_checklist text             not null
        constraint unique_token_sincronizacao_checklist
            unique
);

comment on table public.checklist_offline_dados_unidade is 'Esta tabela contém os dados de controle para possibilitar o checklist offline';

create table if not exists public.checklist_offline_empresa_bloqueada
(
    cod_empresa bigint not null
        constraint pk_checklist_offline_empresa_bloqueada
            primary key
        constraint fk_checklist_offline_empresa_bloqueada
            references public.empresa
);

comment on table public.checklist_offline_empresa_bloqueada is 'Essa tabela contém as empresas em que o checklist offline não é permitido';

create table if not exists integracao.checklist_ordem_servico_item_resolvido
(
    cod_empresa                   bigint                   not null
        constraint fk_integracao_item_resolvido_empresa
            references public.empresa,
    cod_unidade                   bigint                   not null
        constraint fk_integracao_item_resolvido_unidade
            references public.unidade,
    cod_os                        bigint                   not null,
    cod_item_os                   bigint                   not null,
    data_hora_sincronia_resolucao timestamp with time zone not null,
    constraint unique_item_ordem_servico_resolvido
        unique (cod_empresa, cod_unidade, cod_os, cod_item_os)
);

create table if not exists public.funcao_prolog_agrupamento
(
    codigo    smallserial  not null
        constraint pk_funcao_prolog_agrupamento
            primary key,
    nome      varchar(255) not null,
    cod_pilar bigint       not null
        constraint fk_funcao_prolog_agrupamento_pilar_prolog
            references public.pilar_prolog,
    constraint unique_agrupamento_pilar
        unique (codigo, cod_pilar)
);

comment on table public.funcao_prolog_agrupamento is 'Armazena os nomes dos grupos em que as permissões podem ser reunidas.';

create table if not exists public.funcao_prolog_v11
(
    codigo          bigint                        not null,
    cod_pilar       bigint                        not null
        constraint funcao_prolog_v11_cod_pilar_fkey
            references public.pilar_prolog,
    impacto         prolog_impacto_permissao_type not null,
    cod_agrupamento smallint                      not null,
    descricao       text                          not null,
    funcao          varchar(255)                  not null,
    constraint funcao_prolog_v11_pkey
        primary key (codigo, cod_pilar),
    constraint fk_funcao_prolog_v11_funcao_prolog_agrupamento
        foreign key (cod_agrupamento, cod_pilar) references public.funcao_prolog_agrupamento (codigo, cod_pilar)
);

create table if not exists public.cargo_funcao_prolog_v11
(
    cod_unidade            bigint not null
        constraint cargo_funcao_prolog_v11_cod_unidade_fkey1
            references public.unidade,
    cod_funcao_colaborador bigint not null
        constraint fk_cargo_funcao_prolog_cargo
            references public.funcao_data,
    cod_funcao_prolog      bigint not null,
    cod_pilar_prolog       bigint not null
        constraint cargo_funcao_prolog_v11_cod_pilar_prolog_fkey1
            references public.pilar_prolog,
    constraint cargo_funcao_prolog_v11_pkey
        primary key (cod_unidade, cod_funcao_colaborador, cod_funcao_prolog, cod_pilar_prolog),
    constraint cargo_funcao_prolog_v11_cod_pilar_prolog_fkey
        foreign key (cod_pilar_prolog, cod_funcao_prolog) references public.funcao_prolog_v11 (cod_pilar, codigo)
            on update cascade
);

create table if not exists public.dashboard_componente_funcao_prolog
(
    cod_componente    smallint not null
        constraint fk_dashboard_componente_funcao_prolog_dashboard_componente
            references public.dashboard_componente,
    cod_funcao_prolog bigint   not null,
    cod_pilar_prolog  bigint   not null,
    constraint pk_dashboard_componente_funcao_prolog
        primary key (cod_componente, cod_funcao_prolog),
    constraint fk_dashboard_componente_funcao_prolog_funcao_prolog
        foreign key (cod_funcao_prolog, cod_pilar_prolog) references public.funcao_prolog_v11
);

create table if not exists public.pneu_tipo_desgaste_irregular
(
    codigo                        smallint                     not null
        constraint pk_pneu_tipo_desgaste_irregular
            primary key,
    tipo_desgaste_irregular       pneu_desgaste_irregular_type not null
        constraint unique_tipo_desgaste_irregular_pneu
            unique,
    descricao                     text                         not null,
    aparencia_pneu                text                         not null,
    causas_provaveis              text                         not null,
    acao                          text                         not null,
    precaucao                     text                         not null,
    analisado_relatorio_desgastes boolean default false        not null
);

comment on table public.pneu_tipo_desgaste_irregular is 'Descreve cada tipo de desgaste irregular que está mapeado no ProLog.';

comment on column public.pneu_tipo_desgaste_irregular.analisado_relatorio_desgastes is 'Informa se o tipo de desgaste é um
desgaste atualmente analisado e estratificado pelo ProLog no relatório de desgastes irregulares.';

create table if not exists public.pneu_nivel_desgaste_irregular_padrao_prolog
(
    tipo_desgaste_irregular             pneu_desgaste_irregular_type not null
        constraint pk_pneu_nivel_desgaste_irregular_padrao_prolog
            primary key
        constraint fk_pneu_nivel_desgaste_prolog_tipo_desgaste
            references public.pneu_tipo_desgaste_irregular (tipo_desgaste_irregular),
    faixa_desgaste_baixo_milimetros     numrange                     not null,
    faixa_desgaste_moderado_milimetros  numrange                     not null,
    faixa_desgaste_acentuado_milimetros numrange                     not null
);

comment on table public.pneu_nivel_desgaste_irregular_padrao_prolog is 'Essa tabela salva cada tipo de desgaste analisado pelo
ProLog e qual a faixa de sulco, em milímetros, que é analisada para categorizar um desgaste no nível correto, sendo:
BAIXO, MODERADO ou ACENTUADO.';

create table if not exists public.veiculo_transferencia_processo
(
    codigo                           bigserial                not null
        constraint pk_veiculo_transferencia_processo
            primary key,
    cod_unidade_origem               bigint                   not null
        constraint fk_veiculo_transferencia_processo_unidade_origem
            references public.unidade,
    cod_unidade_destino              bigint                   not null
        constraint fk_veiculo_transferencia_processo_unidade_destino
            references public.unidade,
    cod_unidade_colaborador          bigint                   not null
        constraint fk_veiculo_transferencia_processo_unidade_colaborador
            references public.unidade,
    cod_colaborador_realizacao       bigint                   not null
        constraint fk_veiculo_transferencia_processo_colaborador
            references public.colaborador_data (codigo),
    data_hora_transferencia_processo timestamp with time zone not null,
    observacao                       text,
    constraint unidade_origem_destino_diferentes
        check (cod_unidade_origem <> cod_unidade_destino)
);

comment on table public.veiculo_transferencia_processo is 'Tabela utilizada para salvar um processo de transferência de veículos. Um processo pode conter vários veículos.';

create table if not exists public.veiculo_transferencia_informacoes
(
    codigo                           bigserial not null
        constraint pk_veiculo_transferencia_informacoes
            primary key,
    cod_processo_transferencia       bigint    not null
        constraint fk_veiculo_transferencia_info_veiculo_transferencia_proc
            references public.veiculo_transferencia_processo,
    cod_veiculo                      bigint    not null
        constraint fk_veiculo_transferencia_informacoes_veiculo
            references public.veiculo_data (codigo),
    cod_diagrama_veiculo             bigint    not null
        constraint fk_veiculo_transferencia_informacoes_diagrama
            references public.veiculo_diagrama,
    cod_tipo_veiculo                 bigint    not null
        constraint fk_veiculo_transferencia_informacoes_tipo_veiculo
            references public.veiculo_tipo,
    km_veiculo_momento_transferencia bigint    not null
);

comment on table public.veiculo_transferencia_informacoes is 'Tabela utilizada para salvar as informações de cada veículo transferido. Toda transferência possuí um processo
associado.';

create table if not exists public.veiculo_transferencia_vinculo_processo_pneu
(
    cod_veiculo_transferencia_informacoes bigint not null
        constraint unique_vinculo_processo_transferencia_veiculo
            unique
        constraint fk_vinculo_veiculo_transferencia_informacoes
            references public.veiculo_transferencia_informacoes,
    cod_processo_transferencia_pneu       bigint not null
        constraint unique_vinculo_processo_transferencia_pneu
            unique
        constraint fk_vinculo_pneu_transferencia_processo
            references public.pneu_transferencia_processo,
    constraint pk_vinculo_transferencia_veiculo_pneu
        primary key (cod_veiculo_transferencia_informacoes, cod_processo_transferencia_pneu)
);

comment on table public.veiculo_transferencia_vinculo_processo_pneu is 'Tabela utilizada para salvar os códigos de vínculos entre um processo de transferência de um veículo com o processo
de transferência dos pneus que estavam aplicados nesse veículo.';

create table if not exists public.afericao_manutencao_servico_deletado_transferencia
(
    cod_servico                           bigint               not null
        constraint pk_afericao_manutencao_servico_deletado_transferencia
            primary key,
    servico_deletado                      boolean default true not null,
    cod_veiculo_transferencia_informacoes bigint               not null
        constraint fk_servico_deletado_transferencia_informacoes
            references public.veiculo_transferencia_informacoes,
    constraint fk_servico_deletado_transferencia_afericao_manutencao
        foreign key (cod_servico, servico_deletado) references public.afericao_manutencao_data (codigo, deletado)
            deferrable
);

comment on table public.afericao_manutencao_servico_deletado_transferencia is 'Tabela utilizada para salvar os serviços de pneus que foram deletados como consequência de uma transferência de veículos.';

create table if not exists comercial.unidade_cargo_controle_jornada
(
    cod_empresa bigint not null
        constraint fk_unidade_cargo_controle_jornada_empresa
            references public.empresa,
    cod_unidade bigint not null,
    cod_cargo   bigint not null,
    constraint pk_unidade_cargo_controle_jornada
        primary key (cod_empresa, cod_unidade, cod_cargo),
    constraint fk_unidade_cargo_controle_jornada_cargo
        foreign key (cod_empresa, cod_cargo) references public.funcao_data (cod_empresa, codigo),
    constraint fk_unidade_cargo_controle_jornada_unidade
        foreign key (cod_empresa, cod_unidade) references public.unidade (cod_empresa, codigo)
);

comment on table comercial.unidade_cargo_controle_jornada is 'Tabela para armazenar quais cargos de uma unidade utilizam o controle de jornada';

create table if not exists public.checklist_diferentes_unidades_empresa_bloqueada
(
    cod_empresa bigint not null
        constraint pk_checklist_diferentes_unidades_empresa_bloqueada
            primary key
        constraint fk_checklist_diferentes_unidades_empresa_bloqueada
            references public.empresa
);

comment on table public.checklist_diferentes_unidades_empresa_bloqueada is 'Essa tabela contém as empresas em que a realização de checklist de diferentes unidades está bloqueada para os usuários.
Isso é especialmente útil em caso de integrações onde o sistema integrado não suporta isso.';

create table if not exists audit.unidade_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit.funcao_data_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists public.dispositivo_movel_marca_prolog
(
    codigo serial not null
        constraint pk_dispositivo_movel_marca_prolog
            primary key,
    nome   citext not null
        constraint unique_dispositivo_movel_marca_dispositivo
            unique
);

comment on table public.dispositivo_movel_marca_prolog is 'Marcas de dispositivos móveis a nível ProLog';

create table if not exists public.dispositivo_movel
(
    codigo      bigserial not null
        constraint pk_dispositivo_movel
            primary key,
    cod_empresa bigint    not null
        constraint fk_dispositivo_movel_cod_empresa
            references public.empresa,
    cod_marca   bigint
        constraint fk_dispositivo_movel_cod_marca
            references public.dispositivo_movel_marca_prolog,
    modelo      varchar(55),
    descricao   text
);

comment on table public.dispositivo_movel is 'Tabela que armazena os dados dos dispositivos móveis';

comment on column public.dispositivo_movel.cod_marca is 'Pode ser null para evitar de o usuário tentar cadastrar um dispositivo de uma marca que não existe no ProLog e isso impedir o cadastro dele';

create table if not exists public.dispositivo_movel_imei
(
    codigo          bigserial   not null
        constraint dispositivo_movel_imei_pkey
            primary key,
    cod_empresa     bigint      not null
        constraint fk_dispositivo_movel_imei_empresa
            references public.empresa,
    cod_dispositivo bigint      not null
        constraint fk_dispositivo_movel_imei_dispositivo
            references public.dispositivo_movel,
    imei            varchar(15) not null
);

comment on table public.dispositivo_movel_imei is 'Tabela que armazena os IMEIs dos dispositivos móveis';

create unique index if not exists dispositivo_movel_imei_uindex
    on public.dispositivo_movel_imei (cod_empresa, imei);

create table if not exists audit.veiculo_data_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit.pneu_data_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit.colaborador_data_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit.empresa_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists public.veiculo_diagrama_posicao_prolog
(
    cod_diagrama   bigint not null
        constraint veiculo_diagrama_posicao_prolog_cod_diagrama_fkey
            references public.veiculo_diagrama,
    posicao_prolog bigint not null
        constraint veiculo_diagrama_posicao_prolog_posicao_prolog_fkey
            references public.pneu_posicao,
    constraint diagrama_posicao_prolog
        unique (cod_diagrama, posicao_prolog)
);

create table if not exists agendador.configuracao_agendamento
(
    cod_empresa              bigint not null
        constraint unique_cod_empresa_agendador
            unique
        constraint fk_configuracao_agendamento_empresa
            references public.empresa,
    initial_delay_in_minutes bigint not null,
    delay_in_minutes         bigint not null,
    funcionalidade_key       text   not null
);

comment on table agendador.configuracao_agendamento is 'Tabela para armazenar as configurações de agendamento de sincronização que a empresa utilizará.';

create table if not exists integracao.veiculo_cadastrado
(
    cod_empresa_cadastro        bigint                   not null
        constraint fk_veiculo_cadastro_empresa
            references public.empresa,
    cod_unidade_cadastro        bigint                   not null
        constraint fk_veiculo_cadastro_unidade
            references public.unidade,
    cod_veiculo_cadastro_prolog bigint                   not null
        constraint fk_veiculo_cadastro_veiculo
            references public.veiculo_data (codigo),
    placa_veiculo_cadastro      text                     not null,
    data_hora_cadastro_prolog   timestamp with time zone not null,
    data_hora_ultima_edicao     timestamp with time zone,
    constraint unique_placa_cadastrada_empresa_integracao
        unique (cod_empresa_cadastro, placa_veiculo_cadastro)
);

comment on table integracao.veiculo_cadastrado is 'Tabela utilizada para salvar os veículos que foram cadastrados no ProLog a partir de integrações';

create table if not exists audit.pneu_restricao_unidade_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists public.veiculo_transferencia_bloqueio_delecao_os
(
    cod_empresa                       bigint  not null
        constraint pk_empresa_bloqueada_fechamento_os_transferencia
            primary key
        constraint fk_veiculo_transferencia_empresa_bloqueada_fechamento_os_empres
            references public.empresa,
    bloquear_delecao_os_checklist     boolean not null,
    bloquear_delecao_servicos_pneu    boolean not null,
    aviso_bloqueio_tela_transferencia text    not null,
    constraint check_pelo_menos_um_bloqueado
        check (bloquear_delecao_servicos_pneu OR bloquear_delecao_os_checklist)
);

comment on table public.veiculo_transferencia_bloqueio_delecao_os is 'Tabela com a função de armazenar as empresas
onde a deleção automática de OS de check e serviços de pneu não acontecerá sempre que uma transferência de veículos
for realizada.';

create table if not exists integracao.pneu_cadastrado
(
    cod_pneu_cadastro_prolog    bigint                   not null
        constraint fk_pneu_cadastro_pneu
            references public.pneu_data,
    cod_pneu_sistema_integrado  bigint                   not null,
    cod_empresa_cadastro        bigint                   not null
        constraint fk_pneu_cadastro_empresa
            references public.empresa,
    cod_unidade_cadastro        bigint                   not null
        constraint fk_pneu_cadastro_unidade
            references public.unidade,
    cod_cliente_pneu_cadastro   text                     not null,
    token_autenticacao_cadastro text                     not null,
    data_hora_cadastro_prolog   timestamp with time zone not null,
    data_hora_ultima_edicao     timestamp with time zone,
    constraint unique_pneu_cadastrado_empresa_integracao
        unique (cod_empresa_cadastro, cod_cliente_pneu_cadastro),
    constraint unique_cod_pneu_sistema_integrado_empresa
        unique (cod_empresa_cadastro, cod_pneu_sistema_integrado)
);

comment on table integracao.pneu_cadastrado is 'Tabela utilizada para salvar os pneus que foram cadastrados no ProLog a partir de integrações';

create table if not exists public.pneu_posicao_nomenclatura_empresa
(
    cod_empresa              bigint                   not null
        constraint fk_pneu_posicao_nomenclatura_empresa_empresa
            references public.empresa,
    cod_diagrama             bigint                   not null,
    posicao_prolog           integer                  not null,
    nomenclatura             varchar(255)             not null,
    cod_colaborador_cadastro bigint
        constraint fk_pneu_posicao_nomenclatura_empresa_colaborador
            references public.colaborador_data (codigo),
    data_hora_cadastro       timestamp with time zone not null,
    constraint unique_diagrama_empresa_posicao_prolog
        unique (cod_diagrama, cod_empresa, posicao_prolog),
    constraint fk_pneu_posicao_nomenclatura_empresa_diagrama_posicao_prolog
        foreign key (cod_diagrama, posicao_prolog) references public.veiculo_diagrama_posicao_prolog (cod_diagrama, posicao_prolog)
);

comment on table public.pneu_posicao_nomenclatura_empresa is 'Armazena a nomenclatura que cada posição de pneu deve ter para cada empresa/diagrama, EX: 111 / DD';

comment on column public.pneu_posicao_nomenclatura_empresa.cod_colaborador_cadastro is 'Se a coluna possuir valor null, a inserção
foi realizada através da migração da tabela antiga ou import';

create table if not exists suporte.fechamento_os
(
    codigo                     bigserial not null
        constraint fechamento_os_pkey
            primary key,
    cpf_mecanico               bigint,
    data_hora_fim_resolucao    timestamp with time zone,
    data_hora_inicio_resolucao timestamp with time zone,
    tempo_realizacao           bigint,
    placa_veiculo              varchar(7),
    km                         bigint,
    data_hora_conserto         timestamp with time zone,
    feedback_conserto          text,
    cod_unidade                bigint,
    cod_os                     bigint,
    cod_pergunta               bigint,
    cod_alternativa            bigint,
    status_item_fechado        boolean,
    mensagem_status_item       text,
    status_os_fechada          boolean,
    mensagem_status_os         text,
    usuario                    name,
    data_solicitacao           date,
    hora_solicitacao           time
);

create table if not exists aferidor.comandos_bluetooth
(
    codigo           bigserial not null
        constraint pk_comando
            primary key,
    nome             text      not null,
    descricao        text      not null,
    comando_envio    text,
    valor_retorno    text,
    exemplo_execucao text      not null
);

comment on table aferidor.comandos_bluetooth is 'Salva todos os comandos bluetooth compreensíveis pelo Aferidor Zalf.';

create table if not exists aferidor.comandos_teste
(
    one_row  boolean default true not null
        constraint pk_comandos_teste
            primary key
        constraint check_one_row
            check (one_row),
    comandos text[]               not null
);

comment on table aferidor.comandos_teste is 'Salva os comandos que devem ser enviados ao aferidor para concluirmos um procedimento de testes.
Essa tabela está restrita a ter no máximo uma linha.';

create table if not exists aferidor.procedimento_teste
(
    codigo                   bigserial                not null
        constraint pk_procedimento_teste
            primary key,
    cod_colaborador_execucao bigint                   not null
        constraint fk_procedimento_teste_colaborador
            references public.colaborador_data (codigo),
    data_hora_execucao       timestamp with time zone not null,
    nome_dispositivo         text                     not null,
    valores_execucao         jsonb                    not null
);

comment on table aferidor.procedimento_teste is 'Salva os procedimentos de testes já realizados no aferidor.';

create table if not exists cs.nps_pesquisa
(
    codigo                      bigserial            not null
        constraint pk_nps_pesquisa
            primary key,
    titulo_pesquisa             text                 not null,
    breve_descricao_pesquisa    varchar(255),
    periodo_veiculacao_pesquisa daterange            not null,
    titulo_pergunta_escala      text                 not null,
    titulo_pergunta_descritiva  text,
    status_ativo                boolean default true not null,
    legenda_escala_baixa        varchar(255)         not null,
    legenda_escala_alta         varchar(255)         not null
);

comment on table cs.nps_pesquisa is 'Salva as pesquisas de NPS que queremos disponibilizar aos usuários do ProLog.
Só é permitido uma única pesquisa ativa por vez. Também não é permitido pesquisas diferentes com datas de veiculação que se sobreponham.';

create index if not exists nps_pesquisa_periodo_veiculacao_pesquisa_excl
    on cs.nps_pesquisa (periodo_veiculacao_pesquisa)
    where status_ativo;

create unique index if not exists idx_nps_pesquisa_status_ativo
    on cs.nps_pesquisa (status_ativo)
    where status_ativo;

create table if not exists cs.nps_respostas
(
    codigo                        bigserial                not null
        constraint pk_nps_respostas
            primary key,
    cod_nps_pesquisa              bigint                   not null
        constraint fk_nps_respostas_nps_pesquisa
            references cs.nps_pesquisa,
    cod_colaborador_respostas     bigint                   not null
        constraint fk_nps_respostas_colaborador
            references public.colaborador_data (codigo),
    data_hora_realizacao_pesquisa timestamp with time zone not null,
    resposta_pergunta_escala      smallint                 not null
        constraint check_resposta_escala_valor_valido
            check ((resposta_pergunta_escala >= 0) AND (resposta_pergunta_escala <= 10)),
    resposta_pergunta_descritiva  text,
    constraint unique_resposta_nps_colaborador
        unique (cod_nps_pesquisa, cod_colaborador_respostas)
);

comment on table cs.nps_respostas is 'Salva as respostas dos usuários a uma pesquisa de NPS realizada no ProLog.';

create table if not exists cs.nps_bloqueio_pesquisa_colaborador
(
    cod_nps_pesquisa            bigint                   not null
        constraint fk_nps_respostas_nps_pesquisa
            references cs.nps_pesquisa,
    cod_colaborador_bloqueio    bigint                   not null
        constraint fk_nps_respostas_colaborador
            references public.colaborador_data (codigo),
    data_hora_bloqueio_pesquisa timestamp with time zone not null,
    constraint unique_bloqueio_nps_colaborador
        unique (cod_nps_pesquisa, cod_colaborador_bloqueio)
);

comment on table cs.nps_bloqueio_pesquisa_colaborador is 'Salva quais pesquisas o colaborador bloqueou para não ser exibida mais para ele.
Dessa forma, mesmo que uma pesquisa esteja ativa e ainda em veiculação, se um colaborador bloqueá-la, ela não será mais exibida para ele,
mesmo que ele ainda não a tenha respondido.';

create table if not exists integracao.log_request_response
(
    codigo            bigserial not null
        constraint pk_log_request_response
            primary key,
    cod_emresa        bigint,
    token_integracao  text,
    response_status   integer,
    request_json      jsonb,
    response_json     jsonb,
    data_hora_request timestamp with time zone
);

create table if not exists audit.veiculo_pneu_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.veiculo_diagrama_usuario_prolog
(
    codigo               bigserial not null
        constraint veiculo_diagrama_usuario_prolog_pkey
            primary key,
    cod_veiculo_diagrama bigint
        constraint veiculo_diagrama_usuario_prolog_cod_veiculo_diagrama_fkey
            references public.veiculo_diagrama,
    nome                 varchar(255),
    qtd_eixos            integer
);

create table if not exists implantacao.dados_autor_import
(
    codigo      bigserial not null
        constraint dados_autor_import_pkey
            primary key,
    cod_empresa bigint,
    cod_unidade bigint,
    usuario     text,
    data_hora   timestamp with time zone default now(),
    tipo_import varchar(255)
        constraint check_tipo_import_not_null
            check (tipo_import IS NOT NULL)
);

create table if not exists implantacao.prolog_user
(
    codigo   bigserial not null
        constraint prolog_user_pkey
            primary key,
    username text      not null
        constraint prolog_user_username_key
            unique,
    password text      not null
);

create table if not exists integracao.empresa_integracao_sistema
(
    codigo            bigserial not null
        constraint pk_empresa_integracao
            primary key,
    cod_empresa       bigint    not null
        constraint fk_empresa_integracao_empresa
            references public.empresa,
    chave_sistema     text      not null,
    recurso_integrado text      not null,
    constraint unique_empresa_integracao
        unique (cod_empresa, chave_sistema, recurso_integrado)
);

create table if not exists integracao.empresa_integracao_metodos
(
    cod_integracao_sistema bigint not null
        constraint fk_empresa_integracao_sistema_metodos
            references integracao.empresa_integracao_sistema,
    metodo_integrado       text   not null,
    url_completa           text   not null,
    api_token_client       text,
    api_short_code         bigint,
    constraint unique_metodo_integrado
        unique (cod_integracao_sistema, metodo_integrado, url_completa)
);

create table if not exists public.pneu_restricao_unidade_historico
(
    codigo                     bigserial                not null
        constraint pk_pneu_restricao_unidade_historico
            primary key,
    cod_restricao_unidade_pneu bigint                   not null
        constraint fk_pneu_restricao_unidade
            references public.pneu_restricao_unidade,
    cod_empresa                bigint                   not null
        constraint fk_pneu_restricao_unidade_empresa
            references public.empresa,
    cod_unidade                bigint                   not null
        constraint fk_pneu_restricao_unidade_unidade
            references public.unidade,
    cod_colaborador            bigint
        constraint fk_pneu_restricao_unidade_colaborador
            references public.colaborador_data (codigo),
    data_hora_alteracao        timestamp with time zone not null,
    tolerancia_calibragem      real                     not null,
    tolerancia_inspecao        real                     not null,
    sulco_minimo_recapagem     real                     not null,
    sulco_minimo_descarte      real                     not null,
    periodo_afericao_pressao   integer                  not null,
    periodo_afericao_sulco     integer                  not null
);

create table if not exists audit.afericao_data_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_expressonepomuceno_contagem_2019_12_16_natan
(
    codigo                  bigserial not null,
    cod_dados_autor_import  bigint,
    cod_unidade_editavel    bigint,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.v_expressonepomuceno_feiradesantana_2019_12_17_natan
(
    codigo                  bigserial not null,
    cod_dados_autor_import  bigint,
    cod_unidade_editavel    bigint,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao.v_expressonepomuceno_feiradesantana_2019_12_17_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_expressonepomuceno_ilheus_2019_12_18_natan
(
    codigo                  bigserial not null
        constraint v_expressonepomuceno_ilheus_2019_12_18_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_expressonepomuceno_ilheus_2019_12_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_expressonepomuceno_ilheus_2019_12_1_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.v_expressonepomuceno_suzano_2019_12_18_natan
(
    codigo                  bigserial not null
        constraint v_expressonepomuceno_suzano_2019_12_18_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_expressonepomuceno_suzano_2019_12_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_expressonepomuceno_suzano_2019_12_1_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao."v_expressonepomuceno_jundiaí_2019_12_18_natan"
(
    codigo                  bigserial not null
        constraint "v_expressonepomuceno_jundiaí_2019_12_18_natan_pkey"
            primary key,
    cod_dados_autor_import  bigint
        constraint "v_expressonepomuceno_jundiaí_2019__cod_dados_autor_import_fkey"
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint "v_expressonepomuceno_jundiaí_2019_12_cod_unidade_editavel_fkey"
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao."v_expressonepomuceno_asjundiaí_2019_12_18_natan"
(
    codigo                  bigserial not null
        constraint "v_expressonepomuceno_asjundiaí_2019_12_18_natan_pkey"
            primary key,
    cod_dados_autor_import  bigint
        constraint "v_expressonepomuceno_asjundiaí_201_cod_dados_autor_import_fkey"
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint "v_expressonepomuceno_asjundiaí_2019__cod_unidade_editavel_fkey"
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao."v_expressonepomuceno_asjundiaí_2019_12_18_natan_audit"
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_expressonepomuceno_cdlasmg_2019_12_18_natan
(
    codigo                  bigserial not null
        constraint v_expressonepomuceno_cdlasmg_2019_12_18_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_expressonepomuceno_cdlasmg_2019_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_expressonepomuceno_cdlasmg_2019_12__cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao."v_grupoimediato_cdd-campinas_2019_12_18_natan"
(
    codigo                  bigserial not null
        constraint "v_grupoimediato_cdd-campinas_2019_12_18_natan_pkey"
            primary key,
    cod_dados_autor_import  bigint
        constraint "v_grupoimediato_cdd-campinas_2019_1_cod_dados_autor_import_fkey"
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint "v_grupoimediato_cdd-campinas_2019_12__cod_unidade_editavel_fkey"
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao."v_grupoimediato_emp-ambev-guarulhos_2019_12_18_natan"
(
    codigo                  bigserial not null
        constraint "v_grupoimediato_emp-ambev-guarulhos_2019_12_18_natan_pkey"
            primary key,
    cod_dados_autor_import  bigint
        constraint "v_grupoimediato_emp-ambev-guarulhos_cod_dados_autor_import_fkey"
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint "v_grupoimediato_emp-ambev-guarulhos_2_cod_unidade_editavel_fkey"
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao."v_grupoimediato_emp-ambev-agudos_2019_12_18_natan"
(
    codigo                  bigserial not null
        constraint "v_grupoimediato_emp-ambev-agudos_2019_12_18_natan_pkey"
            primary key,
    cod_dados_autor_import  bigint
        constraint "v_grupoimediato_emp-ambev-agudos_20_cod_dados_autor_import_fkey"
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint "v_grupoimediato_emp-ambev-agudos_2019_cod_unidade_editavel_fkey"
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.v_cod_emp_54_cod_unidade_369_2020_1_17_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_54_cod_unidade_369_2020_1_17_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_54_cod_unidade_369_2020_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_54_cod_unidade_369_2020_1_1_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.p_cod_emp_54_cod_unidade_369_2020_1_17_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_54_cod_unidade_369_2020_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_54_cod_unidade_369_2020_1_17_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists migration_checklist.base_checklist_alternativas_agg
(
    cod_checklist        bigint not null
        constraint base_checklist_alternativas_agg_pkey
            primary key,
    cod_checklist_modelo bigint,
    alternativas         text
);

create index if not exists idx_bcaa_alternativas
    on migration_checklist.base_checklist_alternativas_agg (alternativas);

create table if not exists migration_checklist.migration_checklist_modelos
(
    cod_checklist_modelo                     bigint,
    ordem_versao                             integer,
    cod_checklist_modelo_versao              bigint,
    alternativas                             text,
    cod_checklist_primeira_realizacao_modelo bigint,
    checklists_realizados_versao             bigint[]
);

create table if not exists migration_checklist.migration_checklist
(
    cod_checklist        bigint,
    cod_checklist_modelo bigint,
    alternativas         text
);

create index if not exists idx_migration_checklist_alternativas_cod_checklist_modelo
    on migration_checklist.migration_checklist (alternativas, cod_checklist_modelo);

create table if not exists public.checklist_modelo_versao
(
    cod_versao_checklist_modelo    bigserial                not null
        constraint pk_checklist_modelo_versao
            primary key,
    cod_versao_user_friendly       bigint                   not null,
    cod_checklist_modelo           bigint                   not null
        constraint fk_checklist_modelo_versao_checklist_modelo
            references public.checklist_modelo_data
            deferrable,
    data_hora_criacao_versao       timestamp with time zone not null,
    cod_colaborador_criacao_versao bigint
        constraint fk_checklist_modelo_versao_colaborador
            references public.colaborador_data (codigo)
        constraint check_colaborador_not_null_acima_versao_1
            check (cod_colaborador_criacao_versao IS NOT NULL),
    constraint unique_versao_user_friendly_modelo_checklist
        unique (cod_checklist_modelo, cod_versao_user_friendly),
    constraint unique_versao_modelo_checklist
        unique (cod_checklist_modelo, cod_versao_checklist_modelo)
);

comment on table public.checklist_modelo_versao is 'Salva as versões de um modelo de checklist. data_hora_criacao_versao e cod_colaborador_criacao_versao
    podem ser nulos pois na primeira versão não tínhamos quando foi criada e nem quem criou. Porém, existem checks que impedem que essas colunas
    sejam nulas em novas versões.';

create table if not exists public.checklist_data
(
    cod_unidade                        bigint                   not null
        constraint fk_checklist_unidade
            references public.unidade,
    cod_checklist_modelo               bigint                   not null,
    codigo                             bigserial                not null
        constraint pk_checklist
            primary key,
    data_hora                          timestamp with time zone not null,
    cpf_colaborador                    bigint                   not null
        constraint fk_checklist_colaborador
            references public.colaborador_data,
    placa_veiculo                      varchar(7)               not null
        constraint fk_checklist_placa
            references public.veiculo_data,
    tipo                               char,
    tempo_realizacao                   bigint,
    km_veiculo                         bigint,
    data_hora_sincronizacao            timestamp with time zone not null,
    fonte_data_hora_realizacao         text                     not null
        constraint check_fonte_data_hora_realizacao
            check ((fonte_data_hora_realizacao = 'SERVIDOR'::text) OR
                   (fonte_data_hora_realizacao = 'REDE_CELULAR'::text) OR
                   (fonte_data_hora_realizacao = 'LOCAL_CELULAR'::text)),
    versao_app_momento_realizacao      bigint,
    versao_app_momento_sincronizacao   bigint,
    device_id                          text,
    device_imei                        text,
    device_uptime_realizacao_millis    bigint,
    device_uptime_sincronizacao_millis bigint,
    foi_offline                        boolean                  not null,
    deletado                           boolean default false    not null,
    data_hora_deletado                 timestamp with time zone,
    data_hora_importado_prolog         timestamp with time zone,
    total_perguntas_ok                 smallint                 not null,
    total_perguntas_nok                smallint                 not null,
    total_alternativas_ok              smallint                 not null,
    total_alternativas_nok             smallint                 not null,
    pg_username_delecao                text,
    cod_versao_checklist_modelo        bigint                   not null,
    data_hora_realizacao_tz_aplicado   timestamp                not null,
    constraint unique_checklist
        unique (cod_unidade, cod_checklist_modelo, data_hora, cpf_colaborador, placa_veiculo, tipo, tempo_realizacao,
                km_veiculo, fonte_data_hora_realizacao, versao_app_momento_realizacao, device_id, device_imei,
                device_uptime_realizacao_millis),
    constraint fk_checklist_data_checklist_modelo_versao
        foreign key (cod_checklist_modelo, cod_versao_checklist_modelo) references public.checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.checklist_data is 'Checklist';

comment on column public.checklist_data.tipo is 'Tipo do checklist realizado, podendo ser saída ou retorno';

comment on column public.checklist_data.tempo_realizacao is 'Tempo de realização do checklist';

comment on column public.checklist_data.total_perguntas_ok is 'Total de perguntas OK no checklist.
    Uma pergunta é OK quando nenhuma de suas alternatias for selecionada durante a realização do checklist.';

comment on column public.checklist_data.total_perguntas_nok is 'Total de perguntas NOK no checklist.
    Uma pergunta é NOK quando pelo menos uma de suas alternatias for selecionada durante a realização do checklist.';

comment on column public.checklist_data.total_alternativas_ok is 'Total de alternativas OK no checklist, de todas as perguntas.
    Uma alternativa é OK quando não for selecionada durante a realização do checklist.';

comment on column public.checklist_data.total_alternativas_nok is 'Total de alternativas NOK no checklist, de todas as perguntas.
    Uma alternativa é NOK quando for selecionada durante a realização do checklist.';

comment on column public.checklist_data.data_hora_realizacao_tz_aplicado is 'A data/hora de realização do checklist já com o TZ da unidade onde foi realizado aplicado.';

create index if not exists idx_checklist_cod_unidade
    on public.checklist_data (cod_unidade);

create index if not exists idx_checklist_placa_veiculo
    on public.checklist_data (placa_veiculo);

create index if not exists idx_checklist_data_hora_realizacao_tz
    on public.checklist_data ((data_hora_realizacao_tz_aplicado::date));

alter table public.checklist_modelo_data
    add constraint fk_checklist_modelo_checklist_modelo_versao
        foreign key (cod_versao_atual) references public.checklist_modelo_versao
            deferrable;

create table if not exists public.checklist_perguntas_data
(
    cod_checklist_modelo        bigint                not null,
    cod_unidade                 bigint                not null
        constraint fk_checklist_perguntas_unidade
            references public.unidade,
    ordem                       integer               not null,
    pergunta                    text                  not null,
    single_choice               boolean               not null,
    cod_imagem                  bigint
        constraint fk_checklist_perguntas_checklist_galeria_imagens
            references public.checklist_galeria_imagens,
    codigo                      bigserial             not null
        constraint pk_checklist_perguntas
            primary key,
    deletado                    boolean default false not null,
    data_hora_deletado          timestamp with time zone,
    pg_username_delecao         text,
    cod_versao_checklist_modelo bigint,
    codigo_contexto             bigserial             not null,
    constraint unica_pergunta_versao
        unique (codigo_contexto, codigo),
    constraint fk_checklist_perguntas_checklist_modelo_versao
        foreign key (cod_checklist_modelo, cod_versao_checklist_modelo) references public.checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.checklist_perguntas_data is 'Perguntas de um checklist. ATENÇÃO: A deleção direta de perguntas está bloqueada por problemas de
    vínculo que podem acontecer no checklist offline. Só é possível deletar perguntas se todo o modelo de checklist
    for deletado junto. Caso queira remover uma pergunta específica mas ainda deixar o modelo rodando, opte por
    inatvar a perguntas ao invés de deletá-la. Além disso, se quiser remover o modelo como um todo, o ProLog possui
    functions que irão remover os bloqueios de deleção da tabela, deletar o modelo, e reativar os bloqueios.';

comment on column public.checklist_perguntas_data.ordem is 'Ordem que a pergunta deve aparecer no checklist';

comment on column public.checklist_perguntas_data.pergunta is 'Pergunta';

comment on column public.checklist_perguntas_data.single_choice is 'Tipo da pergunta, podendo ser de única ou múltipla escolha';

create table if not exists public.checklist_alternativa_pergunta_data
(
    cod_checklist_modelo        bigint                not null,
    cod_unidade                 bigint                not null
        constraint fk_checklist_alternativa_pergunta_unidade
            references public.unidade,
    alternativa                 text                  not null,
    ordem                       integer               not null,
    cod_pergunta                bigint                not null
        constraint fk_checklist_alternativa_pergunta_pergunta
            references public.checklist_perguntas_data,
    codigo                      bigserial             not null
        constraint pk_checklist_alternativa_pergunta
            primary key,
    alternativa_tipo_outros     boolean default false not null,
    prioridade                  varchar(7)            not null
        constraint fk_checklist_alternativa_prioridade
            references public.checklist_alternativa_prioridade,
    deve_abrir_ordem_servico    boolean default true  not null,
    deletado                    boolean default false not null,
    data_hora_deletado          timestamp with time zone,
    pg_username_delecao         text,
    cod_versao_checklist_modelo bigint,
    codigo_contexto             bigserial             not null,
    constraint unica_alternativa_versao
        unique (codigo_contexto, codigo),
    constraint fk_checklist_alternativa_pergunta_checklist_modelo_versao
        foreign key (cod_checklist_modelo, cod_versao_checklist_modelo) references public.checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.checklist_alternativa_pergunta_data is 'Alternativas de uma pergunta do checklist. ATENÇÃO: A deleção direta de alternativas está bloqueada por problemas de
    vínculo que podem acontecer no checklist offline. Só é possível deletar alternativas se todo o modelo de checklist
    for deletado junto. Caso queira remover uma alternativa específica mas ainda deixar o modelo rodando, opte por
    inatvar a alternativa ao invés de deletá-la. Além disso, se quiser remover o modelo como um todo, o ProLog possui
    functions que irão remover os bloqueios de deleção da tabela, deletar o modelo, e reativar os bloqueios.';

comment on column public.checklist_alternativa_pergunta_data.ordem is 'Ordem que a alternativa deve ser exibida dentro da pergunta';

comment on column public.checklist_alternativa_pergunta_data.prioridade is 'Salva a prioridade que essa alternativa possui, podendo ser: CRITICA, ALTA ou BAIXA';

create index if not exists idx_checklist_alternativa_pergunta_cod_pergunta
    on public.checklist_alternativa_pergunta_data (cod_pergunta);

CREATE RULE alternativa_check_delete_protect AS
    ON DELETE TO public.checklist_alternativa_pergunta_data DO INSTEAD NOTHING;

CREATE RULE pergunta_check_delete_protect AS
    ON DELETE TO public.checklist_perguntas_data DO INSTEAD NOTHING;

create table if not exists migration_checklist.checklist_respostas
(
    cod_checklist_modelo bigint not null,
    cod_unidade          bigint not null,
    cod_checklist        bigint not null
        constraint fk_checklist_respostas_checklist
            references public.checklist_data,
    resposta             text   not null,
    cod_pergunta         bigint not null,
    cod_alternativa      bigint not null
        constraint fk_checklist_respostas_alternativa_pergunta
            references public.checklist_alternativa_pergunta_data,
    constraint pk_checklist_respostas
        primary key (cod_checklist, cod_alternativa),
    constraint unica_resposta_alternativa
        unique (cod_unidade, cod_checklist_modelo, cod_checklist, cod_pergunta, cod_alternativa)
);

comment on table migration_checklist.checklist_respostas is 'Respostas de um checklist';

comment on column migration_checklist.checklist_respostas.resposta is 'Resposta descritiva caso a alternativa selecionada seja = Outros';

create index if not exists idx_checklist_respostas_cod_checklist
    on migration_checklist.checklist_respostas (cod_checklist);

create table if not exists public.checklist_ordem_servico_data
(
    codigo               bigint                not null,
    cod_unidade          bigint                not null
        constraint fk_checklist_ordem_servico_unidade
            references public.unidade,
    cod_checklist        bigint                not null
        constraint fk_checklist_ordem_servico_checklist
            references public.checklist_data,
    status               varchar(255)          not null,
    data_hora_fechamento timestamp with time zone,
    deletado             boolean default false not null,
    data_hora_deletado   timestamp with time zone,
    codigo_prolog        bigserial             not null,
    pg_username_delecao  text,
    constraint pk_checklist_ordem_servico
        primary key (codigo, cod_unidade),
    constraint unique_codigo_deletado_os_check
        unique (codigo_prolog, deletado),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL)))
);

comment on table public.checklist_ordem_servico_data is 'Ordens de serviço geradas pelo checklist';

comment on column public.checklist_ordem_servico_data.status is 'Status da OS, pode ser aberta (A) ou fechada (F)';

comment on column public.checklist_ordem_servico_data.data_hora_fechamento is 'Data que a OS foi fechada';

create table if not exists public.checklist_ordem_servico_itens_data
(
    cod_unidade                          bigint                not null
        constraint fk_checklist_ordem_servico_itens_unidade
            references public.unidade,
    cod_os                               bigint                not null,
    cpf_mecanico                         bigint
        constraint fk_checklist_ordem_servico_itens
            references public.colaborador_data,
    km                                   bigint,
    qt_apontamentos                      integer default 1     not null,
    status_resolucao                     text,
    tempo_realizacao                     bigint,
    data_hora_conserto                   timestamp with time zone,
    feedback_conserto                    text,
    codigo                               bigserial             not null
        constraint pk_checklist_ordem_servico_itens
            primary key,
    cod_pergunta_primeiro_apontamento    bigint                not null,
    cod_alternativa_primeiro_apontamento bigint                not null,
    data_hora_inicio_resolucao           timestamp with time zone,
    data_hora_fim_resolucao              timestamp with time zone,
    deletado                             boolean default false not null,
    data_hora_deletado                   timestamp with time zone,
    pg_username_delecao                  text,
    cod_contexto_pergunta                bigint,
    cod_contexto_alternativa             bigint,
    constraint item_os_nao_repetido_por_os
        unique (cod_os, cod_pergunta_primeiro_apontamento, cod_alternativa_primeiro_apontamento, cod_unidade),
    constraint unique_codigo_deletado_item_os_check
        unique (codigo, deletado),
    constraint fk_checklist_ordem_servico_itens_os
        foreign key (cod_os, cod_unidade) references public.checklist_ordem_servico_data,
    constraint fk_checklist_ordem_servico_itens_perguntas
        foreign key (cod_contexto_pergunta, cod_pergunta_primeiro_apontamento) references public.checklist_perguntas_data (codigo_contexto, codigo),
    constraint fk_checklist_ordem_servico_itens_alternativa_pergunta
        foreign key (cod_contexto_alternativa, cod_alternativa_primeiro_apontamento) references public.checklist_alternativa_pergunta_data (codigo_contexto, codigo),
    constraint deletado_check
        check ((NOT deletado) OR ((data_hora_deletado IS NOT NULL) AND (pg_username_delecao IS NOT NULL))),
    constraint check_data_hora_inicio_resolucao_not_null
        check (deletado OR (((data_hora_conserto IS NOT NULL) AND (data_hora_inicio_resolucao IS NOT NULL)) OR
                            ((data_hora_conserto IS NULL) AND (data_hora_inicio_resolucao IS NULL)))),
    constraint check_data_hora_fim_resolucao_not_null
        check (deletado OR (((data_hora_conserto IS NOT NULL) AND (data_hora_fim_resolucao IS NOT NULL)) OR
                            ((data_hora_conserto IS NULL) AND (data_hora_fim_resolucao IS NULL))))
);

comment on table public.checklist_ordem_servico_itens_data is 'Itens que compõe uma OS';

comment on column public.checklist_ordem_servico_itens_data.cpf_mecanico is 'Colaborador que realizou o conserto do item';

comment on column public.checklist_ordem_servico_itens_data.km is 'Km do veículo no momento do conserto do item';

comment on column public.checklist_ordem_servico_itens_data.qt_apontamentos is 'Quantidade de apontamentos que o mesmo item teve antes de ser consertado';

comment on column public.checklist_ordem_servico_itens_data.tempo_realizacao is 'Tempo de duração do conserto';

comment on column public.checklist_ordem_servico_itens_data.feedback_conserto is 'Descrição do serviço realizado';

comment on constraint check_data_hora_fim_resolucao_not_null on public.checklist_ordem_servico_itens_data is 'Constraint para impedir que novas linhas adicionadas tenham a DATA_HORA_FIM_RESOLUCAO nula.
    Ela foi criada usando NOT VALID para pular a verificação das linhas já existentes.
    Além disso, a verificação é ignorada para linhas deletadas, desse modo podemos deletar itens antigos que não
    têm essa informação salva.';

comment on constraint check_data_hora_inicio_resolucao_not_null on public.checklist_ordem_servico_itens_data is 'Constraint para impedir que novas linhas adicionadas tenham a DATA_HORA_INICIO_RESOLUCAO nula.
    Ela foi criada usando NOT VALID para pular a verificação das linhas já existentes.
    Além disso, a verificação é ignorada para linhas deletadas, desse modo podemos deletar itens antigos que não
    têm essa informação salva.';

create table if not exists public.checklist_ordem_servico_deletada_transferencia
(
    cod_os_prolog                         bigint               not null
        constraint pk_checklist_ordem_servico_deletada_transferencia
            primary key,
    os_deletada                           boolean default true not null,
    cod_veiculo_transferencia_informacoes bigint               not null
        constraint fk_os_deletada_transferencia_informacoes
            references public.veiculo_transferencia_informacoes,
    constraint fk_os_deletada_transferencia_checklist_ordem_servico
        foreign key (cod_os_prolog, os_deletada) references public.checklist_ordem_servico_data (codigo_prolog, deletado)
            deferrable
);

comment on table public.checklist_ordem_servico_deletada_transferencia is 'Tabela utilizada para salvar as OSs do checklist que foram deletadas como consequência de uma transferência de veículos.';

create table if not exists public.checklist_ordem_servico_item_deletado_transferencia
(
    cod_item_os_prolog bigint               not null
        constraint pk_checklist_ordem_servico_item_deletado_transferencia
            primary key,
    item_os_deletado   boolean default true not null,
    constraint fk_item_os_deletado_transferencia_checklist_ordem_servico_itens
        foreign key (cod_item_os_prolog, item_os_deletado) references public.checklist_ordem_servico_itens_data (codigo, deletado)
            deferrable
);

comment on table public.checklist_ordem_servico_item_deletado_transferencia is 'Tabela utilizada para salvar os itens de O.S. do checklist que foram deletados como consequência de uma transferência de veículos.';

create table if not exists piccolotur.checklist_pendente_para_sincronizar
(
    cod_checklist_para_sincronizar bigint                   not null
        constraint unique_cod_checklist_para_sincronizar
            unique
        constraint fk_checklist_pendente_para_sincronizar
            references public.checklist_data,
    sincronizado                   boolean default false    not null,
    precisa_ser_sincronizado       boolean default true     not null,
    next_to_sync                   boolean default false    not null,
    mensagem_erro_ao_sincronizar   text,
    qtd_tentativas                 integer default 0        not null,
    data_hora_realizado            timestamp with time zone not null,
    data_hora_ultima_atualizacao   timestamp with time zone
);

comment on table piccolotur.checklist_pendente_para_sincronizar is 'Tabela para armazenar os códigos dos checklists que precisam ser sincronizados e se já foram sincronizados';

comment on column piccolotur.checklist_pendente_para_sincronizar.qtd_tentativas is 'Coluna que contém a quantidade de tentativas de sincronia dos itens do checklist. Default será 0, pois o momento
    que é salvo o código nesta tabela não representa uma tentativa.';

comment on column piccolotur.checklist_pendente_para_sincronizar.data_hora_realizado is 'Coluna que salva a data e hora que o checklist foi inserido na tabela para ser sincronizado.';

comment on column piccolotur.checklist_pendente_para_sincronizar.data_hora_ultima_atualizacao is 'Coluna que salva a data e hora que aconteceu a última atualziação no código do checklist.
    São consideradas atualizações:
    1 - marcar como sincronizado
    2 - marcar como não precisa sincronizar
    3 - marcar como erro ao sincronizar';

create table if not exists piccolotur.checklist_item_nok_enviado_globus
(
    cod_unidade              bigint                   not null
        constraint fk_item_enviado_unidade
            references public.unidade,
    placa_veiculo_os         text                     not null,
    cpf_colaborador          bigint                   not null,
    cod_checklist            bigint                   not null
        constraint fk_item_enviado_checklist
            references public.checklist_data,
    cod_contexto_pergunta    bigint                   not null
        constraint fk_item_enviado_pergunta_checklist
            references public.checklist_perguntas_data,
    cod_contexto_alternativa bigint                   not null
        constraint fk_item_enviado_alternativa_checklist
            references public.checklist_alternativa_pergunta_data,
    data_hora_envio          timestamp with time zone not null,
    constraint unique_item_enviado_globus
        unique (cod_checklist, cod_contexto_pergunta, cod_contexto_alternativa)
);

comment on table piccolotur.checklist_item_nok_enviado_globus is 'Tabela para armazenar os itens nok que foram enviados para o Globus';

create table if not exists piccolotur.checklist_ordem_servico_item_vinculo
(
    cod_unidade                        bigint                   not null
        constraint fk_integracao_item_vinculo_unidade
            references public.unidade,
    cod_os_globus                      bigint                   not null,
    cod_item_os_globus                 bigint                   not null,
    cod_item_os_prolog                 bigint                   not null
        constraint fk_integracao_item_vinculo_item_prolog
            references public.checklist_ordem_servico_itens_data,
    placa_veiculo_os                   text                     not null,
    cod_checklist_os_prolog            bigint                   not null,
    cod_contexto_pergunta_os_prolog    bigint                   not null,
    cod_contexto_alternativa_os_prolog bigint                   not null,
    data_hora_sincronia_pendencia      timestamp with time zone not null,
    data_hora_sincronia_resolucao      timestamp with time zone,
    constraint unique_item_ordem_servico_vinculo_item_prolog
        unique (cod_unidade, cod_os_globus, cod_item_os_prolog),
    constraint fk_integracao_os_vinculo_os_prolog
        foreign key (cod_unidade, cod_os_globus) references public.checklist_ordem_servico_data (cod_unidade, codigo),
    constraint fk_integracao_item_vinculo_item_nok_enviado_globus
        foreign key (cod_checklist_os_prolog, cod_contexto_pergunta_os_prolog,
                     cod_contexto_alternativa_os_prolog) references piccolotur.checklist_item_nok_enviado_globus (cod_checklist, cod_contexto_pergunta, cod_contexto_alternativa)
);

comment on table piccolotur.checklist_ordem_servico_item_vinculo is 'Tabela utilizada para vincular as ordens de serviço abertas no ProLog a partir do Globus';

create table if not exists migration_checklist.check_perguntas_aux
(
    cod_modelo          bigint not null
        constraint check_perguntas_aux_cod_modelo_fkey
            references public.checklist_modelo_data,
    cod_modelo_versao   bigint not null
        constraint check_perguntas_aux_cod_modelo_versao_fkey
            references public.checklist_modelo_versao,
    cod_pergunta_antigo bigint not null
        constraint check_perguntas_aux_cod_pergunta_antigo_fkey
            references public.checklist_perguntas_data,
    cod_pergunta_novo   bigint not null
        constraint check_perguntas_aux_cod_pergunta_novo_fkey
            references public.checklist_perguntas_data
);

create index if not exists idx_perguntas_aux
    on migration_checklist.check_perguntas_aux (cod_pergunta_antigo, cod_modelo_versao);

create table if not exists migration_checklist.check_alternativas_aux
(
    cod_modelo             bigint not null
        constraint check_alternativas_aux_cod_modelo_fkey
            references public.checklist_modelo_data,
    cod_modelo_versao      bigint not null
        constraint check_alternativas_aux_cod_modelo_versao_fkey
            references public.checklist_modelo_versao,
    cod_alternativa_antigo bigint not null
        constraint check_alternativas_aux_cod_alternativa_antigo_fkey
            references public.checklist_alternativa_pergunta_data,
    cod_alternativa_novo   bigint not null
        constraint check_alternativas_aux_cod_alternativa_novo_fkey
            references public.checklist_alternativa_pergunta_data
);

create index if not exists idx_alternativas_aux
    on migration_checklist.check_alternativas_aux (cod_alternativa_antigo, cod_modelo_versao);

create table if not exists public.checklist_respostas_nok
(
    codigo                      bigserial not null
        constraint pk_checklist_respostas_nok
            primary key,
    cod_unidade                 bigint    not null
        constraint fk_checklist_respostas_unidade
            references public.unidade,
    cod_checklist_modelo        bigint    not null,
    cod_versao_checklist_modelo bigint    not null,
    cod_checklist               bigint    not null
        constraint fk_checklist_respostas_checklist
            references public.checklist_data,
    cod_pergunta                bigint    not null
        constraint fk_checklist_respostas_checklist_perguntas
            references public.checklist_perguntas_data,
    cod_alternativa             bigint    not null
        constraint fk_checklist_respostas_checklist_alternativa
            references public.checklist_alternativa_pergunta_data,
    resposta_outros             text,
    constraint unica_resposta_alternativa_por_check
        unique (cod_checklist, cod_alternativa),
    constraint fk_checklist_respostas_checklist_modelo_versao
        foreign key (cod_checklist_modelo, cod_versao_checklist_modelo) references public.checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo)
);

comment on table public.checklist_respostas_nok is 'Tabela que salva apenas as respostas NOK de um checklist realizado.';

comment on column public.checklist_respostas_nok.resposta_outros is 'Se a alternativa selecionada for do tipo outros e o
    usuário a tiver selecionado na realização do checklist, essa coluna irá conter a descrição que ele forneceu do problema.
    Caso contrário será NULL.';

create index if not exists idx_checklist_respostas_nok_cod_checklist
    on public.checklist_respostas_nok (cod_checklist);

create index if not exists idx_checklist_respostas_nok_cod_alternativa
    on public.checklist_respostas_nok (cod_alternativa);

create table if not exists migration_checklist.migra_cosi_aux_alternativa
(
    codigo_cosi             bigint,
    codigo_alternativa_novo bigint
);

create index if not exists idx_migra_cosi_aux_codigo_cosi_alternativa1
    on migration_checklist.migra_cosi_aux_alternativa (codigo_cosi);

create index if not exists idx_migra_cosi_aux_codigo_alternativa_novo1
    on migration_checklist.migra_cosi_aux_alternativa (codigo_alternativa_novo);

create table if not exists migration_checklist.migra_cosi_aux_pergunta
(
    codigo_cosi          bigint,
    codigo_pergunta_novo bigint
);

create index if not exists idx_migra_cosi_aux_codigo_cosi_pergunta1
    on migration_checklist.migra_cosi_aux_pergunta (codigo_cosi);

create index if not exists idx_migra_cosi_aux_codigo_pergunta_novo1
    on migration_checklist.migra_cosi_aux_pergunta (codigo_pergunta_novo);

create table if not exists public.checklist_ordem_servico_itens_apontamentos
(
    codigo                  bigserial not null
        constraint pk_checklist_apontamentos
            primary key,
    cod_item_ordem_servico  bigint    not null
        constraint fk_checklist_apontamentos_item_ordem_servico
            references public.checklist_ordem_servico_itens_data,
    cod_checklist_realizado bigint    not null
        constraint fk_checklist_apontamentos_checklist
            references public.checklist_data,
    cod_alternativa         bigint    not null
        constraint fk_checklist_alternativa
            references public.checklist_alternativa_pergunta_data,
    nova_qtd_apontamentos   integer   not null,
    constraint unica_qtd_apontamentos_por_item_ordem_servico
        unique (cod_item_ordem_servico, nova_qtd_apontamentos),
    constraint unica_alternativa_por_checklist
        unique (cod_checklist_realizado, cod_alternativa),
    constraint unico_item_ordem_servico_por_checklist
        unique (cod_checklist_realizado, cod_item_ordem_servico)
);

comment on table public.checklist_ordem_servico_itens_apontamentos is 'Salva os apontamentos que houveram nos itens abertos de OS.
        Cada checklist é responsável por incrementar um apontamento de um item já em aberto, com essa tabela conseguiremos
        saber quais checklists foram responsáveis por cada apontamento do item de OS.';

create index if not exists idx_check_itens_apontamentos_cod_item_os
    on public.checklist_ordem_servico_itens_apontamentos (cod_item_ordem_servico);

create table if not exists implantacao.v_cod_emp_59_cod_unidade_370_2020_1_23_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_59_cod_unidade_370_2020_1_23_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_59_cod_unidade_370_2020_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_59_cod_unidade_370_2020_1_2_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao.v_cod_emp_59_cod_unidade_370_2020_1_23_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.p_cod_emp_59_cod_unidade_370_2020_1_23_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_59_cod_unidade_370_2020_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_59_cod_unidade_370_2020_1_23_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists audit_implantacao.p_cod_emp_59_cod_unidade_370_2020_1_23_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_cod_emp_15_cod_unidade_216_2020_1_27_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_15_cod_unidade_216_2020_1_27_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_15_cod_unidade_216_2020_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_15_cod_unidade_216_2020_1_2_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao.v_cod_emp_15_cod_unidade_216_2020_1_27_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists integracao.empresa_config_carga_inicial
(
    cod_empresa          bigint                not null
        constraint pk_empresa_config_carga_inicial
            primary key
        constraint fk_cod_empresa_sobrescreve_pneus_integracao
            references public.empresa,
    sobrescreve_pneus    boolean default false not null,
    sobrescreve_veiculos boolean default false not null
);

create table if not exists implantacao.v_cod_emp_6_cod_unidade_209_2020_1_29_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_6_cod_unidade_209_2020_1_29_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_6_cod_unidade_209_2020_1__cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_6_cod_unidade_209_2020_1_29_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao.v_cod_emp_6_cod_unidade_209_2020_1_29_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.p_cod_emp_6_cod_unidade_209_2020_1_29_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_6_cod_unidade_209_2020_1__cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_6_cod_unidade_209_2020_1_29_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists audit_implantacao.p_cod_emp_6_cod_unidade_209_2020_1_29_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_cod_emp_24_cod_unidade_372_2020_1_29_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_24_cod_unidade_372_2020_1_29_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_24_cod_unidade_372_2020_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_24_cod_unidade_372_2020_1_2_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.p_cod_emp_24_cod_unidade_372_2020_1_29_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_24_cod_unidade_372_2020_1_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_24_cod_unidade_372_2020_1_29_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists audit_implantacao.p_cod_emp_24_cod_unidade_372_2020_1_29_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_cod_emp_15_cod_unidade_208_2020_2_3_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_15_cod_unidade_208_2020_2_3_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_15_cod_unidade_208_2020_2_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_15_cod_unidade_208_2020_2_3_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao.v_cod_emp_15_cod_unidade_208_2020_2_3_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_cod_emp_16_cod_unidade_218_2020_2_3_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_16_cod_unidade_218_2020_2_3_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_16_cod_unidade_218_2020_2_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_16_cod_unidade_218_2020_2_3_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.p_cod_emp_16_cod_unidade_218_2020_2_3_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_16_cod_unidade_218_2020_2_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_16_cod_unidade_218_2020_2_3_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists audit_implantacao.p_cod_emp_16_cod_unidade_218_2020_2_3_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_cod_emp_6_cod_unidade_83_2020_2_4_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_6_cod_unidade_83_2020_2_4_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_6_cod_unidade_83_2020_2_4_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_6_cod_unidade_83_2020_2_4_n_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao.v_cod_emp_6_cod_unidade_83_2020_2_4_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.p_cod_emp_6_cod_unidade_83_2020_2_4_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_6_cod_unidade_83_2020_2_4_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_6_cod_unidade_83_2020_2_4_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists implantacao.p_cod_emp_6_cod_unidade_85_2020_2_4_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_6_cod_unidade_85_2020_2_4_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_6_cod_unidade_85_2020_2_4_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists implantacao.v_cod_emp_6_cod_unidade_85_2020_2_4_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_6_cod_unidade_85_2020_2_4_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_6_cod_unidade_85_2020_2_4_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_6_cod_unidade_85_2020_2_4_n_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.v_cod_emp_6_cod_unidade_84_2020_2_5_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_6_cod_unidade_84_2020_2_5_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_6_cod_unidade_84_2020_2_5_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_6_cod_unidade_84_2020_2_5_n_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists implantacao.p_cod_emp_6_cod_unidade_84_2020_2_5_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_6_cod_unidade_84_2020_2_5_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_6_cod_unidade_84_2020_2_5_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists implantacao.p_cod_emp_6_cod_unidade_74_2020_2_5_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_6_cod_unidade_74_2020_2_5_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_6_cod_unidade_74_2020_2_5_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists implantacao.v_cod_emp_6_cod_unidade_74_2020_2_5_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_6_cod_unidade_74_2020_2_5_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_6_cod_unidade_74_2020_2_5_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_6_cod_unidade_74_2020_2_5_n_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists messaging.push_colaborador_token
(
    codigo                     bigserial                                 not null
        constraint pk_push_colaborador_token
            primary key,
    cod_colaborador            bigint                                    not null,
    token_colaborador_logado   text                                      not null,
    aplicacao_referencia_token messaging.aplicacao_referencia_token_type not null,
    token_push_firebase        text                                      not null
        constraint unique_token
            unique,
    data_hora_cadastro         timestamp with time zone                  not null,
    constraint fk_push_colaborador_token_colaborador
        foreign key (cod_colaborador, token_colaborador_logado) references public.token_autenticacao (cod_colaborador, token)
            on delete cascade
);

comment on table messaging.push_colaborador_token is 'Salva o token do Firebase que está atualmente associado ao colaborador.';

comment on column messaging.push_colaborador_token.token_push_firebase is 'Segundo a documentação, o token é único e não pode ser reutilizado.
    (https://stackoverflow.com/questions/52070864/is-a-fcm-token-reused).
    Essa tabela tem FK com PUBLIC.TOKEN_AUTENTICACAO. A FK é com "on delete cascade" para que quando um colaborador
    deslogue ele não receba mais notificações de push.';

create table if not exists messaging.push_log
(
    codigo                    bigserial                            not null
        constraint pk_push_log
            primary key,
    data_hora_log             timestamp with time zone             not null,
    push_message_scope        text                                 not null,
    push_message_sent         jsonb                                not null,
    message_type              messaging.push_message_type          not null,
    plataform_destination     messaging.push_plataform_destination not null,
    request_response_firebase jsonb                                not null,
    fatal_send_exception      text
);

comment on table messaging.push_log is 'Salva os logs de requisições de notificações feitas para o FCM e as respostas que obtivemos da API.';

comment on column messaging.push_log.push_message_sent is 'Mensagem que foi enviada.';

comment on column messaging.push_log.plataform_destination is 'Indica para qual plataforma a mensagem foi enviada.';

comment on column messaging.push_log.request_response_firebase is 'Contém o JSON de cada request e response feito à API do FCM. Um request é a requisição de envio para um
    destinatário específico. Os requests sempre irão existir, nem sempre existirá uma resposta ou, as vezes, existirá
    uma exception mostrando o erro capturado no envio para um destinatário específico.';

comment on column messaging.push_log.fatal_send_exception is 'Pode conter o stacktrace de uma exception fatal capturada na tentativa de realizar o envio das mensagens.
    Se existir algum conteúdo nessa coluna, significa que nenhuma mensagem pôde ser entregue, pois a falha foi geral.';

create table if not exists public.socorro_rota_opcao_problema
(
    codigo                             bigserial                not null
        constraint pk_socorro_rota_opcao_problema
            primary key,
    cod_empresa                        bigint                   not null
        constraint fk_socorro_rota_opcao_problema_empresa_codigo
            references public.empresa,
    descricao                          citext                   not null,
    obriga_descricao                   boolean                  not null,
    cod_colaborador_ultima_atualizacao bigint                   not null
        constraint fk_socorro_rota_opcao_problema_colaborador_codigo
            references public.colaborador_data (codigo),
    data_hora_ultima_atualizacao       timestamp with time zone not null,
    status_ativo                       boolean default true     not null
);

comment on column public.socorro_rota_opcao_problema.obriga_descricao is 'Campo para forçar o usuário a digitar uma
    descrição na abertura do socorro em rota, caso a opção de problema selecionada tenha esse campo marcado.';

create unique index if not exists unique_descricao_empresa
    on public.socorro_rota_opcao_problema (cod_empresa, descricao)
    where (status_ativo IS TRUE);

create table if not exists public.socorro_rota_opcao_problema_historico
(
    codigo                    bigserial                not null
        constraint pk_socorro_rota_opcao_problema_historico
            primary key,
    cod_problema_socorro_rota bigint                   not null
        constraint fk_socorro_rota_opcao_problema
            references public.socorro_rota_opcao_problema,
    cod_colaborador_alteracao bigint                   not null
        constraint fk_socorro_rota_opcao_problema_historico_colaborador
            references public.colaborador_data (codigo),
    data_hora_alteracao       timestamp with time zone not null,
    cod_empresa               bigint                   not null
        constraint fk_socorro_rota_opcao_problema_historico_empresa_codigo
            references public.empresa,
    descricao                 citext                   not null,
    obriga_descricao          boolean                  not null,
    status_ativo              boolean                  not null
);

comment on column public.socorro_rota_opcao_problema_historico.cod_colaborador_alteracao is 'Código do colaborador que
    realizou a última alteração, vindo da tabela socorro_rota_opcao_problema.';

comment on column public.socorro_rota_opcao_problema_historico.data_hora_alteracao is 'Data e hora da última alteração,
    vinda da tabela socorro_rota_opcao_problema.';

comment on column public.socorro_rota_opcao_problema_historico.descricao is 'Descrição anterior, vinda da tabela
    socorro_rota_opcao_problema.';

comment on column public.socorro_rota_opcao_problema_historico.obriga_descricao is 'Booleano de obrigação de descrição
    anterior, vindo da tabela socorro_rota_opcao_problema.';

create table if not exists public.socorro_rota
(
    codigo       bigserial                not null
        constraint pk_socorro_rota
            primary key,
    cod_unidade  bigint                   not null
        constraint fk_socorro_rota_unidade_codigo
            references public.unidade,
    status_atual socorro_rota_status_type not null
);

comment on table public.socorro_rota is 'Salva um socorro em rota específico e o seu estado atual.
Os estados possíveis são os seguintes:
ABERTO
ABERTO -> EM_ATENDIMENTO
ABERTO -> INVALIDO (motorista também pode se não tiver sido atendido ou o usuário com permissão)
EM_ATENDIMENTO -> FINALIZADO
EM_ATENDIMENTO -> INVALIDO';

create table if not exists public.socorro_rota_abertura
(
    codigo                               bigserial                not null
        constraint pk_socorro_rota_abertura
            primary key,
    cod_socorro_rota                     bigint                   not null
        constraint unica_abertura_socorro
            unique
        constraint fk_socorro_rota_abertura_socorro_rota
            references public.socorro_rota,
    cod_colaborador_abertura             bigint                   not null
        constraint fk_socorro_rota_abertura_colaborador_codigo
            references public.colaborador_data (codigo),
    cod_veiculo_problema                 bigint                   not null
        constraint fk_socorro_rota_abertura_veiculo_codigo
            references public.veiculo_data (codigo),
    km_veiculo_abertura                  bigint                   not null,
    cod_problema_socorro_rota            bigint                   not null
        constraint fk_socorro_rota_abertura_socorro_rota_opcao_problema
            references public.socorro_rota_opcao_problema,
    descricao_problema                   text,
    data_hora_abertura                   timestamp with time zone not null,
    url_foto_1_abertura                  text,
    url_foto_2_abertura                  text,
    url_foto_3_abertura                  text,
    latitude_abertura                    text                     not null,
    longitude_abertura                   text                     not null,
    precisao_localizacao_abertura_metros numeric                  not null,
    endereco_automatico                  text,
    ponto_referencia                     text,
    versao_app_momento_abertura          bigint                   not null,
    device_id_abertura                   text,
    device_imei_abertura                 text,
    device_uptime_millis_abertura        bigint,
    android_api_version_abertura         integer,
    marca_device_abertura                text,
    modelo_device_abertura               text
);

create table if not exists public.socorro_rota_atendimento
(
    codigo                                  bigserial                not null
        constraint pk_socorro_rota_atendimento
            primary key,
    cod_socorro_rota                        bigint                   not null
        constraint unico_atendimento_socorro
            unique
        constraint fk_socorro_rota_atendimento_socorro_rota
            references public.socorro_rota,
    cod_colaborador_atendimento             bigint                   not null
        constraint fk_socorro_rota_atendimento_colaborador_codigo
            references public.colaborador_data (codigo),
    observacao_atendimento                  text,
    data_hora_atendimento                   timestamp with time zone not null,
    latitude_atendimento                    text                     not null,
    longitude_atendimento                   text                     not null,
    precisao_localizacao_atendimento_metros numeric                  not null,
    endereco_automatico                     text,
    versao_app_momento_atendimento          bigint                   not null,
    device_id_atendimento                   text,
    device_imei_atendimento                 text,
    device_uptime_millis_atendimento        bigint,
    android_api_version_atendimento         integer,
    marca_device_atendimento                text,
    modelo_device_atendimento               text
);

create table if not exists public.socorro_rota_invalidacao
(
    codigo                                  bigserial                not null
        constraint pk_socorro_rota_invalidacao
            primary key,
    cod_socorro_rota                        bigint                   not null
        constraint unica_invalidacao_socorro
            unique
        constraint fk_socorro_rota_invalidacao_socorro_rota
            references public.socorro_rota,
    cod_colaborador_invalidacao             bigint                   not null
        constraint fk_socorro_rota_invalidacao_colaborador_codigo
            references public.colaborador_data (codigo),
    motivo_invalidacao                      text                     not null,
    data_hora_invalidacao                   timestamp with time zone not null,
    url_foto_1_invalidacao                  text,
    url_foto_2_invalidacao                  text,
    url_foto_3_invalidacao                  text,
    latitude_invalidacao                    text                     not null,
    longitude_invalidacao                   text                     not null,
    precisao_localizacao_invalidacao_metros numeric                  not null,
    endereco_automatico                     text,
    versao_app_momento_invalidacao          bigint                   not null,
    device_id_invalidacao                   text,
    device_imei_invalidacao                 text,
    device_uptime_millis_invalidacao        bigint,
    android_api_version_invalidacao         integer,
    marca_device_invalidacao                text,
    modelo_device_invalidacao               text
);

create table if not exists public.socorro_rota_finalizacao
(
    codigo                                  bigserial                not null
        constraint pk_socorro_rota_finalizacao
            primary key,
    cod_socorro_rota                        bigint                   not null
        constraint unica_finalizacao_socorro
            unique
        constraint fk_socorro_rota_finalizacao_socorro_rota
            references public.socorro_rota,
    cod_colaborador_finalizacao             bigint                   not null
        constraint fk_socorro_rota_finalizacao_colaborador_codigo
            references public.colaborador_data (codigo),
    observacao_finalizacao                  text                     not null,
    data_hora_finalizacao                   timestamp with time zone not null,
    url_foto_1_finalizacao                  text,
    url_foto_2_finalizacao                  text,
    url_foto_3_finalizacao                  text,
    latitude_finalizacao                    text                     not null,
    longitude_finalizacao                   text                     not null,
    precisao_localizacao_finalizacao_metros numeric                  not null,
    endereco_automatico                     text,
    versao_app_momento_finalizacao          bigint                   not null,
    device_id_finalizacao                   text,
    device_imei_finalizacao                 text,
    device_uptime_millis_finalizacao        bigint,
    android_api_version_finalizacao         integer,
    marca_device_finalizacao                text,
    modelo_device_finalizacao               text
);

create table if not exists public.prolog_paises
(
    codigo           serial      not null
        constraint pk_prolog_paises
            primary key,
    nome_upper       varchar(80) not null,
    nome             varchar(80) not null,
    sigla_iso2       char(2)     not null
        constraint prolog_paises_sigla_iso2_key
            unique,
    sigla_iso3       char(3) default NULL::bpchar,
    numero_un        smallint,
    prefixo_telefone integer     not null,
    constraint unique_sigla_iso2_prefixo_telefone
        unique (sigla_iso2, prefixo_telefone)
);

create table if not exists public.colaborador_telefone
(
    codigo                             bigserial                              not null
        constraint pk_colaborador_telefone
            primary key,
    cod_colaborador                    bigint                                 not null
        constraint fk_colaborador_telefone_colaborador_data_codigo
            references public.colaborador_data (codigo),
    sigla_iso2                         char(2)                                not null,
    prefixo_pais                       integer                                not null,
    numero_telefone                    text                                   not null,
    data_hora_ultima_atualizacao       timestamp with time zone default now() not null,
    cod_colaborador_ultima_atualizacao bigint                                 not null
        constraint fk_colaborador_telefone_atualizacao_colaborador_data_codigo
            references public.colaborador_data (codigo),
    constraint fk_colaborador_telefone_prolog_paises
        foreign key (sigla_iso2, prefixo_pais) references public.prolog_paises (sigla_iso2, prefixo_telefone)
);

create table if not exists public.colaborador_email
(
    codigo                             bigserial not null
        constraint pk_colaborador_email
            primary key,
    cod_colaborador                    bigint
        constraint fk_colaborador_email_colaborador_data_codigo
            references public.colaborador_data (codigo),
    email                              email     not null,
    data_hora_ultima_atualizacao       timestamp with time zone default now(),
    cod_colaborador_ultima_atualizacao bigint
        constraint fk_colaborador_email_atualizacao_colaborador_data_codigo
            references public.colaborador_data (codigo)
);

create table if not exists audit.push_colaborador_token_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit.colaborador_email_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit.colaborador_telefone_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists integracao.empresa_unidades_integracao_bloqueada
(
    codigo                bigserial not null
        constraint pk_empresa_unidades_integracao_bloqueadas
            primary key,
    cod_empresa           bigint    not null
        constraint fk_empresa_unidade_integracao_bloqueada_empresa
            references integracao.token_integracao (cod_empresa),
    cod_unidade_bloqueada bigint    not null,
    constraint unique_unidade_integracao_bloqueada
        unique (cod_empresa, cod_unidade_bloqueada),
    constraint fk_empresa_unidade_integracao_bloqueada_unidade
        foreign key (cod_empresa, cod_unidade_bloqueada) references public.unidade (cod_empresa, codigo)
);

comment on table integracao.empresa_unidades_integracao_bloqueada is 'Tabela que contém as unidades que estão com a integração bloqueada.';

comment on constraint fk_empresa_unidade_integracao_bloqueada_empresa on integracao.empresa_unidades_integracao_bloqueada is 'Constraint para garantir que nenhuma empresa nesta tabela não possua token e consequentemente integração.';

comment on constraint fk_empresa_unidade_integracao_bloqueada_unidade on integracao.empresa_unidades_integracao_bloqueada is 'Constraint para garantir que nenhuma unidade nesta tabela não pertença a empresas integradas.';

create table if not exists audit.token_autenticacao_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit_implantacao.v_cod_emp_6_cod_unidade_74_2020_2_5_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit_implantacao.v_cod_emp_6_cod_unidade_84_2020_2_5_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit_implantacao.v_cod_emp_6_cod_unidade_85_2020_2_4_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.v_cod_emp_60_cod_unidade_375_2020_2_19_natan
(
    codigo                  bigserial not null
        constraint v_cod_emp_60_cod_unidade_375_2020_2_19_natan_pkey
            primary key,
    cod_dados_autor_import  bigint
        constraint v_cod_emp_60_cod_unidade_375_2020_2_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade_editavel    bigint
        constraint v_cod_emp_60_cod_unidade_375_2020_2_1_cod_unidade_editavel_fkey
            references public.unidade,
    placa_editavel          varchar(255),
    km_editavel             bigint,
    marca_editavel          varchar(255),
    modelo_editavel         varchar(255),
    tipo_editavel           varchar(255),
    qtd_eixos_editavel      varchar(255),
    placa_formatada_import  varchar(255),
    marca_formatada_import  varchar(255),
    modelo_formatado_import varchar(255),
    tipo_formatado_import   varchar(255),
    status_import_realizado boolean,
    erros_encontrados       varchar(255),
    usuario_update          varchar(255)
);

create table if not exists audit_implantacao.v_cod_emp_60_cod_unidade_375_2020_2_19_natan_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists public.socorro_rota_empresa_liberada
(
    cod_empresa bigint not null
        constraint socorro_rota_empresa_liberada_pkey
            primary key
        constraint socorro_rota_empresa_liberada_cod_empresa_fkey
            references public.empresa
);

create table if not exists audit.relato_alternativa_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists piccolotur.checklist_erros_sincronia
(
    codigo                         bigserial not null
        constraint pk_checklist_erros_sincronia
            primary key,
    cod_checklist_para_sincronizar bigint    not null,
    nova_qtd_tentativas            integer   not null
        constraint check_nova_qtd_tentativas
            check (nova_qtd_tentativas > 0),
    error_stacktrace               text      not null,
    data_hora_erro                 timestamp with time zone
);

create table if not exists audit.socorro_rota_empresa_liberada_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists implantacao.p_cod_emp_61_cod_unidade_380_2020_3_3_natan
(
    codigo                                  bigserial not null,
    cod_dados_autor_import                  bigint
        constraint p_cod_emp_61_cod_unidade_380_2020_3_cod_dados_autor_import_fkey
            references implantacao.dados_autor_import,
    cod_unidade                             bigint
        constraint p_cod_emp_61_cod_unidade_380_2020_3_3_natan_cod_unidade_fkey
            references public.unidade,
    numero_fogo_editavel                    varchar(255),
    marca_editavel                          varchar(255),
    modelo_editavel                         varchar(255),
    dot_editavel                            varchar(20),
    dimensao_editavel                       varchar(255),
    pressao_recomendada_editavel            varchar(255),
    qtd_sulcos_editavel                     varchar(255),
    altura_sulcos_editavel                  varchar(255),
    valor_pneu_editavel                     varchar(255),
    valor_banda_editavel                    varchar(255),
    vida_atual_editavel                     varchar(255),
    vida_total_editavel                     varchar(255),
    marca_banda_editavel                    varchar(255),
    modelo_banda_editavel                   varchar(255),
    qtd_sulcos_banda_editavel               varchar(255),
    altura_sulcos_banda_editavel            varchar(255),
    pneu_novo_nunca_rodado_editavel         varchar(255),
    numero_fogo_formatado_import            varchar(255),
    marca_formatada_import                  varchar(255),
    modelo_formatado_import                 varchar(255),
    dot_formatado_import                    varchar(255),
    dimensao_formatada_import               varchar(255),
    pressao_recomendada_formatada_import    real,
    qtd_sulcos_formatada_import             smallint,
    altura_sulcos_formatada_import          real,
    valor_pneu_formatado_import             real,
    valor_banda_formatado_import            real,
    vida_atual_formatada_import             smallint,
    vida_total_formatada_import             smallint,
    marca_banda_formatada_import            varchar(255),
    modelo_banda_formatado_import           varchar(255),
    qtd_sulcos_banda_formatada_import       smallint,
    altura_sulcos_banda_formatada_import    real,
    pneu_novo_nunca_rodado_formatado_import boolean,
    status_import_realizado                 boolean,
    erros_encontrados                       text,
    usuario_update                          varchar(255)
);

create table if not exists audit.afericao_configuracao_tipo_afericao_veiculo_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);

create table if not exists audit.movimentacao_motivo_descarte_empresa_audit
(
    codigo              serial not null,
    data_hora_utc       timestamp with time zone default now(),
    operacao            varchar(1),
    pg_username         text,
    pg_application_name text,
    row_log             jsonb,
    is_new_row          boolean
);


create or replace view public.view_mapa_colaborador(mapa, cpf, cod_unidade) as
    SELECT m.mapa,
           c.cpf,
           c.cod_unidade
    FROM ((mapa m
        JOIN unidade_funcao_produtividade ufp ON ((ufp.cod_unidade = m.cod_unidade)))
             JOIN colaborador_data c
                  ON (((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                       (c.cod_unidade = m.cod_unidade))))
    UNION
    SELECT m.mapa,
           c.cpf,
           c.cod_unidade
    FROM ((mapa m
        JOIN unidade_funcao_produtividade ufp ON ((ufp.cod_unidade = m.cod_unidade)))
             JOIN colaborador_data c
                  ON (((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                       (c.cod_unidade = m.cod_unidade))))
    UNION
    SELECT m.mapa,
           c.cpf,
           c.cod_unidade
    FROM ((mapa m
        JOIN unidade_funcao_produtividade ufp ON ((ufp.cod_unidade = m.cod_unidade)))
             JOIN colaborador_data c
                  ON (((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                       (c.cod_unidade = m.cod_unidade))));

comment on view public.view_mapa_colaborador is 'View utilizada para linkar os mapas relizados por cada colaborador';

create or replace view public.view_valor_cx_unidade(cod_unidade, valor_cx_motorista_rota, valor_cx_ajudante_rota) as
SELECT DISTINCT m.cod_unidade,
                max(round(((m.vlbateujornmot / NULLIF(m.cxentreg, (0)::double precision)))::numeric,
                          2)) AS valor_cx_motorista_rota,
                max(round(((m.vlbateujornaju / NULLIF(m.cxentreg, (0)::double precision)))::numeric,
                          2)) AS valor_cx_ajudante_rota
FROM mapa m
WHERE ((m.vltotalmapa > (0)::double precision) AND (m.vlbateujornmot > (0)::double precision))
GROUP BY m.cod_unidade;

create or replace view public.resumo_dados(mapa, tracking, cod_unidade, "código_transportadora") as
SELECT DISTINCT m.data AS mapa,
                t.data AS tracking,
                m.cod_unidade,
                t."código_transportadora"
FROM (mapa m
         LEFT JOIN tracking t ON ((m.data = t.data)))
ORDER BY m.data DESC, t.data;

comment on view public.resumo_dados is 'View utilizada para juntar as datas que tem dados enviados ao sistema, planilhas ambev (2art e tracking)';

create or replace view public.view_intervalo(codigo_marcacao_por_unidade, codigo, cod_unidade, cod_tipo_intervalo,
                                             cpf_colaborador, data_hora, tipo_marcacao, fonte_data_hora,
                                             justificativa_tempo_recomendado, justificativa_estouro, latitude_marcacao,
                                             longitude_marcacao, valido, foi_ajustado, cod_colaborador_insercao,
                                             status_ativo, data_hora_sincronizacao) as
SELECT row_number() OVER (PARTITION BY i.cod_unidade ORDER BY i.codigo) AS codigo_marcacao_por_unidade,
       i.codigo,
       i.cod_unidade,
       i.cod_tipo_intervalo,
       i.cpf_colaborador,
       i.data_hora,
       i.tipo_marcacao,
       i.fonte_data_hora,
       i.justificativa_tempo_recomendado,
       i.justificativa_estouro,
       i.latitude_marcacao,
       i.longitude_marcacao,
       i.valido,
       i.foi_ajustado,
       i.cod_colaborador_insercao,
       i.status_ativo,
       i.data_hora_sincronizacao
FROM intervalo i;

create or replace view public.pneu_valor_vida(cod_unidade, cod_pneu, cod_modelo_banda, vida, valor) as
SELECT srr.cod_unidade,
       srr.cod_pneu,
       srrec.cod_modelo_banda,
       srrec.vida_nova_pneu AS vida,
       srr.custo            AS valor
FROM (pneu_servico_realizado_data srr
         JOIN pneu_servico_realizado_incrementa_vida_data srrec ON ((srr.codigo = srrec.cod_servico_realizado)));

comment on view public.pneu_valor_vida is 'View que contém o valor e a vida associados a um pneu, somente para pneus que já foram recapados.';

create or replace view public.view_analise_pneus("UNIDADE ALOCADO", "COD PNEU", "COD PNEU CLIENTE", "STATUS PNEU",
                                                 cod_unidade, "MARCA", "MODELO", "MEDIDAS", "QTD DE AFERIÇÕES",
                                                 "DTA 1a AFERIÇÃO", "DTA ÚLTIMA AFERIÇÃO", "DIAS ATIVO",
                                                 "MÉDIA KM POR DIA", altura_sulco_interno, altura_sulco_central_interno,
                                                 altura_sulco_central_externo, altura_sulco_externo,
                                                 "MAIOR MEDIÇÃO VIDA", "MENOR SULCO ATUAL", "MILIMETROS GASTOS",
                                                 "KMS POR MILIMETRO", "KMS A PERCORRER", "DIAS RESTANTES",
                                                 "PREVISÃO DE TROCA") as
SELECT u.nome                                                                           AS "UNIDADE ALOCADO",
       p.codigo                                                                         AS "COD PNEU",
       p.codigo_cliente                                                                 AS "COD PNEU CLIENTE",
       p.status                                                                         AS "STATUS PNEU",
       p.cod_unidade,
       map.nome                                                                         AS "MARCA",
       mp.nome                                                                          AS "MODELO",
       ((((dp.largura || '/'::text) || dp.altura) || ' R'::text) || dp.aro)             AS "MEDIDAS",
       dados.qt_afericoes                                                               AS "QTD DE AFERIÇÕES",
       to_char((dados.primeira_afericao)::timestamp with time zone, 'DD/MM/YYYY'::text) AS "DTA 1a AFERIÇÃO",
       to_char((dados.ultima_afericao)::timestamp with time zone, 'DD/MM/YYYY'::text)   AS "DTA ÚLTIMA AFERIÇÃO",
       dados.total_dias                                                                 AS "DIAS ATIVO",
       round(
               CASE
                   WHEN (dados.total_dias > 0) THEN (dados.total_km / (dados.total_dias)::numeric)
                   ELSE NULL::numeric
                   END)                                                                 AS "MÉDIA KM POR DIA",
       p.altura_sulco_interno,
       p.altura_sulco_central_interno,
       p.altura_sulco_central_externo,
       p.altura_sulco_externo,
       round((dados.maior_sulco)::numeric, 2)                                           AS "MAIOR MEDIÇÃO VIDA",
       round((dados.menor_sulco)::numeric, 2)                                           AS "MENOR SULCO ATUAL",
       round((dados.sulco_gasto)::numeric, 2)                                           AS "MILIMETROS GASTOS",
       round((dados.km_por_mm)::numeric, 2)                                             AS "KMS POR MILIMETRO",
       round(((dados.km_por_mm * dados.sulco_restante))::numeric)                       AS "KMS A PERCORRER",
       trunc(
               CASE
                   WHEN ((dados.total_km > (0)::numeric) AND (dados.total_dias > 0) AND
                         ((dados.total_km / (dados.total_dias)::numeric) > (0)::numeric)) THEN (
                           (dados.km_por_mm * dados.sulco_restante) /
                           ((dados.total_km / (dados.total_dias)::numeric))::double precision)
                   ELSE (0)::double precision
                   END)                                                                 AS "DIAS RESTANTES",
       CASE
           WHEN ((dados.total_km > (0)::numeric) AND (dados.total_dias > 0) AND
                 ((dados.total_km / (dados.total_dias)::numeric) > (0)::numeric)) THEN (
                   (((dados.km_por_mm * dados.sulco_restante) /
                     ((dados.total_km / (dados.total_dias)::numeric))::double precision))::integer +
                   ('NOW'::text)::date)
           ELSE NULL::date
           END                                                                          AS "PREVISÃO DE TROCA"
FROM (((((pneu_data p
    JOIN (SELECT av.cod_pneu,
                 av.cod_unidade,
                 count(av.altura_sulco_central_interno)                                     AS qt_afericoes,
                 (min(timezone(tz_unidade(a.cod_unidade), a.data_hora)))::date              AS primeira_afericao,
                 (max(timezone(tz_unidade(a.cod_unidade), a.data_hora)))::date              AS ultima_afericao,
                 ((max(timezone(tz_unidade(a.cod_unidade), a.data_hora)))::date -
                  (min(timezone(tz_unidade(a.cod_unidade), a.data_hora)))::date)            AS total_dias,
                 max(total_km.total_km)                                                     AS total_km,
                 max(GREATEST(av.altura_sulco_interno, av.altura_sulco_central_interno, av.altura_sulco_central_externo,
                              av.altura_sulco_externo))                                     AS maior_sulco,
                 min(LEAST(av.altura_sulco_interno, av.altura_sulco_central_interno, av.altura_sulco_central_externo,
                           av.altura_sulco_externo))                                        AS menor_sulco,
                 (max(GREATEST(av.altura_sulco_interno, av.altura_sulco_central_interno,
                               av.altura_sulco_central_externo, av.altura_sulco_externo)) - min(
                          LEAST(av.altura_sulco_interno, av.altura_sulco_central_interno,
                                av.altura_sulco_central_externo, av.altura_sulco_externo))) AS sulco_gasto,
                 CASE
                     WHEN (
                             CASE
                                 WHEN (p_1.vida_atual = p_1.vida_total) THEN (min(LEAST(av.altura_sulco_interno,
                                                                                        av.altura_sulco_central_interno,
                                                                                        av.altura_sulco_central_externo,
                                                                                        av.altura_sulco_externo)) -
                                                                              pru.sulco_minimo_descarte)
                                 WHEN (p_1.vida_atual < p_1.vida_total) THEN (min(LEAST(av.altura_sulco_interno,
                                                                                        av.altura_sulco_central_interno,
                                                                                        av.altura_sulco_central_externo,
                                                                                        av.altura_sulco_externo)) -
                                                                              pru.sulco_minimo_recapagem)
                                 ELSE NULL::real
                                 END < (0)::double precision) THEN (0)::real
                     ELSE
                         CASE
                             WHEN (p_1.vida_atual = p_1.vida_total) THEN (min(LEAST(av.altura_sulco_interno,
                                                                                    av.altura_sulco_central_interno,
                                                                                    av.altura_sulco_central_externo,
                                                                                    av.altura_sulco_externo)) -
                                                                          pru.sulco_minimo_descarte)
                             WHEN (p_1.vida_atual < p_1.vida_total) THEN (min(LEAST(av.altura_sulco_interno,
                                                                                    av.altura_sulco_central_interno,
                                                                                    av.altura_sulco_central_externo,
                                                                                    av.altura_sulco_externo)) -
                                                                          pru.sulco_minimo_recapagem)
                             ELSE NULL::real
                             END
                     END                                                                    AS sulco_restante,
                 CASE
                     WHEN (((max(timezone(tz_unidade(a.cod_unidade), a.data_hora)))::date -
                            (min(timezone(tz_unidade(a.cod_unidade), a.data_hora)))::date) > 0) THEN (
                             ((max(total_km.total_km))::double precision / max(
                                     GREATEST(av.altura_sulco_interno, av.altura_sulco_central_interno,
                                              av.altura_sulco_central_externo, av.altura_sulco_externo))) - min(
                                     LEAST(av.altura_sulco_interno, av.altura_sulco_central_interno,
                                           av.altura_sulco_central_externo, av.altura_sulco_externo)))
                     ELSE (0)::double precision
                     END                                                                    AS km_por_mm
          FROM ((((afericao_valores_data av
              JOIN afericao_data a ON ((a.codigo = av.cod_afericao)))
              JOIN pneu_data p_1 ON ((((p_1.codigo)::text = (av.cod_pneu)::text) AND
                                      ((p_1.status)::text = 'EM_USO'::text))))
              JOIN pneu_restricao_unidade pru ON ((pru.cod_unidade = av.cod_unidade)))
                   JOIN (SELECT total_km_rodado.cod_pneu,
                                total_km_rodado.cod_unidade,
                                sum(total_km_rodado.km_rodado) AS total_km
                         FROM (SELECT av_1.cod_pneu,
                                      av_1.cod_unidade,
                                      a_1.placa_veiculo,
                                      (max(a_1.km_veiculo) - min(a_1.km_veiculo)) AS km_rodado
                               FROM (afericao_valores_data av_1
                                        JOIN afericao_data a_1 ON ((a_1.codigo = av_1.cod_afericao)))
                               GROUP BY av_1.cod_pneu, av_1.cod_unidade, a_1.placa_veiculo) total_km_rodado
                         GROUP BY total_km_rodado.cod_pneu, total_km_rodado.cod_unidade) total_km
                        ON (((total_km.cod_pneu = av.cod_pneu) AND (total_km.cod_unidade = av.cod_unidade))))
          GROUP BY av.cod_pneu, av.cod_unidade, p_1.vida_atual, p_1.vida_total, pru.sulco_minimo_descarte,
                   pru.sulco_minimo_recapagem) dados ON ((dados.cod_pneu = p.codigo)))
    JOIN dimensao_pneu dp ON ((dp.codigo = p.cod_dimensao)))
    JOIN unidade u ON ((u.codigo = p.cod_unidade)))
    JOIN modelo_pneu mp ON (((mp.codigo = p.cod_modelo) AND (mp.cod_empresa = u.cod_empresa))))
         JOIN marca_pneu map ON ((map.codigo = mp.cod_marca)));

comment on view public.view_analise_pneus is 'View utilizada para gerar dados de uso sobre os pneus, esses dados são usados para gerar relatórios';

create or replace view public.view_pneu_km_rodado_vida(cod_pneu, vida_pneu, km_rodado_vida) as
SELECT q.cod_pneu,
       q.vida_pneu,
       sum(q.km_rodado) AS km_rodado_vida
FROM (SELECT av.cod_pneu,
             av.vida_momento_afericao                AS vida_pneu,
             (max(a.km_veiculo) - min(a.km_veiculo)) AS km_rodado
      FROM (afericao_valores_data av
               JOIN afericao_data a ON ((a.codigo = av.cod_afericao)))
      WHERE ((a.tipo_processo_coleta)::text = 'PLACA'::text)
      GROUP BY av.cod_pneu, a.placa_veiculo, av.vida_momento_afericao
      ORDER BY av.cod_pneu) q
GROUP BY q.cod_pneu, q.vida_pneu
ORDER BY q.cod_pneu, q.vida_pneu;

create or replace view public.view_pneu_km_rodado_total(cod_pneu, vida_pneu, km_rodado_vida, total_km_rodado_todas_vidas) as
    WITH km_rodado_total AS (
        SELECT view_pneu_km_rodado_vida.cod_pneu,
               sum(view_pneu_km_rodado_vida.km_rodado_vida) AS total_km_rodado_todas_vidas
        FROM view_pneu_km_rodado_vida
        GROUP BY view_pneu_km_rodado_vida.cod_pneu
        ORDER BY view_pneu_km_rodado_vida.cod_pneu
    )
    SELECT km_vida.cod_pneu,
           km_vida.vida_pneu,
           km_vida.km_rodado_vida,
           km_total.total_km_rodado_todas_vidas
    FROM (view_pneu_km_rodado_vida km_vida
             JOIN km_rodado_total km_total ON ((km_vida.cod_pneu = km_total.cod_pneu)))
    ORDER BY km_vida.cod_pneu, km_vida.vida_pneu;

create or replace view public.view_pneu_analise_vidas(cod_pneu, status, valor_pneu, valor_banda,
                                                      data_hora_primeira_afericao, cod_primeira_afericao,
                                                      cod_unidade_primeira_afericao, data_hora_ultima_afericao,
                                                      cod_ultima_afericao, cod_unidade_ultima_afericao,
                                                      vida_analisada_pneu, quantidade_afericoes_pneu_vida,
                                                      maior_sulco_aferido_vida, menor_sulco_aferido_vida, sulco_gasto,
                                                      total_dias_ativo, total_km_rodado_vida, sulco_restante,
                                                      km_por_mm_vida, valor_por_km_vida) as
    WITH dados_afericao AS (
        SELECT a.codigo                                                                            AS cod_afericao,
               a.cod_unidade                                                                       AS cod_unidade_afericao,
               a.data_hora                                                                         AS data_hora_afericao,
               a.tipo_processo_coleta                                                              AS tipo_processo_coleta_afericao,
               av.cod_pneu,
               av.vida_momento_afericao,
               av.altura_sulco_central_interno,
               av.altura_sulco_central_externo,
               av.altura_sulco_externo,
               av.altura_sulco_interno,
               row_number()
               OVER (PARTITION BY av.cod_pneu, av.vida_momento_afericao ORDER BY a.data_hora)      AS row_number_asc,
               row_number()
               OVER (PARTITION BY av.cod_pneu, av.vida_momento_afericao ORDER BY a.data_hora DESC) AS row_number_desc
        FROM (afericao_data a
                 JOIN afericao_valores_data av ON ((a.codigo = av.cod_afericao)))
    ),
         primeira_afericao AS (
             SELECT da.cod_pneu,
                    da.vida_momento_afericao,
                    da.cod_afericao,
                    da.cod_unidade_afericao,
                    da.data_hora_afericao
             FROM dados_afericao da
             WHERE (da.row_number_asc = 1)
         ),
         ultima_afericao AS (
             SELECT da.cod_pneu,
                    da.vida_momento_afericao,
                    da.cod_afericao,
                    da.cod_unidade_afericao,
                    da.data_hora_afericao
             FROM dados_afericao da
             WHERE (da.row_number_desc = 1)
         ),
         analises_afericoes AS (
             SELECT da.cod_pneu,
                    da.vida_momento_afericao                                                AS vida_analisada_pneu,
                    count(da.cod_pneu)                                                      AS quantidade_afericoes_pneu_vida,
                    max(GREATEST(da.altura_sulco_externo, da.altura_sulco_central_externo,
                                 da.altura_sulco_central_interno, da.altura_sulco_interno)) AS maior_sulco_aferido_vida,
                    min(LEAST(da.altura_sulco_externo, da.altura_sulco_central_externo, da.altura_sulco_central_interno,
                              da.altura_sulco_interno))                                     AS menor_sulco_aferido_vida
             FROM dados_afericao da
             GROUP BY da.cod_pneu, da.vida_momento_afericao
         )
    SELECT p.codigo                                                                            AS cod_pneu,
           p.status,
           p.valor                                                                             AS valor_pneu,
           COALESCE(pvv.valor, (0)::real)                                                      AS valor_banda,
           pa.data_hora_afericao                                                               AS data_hora_primeira_afericao,
           pa.cod_afericao                                                                     AS cod_primeira_afericao,
           pa.cod_unidade_afericao                                                             AS cod_unidade_primeira_afericao,
           ua.data_hora_afericao                                                               AS data_hora_ultima_afericao,
           ua.cod_afericao                                                                     AS cod_ultima_afericao,
           ua.cod_unidade_afericao                                                             AS cod_unidade_ultima_afericao,
           aa.vida_analisada_pneu,
           aa.quantidade_afericoes_pneu_vida,
           aa.maior_sulco_aferido_vida,
           aa.menor_sulco_aferido_vida,
           (aa.maior_sulco_aferido_vida - aa.menor_sulco_aferido_vida)                         AS sulco_gasto,
           (date_part('days'::text, (ua.data_hora_afericao - pa.data_hora_afericao)))::integer AS total_dias_ativo,
           km_rodado_pneu.km_rodado_vida                                                       AS total_km_rodado_vida,
           func_pneu_calcula_sulco_restante(p.vida_atual, p.vida_total, p.altura_sulco_externo,
                                            p.altura_sulco_central_externo, p.altura_sulco_central_interno,
                                            p.altura_sulco_interno, pru.sulco_minimo_recapagem,
                                            pru.sulco_minimo_descarte)                         AS sulco_restante,
           CASE
               WHEN ((date_part('days'::text, (ua.data_hora_afericao - pa.data_hora_afericao)) >
                      (0)::double precision) AND
                     ((aa.maior_sulco_aferido_vida - aa.menor_sulco_aferido_vida) > (0)::double precision)) THEN (
                       (km_rodado_pneu.km_rodado_vida)::double precision /
                       (aa.maior_sulco_aferido_vida - aa.menor_sulco_aferido_vida))
               ELSE (0)::double precision
               END                                                                             AS km_por_mm_vida,
           CASE
               WHEN (km_rodado_pneu.km_rodado_vida = (0)::numeric) THEN (0)::double precision
               ELSE
                   CASE
                       WHEN (km_rodado_pneu.vida_pneu = 1)
                           THEN (p.valor / (km_rodado_pneu.km_rodado_vida)::double precision)
                       ELSE (COALESCE(pvv.valor, (0)::real) / (km_rodado_pneu.km_rodado_vida)::double precision)
                       END
               END                                                                             AS valor_por_km_vida
    FROM ((((((analises_afericoes aa
        JOIN primeira_afericao pa ON (((pa.cod_pneu = aa.cod_pneu) AND
                                       (pa.vida_momento_afericao = aa.vida_analisada_pneu))))
        JOIN ultima_afericao ua ON (((ua.cod_pneu = aa.cod_pneu) AND
                                     (ua.vida_momento_afericao = aa.vida_analisada_pneu))))
        JOIN pneu_data p ON ((aa.cod_pneu = p.codigo)))
        JOIN pneu_restricao_unidade pru ON ((p.cod_unidade = pru.cod_unidade)))
        LEFT JOIN pneu_valor_vida pvv ON ((p.codigo = pvv.cod_pneu)))
             JOIN view_pneu_km_rodado_vida km_rodado_pneu
                  ON (((km_rodado_pneu.cod_pneu = aa.cod_pneu) AND (km_rodado_pneu.vida_pneu = aa.vida_analisada_pneu))))
    ORDER BY aa.cod_pneu, aa.vida_analisada_pneu;

create or replace view public.view_pneu_analise_vida_atual("UNIDADE ALOCADO", "COD PNEU", "COD PNEU CLIENTE",
                                                           valor_acumulado, km_acumulado, "VIDA ATUAL", "STATUS PNEU",
                                                           cod_unidade, valor_pneu, valor_vida_atual, "MARCA", "MODELO",
                                                           "MEDIDAS", "QTD DE AFERIÇÕES", "DTA 1a AFERIÇÃO",
                                                           "DTA ÚLTIMA AFERIÇÃO", "DIAS ATIVO", "MÉDIA KM POR DIA",
                                                           "MAIOR MEDIÇÃO VIDA", "MENOR SULCO ATUAL",
                                                           "MILIMETROS GASTOS", "KMS POR MILIMETRO", "VALOR POR KM",
                                                           "VALOR POR KM ACUMULADO", "KMS A PERCORRER",
                                                           "DIAS RESTANTES", "PREVISÃO DE TROCA", "DESTINO") as
SELECT u.nome                                                               AS "UNIDADE ALOCADO",
       p.codigo                                                             AS "COD PNEU",
       p.codigo_cliente                                                     AS "COD PNEU CLIENTE",
       (p.valor + sum(pvv.valor))                                           AS valor_acumulado,
       sum(v.total_km_rodado_todas_vidas)                                   AS km_acumulado,
       p.vida_atual                                                         AS "VIDA ATUAL",
       p.status                                                             AS "STATUS PNEU",
       p.cod_unidade,
       p.valor                                                              AS valor_pneu,
       CASE
           WHEN (dados.vida_analisada_pneu = 1) THEN dados.valor_pneu
           ELSE dados.valor_banda
           END                                                              AS valor_vida_atual,
       map.nome                                                             AS "MARCA",
       mp.nome                                                              AS "MODELO",
       ((((dp.largura || '/'::text) || dp.altura) || ' R'::text) || dp.aro) AS "MEDIDAS",
       dados.quantidade_afericoes_pneu_vida                                 AS "QTD DE AFERIÇÕES",
       to_char(dados.data_hora_primeira_afericao, 'DD/MM/YYYY'::text)       AS "DTA 1a AFERIÇÃO",
       to_char(dados.data_hora_ultima_afericao, 'DD/MM/YYYY'::text)         AS "DTA ÚLTIMA AFERIÇÃO",
       dados.total_dias_ativo                                               AS "DIAS ATIVO",
       round(
               CASE
                   WHEN (dados.total_dias_ativo > 0)
                       THEN (dados.total_km_rodado_vida / (dados.total_dias_ativo)::numeric)
                   ELSE NULL::numeric
                   END)                                                     AS "MÉDIA KM POR DIA",
       round((dados.maior_sulco_aferido_vida)::numeric, 2)                  AS "MAIOR MEDIÇÃO VIDA",
       round((dados.menor_sulco_aferido_vida)::numeric, 2)                  AS "MENOR SULCO ATUAL",
       round((dados.sulco_gasto)::numeric, 2)                               AS "MILIMETROS GASTOS",
       round((dados.km_por_mm_vida)::numeric, 2)                            AS "KMS POR MILIMETRO",
       round((dados.valor_por_km_vida)::numeric, 2)                         AS "VALOR POR KM",
       round((
                 CASE
                     WHEN (sum(v.total_km_rodado_todas_vidas) > (0)::numeric) THEN ((p.valor + sum(pvv.valor)) /
                                                                                    (sum(v.total_km_rodado_todas_vidas))::double precision)
                     ELSE (0)::double precision
                     END)::numeric, 2)                                      AS "VALOR POR KM ACUMULADO",
       round(((dados.km_por_mm_vida * dados.sulco_restante))::numeric)      AS "KMS A PERCORRER",
       trunc(
               CASE
                   WHEN ((dados.total_km_rodado_vida > (0)::numeric) AND (dados.total_dias_ativo > 0) AND
                         ((dados.total_km_rodado_vida / (dados.total_dias_ativo)::numeric) > (0)::numeric)) THEN (
                           (dados.km_por_mm_vida * dados.sulco_restante) /
                           ((dados.total_km_rodado_vida / (dados.total_dias_ativo)::numeric))::double precision)
                   ELSE (0)::double precision
                   END)                                                     AS "DIAS RESTANTES",
       CASE
           WHEN ((dados.total_km_rodado_vida > (0)::numeric) AND (dados.total_dias_ativo > 0) AND
                 ((dados.total_km_rodado_vida / (dados.total_dias_ativo)::numeric) > (0)::numeric)) THEN (
                   (((dados.km_por_mm_vida * dados.sulco_restante) /
                     ((dados.total_km_rodado_vida / (dados.total_dias_ativo)::numeric))::double precision))::integer +
                   ('NOW'::text)::date)
           ELSE NULL::date
           END                                                              AS "PREVISÃO DE TROCA",
       CASE
           WHEN (p.vida_atual = p.vida_total) THEN 'DESCARTE'::text
           ELSE 'ANÁLISE'::text
           END                                                              AS "DESTINO"
FROM (((((((pneu_data p
    JOIN (SELECT view_pneu_analise_vidas.cod_pneu,
                 view_pneu_analise_vidas.vida_analisada_pneu,
                 view_pneu_analise_vidas.status,
                 view_pneu_analise_vidas.valor_pneu,
                 view_pneu_analise_vidas.valor_banda,
                 view_pneu_analise_vidas.quantidade_afericoes_pneu_vida,
                 view_pneu_analise_vidas.data_hora_primeira_afericao,
                 view_pneu_analise_vidas.data_hora_ultima_afericao,
                 view_pneu_analise_vidas.total_dias_ativo,
                 view_pneu_analise_vidas.total_km_rodado_vida,
                 view_pneu_analise_vidas.maior_sulco_aferido_vida,
                 view_pneu_analise_vidas.menor_sulco_aferido_vida,
                 view_pneu_analise_vidas.sulco_gasto,
                 view_pneu_analise_vidas.sulco_restante,
                 view_pneu_analise_vidas.km_por_mm_vida,
                 view_pneu_analise_vidas.valor_por_km_vida
          FROM view_pneu_analise_vidas) dados ON (((dados.cod_pneu = p.codigo) AND
                                                   (dados.vida_analisada_pneu = p.vida_atual))))
    JOIN dimensao_pneu dp ON ((dp.codigo = p.cod_dimensao)))
    JOIN unidade u ON ((u.codigo = p.cod_unidade)))
    JOIN modelo_pneu mp ON (((mp.codigo = p.cod_modelo) AND (mp.cod_empresa = u.cod_empresa))))
    JOIN marca_pneu map ON ((map.codigo = mp.cod_marca)))
    JOIN view_pneu_km_rodado_total v ON (((p.codigo = v.cod_pneu) AND (p.vida_atual = v.vida_pneu))))
         LEFT JOIN pneu_valor_vida pvv ON ((pvv.cod_pneu = p.codigo)))
GROUP BY u.nome, p.codigo, p.cod_unidade, dados.valor_banda, dados.valor_pneu, map.nome, mp.nome, dp.largura, dp.altura,
         dp.aro, dados.quantidade_afericoes_pneu_vida, dados.data_hora_primeira_afericao,
         dados.data_hora_ultima_afericao, dados.total_dias_ativo, dados.total_km_rodado_vida,
         dados.maior_sulco_aferido_vida, dados.menor_sulco_aferido_vida, dados.sulco_gasto, dados.km_por_mm_vida,
         dados.valor_por_km_vida, dados.sulco_restante, dados.vida_analisada_pneu
ORDER BY CASE
             WHEN ((dados.total_km_rodado_vida > (0)::numeric) AND (dados.total_dias_ativo > 0) AND
                   ((dados.total_km_rodado_vida / (dados.total_dias_ativo)::numeric) > (0)::numeric)) THEN (
                     (((dados.km_por_mm_vida * dados.sulco_restante) /
                       ((dados.total_km_rodado_vida / (dados.total_dias_ativo)::numeric))::double precision))::integer +
                     ('NOW'::text)::date)
             ELSE NULL::date
             END;

create or replace view public.afericao(codigo, data_hora, placa_veiculo, cpf_aferidor, km_veiculo, tempo_realizacao,
                                       tipo_medicao_coletada, cod_unidade, tipo_processo_coleta) as
SELECT ad.codigo,
       ad.data_hora,
       ad.placa_veiculo,
       ad.cpf_aferidor,
       ad.km_veiculo,
       ad.tempo_realizacao,
       ad.tipo_medicao_coletada,
       ad.cod_unidade,
       ad.tipo_processo_coleta
FROM afericao_data ad
WHERE (ad.deletado = false);

create or replace view public.afericao_valores(cod_afericao, cod_pneu, cod_unidade, altura_sulco_central_interno,
                                               altura_sulco_externo, altura_sulco_interno, psi, posicao,
                                               vida_momento_afericao, altura_sulco_central_externo) as
SELECT av.cod_afericao,
       av.cod_pneu,
       av.cod_unidade,
       av.altura_sulco_central_interno,
       av.altura_sulco_externo,
       av.altura_sulco_interno,
       av.psi,
       av.posicao,
       av.vida_momento_afericao,
       av.altura_sulco_central_externo
FROM afericao_valores_data av
WHERE (av.deletado = false);

create or replace view public.afericao_manutencao(cod_afericao, cod_pneu, cod_unidade, tipo_servico,
                                                  data_hora_resolucao, cpf_mecanico, qt_apontamentos, psi_apos_conserto,
                                                  km_momento_conserto, cod_alternativa, cod_pneu_inserido, codigo,
                                                  cod_processo_movimentacao, tempo_realizacao_millis,
                                                  fechado_automaticamente_movimentacao,
                                                  fechado_automaticamente_integracao) as
SELECT am.cod_afericao,
       am.cod_pneu,
       am.cod_unidade,
       am.tipo_servico,
       am.data_hora_resolucao,
       am.cpf_mecanico,
       am.qt_apontamentos,
       am.psi_apos_conserto,
       am.km_momento_conserto,
       am.cod_alternativa,
       am.cod_pneu_inserido,
       am.codigo,
       am.cod_processo_movimentacao,
       am.tempo_realizacao_millis,
       am.fechado_automaticamente_movimentacao,
       am.fechado_automaticamente_integracao
FROM afericao_manutencao_data am
WHERE (am.deletado = false);

create or replace view public.colaborador(cpf, matricula_ambev, matricula_trans, data_nascimento, data_admissao,
                                          data_demissao, status_ativo, nome, cod_equipe, cod_funcao, cod_unidade,
                                          cod_permissao, cod_empresa, cod_setor, pis, data_hora_cadastro, codigo,
                                          cod_unidade_cadastro) as
SELECT c.cpf,
       c.matricula_ambev,
       c.matricula_trans,
       c.data_nascimento,
       c.data_admissao,
       c.data_demissao,
       c.status_ativo,
       c.nome,
       c.cod_equipe,
       c.cod_funcao,
       c.cod_unidade,
       c.cod_permissao,
       c.cod_empresa,
       c.cod_setor,
       c.pis,
       c.data_hora_cadastro,
       c.codigo,
       c.cod_unidade_cadastro
FROM colaborador_data c
WHERE (c.deletado = false);

create or replace view public.pneu(codigo_cliente, cod_modelo, cod_dimensao, pressao_recomendada, pressao_atual,
                                   altura_sulco_interno, altura_sulco_central_interno, altura_sulco_externo,
                                   cod_unidade, status, vida_atual, vida_total, cod_modelo_banda,
                                   altura_sulco_central_externo, dot, valor, data_hora_cadastro, pneu_novo_nunca_rodado,
                                   codigo, cod_empresa, cod_unidade_cadastro) as
SELECT p.codigo_cliente,
       p.cod_modelo,
       p.cod_dimensao,
       p.pressao_recomendada,
       p.pressao_atual,
       p.altura_sulco_interno,
       p.altura_sulco_central_interno,
       p.altura_sulco_externo,
       p.cod_unidade,
       p.status,
       p.vida_atual,
       p.vida_total,
       p.cod_modelo_banda,
       p.altura_sulco_central_externo,
       p.dot,
       p.valor,
       p.data_hora_cadastro,
       p.pneu_novo_nunca_rodado,
       p.codigo,
       p.cod_empresa,
       p.cod_unidade_cadastro
FROM pneu_data p
WHERE (p.deletado = false);

create or replace view public.checklist_ordem_servico(codigo_prolog, codigo, cod_unidade, cod_checklist, status,
                                                      data_hora_fechamento) as
SELECT cos.codigo_prolog,
       cos.codigo,
       cos.cod_unidade,
       cos.cod_checklist,
       cos.status,
       cos.data_hora_fechamento
FROM checklist_ordem_servico_data cos
WHERE (cos.deletado = false);

create or replace view public.funcao(codigo, nome, cod_empresa) as
SELECT f.codigo,
       f.nome,
       f.cod_empresa
FROM funcao_data f
WHERE (f.deletado = false);

create or replace view public.view_extrato_indicadores(cod_empresa, cod_regional, cod_unidade, cod_equipe, cpf, nome,
                                                       equipe, funcao, data, mapa, placa, cxcarreg, qthlcarregados,
                                                       qthlentregues, qthldevolvidos, resultado_devolucao_hectolitro,
                                                       qtnfcarregadas, qtnfentregues, qtnfdevolvidas,
                                                       resultado_devolucao_nf, entregascompletas, entregasnaorealizadas,
                                                       entregasparciais, entregas_carregadas, resultado_devolucao_pdv,
                                                       kmprevistoroad, kmsai, kmentr, km_percorrido,
                                                       resultado_dispersao_km, hrsai, hr_sai, hrentr, hr_entr,
                                                       tempo_rota, tempoprevistoroad, resultado_tempo_rota_segundos,
                                                       resultado_dispersao_tempo, resultado_tempo_interno_segundos,
                                                       tempo_interno, hrmatinal, resultado_tempo_largada_segundos,
                                                       tempo_largada, total_tracking, apontamentos_ok, apontamentos_nok,
                                                       resultado_tracking, meta_tracking, meta_tempo_rota_mapas,
                                                       meta_caixa_viagem, meta_dev_hl, meta_dev_pdv, meta_dev_nf,
                                                       meta_dispersao_km, meta_dispersao_tempo,
                                                       meta_jornada_liquida_mapas, meta_raio_tracking,
                                                       meta_tempo_interno_mapas, meta_tempo_largada_mapas,
                                                       meta_tempo_rota_horas, meta_tempo_interno_horas,
                                                       meta_tempo_largada_horas, meta_jornada_liquida_horas,
                                                       bateu_dev_pdv, bateu_dev_hl, bateu_dev_nf, bateu_dispersao_tempo,
                                                       bateu_dispersao_km, bateu_tempo_interno, bateu_tempo_rota,
                                                       bateu_tempo_largada, bateu_jornada, bateu_tracking, gol_dev_pdv,
                                                       gol_dev_hl, gol_dev_nf, gol_dispersao_tempo, gol_dispersao_km,
                                                       gol_tempo_interno, gol_tempo_rota, gol_tempo_largada,
                                                       gol_jornada, gol_tracking) as
SELECT dados.cod_empresa,
       dados.cod_regional,
       dados.cod_unidade,
       dados.cod_equipe,
       dados.cpf,
       dados.nome,
       dados.equipe,
       dados.funcao,
       dados.data,
       dados.mapa,
       dados.placa,
       dados.cxcarreg,
       dados.qthlcarregados,
       dados.qthlentregues,
       dados.qthldevolvidos,
       dados.resultado_devolucao_hectolitro,
       dados.qtnfcarregadas,
       dados.qtnfentregues,
       dados.qtnfdevolvidas,
       dados.resultado_devolucao_nf,
       dados.entregascompletas,
       dados.entregasnaorealizadas,
       dados.entregasparciais,
       dados.entregas_carregadas,
       dados.resultado_devolucao_pdv,
       dados.kmprevistoroad,
       dados.kmsai,
       dados.kmentr,
       dados.km_percorrido,
       dados.resultado_dispersao_km,
       dados.hrsai,
       dados.hr_sai,
       dados.hrentr,
       dados.hr_entr,
       dados.tempo_rota,
       dados.tempoprevistoroad,
       dados.resultado_tempo_rota_segundos,
       dados.resultado_dispersao_tempo,
       dados.resultado_tempo_interno_segundos,
       dados.tempo_interno,
       dados.hrmatinal,
       dados.resultado_tempo_largada_segundos,
       dados.tempo_largada,
       dados.total_tracking,
       dados.apontamentos_ok,
       dados.apontamentos_nok,
       dados.resultado_tracking,
       dados.meta_tracking,
       dados.meta_tempo_rota_mapas,
       dados.meta_caixa_viagem,
       dados.meta_dev_hl,
       dados.meta_dev_pdv,
       dados.meta_dev_nf,
       dados.meta_dispersao_km,
       dados.meta_dispersao_tempo,
       dados.meta_jornada_liquida_mapas,
       dados.meta_raio_tracking,
       dados.meta_tempo_interno_mapas,
       dados.meta_tempo_largada_mapas,
       dados.meta_tempo_rota_horas,
       dados.meta_tempo_interno_horas,
       dados.meta_tempo_largada_horas,
       dados.meta_jornada_liquida_horas,
       CASE
           WHEN ((dados.resultado_devolucao_pdv)::double precision <= dados.meta_dev_pdv) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_dev_pdv,
       CASE
           WHEN ((dados.resultado_devolucao_hectolitro)::double precision <= dados.meta_dev_hl) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_dev_hl,
       CASE
           WHEN ((dados.resultado_devolucao_nf)::double precision <= dados.meta_dev_nf) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_dev_nf,
       CASE
           WHEN (dados.resultado_dispersao_tempo <= dados.meta_dispersao_tempo) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_dispersao_tempo,
       CASE
           WHEN ((dados.resultado_dispersao_km)::double precision <= dados.meta_dispersao_km) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_dispersao_km,
       CASE
           WHEN (dados.resultado_tempo_interno_segundos <= (dados.meta_tempo_interno_horas)::double precision)
               THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_tempo_interno,
       CASE
           WHEN (dados.resultado_tempo_rota_segundos <= (dados.meta_tempo_rota_horas)::double precision) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_tempo_rota,
       CASE
           WHEN (dados.resultado_tempo_largada_segundos <= (dados.meta_tempo_largada_horas)::double precision)
               THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_tempo_largada,
       CASE
           WHEN ((((dados.resultado_tempo_largada_segundos + dados.resultado_tempo_rota_segundos) +
                   dados.resultado_tempo_interno_segundos) <= (dados.meta_jornada_liquida_horas)::double precision) OR
                 (dados.tempoprevistoroad > (dados.meta_tempo_rota_horas)::double precision)) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_jornada,
       CASE
           WHEN ((dados.resultado_tracking)::double precision >= dados.meta_tracking) THEN 'SIM'::text
           ELSE 'NÃO'::text
           END AS bateu_tracking,
       CASE
           WHEN ((dados.resultado_devolucao_pdv)::double precision <= dados.meta_dev_pdv) THEN 1
           ELSE 0
           END AS gol_dev_pdv,
       CASE
           WHEN ((dados.resultado_devolucao_hectolitro)::double precision <= dados.meta_dev_hl) THEN 1
           ELSE 0
           END AS gol_dev_hl,
       CASE
           WHEN ((dados.resultado_devolucao_nf)::double precision <= dados.meta_dev_nf) THEN 1
           ELSE 0
           END AS gol_dev_nf,
       CASE
           WHEN (dados.resultado_dispersao_tempo <= dados.meta_dispersao_tempo) THEN 1
           ELSE 0
           END AS gol_dispersao_tempo,
       CASE
           WHEN ((dados.resultado_dispersao_km)::double precision <= dados.meta_dispersao_km) THEN 1
           ELSE 0
           END AS gol_dispersao_km,
       CASE
           WHEN (dados.resultado_tempo_interno_segundos <= (dados.meta_tempo_interno_horas)::double precision) THEN 1
           ELSE 0
           END AS gol_tempo_interno,
       CASE
           WHEN (dados.resultado_tempo_rota_segundos <= (dados.meta_tempo_rota_horas)::double precision) THEN 1
           ELSE 0
           END AS gol_tempo_rota,
       CASE
           WHEN (dados.resultado_tempo_largada_segundos <= (dados.meta_tempo_largada_horas)::double precision) THEN 1
           ELSE 0
           END AS gol_tempo_largada,
       CASE
           WHEN ((((dados.resultado_tempo_largada_segundos + dados.resultado_tempo_rota_segundos) +
                   dados.resultado_tempo_interno_segundos) <= (dados.meta_jornada_liquida_horas)::double precision) OR
                 (dados.tempoprevistoroad > (dados.meta_tempo_rota_horas)::double precision)) THEN 1
           ELSE 0
           END AS gol_jornada,
       CASE
           WHEN ((dados.resultado_tracking)::double precision >= dados.meta_tracking) THEN 1
           ELSE 0
           END AS gol_tracking
FROM (SELECT u.cod_empresa,
             u.cod_regional,
             u.codigo                                                                        AS cod_unidade,
             e.codigo                                                                        AS cod_equipe,
             c.cpf,
             c.nome,
             e.nome                                                                          AS equipe,
             f.nome                                                                          AS funcao,
             m.data,
             m.mapa,
             m.placa,
             m.cxcarreg,
             m.qthlcarregados,
             m.qthlentregues,
             trunc(((m.qthlcarregados - m.qthlentregues))::numeric, 2)                       AS qthldevolvidos,
             trunc((
                       CASE
                           WHEN (m.qthlcarregados > (0)::double precision)
                               THEN ((m.qthlcarregados - m.qthlentregues) / m.qthlcarregados)
                           ELSE (0)::real
                           END)::numeric,
                   4)                                                                        AS resultado_devolucao_hectolitro,
             m.qtnfcarregadas,
             m.qtnfentregues,
             (m.qtnfcarregadas - m.qtnfentregues)                                            AS qtnfdevolvidas,
             trunc((
                       CASE
                           WHEN (m.qtnfcarregadas > 0) THEN (((m.qtnfcarregadas - m.qtnfentregues))::double precision /
                                                             (m.qtnfcarregadas)::real)
                           ELSE (0)::double precision
                           END)::numeric, 4)                                                 AS resultado_devolucao_nf,
             m.entregascompletas,
             m.entregasnaorealizadas,
             m.entregasparciais,
             (m.entregascompletas + m.entregasnaorealizadas)                                 AS entregas_carregadas,
             trunc((
                       CASE
                           WHEN (((m.entregascompletas + m.entregasnaorealizadas) + m.entregasparciais) > 0) THEN (
                                   ((m.entregasnaorealizadas)::real + (m.entregasparciais)::double precision) /
                                   (((m.entregascompletas + m.entregasnaorealizadas) + m.entregasparciais))::double precision)
                           ELSE (0)::double precision
                           END)::numeric, 4)                                                 AS resultado_devolucao_pdv,
             m.kmprevistoroad,
             m.kmsai,
             m.kmentr,
             (m.kmentr - m.kmsai)                                                            AS km_percorrido,
             CASE
                 WHEN (m.kmprevistoroad > (0)::double precision) THEN trunc(
                         (((((m.kmentr - m.kmsai))::double precision - m.kmprevistoroad) / m.kmprevistoroad))::numeric,
                         4)
                 ELSE NULL::numeric
                 END                                                                         AS resultado_dispersao_km,
             to_char(m.hrsai, 'DD/MM/YYYY HH24:MI:SS'::text)                                 AS hrsai,
             m.hrsai                                                                         AS hr_sai,
             to_char(m.hrentr, 'DD/MM/YYYY HH24:MI:SS'::text)                                AS hrentr,
             m.hrentr                                                                        AS hr_entr,
             to_char((m.hrentr - m.hrsai), 'HH24:MI:SS'::text)                               AS tempo_rota,
             date_part('epoch'::text, m.tempoprevistoroad)                                   AS tempoprevistoroad,
             date_part('epoch'::text, (m.hrentr - m.hrsai))                                  AS resultado_tempo_rota_segundos,
             CASE
                 WHEN (date_part('epoch'::text, m.tempoprevistoroad) > (0)::double precision) THEN (
                         (date_part('epoch'::text, (m.hrentr - m.hrsai)) -
                          date_part('epoch'::text, m.tempoprevistoroad)) /
                         date_part('epoch'::text, m.tempoprevistoroad))
                 ELSE (0)::double precision
                 END                                                                         AS resultado_dispersao_tempo,
             date_part('epoch'::text, m.tempointerno)                                        AS resultado_tempo_interno_segundos,
             m.tempointerno                                                                  AS tempo_interno,
             m.hrmatinal,
             date_part('epoch'::text,
                       CASE
                           WHEN ((m.hrsai)::time without time zone < m.hrmatinal) THEN um.meta_tempo_largada_horas
                           ELSE ((m.hrsai - (m.hrmatinal)::interval))::time without time zone
                           END)                                                              AS resultado_tempo_largada_segundos,
             CASE
                 WHEN ((m.hrsai)::time without time zone < m.hrmatinal) THEN um.meta_tempo_largada_horas
                 ELSE ((m.hrsai - (m.hrmatinal)::interval))::time without time zone
                 END                                                                         AS tempo_largada,
             COALESCE(tracking.total_apontamentos, (0)::bigint)                              AS total_tracking,
             COALESCE(tracking.apontamentos_ok, (0)::bigint)                                 AS apontamentos_ok,
             COALESCE((tracking.total_apontamentos - tracking.apontamentos_ok), (0)::bigint) AS apontamentos_nok,
             CASE
                 WHEN (tracking.total_apontamentos > 0) THEN (tracking.apontamentos_ok / tracking.total_apontamentos)
                 ELSE (0)::bigint
                 END                                                                         AS resultado_tracking,
             um.meta_tracking,
             um.meta_tempo_rota_mapas,
             um.meta_caixa_viagem,
             um.meta_dev_hl,
             um.meta_dev_pdv,
             um.meta_dev_nf,
             um.meta_dispersao_km,
             um.meta_dispersao_tempo,
             um.meta_jornada_liquida_mapas,
             um.meta_raio_tracking,
             um.meta_tempo_interno_mapas,
             um.meta_tempo_largada_mapas,
             to_seconds((um.meta_tempo_rota_horas)::text)                                    AS meta_tempo_rota_horas,
             to_seconds((um.meta_tempo_interno_horas)::text)                                 AS meta_tempo_interno_horas,
             to_seconds((um.meta_tempo_largada_horas)::text)                                 AS meta_tempo_largada_horas,
             to_seconds((um.meta_jornada_liquida_horas)::text)                               AS meta_jornada_liquida_horas
      FROM (((((((((view_mapa_colaborador vmc
          JOIN colaborador_data c ON (((c.cpf = vmc.cpf) AND (c.cod_unidade = vmc.cod_unidade))))
          JOIN mapa m ON (((m.mapa = vmc.mapa) AND (m.cod_unidade = vmc.cod_unidade))))
          JOIN unidade u ON ((u.codigo = m.cod_unidade)))
          JOIN empresa em ON ((em.codigo = u.cod_empresa)))
          JOIN regional r ON ((r.codigo = u.cod_regional)))
          JOIN unidade_metas um ON ((um.cod_unidade = u.codigo)))
          JOIN equipe e ON (((e.cod_unidade = c.cod_unidade) AND (c.cod_equipe = e.codigo))))
          JOIN funcao f ON (((f.codigo = c.cod_funcao) AND (f.cod_empresa = em.codigo))))
               LEFT JOIN (SELECT t.mapa                         AS tracking_mapa,
                                 t."código_transportadora"      AS tracking_unidade,
                                 count(t.disp_apont_cadastrado) AS total_apontamentos,
                                 sum(
                                         CASE
                                             WHEN (t.disp_apont_cadastrado <= um_1.meta_raio_tracking) THEN 1
                                             ELSE 0
                                             END)               AS apontamentos_ok
                          FROM (tracking t
                                   JOIN unidade_metas um_1 ON ((um_1.cod_unidade = t."código_transportadora")))
                          GROUP BY t.mapa, t."código_transportadora") tracking
                         ON (((tracking.tracking_mapa = m.mapa) AND (tracking.tracking_unidade = m.cod_unidade))))
      ORDER BY m.data) dados;

create or replace view public.view_intervalo_tipo(codigo_tipo_intervalo_por_unidade, codigo, cod_unidade, nome, icone,
                                                  tempo_recomendado_minutos, tempo_estouro_minutos, horario_sugerido,
                                                  ativo, tipo_jornada, cod_auxiliar) as
SELECT row_number() OVER (PARTITION BY it.cod_unidade ORDER BY it.codigo) AS codigo_tipo_intervalo_por_unidade,
       it.codigo,
       it.cod_unidade,
       it.nome,
       it.icone,
       it.tempo_recomendado_minutos,
       it.tempo_estouro_minutos,
       it.horario_sugerido,
       it.ativo,
       (mtj.cod_tipo_jornada IS NOT NULL)                                 AS tipo_jornada,
       it.cod_auxiliar
FROM (intervalo_tipo it
         LEFT JOIN marcacao_tipo_jornada mtj
                   ON (((it.cod_unidade = mtj.cod_unidade) AND (it.codigo = mtj.cod_tipo_jornada))));

    create or replace function public.func_intervalos_agrupados(f_cod_unidade bigint, f_cpf_colaborador bigint,
                                                            f_cod_tipo_intervalo bigint)
    returns TABLE
            (
                fonte_data_hora_fim             text,
                fonte_data_hora_inicio          text,
                justificativa_estouro           text,
                justificativa_tempo_recomendado text,
                latitude_marcacao_inicio        text,
                longitude_marcacao_inicio       text,
                latitude_marcacao_fim           text,
                longitude_marcacao_fim          text,
                cod_unidade                     bigint,
                cpf_colaborador                 bigint,
                cod_tipo_intervalo              bigint,
                cod_tipo_intervalo_por_unidade  bigint,
                data_hora_inicio                timestamp with time zone,
                data_hora_fim                   timestamp with time zone,
                cod_marcacao_inicio             bigint,
                cod_marcacao_fim                bigint,
                status_ativo_inicio             boolean,
                status_ativo_fim                boolean,
                foi_ajustado_inicio             boolean,
                foi_ajustado_fim                boolean,
                data_hora_sincronizacao_inicio  timestamp with time zone,
                data_hora_sincronizacao_fim     timestamp with time zone,
                tipo_jornada                    boolean,
                device_imei_inicio              text,
                device_imei_inicio_reconhecido  boolean,
                device_marca_inicio             text,
                device_modelo_inicio            text,
                device_imei_fim                 text,
                device_imei_fim_reconhecido     boolean,
                device_marca_fim                text,
                device_modelo_fim               text
            )
    language sql
as
$$
WITH INICIOS AS (
    SELECT MI.COD_MARCACAO_INICIO,
           MV.COD_MARCACAO_FIM                   AS COD_MARCACAO_VINCULO,
           I.FONTE_DATA_HORA                     AS FONTE_DATA_HORA_INICIO,
           I.LATITUDE_MARCACAO                   AS LATITUDE_MARCACAO_INICIO,
           I.LONGITUDE_MARCACAO                  AS LONGITUDE_MARCACAO_INICIO,
           I.COD_UNIDADE                         AS COD_UNIDADE,
           I.CPF_COLABORADOR                     AS CPF_COLABORADOR,
           I.COD_TIPO_INTERVALO                  AS COD_TIPO_INTERVALO,
           I.DATA_HORA                           AS DATA_HORA_INICIO,
           I.CODIGO                              AS CODIGO_INICIO,
           I.STATUS_ATIVO                        AS STATUS_ATIVO_INICIO,
           I.FOI_AJUSTADO                        AS FOI_AJUSTADO_INICIO,
           I.DATA_HORA_SINCRONIZACAO             AS DATA_HORA_SINCRONIZACAO_INICIO,
           I.DEVICE_IMEI                         AS DEVICE_IMEI,
           DMI.IMEI IS NOT NULL                  AS DEVICE_RECONHECIDO,
           I.MARCA_DEVICE                        AS DEVICE_MARCA,
           I.MODELO_DEVICE                       AS DEVICE_MODELO,
           VIT.CODIGO_TIPO_INTERVALO_POR_UNIDADE AS COD_TIPO_INTERVALO_POR_UNIDADE,
           VIT.TIPO_JORNADA                      AS TIPO_JORNADA
    FROM MARCACAO_INICIO MI
             LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV
                       ON MI.COD_MARCACAO_INICIO = MV.COD_MARCACAO_INICIO
             JOIN INTERVALO I
                  ON MI.COD_MARCACAO_INICIO = I.CODIGO
             JOIN UNIDADE UNI
                  ON UNI.CODIGO = I.COD_UNIDADE
             LEFT JOIN DISPOSITIVO_MOVEL_IMEI DMI
                       ON DMI.COD_EMPRESA = UNI.COD_EMPRESA AND DMI.IMEI = I.DEVICE_IMEI
             JOIN VIEW_INTERVALO_TIPO VIT
                  ON I.COD_TIPO_INTERVALO = VIT.CODIGO
    WHERE I.VALIDO = TRUE
      AND CASE WHEN F_COD_UNIDADE IS NULL THEN TRUE ELSE I.COD_UNIDADE = F_COD_UNIDADE END
      AND CASE WHEN F_CPF_COLABORADOR IS NULL THEN TRUE ELSE I.CPF_COLABORADOR = F_CPF_COLABORADOR END
      AND CASE WHEN F_COD_TIPO_INTERVALO IS NULL THEN TRUE ELSE I.COD_TIPO_INTERVALO = F_COD_TIPO_INTERVALO END
),

     FINS AS (
         SELECT MF.COD_MARCACAO_FIM,
                MV.COD_MARCACAO_INICIO                AS COD_MARCACAO_VINCULO,
                F.FONTE_DATA_HORA                     AS FONTE_DATA_HORA_FIM,
                F.JUSTIFICATIVA_ESTOURO               AS JUSTIFICATIVA_ESTOURO,
                F.JUSTIFICATIVA_TEMPO_RECOMENDADO     AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
                F.LATITUDE_MARCACAO                   AS LATITUDE_MARCACAO_FIM,
                F.LONGITUDE_MARCACAO                  AS LONGITUDE_MARCACAO_FIM,
                F.COD_UNIDADE                         AS COD_UNIDADE,
                F.CPF_COLABORADOR                     AS CPF_COLABORADOR,
                F.COD_TIPO_INTERVALO                  AS COD_TIPO_INTERVALO,
                F.DATA_HORA                           AS DATA_HORA_FIM,
                F.CODIGO                              AS CODIGO_FIM,
                F.STATUS_ATIVO                        AS STATUS_ATIVO_FIM,
                F.FOI_AJUSTADO                        AS FOI_AJUSTADO_FIM,
                F.DATA_HORA_SINCRONIZACAO             AS DATA_HORA_SINCRONIZACAO_FIM,
                VIT.CODIGO_TIPO_INTERVALO_POR_UNIDADE AS COD_TIPO_INTERVALO_POR_UNIDADE,
                F.DEVICE_IMEI                         AS DEVICE_IMEI,
                DMI.IMEI IS NOT NULL                  AS DEVICE_RECONHECIDO,
                F.MARCA_DEVICE                        AS DEVICE_MARCA,
                F.MODELO_DEVICE                       AS DEVICE_MODELO,
                VIT.TIPO_JORNADA                      AS TIPO_JORNADA
         FROM MARCACAO_FIM MF
                  LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV
                            ON MF.COD_MARCACAO_FIM = MV.COD_MARCACAO_FIM
                  JOIN INTERVALO F
                       ON MF.COD_MARCACAO_FIM = F.CODIGO
                  JOIN UNIDADE UNI
                       ON UNI.CODIGO = F.COD_UNIDADE
                  LEFT JOIN DISPOSITIVO_MOVEL_IMEI DMI
                            ON DMI.COD_EMPRESA = UNI.COD_EMPRESA AND DMI.IMEI = F.DEVICE_IMEI
                  JOIN VIEW_INTERVALO_TIPO VIT
                       ON F.COD_TIPO_INTERVALO = VIT.CODIGO
         WHERE F.VALIDO = TRUE
           AND CASE WHEN F_COD_UNIDADE IS NULL THEN TRUE ELSE F.COD_UNIDADE = F_COD_UNIDADE END
           AND CASE WHEN F_CPF_COLABORADOR IS NULL THEN TRUE ELSE F.CPF_COLABORADOR = F_CPF_COLABORADOR END
           AND CASE WHEN F_COD_TIPO_INTERVALO IS NULL THEN TRUE ELSE F.COD_TIPO_INTERVALO = F_COD_TIPO_INTERVALO END
     )

SELECT I.FONTE_DATA_HORA_INICIO,
       F.FONTE_DATA_HORA_FIM,
       F.JUSTIFICATIVA_ESTOURO,
       F.JUSTIFICATIVA_TEMPO_RECOMENDADO,
       I.LATITUDE_MARCACAO_INICIO,
       I.LONGITUDE_MARCACAO_INICIO,
       F.LATITUDE_MARCACAO_FIM,
       F.LONGITUDE_MARCACAO_FIM,
       COALESCE(I.COD_UNIDADE, F.COD_UNIDADE)                                       AS COD_UNIDADE,
       COALESCE(I.CPF_COLABORADOR, F.CPF_COLABORADOR)                               AS CPF_COLABORADOR,
       COALESCE(I.COD_TIPO_INTERVALO, F.COD_TIPO_INTERVALO)                         AS COD_TIPO_INTERVALO,
       COALESCE(I.COD_TIPO_INTERVALO_POR_UNIDADE, F.COD_TIPO_INTERVALO_POR_UNIDADE) AS COD_TIPO_INTERVALO_POR_UNIDADE,
       I.DATA_HORA_INICIO,
       F.DATA_HORA_FIM,
       I.CODIGO_INICIO,
       F.CODIGO_FIM,
       I.STATUS_ATIVO_INICIO,
       F.STATUS_ATIVO_FIM,
       I.FOI_AJUSTADO_INICIO,
       F.FOI_AJUSTADO_FIM,
       I.DATA_HORA_SINCRONIZACAO_INICIO,
       F.DATA_HORA_SINCRONIZACAO_FIM,
       (F.TIPO_JORNADA = TRUE OR I.TIPO_JORNADA = TRUE)                             AS TIPO_JORNADA,
       I.DEVICE_IMEI :: TEXT                                                        AS DEVICE_IMEI_INICIO,
       I.DEVICE_RECONHECIDO :: BOOLEAN                                              AS DEVICE_IMEI_INICIO_RECONHECIDO,
       I.DEVICE_MARCA :: TEXT                                                       AS DEVICE_MARCA_INICIO,
       I.DEVICE_MODELO :: TEXT                                                      AS DEVICE_MODELO_INICIO,
       F.DEVICE_IMEI :: TEXT                                                        AS DEVICE_IMEI_FIM,
       F.DEVICE_RECONHECIDO :: BOOLEAN                                              AS DEVICE_IMEI_FIM_RECONHECIDO,
       F.DEVICE_MARCA :: TEXT                                                       AS DEVICE_MARCA_FIM,
       F.DEVICE_MODELO :: TEXT                                                      AS DEVICE_MODELO_FIM
FROM INICIOS I
         FULL OUTER JOIN FINS F
                         ON I.COD_MARCACAO_VINCULO = F.COD_MARCACAO_FIM
ORDER BY CPF_COLABORADOR,
         COD_TIPO_INTERVALO,
         COALESCE(DATA_HORA_INICIO, DATA_HORA_FIM)
$$;

create or replace view public.view_extrato_mapas_versus_intervalos(data, mapa, cod_unidade, intervalos_previstos,
                                                                   intervalos_realizados, cpf_motorista, nome_motorista,
                                                                   inicio_intervalo_mot, fim_intervalo_mot,
                                                                   marcacoes_reconhecidas_mot,
                                                                   tempo_decorrido_minutos_mot,
                                                                   mot_cumpriu_tempo_minimo, cpf_aj1, nome_aj1,
                                                                   inicio_intervalo_aj1, fim_intervalo_aj1,
                                                                   marcacoes_reconhecidas_aj1,
                                                                   tempo_decorrido_minutos_aj1,
                                                                   aj1_cumpriu_tempo_minimo, cpf_aj2, nome_aj2,
                                                                   inicio_intervalo_aj2, fim_intervalo_aj2,
                                                                   marcacoes_reconhecidas_aj2,
                                                                   tempo_decorrido_minutos_aj2,
                                                                   aj2_cumpriu_tempo_minimo) as
SELECT m.data,
       m.mapa,
       m.cod_unidade,
       ((f_if((mot.cpf IS NULL), 0, 1) + f_if((aj1.cpf IS NULL), 0, 1)) +
        f_if((aj2.cpf IS NULL), 0, 1))            AS intervalos_previstos,
       ((f_if(((int_mot.data_hora_fim IS NULL) OR (int_mot.data_hora_inicio IS NULL)), 0, 1) +
         f_if(((int_aj1.data_hora_fim IS NULL) OR (int_aj1.data_hora_inicio IS NULL)), 0, 1)) +
        f_if(((int_aj2.data_hora_fim IS NULL) OR (int_aj2.data_hora_inicio IS NULL)), 0,
             1))                                  AS intervalos_realizados,
       mot.cpf                                    AS cpf_motorista,
       mot.nome                                   AS nome_motorista,
       COALESCE(to_char(timezone(tz_unidade(int_mot.cod_unidade), int_mot.data_hora_inicio), 'HH24:MI'::text),
                '-'::text)                        AS inicio_intervalo_mot,
       COALESCE(to_char(timezone(tz_unidade(int_mot.cod_unidade), int_mot.data_hora_fim), 'HH24:MI'::text),
                '-'::text)                        AS fim_intervalo_mot,
       f_if((int_mot.device_imei_inicio_reconhecido AND int_mot.device_imei_fim_reconhecido), true,
            false)                                AS marcacoes_reconhecidas_mot,
       COALESCE((to_minutes_trunc((int_mot.data_hora_fim - int_mot.data_hora_inicio)))::text,
                '-'::text)                        AS tempo_decorrido_minutos_mot,
       CASE
           WHEN (int_mot.data_hora_fim IS NULL) THEN '-'::text
           WHEN (tipo_mot.tempo_recomendado_minutos >
                 to_minutes_trunc((int_mot.data_hora_fim - int_mot.data_hora_inicio))) THEN 'NÃO'::text
           ELSE 'SIM'::text
           END                                    AS mot_cumpriu_tempo_minimo,
       aj1.cpf                                    AS cpf_aj1,
       COALESCE(aj1.nome, '-'::character varying) AS nome_aj1,
       COALESCE(to_char(timezone(tz_unidade(int_aj1.cod_unidade), int_aj1.data_hora_inicio), 'HH24:MI'::text),
                '-'::text)                        AS inicio_intervalo_aj1,
       COALESCE(to_char(timezone(tz_unidade(int_aj1.cod_unidade), int_aj1.data_hora_fim), 'HH24:MI'::text),
                '-'::text)                        AS fim_intervalo_aj1,
       f_if((int_aj1.device_imei_inicio_reconhecido AND int_aj1.device_imei_fim_reconhecido), true,
            false)                                AS marcacoes_reconhecidas_aj1,
       COALESCE((to_minutes_trunc((int_aj1.data_hora_fim - int_aj1.data_hora_inicio)))::text,
                '-'::text)                        AS tempo_decorrido_minutos_aj1,
       CASE
           WHEN (int_aj1.data_hora_fim IS NULL) THEN '-'::text
           WHEN (tipo_aj1.tempo_recomendado_minutos >
                 to_minutes_trunc((int_aj1.data_hora_fim - int_aj1.data_hora_inicio))) THEN 'NÃO'::text
           ELSE 'SIM'::text
           END                                    AS aj1_cumpriu_tempo_minimo,
       aj2.cpf                                    AS cpf_aj2,
       COALESCE(aj2.nome, '-'::character varying) AS nome_aj2,
       COALESCE(to_char(timezone(tz_unidade(int_aj2.cod_unidade), int_aj2.data_hora_inicio), 'HH24:MI'::text),
                '-'::text)                        AS inicio_intervalo_aj2,
       COALESCE(to_char(timezone(tz_unidade(int_aj2.cod_unidade), int_aj2.data_hora_fim), 'HH24:MI'::text),
                '-'::text)                        AS fim_intervalo_aj2,
       f_if((int_aj2.device_imei_inicio_reconhecido AND int_aj2.device_imei_fim_reconhecido), true,
            false)                                AS marcacoes_reconhecidas_aj2,
       COALESCE((to_minutes_trunc((int_aj2.data_hora_fim - int_aj2.data_hora_inicio)))::text,
                '-'::text)                        AS tempo_decorrido_minutos_aj2,
       CASE
           WHEN (int_aj2.data_hora_fim IS NULL) THEN '-'::text
           WHEN (tipo_aj2.tempo_recomendado_minutos >
                 to_minutes_trunc((int_aj2.data_hora_fim - int_aj2.data_hora_inicio))) THEN 'NÃO'::text
           ELSE 'SIM'::text
           END                                    AS aj2_cumpriu_tempo_minimo
FROM ((((((((((mapa m
    JOIN unidade_funcao_produtividade ufp ON ((ufp.cod_unidade = m.cod_unidade)))
    JOIN colaborador mot ON (((mot.cod_unidade = m.cod_unidade) AND (mot.cod_funcao = ufp.cod_funcao_motorista) AND
                              (mot.matricula_ambev = m.matricmotorista))))
    LEFT JOIN colaborador aj1 ON (((aj1.cod_unidade = m.cod_unidade) AND (aj1.cod_funcao = ufp.cod_funcao_ajudante) AND
                                   (aj1.matricula_ambev = m.matricajud1))))
    LEFT JOIN colaborador aj2 ON (((aj2.cod_unidade = m.cod_unidade) AND (aj2.cod_funcao = ufp.cod_funcao_ajudante) AND
                                   (aj2.matricula_ambev = m.matricajud2))))
    LEFT JOIN func_intervalos_agrupados(NULL::bigint, NULL::bigint, NULL::bigint) int_mot(fonte_data_hora_fim,
                                                                                          fonte_data_hora_inicio,
                                                                                          justificativa_estouro,
                                                                                          justificativa_tempo_recomendado,
                                                                                          latitude_marcacao_inicio,
                                                                                          longitude_marcacao_inicio,
                                                                                          latitude_marcacao_fim,
                                                                                          longitude_marcacao_fim,
                                                                                          cod_unidade, cpf_colaborador,
                                                                                          cod_tipo_intervalo,
                                                                                          cod_tipo_intervalo_por_unidade,
                                                                                          data_hora_inicio,
                                                                                          data_hora_fim,
                                                                                          cod_marcacao_inicio,
                                                                                          cod_marcacao_fim,
                                                                                          status_ativo_inicio,
                                                                                          status_ativo_fim,
                                                                                          foi_ajustado_inicio,
                                                                                          foi_ajustado_fim,
                                                                                          data_hora_sincronizacao_inicio,
                                                                                          data_hora_sincronizacao_fim,
                                                                                          tipo_jornada,
                                                                                          device_imei_inicio,
                                                                                          device_imei_inicio_reconhecido,
                                                                                          device_marca_inicio,
                                                                                          device_modelo_inicio,
                                                                                          device_imei_fim,
                                                                                          device_imei_fim_reconhecido,
                                                                                          device_marca_fim,
                                                                                          device_modelo_fim) ON ((
            (int_mot.cpf_colaborador = mot.cpf) AND
            (tz_date(int_mot.data_hora_inicio, tz_unidade(int_mot.cod_unidade)) = m.data))))
    LEFT JOIN intervalo_tipo tipo_mot ON ((tipo_mot.codigo = int_mot.cod_tipo_intervalo)))
    LEFT JOIN func_intervalos_agrupados(NULL::bigint, NULL::bigint, NULL::bigint) int_aj1(fonte_data_hora_fim,
                                                                                          fonte_data_hora_inicio,
                                                                                          justificativa_estouro,
                                                                                          justificativa_tempo_recomendado,
                                                                                          latitude_marcacao_inicio,
                                                                                          longitude_marcacao_inicio,
                                                                                          latitude_marcacao_fim,
                                                                                          longitude_marcacao_fim,
                                                                                          cod_unidade, cpf_colaborador,
                                                                                          cod_tipo_intervalo,
                                                                                          cod_tipo_intervalo_por_unidade,
                                                                                          data_hora_inicio,
                                                                                          data_hora_fim,
                                                                                          cod_marcacao_inicio,
                                                                                          cod_marcacao_fim,
                                                                                          status_ativo_inicio,
                                                                                          status_ativo_fim,
                                                                                          foi_ajustado_inicio,
                                                                                          foi_ajustado_fim,
                                                                                          data_hora_sincronizacao_inicio,
                                                                                          data_hora_sincronizacao_fim,
                                                                                          tipo_jornada,
                                                                                          device_imei_inicio,
                                                                                          device_imei_inicio_reconhecido,
                                                                                          device_marca_inicio,
                                                                                          device_modelo_inicio,
                                                                                          device_imei_fim,
                                                                                          device_imei_fim_reconhecido,
                                                                                          device_marca_fim,
                                                                                          device_modelo_fim) ON ((
            (int_aj1.cpf_colaborador = aj1.cpf) AND
            (tz_date(int_aj1.data_hora_inicio, tz_unidade(int_aj1.cod_unidade)) = m.data))))
    LEFT JOIN intervalo_tipo tipo_aj1 ON ((tipo_aj1.codigo = int_aj1.cod_tipo_intervalo)))
    LEFT JOIN func_intervalos_agrupados(NULL::bigint, NULL::bigint, NULL::bigint) int_aj2(fonte_data_hora_fim,
                                                                                          fonte_data_hora_inicio,
                                                                                          justificativa_estouro,
                                                                                          justificativa_tempo_recomendado,
                                                                                          latitude_marcacao_inicio,
                                                                                          longitude_marcacao_inicio,
                                                                                          latitude_marcacao_fim,
                                                                                          longitude_marcacao_fim,
                                                                                          cod_unidade, cpf_colaborador,
                                                                                          cod_tipo_intervalo,
                                                                                          cod_tipo_intervalo_por_unidade,
                                                                                          data_hora_inicio,
                                                                                          data_hora_fim,
                                                                                          cod_marcacao_inicio,
                                                                                          cod_marcacao_fim,
                                                                                          status_ativo_inicio,
                                                                                          status_ativo_fim,
                                                                                          foi_ajustado_inicio,
                                                                                          foi_ajustado_fim,
                                                                                          data_hora_sincronizacao_inicio,
                                                                                          data_hora_sincronizacao_fim,
                                                                                          tipo_jornada,
                                                                                          device_imei_inicio,
                                                                                          device_imei_inicio_reconhecido,
                                                                                          device_marca_inicio,
                                                                                          device_modelo_inicio,
                                                                                          device_imei_fim,
                                                                                          device_imei_fim_reconhecido,
                                                                                          device_marca_fim,
                                                                                          device_modelo_fim) ON ((
            (int_aj2.cpf_colaborador = aj2.cpf) AND
            (tz_date(int_aj2.data_hora_inicio, tz_unidade(int_aj2.cod_unidade)) = m.data))))
         LEFT JOIN intervalo_tipo tipo_aj2 ON ((tipo_aj2.codigo = int_aj2.cod_tipo_intervalo)))
ORDER BY m.mapa DESC;

create or replace view public.view_intervalo_mapa_colaborador(data, mapa, cod_unidade, cpf, inicio_intervalo,
                                                              fim_intervalo, tempo_decorrido_minutos,
                                                              cumpriu_tempo_minimo) as
    SELECT view_extrato_mapas_versus_intervalos.data,
           view_extrato_mapas_versus_intervalos.mapa,
           view_extrato_mapas_versus_intervalos.cod_unidade,
           view_extrato_mapas_versus_intervalos.cpf_motorista               AS cpf,
           view_extrato_mapas_versus_intervalos.inicio_intervalo_mot        AS inicio_intervalo,
           view_extrato_mapas_versus_intervalos.fim_intervalo_mot           AS fim_intervalo,
           view_extrato_mapas_versus_intervalos.tempo_decorrido_minutos_mot AS tempo_decorrido_minutos,
           view_extrato_mapas_versus_intervalos.mot_cumpriu_tempo_minimo    AS cumpriu_tempo_minimo
    FROM view_extrato_mapas_versus_intervalos
    UNION
    SELECT view_extrato_mapas_versus_intervalos.data,
           view_extrato_mapas_versus_intervalos.mapa,
           view_extrato_mapas_versus_intervalos.cod_unidade,
           view_extrato_mapas_versus_intervalos.cpf_aj1                     AS cpf,
           view_extrato_mapas_versus_intervalos.inicio_intervalo_aj1        AS inicio_intervalo,
           view_extrato_mapas_versus_intervalos.fim_intervalo_aj1           AS fim_intervalo,
           view_extrato_mapas_versus_intervalos.tempo_decorrido_minutos_aj1 AS tempo_decorrido_minutos,
           view_extrato_mapas_versus_intervalos.aj1_cumpriu_tempo_minimo    AS cumpriu_tempo_minimo
    FROM view_extrato_mapas_versus_intervalos
    UNION
    SELECT view_extrato_mapas_versus_intervalos.data,
           view_extrato_mapas_versus_intervalos.mapa,
           view_extrato_mapas_versus_intervalos.cod_unidade,
           view_extrato_mapas_versus_intervalos.cpf_aj2                     AS cpf,
           view_extrato_mapas_versus_intervalos.inicio_intervalo_aj2        AS inicio_intervalo,
           view_extrato_mapas_versus_intervalos.fim_intervalo_aj2           AS fim_intervalo,
           view_extrato_mapas_versus_intervalos.tempo_decorrido_minutos_aj2 AS tempo_decorrido_minutos,
           view_extrato_mapas_versus_intervalos.aj2_cumpriu_tempo_minimo    AS cumpriu_tempo_minimo
    FROM view_extrato_mapas_versus_intervalos;


create or replace view public.veiculo(placa, cod_unidade, cod_empresa, km, status_ativo, cod_tipo, cod_modelo,
                                      cod_eixos, data_hora_cadastro, cod_unidade_cadastro, codigo) as
SELECT v.placa,
       v.cod_unidade,
       v.cod_empresa,
       v.km,
       v.status_ativo,
       v.cod_tipo,
       v.cod_modelo,
       v.cod_eixos,
       v.data_hora_cadastro,
       v.cod_unidade_cadastro,
       v.codigo
FROM veiculo_data v
WHERE (v.deletado = false);

create or replace view cs.view_nps_respostas(cod_empresa, nome_empresa, cod_unidade, nome_unidade, cod_nps_pesquisa,
                                             resposta_pergunta_escala, resposta_pergunta_descritiva, data_hora_resposta,
                                             cod_colaborador, cpf_colaborador, data_nascimento_colaborador,
                                             nome_colaborador) as
SELECT e.codigo                                                                         AS cod_empresa,
       e.nome                                                                           AS nome_empresa,
       u.codigo                                                                         AS cod_unidade,
       u.nome                                                                           AS nome_unidade,
       nr.cod_nps_pesquisa,
       nr.resposta_pergunta_escala,
       nr.resposta_pergunta_descritiva,
       timezone(tz_unidade((cd.cod_unidade)::bigint), nr.data_hora_realizacao_pesquisa) AS data_hora_resposta,
       cd.codigo                                                                        AS cod_colaborador,
       cd.cpf                                                                           AS cpf_colaborador,
       cd.data_nascimento                                                               AS data_nascimento_colaborador,
       cd.nome                                                                          AS nome_colaborador
FROM (((cs.nps_respostas nr
    JOIN colaborador_data cd ON ((nr.cod_colaborador_respostas = cd.codigo)))
    JOIN unidade u ON ((cd.cod_unidade = u.codigo)))
         JOIN empresa e ON ((cd.cod_empresa = e.codigo)))
ORDER BY e.nome, nr.resposta_pergunta_escala DESC;

create or replace view view_produtividade_extrato(cod_unidade, matricula_ambev, data, cpf, nome_colaborador,
                                                  data_nascimento,
                                                  funcao, cod_funcao, nome_equipe, fator, cargaatual, entrega, mapa,
                                                  placa,
                                                  cxcarreg, cxentreg, qthlcarregados, qthlentregues, qtnfcarregadas,
                                                  qtnfentregues,
                                                  entregascompletas, entregasnaorealizadas, entregasparciais,
                                                  kmprevistoroad,
                                                  kmsai, kmentr, tempoprevistoroad, hrsai, hrentr, tempo_rota,
                                                  tempointerno,
                                                  hrmatinal, apontamentos_ok, total_tracking, tempo_largada,
                                                  meta_tracking,
                                                  meta_tempo_rota_mapas, meta_caixa_viagem, meta_dev_hl, meta_dev_nf,
                                                  meta_dev_pdv,
                                                  meta_dispersao_km, meta_dispersao_tempo, meta_jornada_liquida_mapas,
                                                  meta_raio_tracking, meta_tempo_interno_mapas,
                                                  meta_tempo_largada_mapas,
                                                  meta_tempo_rota_horas, meta_tempo_interno_horas,
                                                  meta_tempo_largada_horas,
                                                  meta_jornada_liquida_horas, valor_rota, valor_recarga,
                                                  valor_diferenca_eld,
                                                  valor_as, valor) as
SELECT vmc.cod_unidade,
       c.matricula_ambev,
       m.data,
       vmc.cpf,
       c.nome                                                             AS nome_colaborador,
       c.data_nascimento,
       f.nome                                                             AS funcao,
       f.codigo                                                           AS cod_funcao,
       e.nome                                                             AS nome_equipe,
       m.fator,
       m.cargaatual,
       m.entrega,
       m.mapa,
       m.placa,
       m.cxcarreg,
       m.cxentreg,
       m.qthlcarregados,
       m.qthlentregues,
       m.qtnfcarregadas,
       m.qtnfentregues,
       m.entregascompletas,
       m.entregasnaorealizadas,
       m.entregasparciais,
       m.kmprevistoroad,
       m.kmsai,
       m.kmentr,
       to_seconds((m.tempoprevistoroad)::text)                            AS tempoprevistoroad,
       m.hrsai,
       m.hrentr,
       to_seconds((((m.hrentr - m.hrsai))::time without time zone)::text) AS tempo_rota,
       to_seconds((m.tempointerno)::text)                                 AS tempointerno,
       m.hrmatinal,
       tracking.apontamentos_ok,
       tracking.total_apontamentos                                        AS total_tracking,
       to_seconds((
           CASE
               WHEN (((m.hrsai)::time without time zone < m.hrmatinal) OR
                     (m.hrmatinal = '00:00:00'::time without time zone)) THEN um.meta_tempo_largada_horas
               ELSE ((m.hrsai - (m.hrmatinal)::interval))::time without time zone
               END)::text)                                                AS tempo_largada,
       um.meta_tracking,
       um.meta_tempo_rota_mapas,
       um.meta_caixa_viagem,
       um.meta_dev_hl,
       um.meta_dev_nf,
       um.meta_dev_pdv,
       um.meta_dispersao_km,
       um.meta_dispersao_tempo,
       um.meta_jornada_liquida_mapas,
       um.meta_raio_tracking,
       um.meta_tempo_interno_mapas,
       um.meta_tempo_largada_mapas,
       to_seconds((um.meta_tempo_rota_horas)::text)                       AS meta_tempo_rota_horas,
       to_seconds((um.meta_tempo_interno_horas)::text)                    AS meta_tempo_interno_horas,
       to_seconds((um.meta_tempo_largada_horas)::text)                    AS meta_tempo_largada_horas,
       to_seconds((um.meta_jornada_liquida_horas)::text)                  AS meta_jornada_liquida_horas,
       -- MAPAS DE ROTA (<> AS E <> RECARGA)
       CASE
           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                 (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)))
               THEN (m.vlbateujornmot + m.vlnaobateujornmot)
           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) AND
                 (m.fator <> (0)::double precision)) THEN ((m.vlbateujornaju + m.vlnaobateujornaju) / m.fator)
           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) AND
                 (m.fator <> (0)::double precision)) THEN ((m.vlbateujornaju + m.vlnaobateujornaju) / m.fator)
           ELSE (0)::real
           END                                                            AS valor_rota,
       -- MAPAS DE RECARGA (<>AS)
       (
               CASE
                   WHEN (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text = 'Recarga'::text)) THEN
                       CASE
                           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista))
                               THEN m.vlrecargamot
                           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                                 (m.fator <> (0)::double precision)) THEN (m.vlrecargaaju / m.fator)
                           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                                 (m.fator <> (0)::double precision)) THEN (m.vlrecargaaju / m.fator)
                           ELSE (0)::real
                           END
                   ELSE (0)::real
                   END +
        -- MAPAS DE RECARGA (AS)
               CASE
                   WHEN (((m.entrega)::text = 'AS'::text) AND ((m.cargaatual)::text = 'Recarga'::text)) THEN
                       CASE
                           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista))
                               THEN uv.rm_motorista_valor_as_recarga
                           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                                 (m.fator <> (0)::double precision)) THEN uv.rm_ajudante_valor_as_recarga
                           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                                 (m.fator <> (0)::double precision)) THEN uv.rm_ajudante_valor_as_recarga
                           ELSE (0)::real
                           END
                   ELSE (0)::real
                   END)                                                   AS valor_recarga,
       -- REMUNERAÇÃO ADICIONAL PARA MAPAS COM TEMPO PREVISTO SUPERIOR A META DE TEMPO EM ROTA
       CASE
           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                 ((m.entrega)::text <> 'AS'::text) AND (m.tempoprevistoroad > um.meta_tempo_rota_horas) AND
                 ((m.cargaatual)::text <> 'Recarga'::text) AND classificacao_roadshow <> 'Longa Distância') THEN (
                   ((m.cxentreg * (view_valor_cx_unidade.valor_cx_motorista_rota)::double precision) /
                    (m.fator)::double precision) - ((m.vlbateujornmot + m.vlnaobateujornmot) + m.vlrecargamot))
           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 ((m.entrega)::text <> 'AS'::text) AND (m.fator <> (0)::double precision) AND
                 (m.tempoprevistoroad > um.meta_tempo_rota_horas) AND ((m.cargaatual)::text <> 'Recarga'::text)
               AND classificacao_roadshow <> 'Longa Distância') THEN (
                   ((m.cxentreg * (view_valor_cx_unidade.valor_cx_ajudante_rota)::double precision) /
                    (m.fator)::double precision) -
                   (((m.vlbateujornaju + m.vlnaobateujornaju) + m.vlrecargaaju) / m.fator))
           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 ((m.entrega)::text <> 'AS'::text) AND (m.fator <> (0)::double precision) AND
                 (m.tempoprevistoroad > um.meta_tempo_rota_horas) AND ((m.cargaatual)::text <> 'Recarga'::text) AND classificacao_roadshow <> 'Longa Distância')
               THEN (
                   ((m.cxentreg * (view_valor_cx_unidade.valor_cx_ajudante_rota)::double precision) /
                    (m.fator)::double precision) -
                   (((m.vlbateujornaju + m.vlnaobateujornaju) + m.vlrecargaaju) / m.fator))
           ELSE (0)::double precision
           END                                                            AS valor_diferenca_eld,
       -- MAPAS DE AS
       CASE
            -- Esse WHEN precisa ser primeiro pois ele verifica a ausência de ajudantes.
            WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                 ((m.entrega)::text = 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)
                 AND (m.matricajud1 is null or m.matricajud1 <= 0) AND (m.matricajud2 is null or m.matricajud2 <= 0))
                THEN
                    uv.rm_motorista_valor_as_sem_ajudante
           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                 ((m.entrega)::text = 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) THEN
               CASE
                   WHEN (m.entregas = 1) THEN uv.rm_motorista_valor_as_1_entrega
                   WHEN (m.entregas = 2) THEN uv.rm_motorista_valor_as_2_entregas
                   WHEN (m.entregas = 3) THEN uv.rm_motorista_valor_as_3_entregas
                   WHEN (m.entregas > 3) THEN uv.rm_motorista_valor_as_maior_3_entregas
                   ELSE (0)::real
                   END
           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 ((m.entrega)::text = 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) THEN
               CASE
                   WHEN (m.entregas = 1) THEN uv.rm_ajudante_valor_as_1_entrega
                   WHEN (m.entregas = 2) THEN uv.rm_ajudante_valor_as_2_entregas
                   WHEN (m.entregas = 3) THEN uv.rm_ajudante_valor_as_3_entregas
                   WHEN (m.entregas > 3) THEN uv.rm_ajudante_valor_as_maior_3_entregas
                   ELSE (0)::real
                   END
           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 ((m.entrega)::text = 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) THEN
               CASE
                   WHEN (m.entregas = 1) THEN uv.rm_ajudante_valor_as_1_entrega
                   WHEN (m.entregas = 2) THEN uv.rm_ajudante_valor_as_2_entregas
                   WHEN (m.entregas = 3) THEN uv.rm_ajudante_valor_as_3_entregas
                   WHEN (m.entregas > 2) THEN uv.rm_ajudante_valor_as_maior_3_entregas
                   ELSE (0)::real
                   END
           ELSE (0)::real
           END                                                            AS valor_as,
       -- SOMA DO VALOR DOS MAPAS DE ROTA + RECARGA + DIFERENÇA ELD
           -- MAPAS DE ROTA (<> AS E <> RECARGA)
      ( CASE
           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                 (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)))
               THEN (m.vlbateujornmot + m.vlnaobateujornmot)
           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) AND
                 (m.fator <> (0)::double precision)) THEN ((m.vlbateujornaju + m.vlnaobateujornaju) / m.fator)
           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) AND
                 (m.fator <> (0)::double precision)) THEN ((m.vlbateujornaju + m.vlnaobateujornaju) / m.fator)
           ELSE (0)::real
           END +
           ---------
                  -- MAPAS DE RECARGA (<>AS)

               CASE
                   WHEN (((m.entrega)::text <> 'AS'::text) AND ((m.cargaatual)::text = 'Recarga'::text)) THEN
                       CASE
                           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista))
                               THEN m.vlrecargamot
                           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                                 (m.fator <> (0)::double precision)) THEN (m.vlrecargaaju / m.fator)
                           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                                 (m.fator <> (0)::double precision)) THEN (m.vlrecargaaju / m.fator)
                           ELSE (0)::real
                           END
                   ELSE (0)::real
                   END +
           ---------
           -- DIFERENÇA ELD
           CASE
           WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                 ((m.entrega)::text <> 'AS'::text) AND (m.tempoprevistoroad > um.meta_tempo_rota_horas) AND
                 ((m.cargaatual)::text <> 'Recarga'::text) AND classificacao_roadshow <> 'Longa Distância') THEN (
                   ((m.cxentreg * (view_valor_cx_unidade.valor_cx_motorista_rota)::double precision) /
                    (m.fator)::double precision) - ((m.vlbateujornmot + m.vlnaobateujornmot) + m.vlrecargamot))
           WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 ((m.entrega)::text <> 'AS'::text) AND (m.fator <> (0)::double precision) AND
                 (m.tempoprevistoroad > um.meta_tempo_rota_horas) AND ((m.cargaatual)::text <> 'Recarga'::text)
               AND classificacao_roadshow <> 'Longa Distância') THEN (
                   ((m.cxentreg * (view_valor_cx_unidade.valor_cx_ajudante_rota)::double precision) /
                    (m.fator)::double precision) -
                   (((m.vlbateujornaju + m.vlnaobateujornaju) + m.vlrecargaaju) / m.fator))
           WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                 ((m.entrega)::text <> 'AS'::text) AND (m.fator <> (0)::double precision) AND
                 (m.tempoprevistoroad > um.meta_tempo_rota_horas) AND ((m.cargaatual)::text <> 'Recarga'::text) AND classificacao_roadshow <> 'Longa Distância')
               THEN (
                   ((m.cxentreg * (view_valor_cx_unidade.valor_cx_ajudante_rota)::double precision) /
                    (m.fator)::double precision) -
                   (((m.vlbateujornaju + m.vlnaobateujornaju) + m.vlrecargaaju) / m.fator))
           ELSE (0)::double precision
           END +
           -------
        -- VALOR MAPAS DE AS
        -- MOTORISTAS
        CASE
            -- Esse WHEN precisa ser primeiro pois ele verifica a ausência de ajudantes.
            WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                 ((m.entrega)::text = 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)
                 AND (m.matricajud1 is null or m.matricajud1 <= 0) AND (m.matricajud2 is null or m.matricajud2 <= 0))
                THEN
                    uv.rm_motorista_valor_as_sem_ajudante
            WHEN ((c.matricula_ambev = m.matricmotorista) AND (c.cod_funcao = ufp.cod_funcao_motorista) AND
                  ((m.entrega)::text = 'AS'::text)) THEN
                CASE
                    WHEN ((m.entregas = 1) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_motorista_valor_as_1_entrega
                    WHEN ((m.entregas = 2) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_motorista_valor_as_2_entregas
                    WHEN ((m.entregas = 3) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_motorista_valor_as_3_entregas
                    WHEN ((m.entregas > 3) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_motorista_valor_as_maior_3_entregas
                    WHEN ((m.cargaatual)::text = 'Recarga'::text) THEN uv.rm_motorista_valor_as_recarga
                    ELSE (0)::real
                    END
            -- AJUDANTE 1
            WHEN ((c.matricula_ambev = m.matricajud1) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                  ((m.entrega)::text = 'AS'::text)) THEN
                CASE
                    WHEN ((m.entregas = 1) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_ajudante_valor_as_1_entrega
                    WHEN ((m.entregas = 2) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_ajudante_valor_as_2_entregas
                    WHEN ((m.entregas = 3) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_ajudante_valor_as_3_entregas
                    WHEN ((m.entregas > 3) AND ((m.cargaatual)::text <> 'Recarga'::text))
                        THEN uv.rm_ajudante_valor_as_maior_3_entregas
                    WHEN ((m.cargaatual)::text = 'Recarga'::text) THEN uv.rm_ajudante_valor_as_recarga
                    ELSE (0)::real
                    END
            -- AJUDANTE 2
            WHEN ((c.matricula_ambev = m.matricajud2) AND (c.cod_funcao = ufp.cod_funcao_ajudante) AND
                  ((m.entrega)::text = 'AS'::text) AND ((m.cargaatual)::text <> 'Recarga'::text)) THEN
                CASE
                    WHEN (m.entregas = 1) THEN uv.rm_ajudante_valor_as_1_entrega
                    WHEN (m.entregas = 2) THEN uv.rm_ajudante_valor_as_2_entregas
                    WHEN (m.entregas = 3) THEN uv.rm_ajudante_valor_as_3_entregas
                    WHEN (m.entregas > 2) THEN uv.rm_ajudante_valor_as_maior_3_entregas
                    WHEN ((m.cargaatual)::text = 'Recarga'::text) THEN uv.rm_ajudante_valor_as_recarga
                    ELSE (0)::real
                    END
            ELSE (0)::real
            END)                                                          AS valor
FROM (((((((((view_mapa_colaborador vmc
    JOIN colaborador_data c ON ((vmc.cpf = c.cpf)))
    JOIN funcao f ON (((f.codigo = c.cod_funcao) AND (f.cod_empresa = c.cod_empresa))))
    JOIN mapa m ON (((m.mapa = vmc.mapa) AND (m.cod_unidade = vmc.cod_unidade))))
    JOIN unidade_metas um ON ((um.cod_unidade = m.cod_unidade)))
    JOIN view_valor_cx_unidade ON ((view_valor_cx_unidade.cod_unidade = m.cod_unidade)))
    JOIN equipe e ON (((e.cod_unidade = c.cod_unidade) AND (c.cod_equipe = e.codigo))))
    JOIN unidade_funcao_produtividade ufp ON (((ufp.cod_unidade = c.cod_unidade) AND (ufp.cod_unidade = m.cod_unidade))))
    LEFT JOIN unidade_valores_rm uv ON ((uv.cod_unidade = m.cod_unidade)))
         LEFT JOIN (SELECT t.mapa                         AS tracking_mapa,
                           t."código_transportadora"      AS cod_transportadora,
                           sum(
                                   CASE
                                       WHEN (t.disp_apont_cadastrado <= um_1.meta_raio_tracking) THEN 1
                                       ELSE 0
                                       END)               AS apontamentos_ok,
                           count(t.disp_apont_cadastrado) AS total_apontamentos
                    FROM (tracking t
                             JOIN unidade_metas um_1 ON ((um_1.cod_unidade = t."código_transportadora")))
                    GROUP BY t.mapa, t."código_transportadora") tracking
                   ON (((tracking.tracking_mapa = m.mapa) AND (tracking.cod_transportadora = m.cod_unidade))));

create or replace view public.view_afericao_configuracao_alerta_sulco(cod_unidade, cod_config,
                                                                      variacao_aceita_sulco_menor_milimetros,
                                                                      variacao_aceita_sulco_maior_milimetros,
                                                                      usa_default_prolog, bloquear_valores_menores,
                                                                      bloquear_valores_maiores) as
    WITH configuracao_prolog AS (
        SELECT ap.variacao_aceita_sulco_maior_milimetros,
               ap.variacao_aceita_sulco_menor_milimetros,
               ap.bloquear_valores_menores,
               ap.bloquear_valores_maiores
        FROM afericao_configuracao_prolog ap
    )
    SELECT u.codigo                                            AS cod_unidade,
           config.codigo                                       AS cod_config,
           COALESCE(config.variacao_aceita_sulco_menor_milimetros,
                    cp.variacao_aceita_sulco_menor_milimetros) AS variacao_aceita_sulco_menor_milimetros,
           COALESCE(config.variacao_aceita_sulco_maior_milimetros,
                    cp.variacao_aceita_sulco_maior_milimetros) AS variacao_aceita_sulco_maior_milimetros,
           f_if((config.codigo IS NULL), true, false)          AS usa_default_prolog,
           COALESCE(config.bloquear_valores_menores,
                    cp.bloquear_valores_menores)               AS bloquear_valores_menores,
           COALESCE(config.bloquear_valores_maiores,
                    cp.bloquear_valores_maiores)               AS bloquear_valores_maiores
    FROM ((unidade u
        LEFT JOIN afericao_configuracao_alerta_sulco config ON ((u.codigo = config.cod_unidade)))
             FULL JOIN configuracao_prolog cp ON (true));

create or replace view public.checklist_modelo(cod_unidade, codigo, cod_versao_atual, nome, status_ativo) as
SELECT cm.cod_unidade,
       cm.codigo,
       cm.cod_versao_atual,
       cm.nome,
       cm.status_ativo
FROM checklist_modelo_data cm
WHERE (cm.deletado = false);

create or replace view public.checklist_ordem_servico_itens(cod_unidade, codigo, cod_os, cpf_mecanico,
                                                            cod_pergunta_primeiro_apontamento, cod_contexto_pergunta,
                                                            cod_contexto_alternativa,
                                                            cod_alternativa_primeiro_apontamento, status_resolucao,
                                                            qt_apontamentos, km, data_hora_conserto,
                                                            data_hora_inicio_resolucao, data_hora_fim_resolucao,
                                                            tempo_realizacao, feedback_conserto) as
SELECT cosi.cod_unidade,
       cosi.codigo,
       cosi.cod_os,
       cosi.cpf_mecanico,
       cosi.cod_pergunta_primeiro_apontamento,
       cosi.cod_contexto_pergunta,
       cosi.cod_contexto_alternativa,
       cosi.cod_alternativa_primeiro_apontamento,
       cosi.status_resolucao,
       cosi.qt_apontamentos,
       cosi.km,
       cosi.data_hora_conserto,
       cosi.data_hora_inicio_resolucao,
       cosi.data_hora_fim_resolucao,
       cosi.tempo_realizacao,
       cosi.feedback_conserto
FROM checklist_ordem_servico_itens_data cosi
WHERE (cosi.deletado = false);

create or replace view public.checklist_alternativa_pergunta(cod_checklist_modelo, cod_versao_checklist_modelo,
                                                             cod_unidade, alternativa, ordem, cod_pergunta, codigo,
                                                             codigo_contexto, alternativa_tipo_outros, prioridade,
                                                             deve_abrir_ordem_servico) as
SELECT cap.cod_checklist_modelo,
       cap.cod_versao_checklist_modelo,
       cap.cod_unidade,
       cap.alternativa,
       cap.ordem,
       cap.cod_pergunta,
       cap.codigo,
       cap.codigo_contexto,
       cap.alternativa_tipo_outros,
       cap.prioridade,
       cap.deve_abrir_ordem_servico
FROM checklist_alternativa_pergunta_data cap
WHERE (cap.deletado = false);

create or replace view public.checklist_perguntas(cod_checklist_modelo, cod_versao_checklist_modelo, cod_unidade, ordem,
                                                  pergunta, single_choice, cod_imagem, codigo, codigo_contexto) as
SELECT cp.cod_checklist_modelo,
       cp.cod_versao_checklist_modelo,
       cp.cod_unidade,
       cp.ordem,
       cp.pergunta,
       cp.single_choice,
       cp.cod_imagem,
       cp.codigo,
       cp.codigo_contexto
FROM checklist_perguntas_data cp
WHERE (cp.deletado = false);

create or replace view public.checklist(cod_unidade, cod_checklist_modelo, cod_versao_checklist_modelo, codigo,
                                        data_hora, data_hora_realizacao_tz_aplicado, data_hora_importado_prolog,
                                        cpf_colaborador, placa_veiculo, tipo, tempo_realizacao, km_veiculo,
                                        data_hora_sincronizacao, fonte_data_hora_realizacao,
                                        versao_app_momento_realizacao, versao_app_momento_sincronizacao, device_id,
                                        device_imei, device_uptime_realizacao_millis,
                                        device_uptime_sincronizacao_millis, foi_offline, total_perguntas_ok,
                                        total_perguntas_nok, total_alternativas_ok, total_alternativas_nok) as
SELECT c.cod_unidade,
       c.cod_checklist_modelo,
       c.cod_versao_checklist_modelo,
       c.codigo,
       c.data_hora,
       c.data_hora_realizacao_tz_aplicado,
       c.data_hora_importado_prolog,
       c.cpf_colaborador,
       c.placa_veiculo,
       c.tipo,
       c.tempo_realizacao,
       c.km_veiculo,
       c.data_hora_sincronizacao,
       c.fonte_data_hora_realizacao,
       c.versao_app_momento_realizacao,
       c.versao_app_momento_sincronizacao,
       c.device_id,
       c.device_imei,
       c.device_uptime_realizacao_millis,
       c.device_uptime_sincronizacao_millis,
       c.foi_offline,
       c.total_perguntas_ok,
       c.total_perguntas_nok,
       c.total_alternativas_ok,
       c.total_alternativas_nok
FROM checklist_data c
WHERE (c.deletado = false);

create or replace view public.estratificacao_os(cod_os, nome_realizador_checklist, placa_veiculo, km, data_hora,
                                                tipo_checklist, cod_pergunta, cod_contexto_pergunta, ordem_pergunta,
                                                pergunta, single_choice, url_imagem, prioridade, prioridade_ordem,
                                                cod_alternativa, cod_contexto_alternativa, alternativa, prazo,
                                                resposta_outros, cod_tipo, cod_unidade, status_os, cod_checklist,
                                                time_zone_unidade, status_item, nome_mecanico, cpf_mecanico,
                                                tempo_realizacao, data_hora_conserto, data_hora_inicio_resolucao_utc,
                                                data_hora_fim_resolucao_utc, km_fechamento, qt_apontamentos,
                                                feedback_conserto, codigo) as
SELECT cos.codigo                                                     AS cod_os,
       realizador.nome                                                AS nome_realizador_checklist,
       c.placa_veiculo,
       c.km_veiculo                                                   AS km,
       c.data_hora_realizacao_tz_aplicado                             AS data_hora,
       c.tipo                                                         AS tipo_checklist,
       cp.codigo                                                      AS cod_pergunta,
       cp.codigo_contexto                                             AS cod_contexto_pergunta,
       cp.ordem                                                       AS ordem_pergunta,
       cp.pergunta,
       cp.single_choice,
       NULL::text                                                     AS url_imagem,
       cap.prioridade,
       CASE cap.prioridade
           WHEN 'CRITICA'::text THEN 1
           WHEN 'ALTA'::text THEN 2
           WHEN 'BAIXA'::text THEN 3
           ELSE NULL::integer
           END                                                        AS prioridade_ordem,
       cap.codigo                                                     AS cod_alternativa,
       cap.codigo_contexto                                            AS cod_contexto_alternativa,
       cap.alternativa,
       prio.prazo,
       crn.resposta_outros,
       v.cod_tipo,
       cos.cod_unidade,
       cos.status                                                     AS status_os,
       cos.cod_checklist,
       tz_unidade(cos.cod_unidade)                                    AS time_zone_unidade,
       cosi.status_resolucao                                          AS status_item,
       mecanico.nome                                                  AS nome_mecanico,
       cosi.cpf_mecanico,
       cosi.tempo_realizacao,
       timezone(tz_unidade(cos.cod_unidade), cosi.data_hora_conserto) AS data_hora_conserto,
       cosi.data_hora_inicio_resolucao                                AS data_hora_inicio_resolucao_utc,
       cosi.data_hora_fim_resolucao                                   AS data_hora_fim_resolucao_utc,
       cosi.km                                                        AS km_fechamento,
       cosi.qt_apontamentos,
       cosi.feedback_conserto,
       cosi.codigo
FROM (((((((((checklist_data c
    JOIN colaborador realizador ON ((realizador.cpf = c.cpf_colaborador)))
    JOIN veiculo v ON (((v.placa)::text = (c.placa_veiculo)::text)))
    JOIN checklist_ordem_servico cos ON ((c.codigo = cos.cod_checklist)))
    JOIN checklist_ordem_servico_itens cosi ON (((cos.codigo = cosi.cod_os) AND (cos.cod_unidade = cosi.cod_unidade))))
    JOIN checklist_perguntas cp ON (((cp.cod_versao_checklist_modelo = c.cod_versao_checklist_modelo) AND
                                     (cosi.cod_contexto_pergunta = cp.codigo_contexto))))
    JOIN checklist_alternativa_pergunta cap ON (((cap.cod_pergunta = cp.codigo) AND
                                                 (cosi.cod_contexto_alternativa = cap.codigo_contexto))))
    JOIN checklist_alternativa_prioridade prio ON (((prio.prioridade)::text = (cap.prioridade)::text)))
    JOIN checklist_respostas_nok crn ON (((crn.cod_checklist = c.codigo) AND (crn.cod_alternativa = cap.codigo))))
         LEFT JOIN colaborador mecanico ON ((mecanico.cpf = cosi.cpf_mecanico)));

create or replace view public.pneu_servico_realizado_incrementa_vida(cod_servico_realizado, cod_modelo_banda,
                                                                     vida_nova_pneu, fonte_servico_realizado) as
SELECT psrivd.cod_servico_realizado,
       psrivd.cod_modelo_banda,
       psrivd.vida_nova_pneu,
       psrivd.fonte_servico_realizado
FROM pneu_servico_realizado_incrementa_vida_data psrivd
WHERE (psrivd.deletado = false);

create or replace view public.movimentacao_pneu_servico_realizado_recapadora(cod_movimentacao, cod_servico_realizado_movimentacao, cod_recapadora) as
SELECT mpsrrd.cod_movimentacao,
       mpsrrd.cod_servico_realizado_movimentacao,
       mpsrrd.cod_recapadora
FROM movimentacao_pneu_servico_realizado_recapadora_data mpsrrd
WHERE (mpsrrd.deletado = false);

create or replace view public.movimentacao_pneu_servico_realizado(cod_movimentacao, cod_servico_realizado, fonte_servico_realizado) as
SELECT mpsrd.cod_movimentacao,
       mpsrd.cod_servico_realizado,
       mpsrd.fonte_servico_realizado
FROM movimentacao_pneu_servico_realizado_data mpsrd
WHERE (mpsrd.deletado = false);

create or replace view public.pneu_servico_realizado(codigo, cod_tipo_servico, cod_unidade, cod_pneu, custo, vida,
                                                     fonte_servico_realizado) as
SELECT psrd.codigo,
       psrd.cod_tipo_servico,
       psrd.cod_unidade,
       psrd.cod_pneu,
       psrd.custo,
       psrd.vida,
       psrd.fonte_servico_realizado
FROM pneu_servico_realizado_data psrd
WHERE (psrd.deletado = false);

create or replace view public.pneu_servico_cadastro(cod_pneu, cod_servico_realizado, fonte_servico_realizado) as
SELECT pscd.cod_pneu,
       pscd.cod_servico_realizado,
       pscd.fonte_servico_realizado
FROM pneu_servico_cadastro_data pscd
WHERE (pscd.deletado = false);

create or replace function audit.func_audit() returns trigger
    security definer
    language plpgsql
as
$$
DECLARE
    F_TABLE_NAME_AUDIT TEXT    := TG_RELNAME || '_audit';
    F_TG_OP            TEXT    := SUBSTRING(TG_OP, 1, 1);
    F_JSON             TEXT    := CASE
                                      WHEN F_TG_OP = 'D'
                                          THEN ROW_TO_JSON(OLD)
                                      ELSE ROW_TO_JSON(NEW)
        END;
    IS_NEW_ROW         BOOLEAN := CASE WHEN F_TG_OP = 'D' THEN FALSE ELSE TRUE END;
BEGIN
    EXECUTE FORMAT(
            'CREATE TABLE IF NOT EXISTS audit.%I (
        CODIGO                  SERIAL,
        DATA_HORA_UTC           TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        OPERACAO                VARCHAR(1),
        PG_USERNAME             TEXT,
        PG_APPLICATION_NAME     TEXT,
        ROW_LOG                 JSONB,
        IS_NEW_ROW              BOOLEAN
      );', F_TABLE_NAME_AUDIT);

    EXECUTE FORMAT(
            'INSERT INTO audit.%I (operacao, row_log, is_new_row, pg_username, pg_application_name)
       VALUES (%L, %L, %L, %L, %L);', F_TABLE_NAME_AUDIT, F_TG_OP, F_JSON, IS_NEW_ROW, SESSION_USER,
            (SELECT CURRENT_SETTING('application_name')));
    RETURN NULL;
END;
$$;

create trigger tg_func_audit_afericao
    after insert or update or delete
    on public.afericao_data
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_colaborador
    after insert or update or delete
    on public.colaborador_data
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_empresa
    after insert or update or delete
    on public.empresa
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_pneu_restricao_unidade
    after insert or update or delete
    on public.pneu_restricao_unidade
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_funcao_data
    after insert or update or delete
    on public.funcao_data
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_pneu
    after insert or update or delete
    on public.pneu_data
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_relato_alternativa
    after insert or update or delete
    on public.relato_alternativa
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_token_autenticacao
    after delete
    on public.token_autenticacao
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_unidade
    after insert or update or delete
    on public.unidade
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_veiculo
    after insert or update or delete
    on public.veiculo_data
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_veiculo_pneu
    after insert or update or delete
    on public.veiculo_pneu
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_movimentacao_motivo_descarte_empresa
    after insert or update or delete
    on public.movimentacao_motivo_descarte_empresa
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_afericao_configuracao_tipo_afericao_veiculo
    after insert or update or delete
    on public.afericao_configuracao_tipo_afericao_veiculo
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_fechamento_os
    after insert or update
    on suporte.fechamento_os
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_messaging_push_colaborador_token
    after insert or update or delete
    on messaging.push_colaborador_token
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_colaborador_telefone
    after insert or update or delete
    on public.colaborador_telefone
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_colaborador_email
    after insert or update or delete
    on public.colaborador_email
    for each row
execute procedure audit.func_audit();

create trigger tg_func_audit_socorro_rota_empresa_liberada
    after insert or update or delete
    on public.socorro_rota_empresa_liberada
    for each row
execute procedure audit.func_audit();

create or replace function integracao.func_integracao_busca_afericoes_empresa(f_token_integracao text, f_cod_ultima_afericao_sincronizada bigint)
    returns TABLE
            (
                cod_afericao                       bigint,
                cod_unidade_afericao               bigint,
                cpf_colaborador                    text,
                placa_veiculo_aferido              character varying,
                cod_pneu_aferido                   bigint,
                numero_fogo                        character varying,
                altura_sulco_interno               numeric,
                altura_sulco_central_interno       numeric,
                altura_sulco_central_externo       numeric,
                altura_sulco_externo               numeric,
                pressao                            numeric,
                km_veiculo_momento_afericao        bigint,
                tempo_realizacao_afericao_em_milis bigint,
                vida_momento_afericao              integer,
                posicao_pneu_momento_afericao      integer,
                data_hora_afericao                 timestamp without time zone,
                tipo_medicao_coletada              character varying,
                tipo_processo_coleta               character varying
            )
    language sql
as
$$
SELECT A.CODIGO                                           AS COD_AFERICAO,
       A.COD_UNIDADE                                      AS COD_UNIDADE_AFERICAO,
       LPAD(A.CPF_AFERIDOR :: TEXT, 11, '0')              AS CPF_COLABORADOR,
       A.PLACA_VEICULO                                    AS PLACA_VEICULO_AFERIDO,
       AV.COD_PNEU                                        AS COD_PNEU_AFERIDO,
       P.CODIGO_CLIENTE                                   AS NUMERO_FOGO,
       TRUNC(AV.ALTURA_SULCO_INTERNO::NUMERIC, 1)         AS ALTURA_SULCO_INTERNO,
       TRUNC(AV.ALTURA_SULCO_CENTRAL_INTERNO::NUMERIC, 1) AS ALTURA_SULCO_CENTRAL_INTERNO,
       TRUNC(AV.ALTURA_SULCO_CENTRAL_EXTERNO::NUMERIC, 1) AS ALTURA_SULCO_CENTRAL_EXTERNO,
       TRUNC(AV.ALTURA_SULCO_EXTERNO::NUMERIC, 1)         AS ALTURA_SULCO_EXTERNO,
       TRUNC(AV.PSI::NUMERIC, 1)                          AS PRESSAO,
       A.KM_VEICULO                                       AS KM_VEICULO_MOMENTO_AFERICAO,
       A.TEMPO_REALIZACAO                                 AS TEMPO_REALIZACAO_AFERICAO_EM_MILIS,
       AV.VIDA_MOMENTO_AFERICAO                           AS VIDA_MOMENTO_AFERICAO,
       AV.POSICAO                                         AS POSICAO_PNEU_MOMENTO_AFERICAO,
       A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE) AS DATA_HORA_AFERICAO,
       A.TIPO_MEDICAO_COLETADA                            AS TIPO_MEDICAO_COLETADA,
       A.TIPO_PROCESSO_COLETA                             AS TIPO_PROCESSO_COLETA
FROM AFERICAO A
         JOIN AFERICAO_VALORES AV ON A.CODIGO = AV.COD_AFERICAO
         JOIN PNEU P ON AV.COD_PNEU = P.CODIGO
WHERE A.COD_UNIDADE IN (SELECT CODIGO
                        FROM UNIDADE
                        WHERE COD_EMPRESA = (SELECT TI.COD_EMPRESA
                                             FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                             WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO))
  AND A.CODIGO > F_COD_ULTIMA_AFERICAO_SINCRONIZADA
ORDER BY A.CODIGO;
$$;

create or replace function prolog_analises.func_veiculo_analise_kms_alterados_consolidado()
    returns TABLE
            (
                dia                                      text,
                total_atualizacoes_km_dia_todas_empresas bigint,
                total_edicoes_km_dia_todas_empresas      bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT TO_CHAR(VAK.DATA_HORA_EDICAO :: DATE, 'DD/MM/YYYY') AS DIA,
               COUNT(*)                                            AS TOTAL_EDICOES_KM_DIA_TODAS_EMPRESAS,
               COUNT(*)
               FILTER (WHERE KM_NOVO < KM_ANTIGO)                  AS TOTAL_EDICOES_KM_DIA_TODAS_EMPRESAS
        FROM PROLOG_ANALISES.VEICULO_ALTERACAO_KM VAK
        GROUP BY VAK.DATA_HORA_EDICAO :: DATE
        ORDER BY VAK.DATA_HORA_EDICAO :: DATE DESC;
END;
$$;

create or replace function prolog_analises.func_veiculo_analise_kms_alterados_por_empresa()
    returns TABLE
            (
                cod_empresa                              bigint,
                nome_empresa                             text,
                dia                                      text,
                total_atualizacoes_km_dia_por_empresa    bigint,
                total_edicoes_km_dia_por_empresa         bigint,
                total_atualizacoes_km_dia_todas_empresas numeric,
                total_edicoes_km_dia_todas_empresas      numeric
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH ALTERACOES_KM_EMPRESA AS (
            SELECT E.CODIGO                           AS COD_EMPRESA,
                   E.NOME :: TEXT                     AS NOME_EMPRESA,
                   VAK.DATA_HORA_EDICAO :: DATE       AS DIA,
                   COUNT(*)                           AS TOTAL_ATUALIZACOES_KM_DIA_POR_EMPRESA,
                   COUNT(*)
                   FILTER (WHERE KM_NOVO < KM_ANTIGO) AS TOTAL_EDICOES_KM_DIA_POR_EMPRESA
            FROM PROLOG_ANALISES.VEICULO_ALTERACAO_KM VAK
                     JOIN PUBLIC.UNIDADE U ON VAK.COD_UNIDADE_ALOCADO = U.CODIGO
                     JOIN PUBLIC.EMPRESA E ON U.COD_EMPRESA = E.CODIGO
            GROUP BY E.CODIGO, VAK.DATA_HORA_EDICAO :: DATE
        )

        SELECT AKE.COD_EMPRESA                           AS COD_EMPRESA,
               AKE.NOME_EMPRESA                          AS NOME_EMPRESA,
               TO_CHAR(AKE.DIA, 'DD/MM/YYYY')            AS DIA,
               AKE.TOTAL_ATUALIZACOES_KM_DIA_POR_EMPRESA AS TOTAL_ATUALIZACOES_KM_DIA_POR_EMPRESA,
               AKE.TOTAL_EDICOES_KM_DIA_POR_EMPRESA      AS TOTAL_EDICOES_KM_DIA_POR_EMPRESA,
               SUM(AKE.TOTAL_ATUALIZACOES_KM_DIA_POR_EMPRESA)
               OVER (
                   PARTITION BY AKE.DIA )                AS TOTAL_ATUALIZACOES_KM_DIA_TODAS_EMPRESAS,
               SUM(AKE.TOTAL_EDICOES_KM_DIA_POR_EMPRESA)
               OVER (
                   PARTITION BY AKE.DIA )                AS TOTAL_EDICOES_KM_DIA_TODAS_EMPRESAS
        FROM ALTERACOES_KM_EMPRESA AKE
        ORDER BY AKE.DIA DESC, AKE.NOME_EMPRESA ASC;
END;
$$;

create or replace function prolog_analises.tg_func_veiculo_alteracao_km() returns trigger
    language plpgsql
as
$$
BEGIN
    INSERT INTO PROLOG_ANALISES.VEICULO_ALTERACAO_KM (PLACA, COD_UNIDADE_ALOCADO, KM_ANTIGO, KM_NOVO)
    VALUES (OLD.PLACA, OLD.COD_UNIDADE, OLD.KM, NEW.KM);
    RETURN NEW;
END;
$$;

create trigger tg_func_veiculo_alteracao_km
    after update
    on public.veiculo_data
    for each row
execute procedure prolog_analises.tg_func_veiculo_alteracao_km();

create or replace function public.array_distinct(anyarray, boolean DEFAULT false) returns anyarray
    immutable
    language sql
as
$$
SELECT ARRAY_AGG(DISTINCT X)
FROM UNNEST($1) T(X)
WHERE CASE WHEN $2 THEN X IS NOT NULL ELSE TRUE END;
$$;

create or replace function public.f_random_string(length integer) returns text
    language plpgsql
as
$$
DECLARE
    CHARS  TEXT[]  := '{0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z,a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z}';
    RESULT TEXT    := '';
    I      INTEGER := 0;
BEGIN
    IF LENGTH < 0
    THEN
        RAISE EXCEPTION 'Given length cannot be less than 0!';
    END IF;
    FOR I IN 1..LENGTH
        LOOP
            RESULT := RESULT || CHARS[CEIL(61 * RANDOM())];
        END LOOP;
    RETURN RESULT;
END;
$$;

create or replace function public.format_cpf(cpf bigint) returns text
    language plpgsql
as
$$
DECLARE
    _CPF TEXT;
BEGIN
    IF LENGTH(CPF::TEXT) > 11
    THEN
        RAISE EXCEPTION 'CPF % fora do padrão', CPF;
    END IF;

    SELECT REPLACE(TO_CHAR(CPF, '000:000:000-00'), ':', '.') INTO _CPF;
    RETURN _CPF;
END;
$$;

create or replace function public.format_with_tz(ts_tz timestamp with time zone, tz_unidade text, ts_fortmat text,
                                                 value_if_null text DEFAULT NULL::text) returns text
    language plpgsql
as
$$
BEGIN
    RETURN COALESCE(TO_CHAR(TS_TZ AT TIME ZONE TZ_UNIDADE, TS_FORTMAT), VALUE_IF_NULL);
END;
$$;

create or replace function suporte.func_afericao_altera_km_coletado_afericao(f_cod_unidade bigint, f_placa text,
                                                                             f_cod_afericao bigint, f_novo_km bigint,
                                                                             OUT aviso_km_afericao_alterado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);
    PERFORM FUNC_GARANTE_VEICULO_EXISTE(F_COD_UNIDADE, F_PLACA);
    PERFORM FUNC_GARANTE_NOVO_KM_MENOR_QUE_ATUAL_VEICULO(F_COD_UNIDADE, F_PLACA, F_NOVO_KM);

    -- Verifica se aferição existe.
    IF NOT EXISTS(SELECT AF.CODIGO
                  FROM AFERICAO AF
                  WHERE AF.PLACA_VEICULO IS NOT NULL
                    AND AF.PLACA_VEICULO = F_PLACA
                    AND AF.COD_UNIDADE = F_COD_UNIDADE
                    AND AF.CODIGO = F_COD_AFERICAO)
    THEN
        RAISE EXCEPTION 'Não foi possível encontrar a aferição realizada com estes parâmetros: Unidade %, Placa %,
                     Código da aferição %', F_COD_UNIDADE, F_PLACA, F_COD_AFERICAO;
    END IF;

    UPDATE AFERICAO
    SET KM_VEICULO = F_NOVO_KM
    WHERE CODIGO = F_COD_AFERICAO
      AND COD_UNIDADE = F_COD_UNIDADE
      AND PLACA_VEICULO = F_PLACA;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao atualizar o km da aferição com estes parâemtros: Unidade %, Placa %, Código da aferição %',
            F_COD_UNIDADE,
            F_PLACA,
            F_COD_AFERICAO;
    END IF;

    SELECT 'O KM DO VEÍCULO NA AFERIÇÃO FOI ALTERADO COM SUCESSO, UNIDADE: '
               || F_COD_UNIDADE
               || ', PLACA: '
               || F_PLACA
               || ', CÓDIGO DA AFERIÇÃO: '
               || F_COD_AFERICAO
    INTO AVISO_KM_AFERICAO_ALTERADO;
END;
$$;

create or replace function suporte.func_afericao_deleta_afericao(f_cod_unidade bigint, f_placa text,
                                                                 f_codigo_afericao bigint,
                                                                 OUT aviso_afericao_deletada text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN
    IF ((SELECT COUNT(codigo)
         FROM AFERICAO_DATA
         WHERE CODIGO = F_CODIGO_AFERICAO
           AND COD_UNIDADE = F_COD_UNIDADE
           AND PLACA_VEICULO = F_PLACA) <= 0)
    THEN
        RAISE EXCEPTION 'Nenhuma aferição encontrada com estes parâmetros: Unidade %, Placa % e Código %',
            F_COD_UNIDADE, F_PLACA, F_CODIGO_AFERICAO;
    END IF;

    -- DELETA AFERIÇÃO.
    UPDATE AFERICAO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND PLACA_VEICULO = F_PLACA
      AND CODIGO = F_CODIGO_AFERICAO
      AND DELETADO = FALSE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao deletar o aferição de unidade: %, placa: % e código: %',
            F_COD_UNIDADE, F_PLACA, F_CODIGO_AFERICAO;
    END IF;

    -- DELETA AFERIÇÃO VALORES.
    UPDATE AFERICAO_VALORES_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND COD_AFERICAO = F_CODIGO_AFERICAO
      AND DELETADO = FALSE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    -- SE TEM AFERIÇÃO, TAMBÉM DEVERÁ CONTER VALORES DE AFERIÇÃO, ENTÃO DEVE-SE VERIFICAR.
    IF ((QTD_LINHAS_ATUALIZADAS <= 0) AND ((SELECT COUNT(*)
                                            FROM AFERICAO_VALORES_DATA AVD
                                            WHERE AVD.COD_UNIDADE = F_COD_UNIDADE
                                              AND AVD.COD_AFERICAO = F_CODIGO_AFERICAO) > 0))
    THEN
        RAISE EXCEPTION 'Erro ao deletar os valores de  aferição de unidade: %, placa: % e código: %',
            F_COD_UNIDADE, F_PLACA, F_CODIGO_AFERICAO;
    END IF;

    -- DELETA AFERIÇÃO MANUTENÇÃO.
    -- Não verificamos quantas linhas atualizadas pois aferição pode não ter manutenções.
    UPDATE AFERICAO_MANUTENCAO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND COD_AFERICAO = F_CODIGO_AFERICAO;

    SELECT 'AFERIÇÃO DELETADA: '
               || F_CODIGO_AFERICAO
               || ', PLACA: '
               || F_PLACA
               || ', CÓDIGO DA UNIDADE: '
               || F_COD_UNIDADE
    INTO AVISO_AFERICAO_DELETADA;
END;
$$;

create or replace function suporte.func_afericao_deleta_servico_afericao(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                         f_cod_pneu bigint, f_numero_fogo text,
                                                                         f_codigo_afericao bigint,
                                                                         f_cod_servico_afericao bigint,
                                                                         f_tipo_servico_afericao text,
                                                                         OUT aviso_servico_afericao_deletado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    F_TIPO_SERVICO_AFERICAO TEXT := LOWER(F_TIPO_SERVICO_AFERICAO);
BEGIN
    --Garante integridade entre unidade e empresa
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE);
    --Verifica se o pneu existe
    PERFORM FUNC_GARANTE_PNEU_EXISTE(F_COD_EMPRESA, F_COD_UNIDADE, F_COD_PNEU, F_NUMERO_FOGO);
    --Verifica se existe afericao
    IF NOT EXISTS(SELECT A.CODIGO
                  FROM AFERICAO A
                  WHERE A.CODIGO = F_CODIGO_AFERICAO
                    AND A.COD_UNIDADE = F_COD_UNIDADE)
    THEN
        RAISE EXCEPTION 'Aferição de código % não existe para a unidade % - %', F_CODIGO_AFERICAO, F_COD_UNIDADE,
            (SELECT NOME
             FROM UNIDADE
             WHERE CODIGO = F_COD_UNIDADE);
    END IF;
    --Verifica se existe serviço de afericao
    IF NOT EXISTS(SELECT AM.CODIGO
                  FROM AFERICAO_MANUTENCAO AM
                  WHERE AM.CODIGO = F_COD_SERVICO_AFERICAO
                    AND AM.COD_AFERICAO = F_CODIGO_AFERICAO
                    AND AM.COD_PNEU = F_COD_PNEU
                    AND AM.COD_UNIDADE = F_COD_UNIDADE
                    AND AM.TIPO_SERVICO = F_TIPO_SERVICO_AFERICAO)
    THEN
        RAISE EXCEPTION 'Não existe serviço de aferição com código: %, do tipo: "%", código de aferição: %,
     e codigo de pneus: %
                      para a unidade % - %', F_COD_SERVICO_AFERICAO, F_TIPO_SERVICO_AFERICAO,
            F_CODIGO_AFERICAO, F_COD_PNEU, F_COD_UNIDADE, (SELECT NOME
                                                           FROM UNIDADE
                                                           WHERE CODIGO = F_COD_UNIDADE);
    END IF;
    -- Deleta aferição manutenção.
    UPDATE AFERICAO_MANUTENCAO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = F_COD_SERVICO_AFERICAO
      AND COD_AFERICAO = F_CODIGO_AFERICAO
      AND COD_UNIDADE = F_COD_UNIDADE
      AND COD_PNEU = F_COD_PNEU;
    SELECT 'SERVIÇO DE AFERIÇÃO DELETADO: '
               || F_COD_SERVICO_AFERICAO
               || ', DO TIPO: '
               || F_TIPO_SERVICO_AFERICAO
               || ', CODIGO DE AFERIÇÃO: '
               || F_CODIGO_AFERICAO
               || ', CÓDIGO PNEU: '
               || F_COD_PNEU
               || ', UNIDADE: '
               || F_COD_UNIDADE
               || ' - '
               || (SELECT U.NOME
                   FROM UNIDADE U
                   WHERE U.CODIGO = F_COD_UNIDADE)
    INTO AVISO_SERVICO_AFERICAO_DELETADO;
END
$$;

create or replace function public.func_afericao_get_afericao_by_codigo(f_cod_unidade bigint, f_cod_afericao bigint, f_tz_unidade text)
    returns TABLE
            (
                cod_afericao                 bigint,
                cod_unidade                  bigint,
                data_hora                    timestamp without time zone,
                placa_veiculo                text,
                km_veiculo                   bigint,
                tempo_realizacao             bigint,
                tipo_processo_coleta         text,
                tipo_medicao_coletada        text,
                cpf                          text,
                nome                         text,
                altura_sulco_central_interno real,
                altura_sulco_central_externo real,
                altura_sulco_externo         real,
                altura_sulco_interno         real,
                pressao_pneu                 integer,
                posicao_pneu                 integer,
                vida_pneu_momento_afericao   integer,
                vidas_total_pneu             integer,
                codigo_pneu                  bigint,
                codigo_pneu_cliente          text,
                pressao_recomendada          real
            )
    language sql
as
$$
SELECT A.CODIGO                              AS COD_AFERICAO,
       A.COD_UNIDADE                         AS COD_UNIDADE,
       A.DATA_HORA AT TIME ZONE F_TZ_UNIDADE AS DATA_HORA,
       A.PLACA_VEICULO :: TEXT               AS PLACA_VEICULO,
       A.KM_VEICULO                          AS KM_VEICULO,
       A.TEMPO_REALIZACAO                    AS TEMPO_REALIZACAO,
       A.TIPO_PROCESSO_COLETA :: TEXT        AS TIPO_PROCESSO_COLETA,
       A.TIPO_MEDICAO_COLETADA :: TEXT       AS TIPO_MEDICAO_COLETADA,
       C.CPF :: TEXT                         AS CPF,
       C.NOME :: TEXT                        AS NOME,
       AV.ALTURA_SULCO_CENTRAL_INTERNO       AS ALTURA_SULCO_CENTRAL_INTERNO,
       AV.ALTURA_SULCO_CENTRAL_EXTERNO       AS ALTURA_SULCO_CENTRAL_EXTERNO,
       AV.ALTURA_SULCO_EXTERNO               AS ALTURA_SULCO_EXTERNO,
       AV.ALTURA_SULCO_INTERNO               AS ALTURA_SULCO_INTERNO,
       AV.PSI :: INT                         AS PRESSAO_PNEU,
       AV.POSICAO                            AS POSICAO_PNEU,
       AV.VIDA_MOMENTO_AFERICAO              AS VIDA_PNEU_MOMENTO_AFERICAO,
       P.VIDA_TOTAL                          AS VIDAS_TOTAL_PNEU,
       P.CODIGO                              AS CODIGO_PNEU,
       P.CODIGO_CLIENTE :: TEXT              AS CODIGO_PNEU_CLIENTE,
       P.PRESSAO_RECOMENDADA                 AS PRESSAO_RECOMENDADA
FROM AFERICAO A
         JOIN AFERICAO_VALORES AV
              ON A.CODIGO = AV.COD_AFERICAO
         JOIN PNEU_ORDEM PO
              ON AV.POSICAO = PO.POSICAO_PROLOG
         JOIN PNEU P
              ON P.CODIGO = AV.COD_PNEU
         JOIN MODELO_PNEU MO
              ON MO.CODIGO = P.COD_MODELO
         JOIN MARCA_PNEU MP
              ON MP.CODIGO = MO.COD_MARCA
         JOIN COLABORADOR C
              ON C.CPF = A.CPF_AFERIDOR
WHERE AV.COD_AFERICAO = F_COD_AFERICAO
  AND AV.COD_UNIDADE = F_COD_UNIDADE
ORDER BY PO.ORDEM_EXIBICAO ASC;
$$;

create or replace function public.func_afericao_get_afericoes_avulsas_paginada(f_cod_unidade bigint,
                                                                               f_data_inicial date, f_data_final date,
                                                                               f_limit bigint, f_offset bigint,
                                                                               f_tz_unidade text)
    returns TABLE
            (
                km_veiculo            bigint,
                cod_afericao          bigint,
                cod_unidade           bigint,
                data_hora             timestamp without time zone,
                placa_veiculo         text,
                tipo_medicao_coletada text,
                tipo_processo_coleta  text,
                cpf                   text,
                nome                  text,
                tempo_realizacao      bigint
            )
    language sql
as
$$
SELECT A.KM_VEICULO,
       A.CODIGO                              AS COD_AFERICAO,
       A.COD_UNIDADE                         AS COD_UNIDADE,
       A.DATA_HORA AT TIME ZONE F_TZ_UNIDADE AS DATA_HORA,
       A.PLACA_VEICULO :: TEXT,
       A.TIPO_MEDICAO_COLETADA :: TEXT,
       A.TIPO_PROCESSO_COLETA :: TEXT,
       C.CPF :: TEXT,
       C.NOME :: TEXT,
       A.TEMPO_REALIZACAO
FROM AFERICAO A
         JOIN VEICULO V ON V.PLACA = A.PLACA_VEICULO
         JOIN COLABORADOR C ON C.CPF = A.CPF_AFERIDOR
WHERE A.COD_UNIDADE = F_COD_UNIDADE
  AND (A.DATA_HORA AT TIME ZONE F_TZ_UNIDADE) :: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
ORDER BY A.DATA_HORA DESC
LIMIT F_LIMIT
    OFFSET F_OFFSET;
$$;

create or replace function public.func_afericao_get_afericoes_placas_paginada(f_cod_unidade bigint,
                                                                              f_cod_tipo_veiculo bigint,
                                                                              f_placa_veiculo text, f_data_inicial date,
                                                                              f_data_final date, f_limit bigint,
                                                                              f_offset bigint, f_tz_unidade text)
    returns TABLE
            (
                km_veiculo            bigint,
                cod_afericao          bigint,
                cod_unidade           bigint,
                data_hora             timestamp without time zone,
                placa_veiculo         text,
                tipo_medicao_coletada text,
                tipo_processo_coleta  text,
                cpf                   text,
                nome                  text,
                tempo_realizacao      bigint
            )
    language sql
as
$$
SELECT A.KM_VEICULO,
       A.CODIGO                              AS COD_AFERICAO,
       A.COD_UNIDADE                         AS COD_UNIDADE,
       A.DATA_HORA AT TIME ZONE F_TZ_UNIDADE AS DATA_HORA,
       A.PLACA_VEICULO :: TEXT,
       A.TIPO_MEDICAO_COLETADA :: TEXT,
       A.TIPO_PROCESSO_COLETA :: TEXT,
       C.CPF :: TEXT,
       C.NOME :: TEXT,
       A.TEMPO_REALIZACAO
FROM AFERICAO A
         JOIN VEICULO V ON V.PLACA = A.PLACA_VEICULO
         JOIN COLABORADOR C ON C.CPF = A.CPF_AFERIDOR
WHERE A.COD_UNIDADE = F_COD_UNIDADE
  AND CASE
          WHEN F_COD_TIPO_VEICULO IS NOT NULL
              THEN V.COD_TIPO = F_COD_TIPO_VEICULO
          ELSE TRUE END
  AND CASE
          WHEN F_PLACA_VEICULO IS NOT NULL
              THEN V.PLACA = F_PLACA_VEICULO
          ELSE TRUE END
  AND (A.DATA_HORA AT TIME ZONE F_TZ_UNIDADE)::DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
ORDER BY A.DATA_HORA DESC
LIMIT F_LIMIT
    OFFSET F_OFFSET;
$$;

create or replace function public.func_afericao_get_config_tipo_afericao_veiculo(f_cod_unidade bigint)
    returns TABLE
            (
                cod_configuracao          bigint,
                cod_unidade_configuracao  bigint,
                cod_tipo_veiculo          bigint,
                nome_tipo_veiculo         text,
                cod_empresa_tipo_veiculo  bigint,
                status_ativo_tipo_veiculo boolean,
                pode_aferir_sulco         boolean,
                pode_aferir_pressao       boolean,
                pode_aferir_sulco_pressao boolean,
                pode_aferir_estepe        boolean
            )
    language plpgsql
as
$$
DECLARE
    F_COD_EMPRESA BIGINT := (SELECT U.COD_EMPRESA
                             FROM UNIDADE U
                             WHERE U.CODIGO = F_COD_UNIDADE);
BEGIN
    RETURN QUERY
        SELECT CONFIG.CODIGO                                                       AS COD_CONFIGURACAO,
               -- Usamos o código da unidade recebido por parâmetro pois se um tipo não tiver configurado para a unidade buscada
               -- o código da tabela será NULL.
               F_COD_UNIDADE                                                       AS COD_UNIDADE_CONFIGURACAO,
               VT.CODIGO                                                           AS COD_TIPO_VEICULO,
               VT.NOME :: TEXT                                                     AS NOME_TIPO_VEICULO,
               VT.COD_EMPRESA                                                      AS COD_EMPRESA_TIPO_VEICULO,
               VT.STATUS_ATIVO                                                     AS STATUS_ATIVO_TIPO_VEICULO,
               -- Essas verificações servem para o caso do tipo de veículo não ter configuracão criada,
               -- assim retornamos um default que libera tudo.
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_SULCO)         AS PODE_AFERIR_SULCO,
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_PRESSAO)       AS PODE_AFERIR_PRESSAO,
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_SULCO_PRESSAO) AS PODE_AFERIR_SULCO_PRESSAO,
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_ESTEPE)        AS PODE_AFERIR_ESTEPE
        FROM VEICULO_TIPO VT
                 LEFT JOIN AFERICAO_CONFIGURACAO_TIPO_AFERICAO_VEICULO CONFIG
                           ON CONFIG.COD_TIPO_VEICULO = VT.CODIGO
                               AND CONFIG.COD_UNIDADE = F_COD_UNIDADE
        WHERE VT.COD_EMPRESA = F_COD_EMPRESA
          AND (CONFIG.COD_UNIDADE = F_COD_UNIDADE OR CONFIG.COD_UNIDADE IS NULL)
        ORDER BY VT.NOME ASC;
END;
$$;

create or replace function public.func_pneu_get_pneu_by_codigo(f_cod_pneu bigint)
    returns TABLE
            (
                codigo                       bigint,
                codigo_cliente               text,
                dot                          text,
                valor                        real,
                cod_unidade_alocado          bigint,
                cod_regional_alocado         bigint,
                pneu_novo_nunca_rodado       boolean,
                cod_marca_pneu               bigint,
                nome_marca_pneu              text,
                cod_modelo_pneu              bigint,
                nome_modelo_pneu             text,
                qt_sulcos_modelo_pneu        smallint,
                cod_marca_banda              bigint,
                nome_marca_banda             text,
                altura_sulcos_modelo_pneu    real,
                cod_modelo_banda             bigint,
                nome_modelo_banda            text,
                qt_sulcos_modelo_banda       smallint,
                altura_sulcos_modelo_banda   real,
                valor_banda                  real,
                altura                       integer,
                largura                      integer,
                aro                          real,
                cod_dimensao                 bigint,
                altura_sulco_central_interno real,
                altura_sulco_central_externo real,
                altura_sulco_interno         real,
                altura_sulco_externo         real,
                pressao_recomendada          real,
                pressao_atual                real,
                status                       text,
                vida_atual                   integer,
                vida_total                   integer,
                posicao_pneu                 integer,
                posicao_aplicado_cliente     text,
                cod_veiculo_aplicado         bigint,
                placa_aplicado               text
            )
    language sql
as
$$
SELECT P.CODIGO,
       P.CODIGO_CLIENTE,
       P.DOT,
       P.VALOR,
       U.CODIGO                         AS COD_UNIDADE_ALOCADO,
       R.CODIGO                         AS COD_REGIONAL_ALOCADO,
       P.PNEU_NOVO_NUNCA_RODADO,
       MP.CODIGO                        AS COD_MARCA_PNEU,
       MP.NOME                          AS NOME_MARCA_PNEU,
       MOP.CODIGO                       AS COD_MODELO_PNEU,
       MOP.NOME                         AS NOME_MODELO_PNEU,
       MOP.QT_SULCOS                    AS QT_SULCOS_MODELO_PNEU,
       MAB.CODIGO                       AS COD_MARCA_BANDA,
       MAB.NOME                         AS NOME_MARCA_BANDA,
       MOP.ALTURA_SULCOS                AS ALTURA_SULCOS_MODELO_PNEU,
       MOB.CODIGO                       AS COD_MODELO_BANDA,
       MOB.NOME                         AS NOME_MODELO_BANDA,
       MOB.QT_SULCOS                    AS QT_SULCOS_MODELO_BANDA,
       MOB.ALTURA_SULCOS                AS ALTURA_SULCOS_MODELO_BANDA,
       PVV.VALOR                        AS VALOR_BANDA,
       PD.ALTURA,
       PD.LARGURA,
       PD.ARO,
       PD.CODIGO                        AS COD_DIMENSAO,
       P.ALTURA_SULCO_CENTRAL_INTERNO,
       P.ALTURA_SULCO_CENTRAL_EXTERNO,
       P.ALTURA_SULCO_INTERNO,
       P.ALTURA_SULCO_EXTERNO,
       P.PRESSAO_RECOMENDADA,
       P.PRESSAO_ATUAL,
       P.STATUS,
       P.VIDA_ATUAL,
       P.VIDA_TOTAL,
       VP.POSICAO                       AS POSICAO_PNEU,
       COALESCE(PPNE.NOMENCLATURA, '-') AS POSICAO_APLICADO_CLIENTE,
       VEI.CODIGO                       AS COD_VEICULO_APLICADO,
       VEI.PLACA                        AS PLACA_APLICADO
FROM PNEU P
         JOIN MODELO_PNEU MOP ON MOP.CODIGO = P.COD_MODELO
         JOIN MARCA_PNEU MP ON MP.CODIGO = MOP.COD_MARCA
         JOIN DIMENSAO_PNEU PD ON PD.CODIGO = P.COD_DIMENSAO
         JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
         JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
         JOIN REGIONAL R ON U.COD_REGIONAL = R.CODIGO
         LEFT JOIN MODELO_BANDA MOB ON MOB.CODIGO = P.COD_MODELO_BANDA AND MOB.COD_EMPRESA = U.COD_EMPRESA
         LEFT JOIN MARCA_BANDA MAB ON MAB.CODIGO = MOB.COD_MARCA AND MAB.COD_EMPRESA = MOB.COD_EMPRESA
         LEFT JOIN PNEU_VALOR_VIDA PVV ON PVV.COD_PNEU = P.CODIGO AND PVV.VIDA = P.VIDA_ATUAL
         LEFT JOIN VEICULO_PNEU VP ON VP.COD_PNEU = P.CODIGO
         LEFT JOIN VEICULO VEI ON VEI.PLACA = VP.PLACA
         LEFT JOIN VEICULO_TIPO VT ON VT.CODIGO = VEI.COD_TIPO AND VT.COD_EMPRESA = E.CODIGO
         LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
    AND PPNE.COD_DIAGRAMA = VD.CODIGO
    AND PPNE.POSICAO_PROLOG = VP.POSICAO
WHERE P.CODIGO = F_COD_PNEU
ORDER BY P.CODIGO_CLIENTE ASC;
$$;

create or replace function public.func_afericao_get_pneu_para_afericao_avulsa(f_cod_pneu bigint, f_tz_unidade text)
    returns TABLE
            (
                codigo                                bigint,
                codigo_cliente                        text,
                dot                                   text,
                valor                                 real,
                cod_unidade_alocado                   bigint,
                cod_regional_alocado                  bigint,
                pneu_novo_nunca_rodado                boolean,
                cod_marca_pneu                        bigint,
                nome_marca_pneu                       text,
                cod_modelo_pneu                       bigint,
                nome_modelo_pneu                      text,
                qt_sulcos_modelo_pneu                 smallint,
                cod_marca_banda                       bigint,
                nome_marca_banda                      text,
                altura_sulcos_modelo_pneu             real,
                cod_modelo_banda                      bigint,
                nome_modelo_banda                     text,
                qt_sulcos_modelo_banda                smallint,
                altura_sulcos_modelo_banda            real,
                valor_banda                           real,
                altura                                integer,
                largura                               integer,
                aro                                   real,
                cod_dimensao                          bigint,
                altura_sulco_central_interno          real,
                altura_sulco_central_externo          real,
                altura_sulco_interno                  real,
                altura_sulco_externo                  real,
                pressao_recomendada                   real,
                pressao_atual                         real,
                status                                text,
                vida_atual                            integer,
                vida_total                            integer,
                posicao_pneu                          integer,
                posicao_aplicado_cliente              text,
                cod_veiculo_aplicado                  bigint,
                placa_aplicado                        text,
                ja_foi_aferido                        boolean,
                cod_ultima_afericao                   bigint,
                data_hora_ultima_afericao             timestamp without time zone,
                placa_veiculo_ultima_afericao         text,
                tipo_medicao_coletada_ultima_afericao text,
                tipo_processo_coleta_ultima_afericao  text,
                nome_colaborador_ultima_afericao      text
            )
    language sql
as
$$
WITH AFERICOES AS (
    SELECT INNER_TABLE.CODIGO           AS COD_AFERICAO,
           INNER_TABLE.COD_PNEU         AS COD_PNEU,
           INNER_TABLE.DATA_HORA,
           INNER_TABLE.PLACA_VEICULO,
           INNER_TABLE.TIPO_MEDICAO_COLETADA,
           INNER_TABLE.TIPO_PROCESSO_COLETA,
           INNER_TABLE.NOME_COLABORADOR AS NOME_COLABORADOR,
           CASE
               WHEN INNER_TABLE.NOME_COLABORADOR IS NOT NULL
                   THEN TRUE
               ELSE FALSE END           AS JA_FOI_AFERIDO
    FROM (SELECT A.CODIGO,
                 AV.COD_PNEU,
                 A.DATA_HORA,
                 A.PLACA_VEICULO,
                 A.TIPO_MEDICAO_COLETADA,
                 A.TIPO_PROCESSO_COLETA,
                 C.NOME                      AS NOME_COLABORADOR,
                 MAX(A.CODIGO)
                 OVER (
                     PARTITION BY COD_PNEU ) AS MAX_COD_AFERICAO
          FROM PNEU P
                   LEFT JOIN AFERICAO_VALORES AV ON P.CODIGO = AV.COD_PNEU
                   LEFT JOIN AFERICAO A ON AV.COD_AFERICAO = A.CODIGO
                   LEFT JOIN COLABORADOR C ON A.CPF_AFERIDOR = C.CPF
          WHERE P.STATUS = 'ESTOQUE'
            AND P.CODIGO = F_COD_PNEU) AS INNER_TABLE
    WHERE CODIGO = INNER_TABLE.MAX_COD_AFERICAO
)

SELECT F.*,
       A.JA_FOI_AFERIDO                      AS JA_FOI_AFERIDO,
       A.COD_AFERICAO                        AS COD_ULTIMA_AFERICAO,
       A.DATA_HORA AT TIME ZONE F_TZ_UNIDADE AS DATA_HORA_ULTIMA_AFERICAO,
       A.PLACA_VEICULO :: TEXT               AS PLACA_VEICULO_ULTIMA_AFERICAO,
       A.TIPO_MEDICAO_COLETADA :: TEXT       AS TIPO_MEDICAO_COLETADA_ULTIMA_AFERICAO,
       A.TIPO_PROCESSO_COLETA :: TEXT        AS TIPO_PROCESSO_COLETA_ULTIMA_AFERICAO,
       A.NOME_COLABORADOR :: TEXT            AS NOME_COLABORADOR_ULTIMA_AFERICAO
FROM FUNC_PNEU_GET_PNEU_BY_CODIGO(F_COD_PNEU) AS F
         LEFT JOIN AFERICOES A ON F.CODIGO = A.COD_PNEU
WHERE F.CODIGO = F_COD_PNEU;
$$;

create or replace function public.func_pneu_get_listagem_pneus_by_status(f_cod_unidade bigint, f_status_pneu text)
    returns TABLE
            (
                codigo                       bigint,
                codigo_cliente               text,
                dot                          text,
                valor                        real,
                cod_unidade_alocado          bigint,
                cod_regional_alocado         bigint,
                pneu_novo_nunca_rodado       boolean,
                cod_marca_pneu               bigint,
                nome_marca_pneu              text,
                cod_modelo_pneu              bigint,
                nome_modelo_pneu             text,
                qt_sulcos_modelo_pneu        smallint,
                cod_marca_banda              bigint,
                nome_marca_banda             text,
                altura_sulcos_modelo_pneu    real,
                cod_modelo_banda             bigint,
                nome_modelo_banda            text,
                qt_sulcos_modelo_banda       smallint,
                altura_sulcos_modelo_banda   real,
                valor_banda                  real,
                altura                       integer,
                largura                      integer,
                aro                          real,
                cod_dimensao                 bigint,
                altura_sulco_central_interno real,
                altura_sulco_central_externo real,
                altura_sulco_interno         real,
                altura_sulco_externo         real,
                pressao_recomendada          real,
                pressao_atual                real,
                status                       text,
                vida_atual                   integer,
                vida_total                   integer,
                posicao_pneu                 integer,
                posicao_aplicado_cliente     text,
                cod_veiculo_aplicado         bigint,
                placa_aplicado               text
            )
    language sql
as
$$
SELECT P.CODIGO,
       P.CODIGO_CLIENTE,
       P.DOT,
       P.VALOR,
       U.CODIGO                         AS COD_UNIDADE_ALOCADO,
       R.CODIGO                         AS COD_REGIONAL_ALOCADO,
       P.PNEU_NOVO_NUNCA_RODADO,
       MP.CODIGO                        AS COD_MARCA_PNEU,
       MP.NOME                          AS NOME_MARCA_PNEU,
       MOP.CODIGO                       AS COD_MODELO_PNEU,
       MOP.NOME                         AS NOME_MODELO_PNEU,
       MOP.QT_SULCOS                    AS QT_SULCOS_MODELO_PNEU,
       MAB.CODIGO                       AS COD_MARCA_BANDA,
       MAB.NOME                         AS NOME_MARCA_BANDA,
       MOP.ALTURA_SULCOS                AS ALTURA_SULCOS_MODELO_PNEU,
       MOB.CODIGO                       AS COD_MODELO_BANDA,
       MOB.NOME                         AS NOME_MODELO_BANDA,
       MOB.QT_SULCOS                    AS QT_SULCOS_MODELO_BANDA,
       MOB.ALTURA_SULCOS                AS ALTURA_SULCOS_MODELO_BANDA,
       PVV.VALOR                        AS VALOR_BANDA,
       PD.ALTURA,
       PD.LARGURA,
       PD.ARO,
       PD.CODIGO                        AS COD_DIMENSAO,
       P.ALTURA_SULCO_CENTRAL_INTERNO,
       P.ALTURA_SULCO_CENTRAL_EXTERNO,
       P.ALTURA_SULCO_INTERNO,
       P.ALTURA_SULCO_EXTERNO,
       P.PRESSAO_RECOMENDADA,
       P.PRESSAO_ATUAL,
       P.STATUS,
       P.VIDA_ATUAL,
       P.VIDA_TOTAL,
       VP.POSICAO                       AS POSICAO_PNEU,
       COALESCE(PPNE.NOMENCLATURA, '-') AS POSICAO_APLICADO,
       VEI.CODIGO                       AS COD_VEICULO,
       VEI.PLACA                        AS PLACA
FROM PNEU P
         JOIN MODELO_PNEU MOP ON MOP.CODIGO = P.COD_MODELO
         JOIN MARCA_PNEU MP ON MP.CODIGO = MOP.COD_MARCA
         JOIN DIMENSAO_PNEU PD ON PD.CODIGO = P.COD_DIMENSAO
         JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
         JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
         JOIN REGIONAL R ON U.COD_REGIONAL = R.CODIGO
         LEFT JOIN VEICULO_PNEU VP ON VP.COD_PNEU = P.CODIGO AND VP.COD_UNIDADE = P.COD_UNIDADE
         LEFT JOIN VEICULO VEI ON VEI.PLACA = VP.PLACA
         LEFT JOIN VEICULO_TIPO VT ON VT.CODIGO = VEI.COD_TIPO AND VT.COD_EMPRESA = E.CODIGO
         LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
         LEFT JOIN MODELO_BANDA MOB ON MOB.CODIGO = P.COD_MODELO_BANDA AND MOB.COD_EMPRESA = U.COD_EMPRESA
         LEFT JOIN MARCA_BANDA MAB ON MAB.CODIGO = MOB.COD_MARCA AND MAB.COD_EMPRESA = MOB.COD_EMPRESA
         LEFT JOIN PNEU_VALOR_VIDA PVV ON PVV.COD_PNEU = P.CODIGO AND PVV.VIDA = P.VIDA_ATUAL
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
    AND PPNE.COD_DIAGRAMA = VD.CODIGO
    AND PPNE.POSICAO_PROLOG = VP.POSICAO
WHERE P.COD_UNIDADE = F_COD_UNIDADE
  AND P.STATUS LIKE F_STATUS_PNEU
ORDER BY P.CODIGO_CLIENTE ASC;
$$;

create or replace function public.func_afericao_get_pneus_disponiveis_afericao_avulsa(f_cod_unidade bigint)
    returns TABLE
            (
                codigo                                bigint,
                codigo_cliente                        text,
                dot                                   text,
                valor                                 real,
                cod_unidade_alocado                   bigint,
                cod_regional_alocado                  bigint,
                pneu_novo_nunca_rodado                boolean,
                cod_marca_pneu                        bigint,
                nome_marca_pneu                       text,
                cod_modelo_pneu                       bigint,
                nome_modelo_pneu                      text,
                qt_sulcos_modelo_pneu                 smallint,
                cod_marca_banda                       bigint,
                nome_marca_banda                      text,
                altura_sulcos_modelo_pneu             real,
                cod_modelo_banda                      bigint,
                nome_modelo_banda                     text,
                qt_sulcos_modelo_banda                smallint,
                altura_sulcos_modelo_banda            real,
                valor_banda                           real,
                altura                                integer,
                largura                               integer,
                aro                                   real,
                cod_dimensao                          bigint,
                altura_sulco_central_interno          real,
                altura_sulco_central_externo          real,
                altura_sulco_interno                  real,
                altura_sulco_externo                  real,
                pressao_recomendada                   real,
                pressao_atual                         real,
                status                                text,
                vida_atual                            integer,
                vida_total                            integer,
                posicao_pneu                          integer,
                posicao_aplicado_cliente              text,
                cod_veiculo_aplicado                  bigint,
                placa_aplicado                        text,
                ja_foi_aferido                        boolean,
                cod_ultima_afericao                   bigint,
                data_hora_ultima_afericao             timestamp without time zone,
                placa_veiculo_ultima_afericao         text,
                tipo_medicao_coletada_ultima_afericao text,
                tipo_processo_coleta_ultima_afericao  text,
                nome_colaborador_ultima_afericao      text
            )
    language sql
as
$$
WITH AFERICOES AS (
    SELECT INNER_TABLE.CODIGO           AS COD_AFERICAO,
           INNER_TABLE.COD_PNEU         AS COD_PNEU,
           INNER_TABLE.DATA_HORA,
           INNER_TABLE.PLACA_VEICULO,
           INNER_TABLE.TIPO_MEDICAO_COLETADA,
           INNER_TABLE.TIPO_PROCESSO_COLETA,
           INNER_TABLE.NOME_COLABORADOR AS NOME_COLABORADOR,
           CASE
               WHEN INNER_TABLE.NOME_COLABORADOR IS NOT NULL
                   THEN TRUE
               ELSE FALSE END           AS JA_FOI_AFERIDO
    FROM (SELECT A.CODIGO,
                 AV.COD_PNEU,
                 A.DATA_HORA,
                 A.PLACA_VEICULO,
                 A.TIPO_MEDICAO_COLETADA,
                 A.TIPO_PROCESSO_COLETA,
                 C.NOME                      AS NOME_COLABORADOR,
                 MAX(A.CODIGO)
                 OVER (
                     PARTITION BY COD_PNEU ) AS MAX_COD_AFERICAO
          FROM PNEU P
                   LEFT JOIN AFERICAO_VALORES AV ON P.CODIGO = AV.COD_PNEU
                   LEFT JOIN AFERICAO A ON AV.COD_AFERICAO = A.CODIGO
                   LEFT JOIN COLABORADOR C ON A.CPF_AFERIDOR = C.CPF
          WHERE P.COD_UNIDADE = f_cod_unidade
            AND P.STATUS = 'ESTOQUE') AS INNER_TABLE
    WHERE CODIGO = INNER_TABLE.MAX_COD_AFERICAO
)

SELECT F.*,
       A.JA_FOI_AFERIDO                                   AS JA_FOI_AFERIDO,
       A.COD_AFERICAO                                     AS COD_ULTIMA_AFERICAO,
       A.DATA_HORA AT TIME ZONE TZ_UNIDADE(f_cod_unidade) AS DATA_HORA_ULTIMA_AFERICAO,
       A.PLACA_VEICULO::TEXT                              AS PLACA_VEICULO_ULTIMA_AFERICAO,
       A.TIPO_MEDICAO_COLETADA::TEXT                      AS TIPO_MEDICAO_COLETADA_ULTIMA_AFERICAO,
       A.TIPO_PROCESSO_COLETA::TEXT                       AS TIPO_PROCESSO_COLETA_ULTIMA_AFERICAO,
       A.NOME_COLABORADOR::TEXT                           AS NOME_COLABORADOR_ULTIMA_AFERICAO
FROM FUNC_PNEU_GET_LISTAGEM_PNEUS_BY_STATUS(f_cod_unidade, 'ESTOQUE') AS F
         LEFT JOIN AFERICOES A ON F.CODIGO = A.COD_PNEU;
$$;

create or replace function public.func_afericao_get_restricao_by_placa(f_placa_veiculo text)
    returns TABLE
            (
                sulco_minimo_descarte    real,
                sulco_minimo_recapagem   real,
                tolerancia_calibragem    real,
                tolerancia_inspecao      real,
                periodo_afericao_sulco   integer,
                periodo_afericao_pressao integer
            )
    language sql
as
$$
SELECT ER.SULCO_MINIMO_DESCARTE,
       ER.SULCO_MINIMO_RECAPAGEM,
       ER.TOLERANCIA_CALIBRAGEM,
       ER.TOLERANCIA_INSPECAO,
       ER.PERIODO_AFERICAO_SULCO,
       ER.PERIODO_AFERICAO_PRESSAO
FROM VEICULO V
         JOIN UNIDADE U ON U.CODIGO = V.COD_UNIDADE
         JOIN EMPRESA E ON E.CODIGO = U.COD_EMPRESA
         JOIN PNEU_RESTRICAO_UNIDADE ER ON ER.COD_EMPRESA = E.CODIGO AND ER.COD_UNIDADE = U.CODIGO
WHERE V.PLACA = F_PLACA_VEICULO;
$$;

create or replace function public.func_afericao_get_restricao_by_unidade(f_cod_unidade bigint)
    returns TABLE
            (
                sulco_minimo_descarte    real,
                sulco_minimo_recapagem   real,
                tolerancia_calibragem    real,
                tolerancia_inspecao      real,
                periodo_afericao_sulco   integer,
                periodo_afericao_pressao integer
            )
    language sql
as
$$
SELECT ER.SULCO_MINIMO_DESCARTE,
       ER.SULCO_MINIMO_RECAPAGEM,
       ER.TOLERANCIA_CALIBRAGEM,
       ER.TOLERANCIA_INSPECAO,
       ER.PERIODO_AFERICAO_SULCO,
       ER.PERIODO_AFERICAO_PRESSAO
FROM UNIDADE U
         JOIN EMPRESA E ON E.CODIGO = U.COD_EMPRESA
         JOIN PNEU_RESTRICAO_UNIDADE ER ON ER.COD_EMPRESA = E.CODIGO AND U.CODIGO = ER.COD_UNIDADE
WHERE U.CODIGO = F_COD_UNIDADE;
$$;

create or replace function public.func_afericao_relatorio_qtd_afericoes_realizadas_por_dia(f_cod_unidades bigint[],
                                                                                           f_data_hoje_utc timestamp with time zone,
                                                                                           f_dias_retroativos_para_buscar bigint)
    returns TABLE
            (
                data                       date,
                data_formatada             text,
                qtd_afericao_sulco         bigint,
                qtd_afericao_pressao       bigint,
                qtd_afericao_sulco_pressao bigint
            )
    language plpgsql
as
$$
DECLARE
    DATA_INICIAL           DATE    := F_DATA_HOJE_UTC + INTERVAL '1' DAY
        - (INTERVAL '1' DAY * F_DIAS_RETROATIVOS_PARA_BUSCAR);
    DATA_FINAL             DATE    := F_DATA_HOJE_UTC + INTERVAL '1' DAY;
    AFERICAO_SULCO         VARCHAR := 'SULCO';
    AFERICAO_PRESSAO       VARCHAR := 'PRESSAO';
    AFERICAO_SULCO_PRESSAO VARCHAR := 'SULCO_PRESSAO';
BEGIN
    RETURN QUERY
        WITH DIAS AS (
            SELECT G.DAY :: DATE AS DATA
            FROM GENERATE_SERIES(DATA_INICIAL, DATA_FINAL, '1 DAY') G(DAY)
            ORDER BY DATA
        ),

             AFERICOES_DIA AS (
                 SELECT (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)) :: DATE AS DATA,
                        SUM(CASE WHEN A.TIPO_MEDICAO_COLETADA = AFERICAO_SULCO THEN 1 ELSE 0 END) QTD_AFERICAO_SULCO,
                        SUM(
                                CASE WHEN A.TIPO_MEDICAO_COLETADA = AFERICAO_PRESSAO THEN 1 ELSE 0 END) QTD_AFERICAO_PRESSAO,
                        SUM(CASE
                                WHEN A.TIPO_MEDICAO_COLETADA = AFERICAO_SULCO_PRESSAO THEN 1
                                ELSE 0 END) QTD_AFERICAO_SULCO_PRESSAO
                 FROM AFERICAO A
                 WHERE A.COD_UNIDADE = ANY (F_COD_UNIDADES)
                   AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)) :: DATE BETWEEN DATA_INICIAL AND DATA_FINAL
                 GROUP BY DATA
                 ORDER BY DATA
             )

        SELECT D.DATA                        AS DATA,
               TO_CHAR(D.DATA, 'DD/MM')      AS DATA_FORMATADA,
               AD.QTD_AFERICAO_SULCO         AS QTD_AFERICAO_SULCO,
               AD.QTD_AFERICAO_PRESSAO       AS QTD_AFERICAO_PRESSAO,
               AD.QTD_AFERICAO_SULCO_PRESSAO AS QTD_AFERICAO_SULCO_PRESSAO
        FROM DIAS D
                 LEFT JOIN AFERICOES_DIA AD ON D.DATA = AD.DATA
        ORDER BY D.DATA;
END;
$$;

create or replace function public.func_afericao_relatorio_qtd_dias_placas_vencidas(f_cod_unidades bigint[], f_data_hoje_utc timestamp with time zone)
    returns TABLE
            (
                unidade                           text,
                placa                             text,
                pode_aferir_sulco                 boolean,
                pode_aferir_pressao               boolean,
                qtd_dias_afericao_sulco_vencida   integer,
                qtd_dias_afericao_pressao_vencida integer
            )
    language plpgsql
as
$$
DECLARE
    AFERICAO_SULCO         VARCHAR := 'SULCO';
    AFERICAO_PRESSAO       VARCHAR := 'PRESSAO';
    AFERICAO_SULCO_PRESSAO VARCHAR := 'SULCO_PRESSAO';
BEGIN
    RETURN QUERY
        WITH VEICULOS_ATIVOS_UNIDADES AS (
            SELECT V.PLACA
            FROM VEICULO V
            WHERE V.COD_UNIDADE = ANY (F_COD_UNIDADES)
              AND V.STATUS_ATIVO
        ),
             -- As CTEs ULTIMA_AFERICAO_SULCO e ULTIMA_AFERICAO_PRESSAO retornam a placa de cada veículo e a quantidade de dias
             -- que a aferição de sulco e pressão, respectivamente, estão vencidas. Um número negativo será retornado caso ainda
             -- esteja com a aferição no prazo e ele indicará quantos dias faltam para vencer. Um -20, por exemplo, significa
             -- que a placa vai vencer em 20 dias.
             ULTIMA_AFERICAO_SULCO AS (
                 SELECT DISTINCT ON (A.PLACA_VEICULO) A.COD_UNIDADE,
                                                      A.PLACA_VEICULO                    AS PLACA,
                                                      DATE_PART('DAY', F_DATA_HOJE_UTC - MAX(DATA_HORA))
                                                          -
                                                      (PRU.PERIODO_AFERICAO_SULCO)       AS QTD_DIAS_ENTRE_ULTIMA_AFERICAO_SULCO_E_HOJE
                 FROM AFERICAO A
                          JOIN PNEU_RESTRICAO_UNIDADE PRU
                               ON (SELECT V.COD_UNIDADE
                                   FROM VEICULO V
                                   WHERE V.PLACA = A.PLACA_VEICULO) = PRU.COD_UNIDADE
                 WHERE A.TIPO_MEDICAO_COLETADA IN (AFERICAO_SULCO, AFERICAO_SULCO_PRESSAO)
                   AND PLACA_VEICULO = ANY (SELECT VAU.PLACA
                                            FROM VEICULOS_ATIVOS_UNIDADES VAU)
                 GROUP BY A.DATA_HORA,
                          A.COD_UNIDADE,
                          A.PLACA_VEICULO,
                          PRU.PERIODO_AFERICAO_SULCO
                 ORDER BY A.PLACA_VEICULO, A.DATA_HORA DESC
             ),
             ULTIMA_AFERICAO_PRESSAO AS (
                 SELECT DISTINCT ON (A.PLACA_VEICULO) A.COD_UNIDADE,
                                                      A.PLACA_VEICULO                      AS PLACA,
                                                      DATE_PART('DAY', F_DATA_HOJE_UTC - MAX(DATA_HORA))
                                                          -
                                                      (PRU.PERIODO_AFERICAO_PRESSAO)       AS QTD_DIAS_ENTRE_ULTIMA_AFERICAO_PRESSAO_E_HOJE
                 FROM AFERICAO A
                          JOIN PNEU_RESTRICAO_UNIDADE PRU
                               ON (SELECT V.COD_UNIDADE
                                   FROM VEICULO V
                                   WHERE V.PLACA = A.PLACA_VEICULO) = PRU.COD_UNIDADE
                 WHERE A.COD_UNIDADE = ANY (F_COD_UNIDADES)
                   AND A.TIPO_MEDICAO_COLETADA IN (AFERICAO_PRESSAO, AFERICAO_SULCO_PRESSAO)
                   AND PLACA_VEICULO = ANY (SELECT VAU.PLACA
                                            FROM VEICULOS_ATIVOS_UNIDADES VAU)
                 GROUP BY A.DATA_HORA,
                          A.COD_UNIDADE,
                          A.PLACA_VEICULO,
                          PRU.PERIODO_AFERICAO_PRESSAO
                 ORDER BY A.PLACA_VEICULO, A.DATA_HORA DESC
             ),

             PRE_SELECT AS (
                 SELECT U.NOME                                            AS NOME_UNIDADE,
                        V.PLACA                                           AS PLACA_VEICULO,
                        COALESCE((
                                     SELECT (FA.PODE_AFERIR_SULCO OR FA.PODE_AFERIR_SULCO_PRESSAO)
                                     FROM FUNC_AFERICAO_GET_CONFIG_TIPO_AFERICAO_VEICULO(V.COD_UNIDADE) FA
                                     WHERE FA.COD_TIPO_VEICULO = V.COD_TIPO), FALSE)
                                                                          AS PODE_AFERIR_SULCO,
                        COALESCE((
                                     SELECT (FA.PODE_AFERIR_PRESSAO OR FA.PODE_AFERIR_SULCO_PRESSAO)
                                     FROM FUNC_AFERICAO_GET_CONFIG_TIPO_AFERICAO_VEICULO(V.COD_UNIDADE) FA
                                     WHERE FA.COD_TIPO_VEICULO = V.COD_TIPO), FALSE)
                                                                          AS PODE_AFERIR_PRESSAO,
                        -- Por conta do filtro no WHERE, agora não é mais a diferença de dias e sim somente as vencidas (ou ainda
                        -- nunca aferidas).
                        UAS.QTD_DIAS_ENTRE_ULTIMA_AFERICAO_SULCO_E_HOJE   AS QTD_DIAS_AFERICAO_SULCO_VENCIDA,
                        UAP.QTD_DIAS_ENTRE_ULTIMA_AFERICAO_PRESSAO_E_HOJE AS QTD_DIAS_AFERICAO_PRESSAO_VENCIDA
                 FROM UNIDADE U
                          JOIN VEICULO V
                               ON V.COD_UNIDADE = U.CODIGO
                          LEFT JOIN ULTIMA_AFERICAO_SULCO UAS
                                    ON UAS.PLACA = V.PLACA
                          LEFT JOIN ULTIMA_AFERICAO_PRESSAO UAP
                                    ON UAP.PLACA = V.PLACA
                 WHERE
                     -- Se algum dos dois tipos de aferição estiver vencido, retornamos a linha.
                     (UAS.QTD_DIAS_ENTRE_ULTIMA_AFERICAO_SULCO_E_HOJE > 0 OR
                      UAP.QTD_DIAS_ENTRE_ULTIMA_AFERICAO_PRESSAO_E_HOJE > 0)
                 GROUP BY U.NOME,
                          V.PLACA,
                          V.COD_TIPO,
                          V.COD_UNIDADE,
                          UAS.QTD_DIAS_ENTRE_ULTIMA_AFERICAO_SULCO_E_HOJE,
                          UAP.QTD_DIAS_ENTRE_ULTIMA_AFERICAO_PRESSAO_E_HOJE
             )
        SELECT PS.NOME_UNIDADE :: TEXT                         AS NOME_UNIDADE,
               PS.PLACA_VEICULO :: TEXT                        AS PLACA_VEICULO,
               PS.PODE_AFERIR_SULCO                            AS PODE_AFERIR_SULCO,
               PS.PODE_AFERIR_PRESSAO                          AS PODE_AFERIR_PRESSAO,
               PS.QTD_DIAS_AFERICAO_SULCO_VENCIDA :: INTEGER   AS QTD_DIAS_AFERICAO_SULCO_VENCIDA,
               PS.QTD_DIAS_AFERICAO_PRESSAO_VENCIDA :: INTEGER AS QTD_DIAS_AFERICAO_PRESSAO_VENCIDA
        FROM PRE_SELECT PS
             -- Para a placa ser exibida, ao menos um dos tipos de aferições, de sulco ou pressão, devem estar habilitadas.
        WHERE PS.PODE_AFERIR_SULCO
           OR PS.PODE_AFERIR_PRESSAO
        ORDER BY PS.QTD_DIAS_AFERICAO_SULCO_VENCIDA DESC,
                 PS.QTD_DIAS_AFERICAO_PRESSAO_VENCIDA DESC;
END;
$$;

create or replace function public.func_cargos_copia_permissoes_cargos_entre_unidades(f_cod_unidade_origem_copia_permissoes_cargos bigint,
                                                                                     f_cod_unidades_destino_permissoes_cargos bigint[],
                                                                                     OUT aviso_permissoes_copiadas text) returns text
    language plpgsql
as
$$
BEGIN
    -- REMOVE UNIDADES DUPLICADAS DO ARRAY DE DESTINO.
    F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS := ARRAY_DISTINCT(F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS);

    -- VERIFICA SE A UNIDADE DE ORIGEM NÃO ESTÁ ENTRE AS DE DESTINO.
    IF F_COD_UNIDADE_ORIGEM_COPIA_PERMISSOES_CARGOS = ANY (F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS)
    THEN
        RAISE EXCEPTION 'O código da unidade de origem não pode constar nas unidades de destino!';
    END IF;

    -- VERIFICA SE TODAS AS UNIDADES DE DESTINO PERTENCEM A MESMA EMPRESA.
    IF (SELECT COUNT(DISTINCT U.COD_EMPRESA)
        FROM UNIDADE U
        WHERE U.CODIGO = ANY (F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS)) > 1
    THEN
        RAISE EXCEPTION 'Só é possível copiar as permissões para unidades da mesma empresa!';
    END IF;

    -- VERIFICA SE A EMPRESA DA UNIDADE DE ORIGEM É A MESMA DAS UNIDADES DE DESTINO.
    IF (SELECT DISTINCT U.COD_EMPRESA
        FROM UNIDADE U
        WHERE U.CODIGO = ANY (F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS)) != (SELECT U.COD_EMPRESA
                                                                             FROM UNIDADE U
                                                                             WHERE U.CODIGO =
                                                                                   F_COD_UNIDADE_ORIGEM_COPIA_PERMISSOES_CARGOS)
    THEN
        RAISE EXCEPTION 'A empresa da unidade de origem precisa ser a mesma das unidades de destino!';
    END IF;

    -- DELETA TODOS AS PERMISSÕES DOS CARGOS DAS UNIDADES DE DESTINO.
    DELETE
    FROM CARGO_FUNCAO_PROLOG_V11 CFP
    WHERE CFP.COD_UNIDADE = ANY (F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS);

    -- COPIA AS PERMISSÕES DOS CARGOS DA UNIDADE DE ORIGEM PARA TODAS AS DE DESTINO.
    INSERT INTO CARGO_FUNCAO_PROLOG_V11
    (COD_UNIDADE,
     COD_FUNCAO_COLABORADOR,
     COD_FUNCAO_PROLOG,
     COD_PILAR_PROLOG)
    SELECT UNNEST(ARRAY [F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS]) AS COD_UNIDADE,
           COD_FUNCAO_COLABORADOR,
           COD_FUNCAO_PROLOG,
           COD_PILAR_PROLOG
    FROM CARGO_FUNCAO_PROLOG_V11
    WHERE COD_UNIDADE = F_COD_UNIDADE_ORIGEM_COPIA_PERMISSOES_CARGOS
    ORDER BY COD_UNIDADE, COD_FUNCAO_COLABORADOR;

    SELECT 'PERMISSÕES COPIADAS COM SUCESSO DA UNIDADE '
               || F_COD_UNIDADE_ORIGEM_COPIA_PERMISSOES_CARGOS
               || ' PARA A(S) UNIDADE(S) '
               || ARRAY_TO_STRING(F_COD_UNIDADES_DESTINO_PERMISSOES_CARGOS, ', ')
    INTO AVISO_PERMISSOES_COPIADAS;
END;
$$;

create or replace function public.func_cargos_deleta_cargo(f_cod_empresa bigint, f_cod_cargo bigint, f_token text) returns bigint
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_COLABORADOR_UPDATE BIGINT := (SELECT COD_COLABORADOR
                                        FROM TOKEN_AUTENTICACAO
                                        WHERE TOKEN = F_TOKEN);
    QTD_LINHAS_ATUALIZADAS   BIGINT;
BEGIN
    IF F_COD_COLABORADOR_UPDATE IS NULL OR F_COD_COLABORADOR_UPDATE <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível validar sua sessão, por favor, faça login novamente');
    END IF;

    IF ((SELECT COUNT(CODIGO)
         FROM FUNCAO
         WHERE COD_EMPRESA = F_COD_EMPRESA
           AND CODIGO = F_COD_CARGO) <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Erro ao deletar, possivelmente este cargo já foi deletado');
    END IF;

    IF ((SELECT COUNT(CODIGO)
         FROM COLABORADOR
         WHERE COD_EMPRESA = F_COD_EMPRESA
           AND COD_FUNCAO = F_COD_CARGO) > 0)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não é possível deletar pois existem colaboradores vinculados a este cargo');
    END IF;

    -- Deleta cargo.
    UPDATE FUNCAO_DATA
    SET DELETADO               = TRUE,
        DATA_HORA_DELETADO     = NOW(),
        DATA_HORA_UPDATE       = NOW(),
        PG_USERNAME_DELECAO    = SESSION_USER,
        COD_COLABORADOR_UPDATE = F_COD_COLABORADOR_UPDATE
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND CODIGO = F_COD_CARGO;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR('Erro ao deletar o cargo, tente novamente');
    END IF;

    RETURN QTD_LINHAS_ATUALIZADAS;
END;
$$;

create or replace function public.func_cargos_edita_cargo(f_cod_empresa bigint, f_cod_cargo bigint, f_nome_cargo text,
                                                          f_token text) returns bigint
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_COLABORADOR_UPDATE BIGINT := (SELECT COD_COLABORADOR
                                        FROM TOKEN_AUTENTICACAO
                                        WHERE TOKEN = F_TOKEN);
    QTD_LINHAS_ATUALIZADAS   BIGINT;
BEGIN
    IF F_COD_COLABORADOR_UPDATE IS NULL OR F_COD_COLABORADOR_UPDATE <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível validar sua sessão, por favor, faça login novamente');
    END IF;

    IF ((SELECT COUNT(CODIGO)
         FROM FUNCAO
         WHERE COD_EMPRESA = F_COD_EMPRESA
           AND CODIGO = F_COD_CARGO) <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Erro ao editar, possivelmente este cargo já foi deletado');
    END IF;

    -- Edita o cargo.
    UPDATE FUNCAO_DATA
    SET NOME                   = TRIM_AND_REMOVE_EXTRA_SPACES(F_NOME_CARGO),
        DATA_HORA_UPDATE       = NOW(),
        COD_COLABORADOR_UPDATE = F_COD_COLABORADOR_UPDATE
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND CODIGO = F_COD_CARGO;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Erro ao editar o cargo, tente novamente');
    END IF;
    --
    --
    RETURN QTD_LINHAS_ATUALIZADAS;
END;
$$;

create or replace function public.func_cargos_get_cargo(f_cod_empresa bigint, f_cod_cargo bigint)
    returns TABLE
            (
                cod_empresa bigint,
                cod_cargo   bigint,
                nome_cargo  text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT F.COD_EMPRESA  AS COD_EMPRESA,
               F.CODIGO       AS COD_CARGO,
               F.NOME :: TEXT AS NOME_CARGO
        FROM FUNCAO F
        WHERE F.COD_EMPRESA = F_COD_EMPRESA
          AND F.CODIGO = F_COD_CARGO;
END;
$$;

create or replace function public.func_cargos_get_cargos_em_uso(f_cod_unidade bigint)
    returns TABLE
            (
                cod_cargo                    bigint,
                nome_cargo                   text,
                qtd_colaboradores_vinculados bigint,
                qtd_permissoes_vinculadas    bigint
            )
    language plpgsql
as
$$
DECLARE
    PILARES_LIBERADOS_UNIDADE BIGINT[] := (SELECT ARRAY_AGG(UPP.COD_PILAR)
                                           FROM UNIDADE_PILAR_PROLOG UPP
                                           WHERE UPP.COD_UNIDADE = F_COD_UNIDADE);
BEGIN
    RETURN QUERY
        WITH CARGOS_EM_USO AS (
            SELECT DISTINCT COD_FUNCAO
            FROM COLABORADOR C
            WHERE C.COD_UNIDADE = F_COD_UNIDADE
        )

        SELECT F.CODIGO                                                        AS COD_CARGO,
               F.NOME :: TEXT                                                  AS NOME_CARGO,
               (SELECT COUNT(*)
                FROM COLABORADOR C
                WHERE C.COD_FUNCAO = F.CODIGO
                  AND C.COD_UNIDADE = F_COD_UNIDADE)                           AS QTD_COLABORADORES_VINCULADOS,
               -- Se não tivesse esse FILTER, cargos que não possuem nenhuma permissão vinculada retornariam 1.
               COUNT(*)
               FILTER (WHERE CFP.COD_UNIDADE IS NOT NULL
                   -- Consideramos apenas as permissões de pilares liberados para a unidade.
                   AND CFP.COD_PILAR_PROLOG = ANY (PILARES_LIBERADOS_UNIDADE)) AS QTD_PERMISSOES_VINCULADAS
        FROM FUNCAO F
                 LEFT JOIN CARGO_FUNCAO_PROLOG_V11 CFP
                           ON F.CODIGO = CFP.COD_FUNCAO_COLABORADOR
                               AND CFP.COD_UNIDADE = F_COD_UNIDADE
             -- Não podemos simplesmente filtrar pelo código da unidade presente na tabela CARGO_FUNCAO_PROLOG_V11, pois desse
             -- modo iríamos remover do retorno cargos usados mas sem permissões vinculadas. Por isso utilizamos esse modo de
             -- filtragem com a CTE criada acima.
        WHERE F.CODIGO IN (SELECT *
                           FROM CARGOS_EM_USO)
        GROUP BY F.CODIGO, F.NOME
        ORDER BY F.NOME ASC;
END;
$$;

create or replace function public.func_cargos_get_cargos_nao_utilizados(f_cod_unidade bigint)
    returns TABLE
            (
                cod_cargo                 bigint,
                nome_cargo                text,
                qtd_permissoes_vinculadas bigint
            )
    language plpgsql
as
$$
DECLARE
    PILARES_LIBERADOS_UNIDADE BIGINT[] := (SELECT ARRAY_AGG(UPP.COD_PILAR)
                                           FROM UNIDADE_PILAR_PROLOG UPP
                                           WHERE UPP.COD_UNIDADE = F_COD_UNIDADE);
BEGIN
    RETURN QUERY
        WITH CARGOS_EM_USO AS (
            SELECT DISTINCT COD_FUNCAO
            FROM COLABORADOR C
            WHERE C.COD_UNIDADE = F_COD_UNIDADE
        )

        SELECT F.CODIGO                                                        AS COD_CARGO,
               F.NOME :: TEXT                                                  AS NOME_CARGO,
               COUNT(*)
               FILTER (WHERE CFP.COD_UNIDADE IS NOT NULL
                   -- Consideramos apenas as permissões de pilares liberados para a unidade.
                   AND CFP.COD_PILAR_PROLOG = ANY (PILARES_LIBERADOS_UNIDADE)) AS QTD_PERMISSOES_VINCULADAS
        FROM FUNCAO F
                 LEFT JOIN CARGO_FUNCAO_PROLOG_V11 CFP
                           ON F.CODIGO = CFP.COD_FUNCAO_COLABORADOR
                               AND CFP.COD_UNIDADE = F_COD_UNIDADE
             -- Para buscar os cargos não utilizados, adotamos a lógica de buscar todos os da empresa e depois remover os que
             -- tem colaboradores vinculados, isso é feito nas duas condições abaixo do WHERE.
        WHERE F.COD_EMPRESA = (SELECT U.COD_EMPRESA
                               FROM UNIDADE U
                               WHERE U.CODIGO = F_COD_UNIDADE)
          AND F.CODIGO NOT IN (SELECT *
                               FROM CARGOS_EM_USO)
        GROUP BY F.CODIGO, F.NOME
        ORDER BY F.NOME ASC;
END;
$$;

create or replace function public.func_cargos_get_permissoes_detalhadas(f_cod_unidade bigint, f_cod_cargo bigint)
    returns TABLE
            (
                cod_cargo           bigint,
                cod_unidade_cargo   bigint,
                nome_cargo          text,
                cod_pilar           bigint,
                nome_pilar          character varying,
                cod_funcionalidade  smallint,
                nome_funcionalidade character varying,
                cod_permissao       bigint,
                nome_permissao      character varying,
                impacto_permissao   prolog_impacto_permissao_type,
                descricao_permissao text,
                permissao_liberada  boolean
            )
    language plpgsql
as
$$
DECLARE
    PILARES_LIBERADOS_UNIDADE BIGINT[] := (SELECT ARRAY_AGG(UPP.COD_PILAR)
                                           FROM UNIDADE_PILAR_PROLOG UPP
                                           WHERE UPP.COD_UNIDADE = F_COD_UNIDADE);
BEGIN
    RETURN QUERY
        WITH PERMISSOES_CARGO_UNIDADE AS (
            SELECT CFP.COD_FUNCAO_COLABORADOR AS COD_CARGO,
                   CFP.COD_UNIDADE            AS COD_UNIDADE_CARGO,
                   CFP.COD_FUNCAO_PROLOG      AS COD_FUNCAO_PROLOG,
                   CFP.COD_PILAR_PROLOG       AS COD_PILAR_PROLOG
            FROM CARGO_FUNCAO_PROLOG_V11 CFP
            WHERE CFP.COD_UNIDADE = F_COD_UNIDADE
              AND CFP.COD_FUNCAO_COLABORADOR = F_COD_CARGO
        )

        SELECT F_COD_CARGO                       AS COD_CARGO,
               F_COD_UNIDADE                     AS COD_UNIDADE_CARGO,
               F.NOME :: TEXT                    AS NOME_CARGO,
               FP.COD_PILAR                      AS COD_PILAR,
               PP.PILAR                          AS NOME_PILAR,
               FP.COD_AGRUPAMENTO                AS COD_FUNCIONALIDADE,
               FPA.NOME                          AS NOME_FUNCIONALIDADE,
               FP.CODIGO                         AS COD_PERMISSAO,
               FP.FUNCAO                         AS NOME_PERMISSAO,
               FP.IMPACTO                        AS IMPACTO_PERMISSAO,
               FP.DESCRICAO                      AS DESCRICAO_PERMISSAO,
               PCU.COD_UNIDADE_CARGO IS NOT NULL AS PERMISSAO_LIBERADA
        FROM PILAR_PROLOG PP
                 JOIN FUNCAO_PROLOG_V11 FP ON FP.COD_PILAR = PP.CODIGO
                 JOIN UNIDADE_PILAR_PROLOG UPP ON UPP.COD_PILAR = PP.CODIGO
                 JOIN FUNCAO_PROLOG_AGRUPAMENTO FPA ON FPA.CODIGO = FP.COD_AGRUPAMENTO
                 JOIN FUNCAO F ON F.CODIGO = F_COD_CARGO
                 LEFT JOIN PERMISSOES_CARGO_UNIDADE PCU ON PCU.COD_FUNCAO_PROLOG = FP.CODIGO
        WHERE UPP.COD_UNIDADE = F_COD_UNIDADE
          AND FP.COD_PILAR = ANY (PILARES_LIBERADOS_UNIDADE)
        ORDER BY PP.PILAR, FP.COD_AGRUPAMENTO, FP.IMPACTO DESC;
END;
$$;

create or replace function public.func_cargos_get_todos_cargos_empresa(f_cod_empresa bigint)
    returns TABLE
            (
                cod_cargo                    bigint,
                nome_cargo                   text,
                qtd_colaboradores_vinculados bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT DISTINCT F.CODIGO                              AS COD_CARGO,
                        F.NOME :: TEXT                        AS NOME_CARGO,
                        (SELECT COUNT(*)
                         FROM COLABORADOR C
                         WHERE C.COD_FUNCAO = F.CODIGO
                           AND C.COD_EMPRESA = F_COD_EMPRESA) AS QTD_COLABORADORES_VINCULADOS
        FROM FUNCAO F
        WHERE F.COD_EMPRESA = F_COD_EMPRESA
        ORDER BY 2 ASC;
END;
$$;

create or replace function public.func_cargos_get_todos_cargos_unidade(f_cod_unidade bigint)
    returns TABLE
            (
                cod_cargo  bigint,
                nome_cargo text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT DISTINCT F.CODIGO       AS COD_CARGO,
                        F.NOME :: TEXT AS NOME_CARGO
        FROM FUNCAO F
                 JOIN UNIDADE U ON U.COD_EMPRESA = F.COD_EMPRESA
        WHERE U.CODIGO = F_COD_UNIDADE
        ORDER BY 2 ASC;
END;
$$;

create or replace function public.func_cargos_insere_cargo(f_cod_empresa bigint, f_nome_cargo text, f_token text) returns bigint
    language plpgsql
as
$$
DECLARE
    F_COD_COLABORADOR_UPDATE BIGINT := (SELECT COD_COLABORADOR
                                        FROM TOKEN_AUTENTICACAO
                                        WHERE TOKEN = F_TOKEN);
    COD_CARGO_INSERIDO       BIGINT;
BEGIN
    IF F_COD_COLABORADOR_UPDATE IS NULL OR F_COD_COLABORADOR_UPDATE <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível validar sua sessão, por favor, faça login novamente');
    END IF;

    INSERT INTO FUNCAO_DATA (COD_EMPRESA, NOME, COD_COLABORADOR_UPDATE)
    VALUES (F_COD_EMPRESA, TRIM_AND_REMOVE_EXTRA_SPACES(F_NOME_CARGO), F_COD_COLABORADOR_UPDATE) RETURNING CODIGO
        INTO COD_CARGO_INSERIDO;

    -- Verificamos se o insert funcionou.
    IF COD_CARGO_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível inserir o cargo, tente novamente');
    END IF;

    RETURN COD_CARGO_INSERIDO;
END;
$$;

create or replace function suporte.func_checklist_altera_km_coletado_checklist_realizado(f_cod_unidade bigint,
                                                                                         f_placa text,
                                                                                         f_cod_checklist_realizado bigint,
                                                                                         f_novo_km bigint,
                                                                                         OUT aviso_km_checklist_alterado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);
    PERFORM FUNC_GARANTE_VEICULO_EXISTE(F_COD_UNIDADE, F_PLACA);
    PERFORM FUNC_GARANTE_NOVO_KM_MENOR_QUE_ATUAL_VEICULO(F_COD_UNIDADE, F_PLACA, F_NOVO_KM);

    -- Verifica se o checklist existe.
    IF NOT EXISTS(SELECT CD.CODIGO
                  FROM CHECKLIST CD
                  WHERE CD.CODIGO = F_COD_CHECKLIST_REALIZADO
                    AND CD.COD_UNIDADE = F_COD_UNIDADE
                    AND CD.PLACA_VEICULO = F_PLACA)
    THEN
        RAISE EXCEPTION 'Não foi possível encontrar o checklist realizado com estes parâmetros: Unidade %, Placa %,
                     Código da realização do checklist %', F_COD_UNIDADE, F_PLACA, F_COD_CHECKLIST_REALIZADO;
    END IF;

    UPDATE CHECKLIST_DATA
    SET KM_VEICULO = F_NOVO_KM
    WHERE CODIGO = F_COD_CHECKLIST_REALIZADO
      AND COD_UNIDADE = F_COD_UNIDADE
      AND PLACA_VEICULO = F_PLACA;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao atualizar o km do checklist realizado com estes parâemtros: Unidade %, Placa %,
                     Código da realização do checklist %', F_COD_UNIDADE, F_PLACA, F_COD_CHECKLIST_REALIZADO;
    END IF;

    SELECT 'O KM DO VEÍCULO NO CHECKLIST REALIZADO FOI ALTERADO COM SUCESSO, UNIDADE: '
               || F_COD_UNIDADE
               || ', PLACA: '
               || F_PLACA
               || ', CÓDIGO DO CHECKLIST REALIZADO: '
               || F_COD_CHECKLIST_REALIZADO
    INTO AVISO_KM_CHECKLIST_ALTERADO;
END;
$$;

create or replace function suporte.func_checklist_deleta_checklist_e_os(f_cod_unidade bigint, f_cod_checklist bigint,
                                                                        f_placa text, f_cpf_colaborador bigint,
                                                                        OUT aviso_checklist_deletado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN
    -- Deleta checklist.
    UPDATE CHECKLIST_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = F_COD_CHECKLIST
      AND COD_UNIDADE = F_COD_UNIDADE
      AND PLACA_VEICULO = F_PLACA
      AND CPF_COLABORADOR = F_CPF_COLABORADOR;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao deletar o checklist de código: % e Unidade: %', F_COD_CHECKLIST, F_COD_UNIDADE;
    END IF;

    -- Deleta O.S.
    UPDATE CHECKLIST_ORDEM_SERVICO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_CHECKLIST = F_COD_CHECKLIST
      AND COD_UNIDADE = F_COD_UNIDADE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF ((QTD_LINHAS_ATUALIZADAS <= 0) AND ((SELECT COUNT(*)
                                            FROM CHECKLIST_ORDEM_SERVICO_DATA COSD
                                            WHERE COSD.COD_CHECKLIST = F_COD_CHECKLIST
                                              AND COSD.COD_UNIDADE = F_COD_UNIDADE) > 0))
    THEN
        RAISE EXCEPTION 'Erro ao deletar O.S. do checklist de código: % e Unidade: %', F_COD_CHECKLIST, F_COD_UNIDADE;
    END IF;

    -- Deleta itens da O.S.
    UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND COD_OS =
          (SELECT COSD.CODIGO
           FROM CHECKLIST_ORDEM_SERVICO_DATA COSD
           WHERE COSD.COD_CHECKLIST = F_COD_CHECKLIST
             AND COSD.COD_UNIDADE = F_COD_UNIDADE);

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    -- Se tem O.S. então também deverá ter itens, por isso a verificação serve.
    IF ((QTD_LINHAS_ATUALIZADAS <= 0) AND ((SELECT COUNT(*)
                                            FROM CHECKLIST_ORDEM_SERVICO_DATA COS
                                            WHERE COS.COD_CHECKLIST = F_COD_CHECKLIST
                                              AND COS.COD_UNIDADE = F_COD_UNIDADE) > 0))
    THEN
        RAISE EXCEPTION 'Erro ao deletar itens da O.S. do checklist de código: % e Unidade: %', F_COD_CHECKLIST,
            F_COD_UNIDADE;
    END IF;

    SELECT 'CHECKLIST DELETADO: '
               || F_COD_CHECKLIST
               || ', CÓDIGO DA UNIDADE: '
               || F_COD_UNIDADE
    INTO AVISO_CHECKLIST_DELETADO;
END;
$$;

create or replace function suporte.func_checklist_deleta_modelo_checklist(f_cod_unidade bigint,
                                                                          f_cod_modelo_checklist bigint,
                                                                          f_deletar_checklists_realizados_desse_modelo boolean DEFAULT false,
                                                                          OUT aviso_modelo_checklist_deletado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
    CHECKLIST              RECORD;
BEGIN

    IF F_DELETAR_CHECKLISTS_REALIZADOS_DESSE_MODELO
    THEN
        FOR CHECKLIST IN SELECT C.COD_UNIDADE,
                                C.CODIGO
                         FROM CHECKLIST C
                         WHERE C.COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
                           AND C.COD_UNIDADE = F_COD_UNIDADE
            LOOP
                PERFORM FUNC_CHECKLIST_DELETA_CHECKLIST_E_OS(F_COD_UNIDADE := CHECKLIST.COD_UNIDADE,
                                                             F_COD_CHECKLIST := CHECKLIST.CODIGO);
            END LOOP;
    END IF;

    -- Deleta modelo de checklist.
    UPDATE CHECKLIST_MODELO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = F_COD_MODELO_CHECKLIST
      AND COD_UNIDADE = F_COD_UNIDADE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao deletar o modelo de checklist de código: % e Unidade: %',
            F_COD_MODELO_CHECKLIST, F_COD_UNIDADE;
    END IF;

    -- Deleta pergundas do modelo de checklist.
    UPDATE CHECKLIST_PERGUNTAS_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
      AND COD_UNIDADE = F_COD_UNIDADE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao deletar as perguntas do modelo de checklist de código: % e Unidade: %',
            F_COD_MODELO_CHECKLIST, F_COD_UNIDADE;
    END IF;

    -- Deleta as alternativas das pergundas do modelo de checklist.
    UPDATE CHECKLIST_ALTERNATIVA_PERGUNTA_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
      AND COD_UNIDADE = F_COD_UNIDADE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao deletar as alternativas do modelo de checklist de código: % e Unidade: %',
            F_COD_MODELO_CHECKLIST, F_COD_UNIDADE;
    END IF;

    -- As únicas coisas que deletamos de fato são os vínculos de cargos e tipos de veículos, assim um modelo marcado
    -- como "deletado" não fica com vínculos que podem bloquear outras operações do BD.
    DELETE
    FROM CHECKLIST_MODELO_FUNCAO
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST;
    DELETE
    FROM CHECKLIST_MODELO_VEICULO_TIPO
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND COD_MODELO = F_COD_MODELO_CHECKLIST;

    SELECT 'MODELO DE CHECKLIST DELETADO: '
               || F_COD_MODELO_CHECKLIST
               || ', CÓDIGO DA UNIDADE: '
               || F_COD_UNIDADE
               || F_IF(F_DELETAR_CHECKLISTS_REALIZADOS_DESSE_MODELO,
                       '. OS CHECKLISTS REALIZADOS DESSE MODELO TAMBÉM FORAM DELETADOS.' :: TEXT,
                       '. OS CHECKLISTS REALIZADOS DESSE MODELO NÃO FORAM DELETADOS.' :: TEXT)
    INTO AVISO_MODELO_CHECKLIST_DELETADO;
END;
$$;

create or replace function public.func_checklist_get_cod_checklist_duplicado(f_cod_unidade_checklist bigint,
                                                                             f_cod_modelo_checklist bigint,
                                                                             f_data_hora_realizacao timestamp with time zone,
                                                                             f_cod_colaborador bigint,
                                                                             f_placa_veiculo text,
                                                                             f_tipo_checklist character,
                                                                             f_km_coletado bigint,
                                                                             f_tempo_realizacao bigint,
                                                                             f_fonte_data_hora_realizacao text,
                                                                             f_versao_app_momento_realizacao integer,
                                                                             f_device_id text, f_device_imei text,
                                                                             f_device_uptime_realizacao_millis bigint)
    returns TABLE
            (
                checklist_ja_existe boolean,
                cod_checklist       bigint
            )
    language sql
as
$$
WITH CTE AS (
    -- O duplo select serve para retornar null caso o código não seja encontrado.
    SELECT (SELECT C.CODIGO AS COD_CHECKLIST
            FROM CHECKLIST C
            WHERE C.COD_UNIDADE = F_COD_UNIDADE_CHECKLIST
              AND C.COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
              AND C.DATA_HORA = F_DATA_HORA_REALIZACAO
              AND C.CPF_COLABORADOR = (SELECT CO.CPF
                                       FROM COLABORADOR CO
                                       WHERE CO.CODIGO = F_COD_COLABORADOR)
              AND C.PLACA_VEICULO = F_PLACA_VEICULO
              AND C.TIPO = F_TIPO_CHECKLIST
              AND C.KM_VEICULO = F_KM_COLETADO
              AND C.TEMPO_REALIZACAO = F_TEMPO_REALIZACAO
              AND C.FONTE_DATA_HORA_REALIZACAO = F_FONTE_DATA_HORA_REALIZACAO
              AND C.VERSAO_APP_MOMENTO_REALIZACAO = F_VERSAO_APP_MOMENTO_REALIZACAO
              AND C.DEVICE_ID = F_DEVICE_ID
              AND C.DEVICE_IMEI = F_DEVICE_IMEI
              AND C.DEVICE_UPTIME_REALIZACAO_MILLIS = F_DEVICE_UPTIME_REALIZACAO_MILLIS) AS COD_CHECKLIST
)

SELECT CTE.COD_CHECKLIST IS NOT NULL,
       CTE.COD_CHECKLIST
FROM CTE;
$$;

create or replace function public.func_checklist_get_farol_checklist(f_cod_unidade bigint, f_data_inicial date,
                                                                     f_data_final date,
                                                                     f_itens_criticos_retroativos boolean,
                                                                     f_tz_unidade text)
    returns TABLE
            (
                data                               date,
                placa                              character varying,
                cod_checklist_saida                bigint,
                data_hora_ultimo_checklist_saida   timestamp without time zone,
                cod_checklist_modelo_saida         bigint,
                nome_colaborador_checklist_saida   character varying,
                cod_checklist_retorno              bigint,
                data_hora_ultimo_checklist_retorno timestamp without time zone,
                cod_checklist_modelo_retorno       bigint,
                nome_colaborador_checklist_retorno character varying,
                codigo_pergunta                    bigint,
                descricao_pergunta                 text,
                descricao_alternativa              text,
                alternativa_tipo_outros            boolean,
                descricao_alternativa_tipo_outros  text,
                codigo_item_critico                bigint,
                data_hora_apontamento_item_critico timestamp without time zone
            )
    language plpgsql
as
$$
DECLARE
    CHECKLIST_TIPO_SAIDA         CHAR := 'S';
    CHECKLIST_TIPO_RETORNO       CHAR := 'R';
    CHECKLIST_PRIORIDADE_CRITICA TEXT := 'CRITICA';
    ORDEM_SERVICO_ABERTA         CHAR := 'A';
    ORDEM_SERVICO_ITEM_PENDENDTE CHAR := 'P';
BEGIN
    RETURN QUERY
        WITH ULTIMOS_CHECKLISTS_VEICULOS AS (
            SELECT INNERTABLE.DATA,
                   INNERTABLE.PLACA,
                   INNERTABLE.COD_CHECKLIST_SAIDA,
                   INNERTABLE.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                   CS.COD_CHECKLIST_MODELO AS COD_CHECKLIST_MODELO_SAIDA,
                   COS.NOME                AS NOME_COLABORADOR_CHECKLIST_SAIDA,
                   INNERTABLE.COD_CHECKLIST_RETORNO,
                   INNERTABLE.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
                   CR.COD_CHECKLIST_MODELO AS COD_CHECKLIST_MODELO_RETORNO,
                   COR.NOME                AS NOME_COLABORADOR_CHECKLIST_RETORNO
            FROM (SELECT G.DAY :: DATE                                               AS DATA,
                         V.PLACA,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_SAIDA
                                     THEN C.CODIGO END)                              AS COD_CHECKLIST_SAIDA,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_SAIDA
                                     THEN C.DATA_HORA END) AT TIME ZONE
                         F_TZ_UNIDADE                                                AS DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_RETORNO
                                     THEN C.CODIGO END)                              AS COD_CHECKLIST_RETORNO,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_RETORNO
                                     THEN C.DATA_HORA END) AT TIME ZONE
                         F_TZ_UNIDADE                                                AS DATA_HORA_ULTIMO_CHECKLIST_RETORNO
                  FROM VEICULO V
                           CROSS JOIN GENERATE_SERIES(F_DATA_INICIAL, F_DATA_FINAL, '1 DAY') G(DAY)
                           LEFT JOIN CHECKLIST C
                                     ON C.PLACA_VEICULO = V.PLACA AND
                                        G.DAY :: DATE = (C.DATA_HORA AT TIME ZONE F_TZ_UNIDADE) :: DATE
                  WHERE V.COD_UNIDADE = F_COD_UNIDADE
                    AND V.STATUS_ATIVO = TRUE
                  GROUP BY 1, 2
                  ORDER BY 1, 2) AS INNERTABLE
                     LEFT JOIN CHECKLIST CS ON CS.CODIGO = INNERTABLE.COD_CHECKLIST_SAIDA
                     LEFT JOIN CHECKLIST CR ON CR.CODIGO = INNERTABLE.COD_CHECKLIST_RETORNO
                     LEFT JOIN COLABORADOR COS ON COS.CPF = CS.CPF_COLABORADOR
                     LEFT JOIN COLABORADOR COR ON COR.CPF = CR.CPF_COLABORADOR
            ORDER BY INNERTABLE.DATA, INNERTABLE.PLACA
        ),

             ITENS_PRIORIDADE AS (
                 SELECT COSI.*,
                        CAP.PRIORIDADE
                 FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                               ON CAP.CODIGO = COSI.COD_ALTERNATIVA
                          JOIN CHECKLIST_PERGUNTAS CP
                               ON CP.CODIGO = CAP.COD_PERGUNTA
                 WHERE COSI.COD_UNIDADE = F_COD_UNIDADE
                   AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                   AND COSI.STATUS_RESOLUCAO = ORDEM_SERVICO_ITEM_PENDENDTE
             )

        SELECT Q.DATA,
               Q.PLACA,
               Q.COD_CHECKLIST_SAIDA,
               Q.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
               Q.COD_CHECKLIST_MODELO_SAIDA,
               Q.NOME_COLABORADOR_CHECKLIST_SAIDA,
               Q.COD_CHECKLIST_RETORNO,
               Q.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
               Q.COD_CHECKLIST_MODELO_RETORNO,
               Q.NOME_COLABORADOR_CHECKLIST_RETORNO,
               Q.CODIGO_PERGUNTA,
               Q.DESCRICAO_PERGUNTA,
               Q.DESCRICAO_ALTERNATIVA,
               CASE
                   WHEN Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_SAIDA
                       OR Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO
                       THEN TRUE
                   ELSE FALSE
                   END AS ALTERNATIVA_TIPO_OUTROS,
               CASE
                   WHEN Q.ITEM_CRITICO_DE_SAIDA_TIPO_OUTROS
                       THEN (SELECT CR.RESPOSTA
                             FROM CHECKLIST_RESPOSTAS CR
                             WHERE CR.COD_CHECKLIST = Q.COD_CHECKLIST_SAIDA
                               AND CR.COD_ALTERNATIVA = Q.CODIGO_ALTERNATIVA)
                   WHEN Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO
                       THEN (SELECT CR.RESPOSTA
                             FROM CHECKLIST_RESPOSTAS CR
                             WHERE CR.COD_CHECKLIST = Q.COD_CHECKLIST_RETORNO
                               AND CR.COD_ALTERNATIVA = Q.CODIGO_ALTERNATIVA)
                   ELSE NULL
                   END AS DESCRICAO_ALTERNATIVA_TIPO_OUTROS,
               Q.CODIGO_ITEM_CRITICO,
               Q.DATA_HORA_APONTAMENTO_ITEM_CRITICO
        FROM (SELECT DISTINCT ON (UCV.PLACA) UCV.DATA,
                                             UCV.PLACA,
                                             UCV.COD_CHECKLIST_SAIDA,
                                             UCV.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                                             UCV.COD_CHECKLIST_MODELO_SAIDA,
                                             UCV.NOME_COLABORADOR_CHECKLIST_SAIDA,
                                             UCV.COD_CHECKLIST_RETORNO,
                                             UCV.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
                                             UCV.COD_CHECKLIST_MODELO_RETORNO,
                                             UCV.NOME_COLABORADOR_CHECKLIST_RETORNO,
                                             CP.CODIGO       AS CODIGO_PERGUNTA,
                                             CP.PERGUNTA     AS DESCRICAO_PERGUNTA,
                                             CAP.ALTERNATIVA AS DESCRICAO_ALTERNATIVA,
                                             CAP.CODIGO      AS CODIGO_ALTERNATIVA,
                                             CASE
                                                 WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                                                     AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                                     AND CAP.ALTERNATIVA_TIPO_OUTROS
                                                     AND COSI.COD_ALTERNATIVA = CAP.CODIGO)
                                                     THEN TRUE
                                                 ELSE FALSE
                                                 END         AS ITEM_CRITICO_DE_SAIDA_TIPO_OUTROS,
                                             CASE
                                                 WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                                                     AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                                     AND CAP.ALTERNATIVA_TIPO_OUTROS)
                                                     THEN TRUE
                                                 ELSE FALSE
                                                 END         AS ALTERNATIVA_TIPO_OUTROS_CHECKLIST_SAIDA,
                                             CASE
                                                 WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_RETORNO
                                                     AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                                     AND CAP.ALTERNATIVA_TIPO_OUTROS)
                                                     THEN TRUE
                                                 ELSE FALSE
                                                 END         AS ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO,
                                             CASE
                                                 WHEN CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                                     THEN COSI.CODIGO
                                                 ELSE NULL
                                                 END         AS CODIGO_ITEM_CRITICO,
                                             CASE
                                                 WHEN COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                                                     AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                                     THEN UCV.DATA_HORA_ULTIMO_CHECKLIST_SAIDA
                                                 WHEN COS.COD_CHECKLIST = UCV.COD_CHECKLIST_RETORNO
                                                     AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                                     THEN UCV.DATA_HORA_ULTIMO_CHECKLIST_RETORNO
                                                 ELSE NULL
                                                 END         AS DATA_HORA_APONTAMENTO_ITEM_CRITICO
              FROM ULTIMOS_CHECKLISTS_VEICULOS UCV
                       LEFT JOIN CHECKLIST_ORDEM_SERVICO COS
                                 ON COS.COD_CHECKLIST IN (UCV.COD_CHECKLIST_SAIDA, UCV.COD_CHECKLIST_RETORNO)
                                     AND COS.STATUS = ORDEM_SERVICO_ABERTA
                                     AND COS.CODIGO IS NOT NULL
                  -- UTILIZAMOS O JOIN COM ITENS_PRIORIDADE AO INVÉS DE CHECKLIST_ORDEM_SERVICO_ITENS POIS DESSE MODO CONSIDERAMOS
                  -- APENAS OS ITENS ABERTOS CRÍTICOS, QUE É O QUE IMPORTA PARA O FAROL.
                       LEFT JOIN ITENS_PRIORIDADE COSI
                                 ON COS.CODIGO = COSI.COD_OS
                                     AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                                     AND COSI.STATUS_RESOLUCAO = ORDEM_SERVICO_ITEM_PENDENDTE
                                     AND COSI.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                       LEFT JOIN CHECKLIST_PERGUNTAS CP
                                 ON CP.CODIGO = COSI.COD_PERGUNTA
                       LEFT JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                                 ON CAP.COD_PERGUNTA = CP.CODIGO
                                     AND CAP.CODIGO = COSI.COD_ALTERNATIVA
                                     AND CAP.PRIORIDADE IS NOT NULL
                                     AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA) AS Q
        ORDER BY Q.DATA, Q.PLACA, Q.CODIGO_PERGUNTA;
END;
$$;

create or replace function public.func_checklist_get_listagem_modelos_checklist(f_cod_unidade bigint)
    returns TABLE
            (
                modelo          text,
                cod_modelo      bigint,
                cod_unidade     bigint,
                nome_cargo      text,
                tipo_veiculo    text,
                total_perguntas bigint,
                status_ativo    boolean
            )
    language sql
as
$$
SELECT CM.NOME          AS MODELO,
       CM.CODIGO        AS COD_MODELO,
       CM.COD_UNIDADE   AS COD_UNIDADE,
       F.NOME           AS NOME_CARGO,
       VT.NOME          AS TIPO_VEICULO,
       COUNT(CP.CODIGO) AS TOTAL_PERGUNTAS,
       CM.STATUS_ATIVO  AS STATUS_ATIVO
FROM CHECKLIST_MODELO CM
         JOIN CHECKLIST_PERGUNTAS CP ON CM.COD_UNIDADE = CP.COD_UNIDADE
    AND CM.CODIGO = CP.COD_CHECKLIST_MODELO
    AND CM.COD_VERSAO_ATUAL = CP.COD_VERSAO_CHECKLIST_MODELO
         LEFT JOIN CHECKLIST_MODELO_FUNCAO CMF ON CM.COD_UNIDADE = CMF.COD_UNIDADE
    AND CM.CODIGO = CMF.COD_CHECKLIST_MODELO
         LEFT JOIN FUNCAO F ON CMF.COD_FUNCAO = F.CODIGO
         LEFT JOIN CHECKLIST_MODELO_VEICULO_TIPO CMVT ON CM.COD_UNIDADE = CMVT.COD_UNIDADE
    AND CM.CODIGO = CMVT.COD_MODELO
         LEFT JOIN VEICULO_TIPO VT ON CMVT.COD_TIPO_VEICULO = VT.CODIGO
WHERE CM.COD_UNIDADE = F_COD_UNIDADE
GROUP BY CM.NOME, CM.CODIGO, CM.COD_UNIDADE, F.NOME, VT.CODIGO, CM.STATUS_ATIVO
ORDER BY CM.STATUS_ATIVO DESC, CM.CODIGO ASC;
$$;

create or replace function public.func_checklist_get_regionais_unidades_selecao(f_cod_colaborador bigint)
    returns TABLE
            (
                codigo_regional                                            bigint,
                nome_regional                                              text,
                codigo_unidade                                             bigint,
                nome_unidade                                               text,
                realizacao_checklist_diferentes_unidades_bloqueado_empresa boolean
            )
    language plpgsql
as
$$
DECLARE
    EMPRESA_BLOQUEADA_DIFERENTES_UNIDADES BOOLEAN := FUNC_CHECKLIST_REALIZACAO_DIFERENTES_UNIDADES_EMPRESA_BLOQUEADA(
            (SELECT C.COD_EMPRESA
             FROM COLABORADOR C
             WHERE C.CODIGO = F_COD_COLABORADOR));
BEGIN
    RETURN QUERY
        SELECT DISTINCT ON (F.CODIGO_REGIONAL, F.CODIGO_UNIDADE) F.CODIGO_REGIONAL                     AS CODIGO_REGIONAL,
                                                                 F.NOME_REGIONAL                       AS NOME_REGIONAL,
                                                                 F.CODIGO_UNIDADE                      AS CODIGO_UNIDADE,
                                                                 F.NOME_UNIDADE                        AS NOME_UNIDADE,
                                                                 EMPRESA_BLOQUEADA_DIFERENTES_UNIDADES AS REALIZACAO_CHECKLIST_DIFERENTES_UNIDADES_BLOQUEADO_EMPRESA
        FROM FUNC_COLABORADOR_GET_UNIDADES_ACESSO(F_COD_COLABORADOR) F
        ORDER BY F.CODIGO_REGIONAL ASC, F.CODIGO_UNIDADE ASC;
END;
$$;

create or replace function public.func_checklist_insert_checklist_infos(f_cod_unidade_checklist bigint,
                                                                        f_cod_modelo_checklist bigint,
                                                                        f_data_hora_realizacao timestamp with time zone,
                                                                        f_cod_colaborador bigint, f_cod_veiculo bigint,
                                                                        f_placa_veiculo text,
                                                                        f_tipo_checklist character,
                                                                        f_km_coletado bigint, f_tempo_realizacao bigint,
                                                                        f_data_hora_sincronizacao timestamp with time zone,
                                                                        f_fonte_data_hora_realizacao text,
                                                                        f_versao_app_momento_realizacao integer,
                                                                        f_versao_app_momento_sincronizacao integer,
                                                                        f_device_id text, f_device_imei text,
                                                                        f_device_uptime_realizacao_millis bigint,
                                                                        f_device_uptime_sincronizacao_millis bigint) returns bigint
    language plpgsql
as
$$
DECLARE
    -- Iremos atualizar o KM do Veículo somente para o caso em que o KM atual do veículo for menor que o KM coletado.
    DEVE_ATUALIZAR_KM_VEICULO BOOLEAN := (CASE
                                              WHEN (F_KM_COLETADO > (SELECT V.KM
                                                                     FROM VEICULO V
                                                                     WHERE V.CODIGO = F_COD_VEICULO))
                                                  THEN
                                                  TRUE
                                              ELSE FALSE END);
    COD_CHECKLIST_INSERIDO    BIGINT;
    QTD_LINHAS_ATUALIZADAS    BIGINT;
BEGIN

    INSERT INTO CHECKLIST(COD_UNIDADE,
                          COD_CHECKLIST_MODELO,
                          DATA_HORA,
                          CPF_COLABORADOR,
                          PLACA_VEICULO,
                          TIPO,
                          TEMPO_REALIZACAO,
                          KM_VEICULO,
                          DATA_HORA_SINCRONIZACAO,
                          FONTE_DATA_HORA_REALIZACAO,
                          VERSAO_APP_MOMENTO_REALIZACAO,
                          VERSAO_APP_MOMENTO_SINCRONIZACAO,
                          DEVICE_ID,
                          DEVICE_IMEI,
                          DEVICE_UPTIME_REALIZACAO_MILLIS,
                          DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
                          FOI_OFFLINE)
    VALUES (F_COD_UNIDADE_CHECKLIST,
            F_COD_MODELO_CHECKLIST,
            F_DATA_HORA_REALIZACAO,
            (SELECT C.CPF FROM COLABORADOR C WHERE C.CODIGO = F_COD_COLABORADOR),
            F_PLACA_VEICULO,
            F_TIPO_CHECKLIST,
            F_TEMPO_REALIZACAO,
            F_KM_COLETADO,
            F_DATA_HORA_SINCRONIZACAO,
            F_FONTE_DATA_HORA_REALIZACAO,
            F_VERSAO_APP_MOMENTO_REALIZACAO,
            F_VERSAO_APP_MOMENTO_SINCRONIZACAO,
            F_DEVICE_ID,
            F_DEVICE_IMEI,
            F_DEVICE_UPTIME_REALIZACAO_MILLIS,
            F_DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
            TRUE) RETURNING CODIGO INTO COD_CHECKLIST_INSERIDO;

    -- Verificamos se o insert funcionou.
    IF COD_CHECKLIST_INSERIDO <= 0
    THEN
        RAISE EXCEPTION 'Não foi possível inserir o checklist';
    END IF;

    IF DEVE_ATUALIZAR_KM_VEICULO
    THEN
        UPDATE VEICULO SET KM = F_KM_COLETADO WHERE CODIGO = F_COD_VEICULO;
    END IF;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    -- Se devemos atualizar o KM mas nenhuma linha foi alterada, então temos um erro.
    IF (DEVE_ATUALIZAR_KM_VEICULO AND QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Não foi possível atualizar o km do veículo';
    END IF;

    RETURN COD_CHECKLIST_INSERIDO;
END;
$$;

create or replace function public.func_checklist_insert_respostas_checklist(f_cod_unidade_checklist bigint,
                                                                            f_cod_modelo_checklist bigint,
                                                                            f_cod_checklist bigint, f_resposta text,
                                                                            f_cod_pergunta bigint,
                                                                            f_cod_alternativa bigint) returns bigint
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_INSERIDAS BIGINT;
BEGIN
    INSERT INTO CHECKLIST_RESPOSTAS(COD_CHECKLIST_MODELO,
                                    COD_UNIDADE,
                                    COD_CHECKLIST,
                                    RESPOSTA,
                                    COD_PERGUNTA,
                                    COD_ALTERNATIVA)
    VALUES (F_COD_MODELO_CHECKLIST,
            F_COD_UNIDADE_CHECKLIST,
            F_COD_CHECKLIST,
            F_RESPOSTA,
            F_COD_PERGUNTA,
            F_COD_ALTERNATIVA)
    ON CONFLICT ON CONSTRAINT PK_CHECKLIST_RESPOSTAS DO NOTHING;

    --     GET DIAGNOSTICS QTD_LINHAS_INSERIDAS = ROW_COUNT;
-- 
--     IF QTD_LINHAS_INSERIDAS <> 1
--     THEN
--         RAISE EXCEPTION 'Não foi possível inserir a resposta';
--     END IF;

    RETURN 1;
END;
$$;

create or replace function public.func_checklist_offline_empresa_liberada(f_cod_empresa bigint) returns boolean
    language sql
as
$$
SELECT NOT EXISTS(
        SELECT COEB.COD_EMPRESA
        FROM CHECKLIST_OFFLINE_EMPRESA_BLOQUEADA COEB
        WHERE COEB.COD_EMPRESA = F_COD_EMPRESA)
$$;

create or replace function public.func_checklist_offline_get_colaboradores_disponiveis(f_cod_unidade bigint)
    returns TABLE
            (
                cod_unidade_colaborador   bigint,
                cod_colaborador           bigint,
                nome_colaborador          text,
                cpf_colaborador           text,
                data_nascimento           date,
                cod_cargo_colaborador     integer,
                cod_permissao_colaborador integer
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT C.COD_UNIDADE :: BIGINT      AS COD_UNIDADE_COLABORADOR,
               C.CODIGO                     AS COD_COLABORADOR,
               C.NOME :: TEXT               AS NOME_COLABORADOR,
               LPAD(C.CPF :: TEXT, 11, '0') AS CPF_COLABORADOR,
               C.DATA_NASCIMENTO :: DATE    AS DATA_NASCIMENTO,
               C.COD_FUNCAO                 AS COD_CARGO_COLABORADOR,
               C.COD_PERMISSAO :: INTEGER   AS COD_PERMISSAO_COLABORADOR
        FROM COLABORADOR C
        WHERE C.COD_UNIDADE = F_COD_UNIDADE
          AND C.STATUS_ATIVO
          -- Apenas colaboradores que possuem funções associadas a modelos de checklist ativos.
          AND C.COD_FUNCAO IN (SELECT CMF.COD_FUNCAO
                               FROM CHECKLIST_MODELO CM
                                        JOIN CHECKLIST_MODELO_FUNCAO CMF
                                             ON CM.CODIGO = CMF.COD_CHECKLIST_MODELO
                               WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                                 AND CM.STATUS_ATIVO = TRUE);
END;
$$;

create or replace function public.func_checklist_offline_get_informacoes_unidade(f_cod_unidade bigint)
    returns TABLE
            (
                cod_empresa   bigint,
                nome_empresa  text,
                cod_regional  bigint,
                nome_regional text,
                cod_unidade   bigint,
                nome_unidade  text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT E.CODIGO       AS COD_EMPRESA,
               E.NOME::TEXT   AS NOME_EMPRESA,
               R.CODIGO       AS COD_REGIONAL,
               R.REGIAO::TEXT AS NOME_REGIONAL,
               U.CODIGO       AS COD_UNIDADE,
               U.NOME::TEXT   AS NOME_UNIDADE
        FROM UNIDADE U
                 JOIN EMPRESA E
                      ON U.COD_EMPRESA = E.CODIGO
                 JOIN REGIONAL R
                      ON U.COD_REGIONAL = R.CODIGO
        WHERE U.CODIGO = F_COD_UNIDADE;
END;
$$;

create or replace function public.func_checklist_offline_get_placas_disponiveis(f_cod_unidade bigint)
    returns TABLE
            (
                cod_veiculo      bigint,
                placa_veiculo    text,
                cod_tipo_veiculo bigint,
                km_atual_veiculo bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT V.CODIGO        AS COD_VEICULO,
               V.PLACA :: TEXT AS PLACA_VEICULO,
               V.COD_TIPO      AS COD_TIPO_VEICULO,
               v.KM            AS KM_ATUAL_VEICULO
        FROM VEICULO V
        WHERE V.COD_UNIDADE = F_COD_UNIDADE
          AND V.STATUS_ATIVO
          AND V.COD_TIPO IN (SELECT CMVT.COD_TIPO_VEICULO
                             FROM CHECKLIST_MODELO_VEICULO_TIPO CMVT
                                      JOIN CHECKLIST_MODELO CM
                                           ON CMVT.COD_MODELO = CM.CODIGO
                             WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                               AND CM.STATUS_ATIVO = TRUE);
END;
$$;

create or replace function public.func_checklist_offline_update_versao_dados_unidade(f_cod_unidade bigint)
    returns TABLE
            (
                empresa_checklist_offline_bloqueado boolean,
                versao_dados_checklist_unidade      bigint
            )
    language plpgsql
as
$$
DECLARE
    F_COD_EMPRESA   BIGINT := (SELECT U.COD_EMPRESA
                               FROM UNIDADE U
                               WHERE U.CODIGO = F_COD_UNIDADE);
    VERSAO_DADOS_BD BIGINT;
BEGIN
    IF (SELECT EXISTS(SELECT COEB.COD_EMPRESA
                      FROM CHECKLIST_OFFLINE_EMPRESA_BLOQUEADA COEB
                      WHERE COEB.COD_EMPRESA = F_COD_EMPRESA))
    THEN
        RETURN QUERY
            SELECT TRUE           AS EMPRESA_CHECKLIST_OFFLINE_BLOQUEADO,
                   NULL :: BIGINT AS VERSAO_DADOS_CHECKLIST_UNIDADE;
    ELSE
        IF (SELECT EXISTS(SELECT COD_UNIDADE FROM CHECKLIST_OFFLINE_DADOS_UNIDADE WHERE COD_UNIDADE = F_COD_UNIDADE))
        THEN
            UPDATE CHECKLIST_OFFLINE_DADOS_UNIDADE
            SET VERSAO_DADOS = VERSAO_DADOS + 1
            WHERE COD_UNIDADE = F_COD_UNIDADE RETURNING VERSAO_DADOS INTO VERSAO_DADOS_BD;
        ELSE
            INSERT INTO CHECKLIST_OFFLINE_DADOS_UNIDADE(COD_UNIDADE, TOKEN_SINCRONIZACAO_CHECKLIST)
            VALUES (F_COD_UNIDADE, F_RANDOM_STRING(64)) RETURNING VERSAO_DADOS INTO VERSAO_DADOS_BD;
        END IF;

        RETURN QUERY
            SELECT FALSE           AS EMPRESA_CHECKLIST_OFFLINE_BLOQUEADO,
                   VERSAO_DADOS_BD AS VERSAO_DADOS_CHECKLIST_UNIDADE;
    END IF;
END;
$$;

create or replace function public.func_checklist_offline_update_versao_dados_unidade_colaborador(f_cod_colaborador bigint)
    returns TABLE
            (
                empresa_checklist_offline_bloqueado boolean,
                versao_dados_checklist_unidade      bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT *
        FROM FUNC_CHECKLIST_OFFLINE_UPDATE_VERSAO_DADOS_UNIDADE((SELECT C.COD_UNIDADE
                                                                 FROM COLABORADOR C
                                                                 WHERE C.CODIGO = F_COD_COLABORADOR));
END;
$$;

create or replace function public.func_checklist_offline_update_versao_dados_unidade_modelo_check(f_cod_modelo_checklist bigint)
    returns TABLE
            (
                empresa_checklist_offline_bloqueado boolean,
                versao_dados_checklist_unidade      bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT *
        FROM FUNC_CHECKLIST_OFFLINE_UPDATE_VERSAO_DADOS_UNIDADE((SELECT CM.COD_UNIDADE
                                                                 FROM CHECKLIST_MODELO CM
                                                                 WHERE CM.CODIGO = F_COD_MODELO_CHECKLIST));
END;
$$;

create or replace function public.func_checklist_offline_update_versao_dados_unidade_veiculo(f_cod_veiculo bigint)
    returns TABLE
            (
                empresa_checklist_offline_bloqueado boolean,
                versao_dados_checklist_unidade      bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT *
        FROM FUNC_CHECKLIST_OFFLINE_UPDATE_VERSAO_DADOS_UNIDADE((SELECT V.COD_UNIDADE
                                                                 FROM VEICULO V
                                                                 WHERE V.CODIGO = F_COD_VEICULO));
END;
$$;

create or replace function suporte.func_checklist_os_deleta_os_checklist(f_cod_unidade bigint, f_cod_os bigint,
                                                                         f_cod_checklist bigint,
                                                                         OUT aviso_checklist_os_deletado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN
    --VERIFICA SE EXISTE UNIDADE
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    --VERIFICA A EXISTÊNCIA DA ORDEM DE SERVIÇO DE ACORDO COM A CHAVE COMPOSTA RECEBIDA POR PARÂMETRO:
    IF NOT EXISTS(
            SELECT *
            FROM CHECKLIST_ORDEM_SERVICO_DATA
            WHERE CODIGO = F_COD_OS
              AND COD_UNIDADE = F_COD_UNIDADE
              AND COD_CHECKLIST = F_COD_CHECKLIST
        )
    THEN
        RAISE EXCEPTION 'ORDEM DE SERVIÇO COM CÓDIGO: %, UNIDADE: %, CÓDIGO DE CHECKLIST: % NÃO ENCONTRADO',
            F_COD_OS, F_COD_UNIDADE, F_COD_CHECKLIST;
    END IF;

    --DELETA ITEM ORDEM SERVIÇO:
    UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_OS = F_COD_OS
      AND COD_UNIDADE = F_COD_UNIDADE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'ERRO AO DELETAR ITEM DA ORDEM DE SERVIÇO DA UNIDADE: %, CÓDIGO OS: % E CÓDIGO CHECKLIST: %',
            F_COD_UNIDADE, F_COD_OS, F_COD_CHECKLIST;
    END IF;

    --DELETA OS:
    UPDATE CHECKLIST_ORDEM_SERVICO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = F_COD_OS
      AND COD_UNIDADE = F_COD_UNIDADE
      AND COD_CHECKLIST = F_COD_CHECKLIST;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'ERRO AO DELETAR ORDEM DE SERVIÇO DA UNIDADE: %, CÓDIGO OS: %, CÓDIGO CHECKLIST: %',
            F_COD_UNIDADE, F_COD_OS, F_COD_CHECKLIST;
    END IF;

    SELECT 'DELEÇÃO DA OS: '
               || F_COD_OS
               || ', CÓDIGO CHECKLIST'
               || F_COD_CHECKLIST
               || ', CÓDIGO UNIDADE: '
               || F_COD_UNIDADE
               || ' REALIZADO COM SUCESSO.'
    INTO AVISO_CHECKLIST_OS_DELETADO;
END
$$;

create or replace function public.func_checklist_os_get_itens_resolucao(f_cod_unidade bigint, f_cod_os bigint,
                                                                        f_placa_veiculo text,
                                                                        f_prioridade_alternativa text,
                                                                        f_status_itens text,
                                                                        f_data_hora_atual_utc timestamp with time zone,
                                                                        f_limit integer, f_offset integer)
    returns TABLE
            (
                placa_veiculo                         text,
                km_atual_veiculo                      bigint,
                cod_os                                bigint,
                cod_unidade_item_os                   bigint,
                cod_item_os                           bigint,
                data_hora_primeiro_apontamento_item   timestamp without time zone,
                status_item_os                        text,
                prazo_resolucao_item_horas            integer,
                prazo_restante_resolucao_item_minutos bigint,
                qtd_apontamentos                      integer,
                cod_colaborador_resolucao             bigint,
                nome_colaborador_resolucao            text,
                data_hora_resolucao                   timestamp without time zone,
                data_hora_inicio_resolucao            timestamp without time zone,
                data_hora_fim_resolucao               timestamp without time zone,
                feedback_resolucao                    text,
                duracao_resolucao_minutos             bigint,
                km_veiculo_coletado_resolucao         bigint,
                cod_pergunta                          bigint,
                descricao_pergunta                    text,
                cod_alternativa                       bigint,
                descricao_alternativa                 text,
                alternativa_tipo_outros               boolean,
                descricao_tipo_outros                 text,
                prioridade_alternativa                text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH DADOS AS (
            SELECT C.PLACA_VEICULO :: TEXT                                                AS PLACA_VEICULO,
                   V.KM                                                                   AS KM_ATUAL_VEICULO,
                   COS.CODIGO                                                             AS COD_OS,
                   COS.COD_UNIDADE                                                        AS COD_UNIDADE_ITEM_OS,
                   COSI.CODIGO                                                            AS COD_ITEM_OS,
                   C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)                     AS DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM,
                   COSI.STATUS_RESOLUCAO                                                  AS STATUS_ITEM_OS,
                   PRIO.PRAZO                                                             AS PRAZO_RESOLUCAO_ITEM_HORAS,
                   TO_MINUTES_TRUNC((C.DATA_HORA
                       + (PRIO.PRAZO || ' HOURS') :: INTERVAL)
                       -
                                    F_DATA_HORA_ATUAL_UTC)                                AS PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS,
                   COSI.QT_APONTAMENTOS                                                   AS QTD_APONTAMENTOS,
                   CO.CODIGO                                                              AS COD_COLABORADOR_RESOLUCAO,
                   CO.NOME :: TEXT                                                        AS NOME_COLABORADOR_RESOLUCAO,
                   COSI.DATA_HORA_CONSERTO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)         AS DATA_HORA_RESOLUCAO,
                   COSI.DATA_HORA_INICIO_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE) AS DATA_HORA_INICIO_RESOLUCAO,
                   COSI.DATA_HORA_FIM_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)    AS DATA_HORA_FIM_RESOLUCAO,
                   COSI.FEEDBACK_CONSERTO                                                 AS FEEDBACK_RESOLUCAO,
                   MILLIS_TO_MINUTES(COSI.TEMPO_REALIZACAO)                               AS DURACAO_RESOLUCAO_MINUTOS,
                   COSI.KM                                                                AS KM_VEICULO_COLETADO_RESOLUCAO,
                   CP.CODIGO                                                              AS COD_PERGUNTA,
                   CP.PERGUNTA                                                            AS DESCRICAO_PERGUNTA,
                   CAP.CODIGO                                                             AS COD_ALTERNATIVA,
                   CAP.ALTERNATIVA                                                        AS DESCRICAO_ALTERNATIVA,
                   CAP.ALTERNATIVA_TIPO_OUTROS                                            AS ALTERNATIVA_TIPO_OUTROS,
                   CASE
                       WHEN CAP.ALTERNATIVA_TIPO_OUTROS
                           THEN
                           (SELECT CRN.RESPOSTA_OUTROS
                            FROM CHECKLIST_RESPOSTAS_NOK CRN
                            WHERE CRN.COD_CHECKLIST = C.CODIGO
                              AND CRN.COD_ALTERNATIVA = CAP.CODIGO) :: TEXT
                       ELSE NULL
                       END                                                                AS DESCRICAO_TIPO_OUTROS,
                   CAP.PRIORIDADE :: TEXT                                                 AS PRIORIDADE_ALTERNATIVA
            FROM CHECKLIST C
                     JOIN CHECKLIST_ORDEM_SERVICO COS
                          ON C.CODIGO = COS.COD_CHECKLIST
                     JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          ON COS.CODIGO = COSI.COD_OS
                              AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                     JOIN CHECKLIST_PERGUNTAS CP
                          ON COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO = CP.CODIGO
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO
                     JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE PRIO
                          ON CAP.PRIORIDADE = PRIO.PRIORIDADE
                     JOIN VEICULO V
                          ON C.PLACA_VEICULO = V.PLACA
                     LEFT JOIN COLABORADOR CO
                               ON CO.CPF = COSI.CPF_MECANICO
            WHERE F_IF(F_COD_UNIDADE IS NULL, TRUE, COS.COD_UNIDADE = F_COD_UNIDADE)
              AND F_IF(F_COD_OS IS NULL, TRUE, COS.CODIGO = F_COD_OS)
              AND F_IF(F_PLACA_VEICULO IS NULL, TRUE, C.PLACA_VEICULO = F_PLACA_VEICULO)
              AND F_IF(F_PRIORIDADE_ALTERNATIVA IS NULL, TRUE, CAP.PRIORIDADE = F_PRIORIDADE_ALTERNATIVA)
              AND F_IF(F_STATUS_ITENS IS NULL, TRUE, COSI.STATUS_RESOLUCAO = F_STATUS_ITENS)
            LIMIT F_LIMIT
                OFFSET F_OFFSET
        ),
             DADOS_VEICULO AS (
                 SELECT V.PLACA :: TEXT AS PLACA_VEICULO,
                        V.KM            AS KM_ATUAL_VEICULO
                 FROM VEICULO V
                 WHERE V.PLACA = F_PLACA_VEICULO
             )

             -- NÓS USAMOS ESSE DADOS_VEICULO COM F_IF POIS PODE ACONTECER DE NÃO EXISTIR DADOS PARA OS FILTROS APLICADOS E
             -- DESSE MODO ACABARÍAMOS NÃO RETORNANDO PLACA E KM TAMBÉM, MAS ESSAS SÃO INFORMAÇÕES NECESSÁRIAS POIS O OBJETO
             -- CONSTRUÍDO A PARTIR DESSA FUNCTION USA ELAS.
        SELECT F_IF(D.PLACA_VEICULO IS NULL, DV.PLACA_VEICULO, D.PLACA_VEICULO)          AS PLACA_VEICULO,
               F_IF(D.KM_ATUAL_VEICULO IS NULL, DV.KM_ATUAL_VEICULO, D.KM_ATUAL_VEICULO) AS KM_ATUAL_VEICULO,
               D.COD_OS                                                                  AS COD_OS,
               D.COD_UNIDADE_ITEM_OS                                                     AS COD_UNIDADE_ITEM_OS,
               D.COD_ITEM_OS                                                             AS COD_ITEM_OS,
               D.DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM                                     AS DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM,
               D.STATUS_ITEM_OS                                                          AS STATUS_ITEM_OS,
               D.PRAZO_RESOLUCAO_ITEM_HORAS                                              AS PRAZO_RESOLUCAO_ITEM_HORAS,
               D.PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS                                   AS PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS,
               D.QTD_APONTAMENTOS                                                        AS QTD_APONTAMENTOS,
               D.COD_COLABORADOR_RESOLUCAO                                               AS COD_COLABORADOR_RESOLUCAO,
               D.NOME_COLABORADOR_RESOLUCAO                                              AS NOME_COLABORADOR_RESOLUCAO,
               D.DATA_HORA_RESOLUCAO                                                     AS DATA_HORA_RESOLUCAO,
               D.DATA_HORA_INICIO_RESOLUCAO                                              AS DATA_HORA_INICIO_RESOLUCAO,
               D.DATA_HORA_FIM_RESOLUCAO                                                 AS DATA_HORA_FIM_RESOLUCAO,
               D.FEEDBACK_RESOLUCAO                                                      AS FEEDBACK_RESOLUCAO,
               D.DURACAO_RESOLUCAO_MINUTOS                                               AS DURACAO_RESOLUCAO_MINUTOS,
               D.KM_VEICULO_COLETADO_RESOLUCAO                                           AS KM_VEICULO_COLETADO_RESOLUCAO,
               D.COD_PERGUNTA                                                            AS COD_PERGUNTA,
               D.DESCRICAO_PERGUNTA                                                      AS DESCRICAO_PERGUNTA,
               D.COD_ALTERNATIVA                                                         AS COD_ALTERNATIVA,
               D.DESCRICAO_ALTERNATIVA                                                   AS DESCRICAO_ALTERNATIVA,
               D.ALTERNATIVA_TIPO_OUTROS                                                 AS ALTERNATIVA_TIPO_OUTROS,
               D.DESCRICAO_TIPO_OUTROS                                                   AS DESCRICAO_TIPO_OUTROS,
               D.PRIORIDADE_ALTERNATIVA                                                  AS PRIORIDADE_ALTERNATIVA
        FROM DADOS D
                 RIGHT JOIN DADOS_VEICULO DV
                            ON D.PLACA_VEICULO = DV.PLACA_VEICULO;
END;
$$;

create or replace function public.func_checklist_os_get_ordem_servico_resolucao(f_cod_unidade bigint, f_cod_os bigint,
                                                                                f_data_hora_atual_utc timestamp with time zone)
    returns TABLE
            (
                placa_veiculo                         text,
                km_atual_veiculo                      bigint,
                cod_os                                bigint,
                cod_unidade_os                        bigint,
                status_os                             text,
                data_hora_abertura_os                 timestamp without time zone,
                data_hora_fechamento_os               timestamp without time zone,
                cod_item_os                           bigint,
                cod_unidade_item_os                   bigint,
                data_hora_primeiro_apontamento_item   timestamp without time zone,
                status_item_os                        text,
                prazo_resolucao_item_horas            integer,
                prazo_restante_resolucao_item_minutos bigint,
                qtd_apontamentos                      integer,
                cod_colaborador_resolucao             bigint,
                nome_colaborador_resolucao            text,
                data_hora_resolucao                   timestamp without time zone,
                data_hora_inicio_resolucao            timestamp without time zone,
                data_hora_fim_resolucao               timestamp without time zone,
                feedback_resolucao                    text,
                duracao_resolucao_minutos             bigint,
                km_veiculo_coletado_resolucao         bigint,
                cod_pergunta                          bigint,
                descricao_pergunta                    text,
                cod_alternativa                       bigint,
                descricao_alternativa                 text,
                alternativa_tipo_outros               boolean,
                descricao_tipo_outros                 text,
                prioridade_alternativa                text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT C.PLACA_VEICULO :: TEXT                                                AS PLACA_VEICULO,
               V.KM                                                                   AS KM_ATUAL_VEICULO,
               COS.CODIGO                                                             AS COD_OS,
               COS.COD_UNIDADE                                                        AS COD_UNIDADE_OS,
               COS.STATUS :: TEXT                                                     AS STATUS_OS,
               C.DATA_HORA_REALIZACAO_TZ_APLICADO                                     AS DATA_HORA_ABERTURA_OS,
               COS.DATA_HORA_FECHAMENTO AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE)        AS DATA_HORA_FECHAMENTO_OS,
               COSI.CODIGO                                                            AS COD_ITEM_OS,
               COS.COD_UNIDADE                                                        AS COD_UNIDADE_ITEM_OS,
               C.DATA_HORA_REALIZACAO_TZ_APLICADO                                     AS DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM,
               COSI.STATUS_RESOLUCAO                                                  AS STATUS_ITEM_OS,
               PRIO.PRAZO                                                             AS PRAZO_RESOLUCAO_ITEM_HORAS,
               TO_MINUTES_TRUNC((C.DATA_HORA
                   + (PRIO.PRAZO || ' HOURS') :: INTERVAL)
                   -
                                F_DATA_HORA_ATUAL_UTC)                                AS PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS,
               COSI.QT_APONTAMENTOS                                                   AS QTD_APONTAMENTOS,
               CO.CODIGO                                                              AS COD_COLABORADOR_RESOLUCAO,
               CO.NOME :: TEXT                                                        AS NOME_COLABORADOR_RESOLUCAO,
               COSI.DATA_HORA_CONSERTO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)         AS DATA_HORA_RESOLUCAO,
               COSI.DATA_HORA_INICIO_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE) AS DATA_HORA_INICIO_RESOLUCAO,
               COSI.DATA_HORA_FIM_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)    AS DATA_HORA_FIM_RESOLUCAO,
               COSI.FEEDBACK_CONSERTO                                                 AS FEEDBACK_RESOLUCAO,
               MILLIS_TO_MINUTES(COSI.TEMPO_REALIZACAO)                               AS DURACAO_RESOLUCAO_MINUTOS,
               COSI.KM                                                                AS KM_VEICULO_COLETADO_RESOLUCAO,
               CP.CODIGO                                                              AS COD_PERGUNTA,
               CP.PERGUNTA                                                            AS DESCRICAO_PERGUNTA,
               CAP.CODIGO                                                             AS COD_ALTERNATIVA,
               CAP.ALTERNATIVA                                                        AS DESCRICAO_ALTERNATIVA,
               CAP.ALTERNATIVA_TIPO_OUTROS                                            AS ALTERNATIVA_TIPO_OUTROS,
               CASE
                   WHEN CAP.ALTERNATIVA_TIPO_OUTROS
                       THEN
                       (SELECT CRN.RESPOSTA_OUTROS
                        FROM CHECKLIST_RESPOSTAS_NOK CRN
                        WHERE CRN.COD_CHECKLIST = C.CODIGO
                          AND CRN.COD_ALTERNATIVA = CAP.CODIGO) :: TEXT
                   ELSE NULL
                   END                                                                AS DESCRICAO_TIPO_OUTROS,
               CAP.PRIORIDADE :: TEXT                                                 AS PRIORIDADE_ALTERNATIVA
        FROM CHECKLIST C
                 JOIN CHECKLIST_ORDEM_SERVICO COS
                      ON C.CODIGO = COS.COD_CHECKLIST
                 JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                      ON COS.CODIGO = COSI.COD_OS
                          AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                 JOIN CHECKLIST_PERGUNTAS CP
                      ON COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO = CP.CODIGO
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                      ON COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO
                 JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE PRIO
                      ON CAP.PRIORIDADE = PRIO.PRIORIDADE
                 JOIN VEICULO V
                      ON C.PLACA_VEICULO = V.PLACA
                 LEFT JOIN COLABORADOR CO
                           ON CO.CPF = COSI.CPF_MECANICO
        WHERE COS.CODIGO = F_COD_OS
          AND COS.COD_UNIDADE = F_COD_UNIDADE;
END;
$$;

create or replace function public.func_checklist_os_get_os_listagem(f_cod_unidade bigint, f_cod_tipo_veiculo bigint,
                                                                    f_placa_veiculo text, f_status_os text,
                                                                    f_limit integer, f_offset integer)
    returns TABLE
            (
                placa_veiculo        text,
                cod_os               bigint,
                cod_unidade_os       bigint,
                cod_checklist        bigint,
                data_hora_abertura   timestamp without time zone,
                data_hora_fechamento timestamp without time zone,
                status_os            text,
                qtd_itens_pendentes  integer,
                qtd_itens_resolvidos integer
            )
    language plpgsql
as
$$
DECLARE
    STATUS_ITEM_PENDENTE  TEXT = 'P';
    STATUS_ITEM_RESOLVIDO TEXT = 'R';
BEGIN
    RETURN QUERY
        WITH OS AS (
            SELECT COS.CODIGO                                                   AS COD_OS,
                   COS.COD_UNIDADE                                              AS COD_UNIDADE_OS,
                   COUNT(COS.CODIGO)
                   FILTER (WHERE COSI.STATUS_RESOLUCAO = STATUS_ITEM_PENDENTE)  AS QTD_ITENS_PENDENTES,
                   COUNT(COS.CODIGO)
                   FILTER (WHERE COSI.STATUS_RESOLUCAO = STATUS_ITEM_RESOLVIDO) AS QTD_ITENS_RESOLVIDOS
            FROM CHECKLIST_ORDEM_SERVICO COS
                     JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          ON COS.CODIGO = COSI.COD_OS
                              AND COS.COD_UNIDADE = COSI.COD_UNIDADE
            WHERE COS.COD_UNIDADE = F_COD_UNIDADE
            GROUP BY COS.COD_UNIDADE, COS.CODIGO
        )

        SELECT C.PLACA_VEICULO :: TEXT                                         AS PLACA_VEICULO,
               COS.CODIGO                                                      AS COD_OS,
               COS.COD_UNIDADE                                                 AS COD_UNIDADE_OS,
               COS.COD_CHECKLIST                                               AS COD_CHECKLIST,
               -- A DATA/HORA DO CHECK É A ABERTURA DA O.S.
               C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)              AS DATA_HORA_ABERTURA,
               COS.DATA_HORA_FECHAMENTO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE) AS DATA_HORA_FECHAMENTO,
               COS.STATUS :: TEXT                                              AS STATUS_OS,
               OS.QTD_ITENS_PENDENTES :: INTEGER                               AS QTD_ITENS_PENDENTES,
               OS.QTD_ITENS_RESOLVIDOS :: INTEGER                              AS QTD_ITENS_RESOLVIDOS
        FROM CHECKLIST C
                 JOIN CHECKLIST_ORDEM_SERVICO COS
                      ON COS.COD_CHECKLIST = C.CODIGO
                 JOIN OS
                      ON OS.COD_OS = COS.CODIGO
                          AND OS.COD_UNIDADE_OS = COS.COD_UNIDADE
                 JOIN VEICULO V
                      ON V.PLACA = C.PLACA_VEICULO
                 JOIN VEICULO_TIPO VT
                      ON V.COD_TIPO = VT.CODIGO
        WHERE C.COD_UNIDADE = F_COD_UNIDADE
          AND F_IF(F_COD_TIPO_VEICULO IS NULL, TRUE, F_COD_TIPO_VEICULO = VT.CODIGO)
          AND F_IF(F_PLACA_VEICULO IS NULL, TRUE, F_PLACA_VEICULO = C.PLACA_VEICULO)
          AND F_IF(F_STATUS_OS IS NULL, TRUE, F_STATUS_OS = COS.STATUS)
        ORDER BY COS.CODIGO DESC
        LIMIT F_LIMIT
            OFFSET F_OFFSET;
END;
$$;

create or replace function public.func_checklist_os_get_qtd_itens_placa_listagem(f_cod_unidade bigint,
                                                                                 f_cod_tipo_veiculo bigint,
                                                                                 f_placa_veiculo text,
                                                                                 f_status_itens_os text,
                                                                                 f_limit integer, f_offset integer)
    returns TABLE
            (
                placa_veiculo                text,
                qtd_itens_prioridade_critica bigint,
                qtd_itens_prioridade_alta    bigint,
                qtd_itens_prioridade_baixa   bigint,
                total_itens                  bigint
            )
    language plpgsql
as
$$
DECLARE
    TIPO_ITEM_PRIORIDADE_CRITICA TEXT := 'CRITICA';
    TIPO_ITEM_PRIORIDADE_ALTA    TEXT := 'ALTA';
    TIPO_ITEM_PRIORIDADE_BAIXA   TEXT := 'BAIXA';
BEGIN
    RETURN QUERY
        SELECT V.PLACA :: TEXT           AS PLACA_VEICULO,
               COUNT(CASE
                         WHEN CAP.PRIORIDADE = TIPO_ITEM_PRIORIDADE_CRITICA
                             THEN 1 END) AS QTD_ITENS_PRIORIDADE_CRITICA,
               COUNT(CASE
                         WHEN CAP.PRIORIDADE = TIPO_ITEM_PRIORIDADE_ALTA
                             THEN 1 END) AS QTD_ITENS_PRIORIDADE_ALTA,
               COUNT(CASE
                         WHEN CAP.PRIORIDADE = TIPO_ITEM_PRIORIDADE_BAIXA
                             THEN 1 END) AS QTD_ITENS_PRIORIDADE_BAIXA,
               COUNT(CAP.PRIORIDADE)     AS TOTAL_ITENS
        FROM VEICULO V
                 JOIN CHECKLIST C
                      ON V.PLACA = C.PLACA_VEICULO
                 JOIN CHECKLIST_ORDEM_SERVICO COS
                      ON C.CODIGO = COS.COD_CHECKLIST
                 JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                      ON COS.CODIGO = COSI.COD_OS
                          AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                      ON CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                 JOIN VEICULO_TIPO VT
                      ON V.COD_TIPO = VT.CODIGO
        WHERE V.COD_UNIDADE = F_COD_UNIDADE
          AND F_IF(F_COD_TIPO_VEICULO IS NULL, TRUE, VT.CODIGO = F_COD_TIPO_VEICULO)
          AND F_IF(F_PLACA_VEICULO IS NULL, TRUE, V.PLACA = F_PLACA_VEICULO)
          AND F_IF(F_STATUS_ITENS_OS IS NULL, TRUE, COSI.STATUS_RESOLUCAO = F_STATUS_ITENS_OS)
        GROUP BY V.PLACA
        ORDER BY QTD_ITENS_PRIORIDADE_CRITICA DESC,
                 QTD_ITENS_PRIORIDADE_ALTA DESC,
                 QTD_ITENS_PRIORIDADE_BAIXA DESC,
                 PLACA_VEICULO ASC
        LIMIT F_LIMIT
            OFFSET F_OFFSET;
END;
$$;

create or replace function public.func_checklist_os_relatorio_media_tempo_conserto_item(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                unidade                                      text,
                pergunta                                     text,
                alternativa                                  text,
                prioridade                                   text,
                "PRAZO CONSERTO EM HORAS"                    integer,
                "QTD APONTADOS"                              bigint,
                "TOTAL ITENS RESOLVIDOS"                     bigint,
                "QTD RESOLVIDOS DENTRO PRAZO"                bigint,
                "MÉDIA TEMPO CONSERTO EM HORAS / EM MINUTOS" text,
                "PORCENTAGEM"                                text
            )
    language sql
as
$$
SELECT NOME_UNIDADE                                                               AS NOME_UNIDADE,
       PERGUNTA                                                                   AS PERGUNTA,
       ALTERNATIVA                                                                AS ALTERNATIVA,
       PRIORIDADE                                                                 AS PRIORIDADE,
       PRAZO_CONSERTO_EM_HORAS                                                    AS PRAZO_CONSERTO_HORAS,
       QTD_APONTADOS                                                              AS QTD_APONTADOS,
       TOTAL_ITENS_RESOLVIDOS                                                     AS TOTAL_ITENS_RESOLVIDOS,
       QTD_RESOLVIDOS_DENTRO_PRAZO                                                AS QTD_RESOLVIDOS_DENTRO_PRAZO,
       TRUNC(MEDIA_TEMPO_CONSERTO_SEGUNDOS / 3600) || ' / ' ||
       TRUNC(MEDIA_TEMPO_CONSERTO_SEGUNDOS / 60)                                  AS MD_TEMPO_CONSERTO_HORAS_MINUTOS,
       ROUND((QTD_RESOLVIDOS_DENTRO_PRAZO / QTD_APONTADOS :: FLOAT) * 100) || '%' AS PORCENTAGEM
FROM (SELECT U.NOME                                       AS NOME_UNIDADE,
             EO.PERGUNTA,
             EO.ALTERNATIVA,
             EO.PRIORIDADE,
             EO.PRAZO                                     AS PRAZO_CONSERTO_EM_HORAS,
             COUNT(EO.PERGUNTA)                           AS QTD_APONTADOS,
             SUM(CASE
                     WHEN EO.CPF_MECANICO IS NOT NULL
                         THEN 1
                     ELSE 0 END)                          AS TOTAL_ITENS_RESOLVIDOS,
             SUM(CASE
                     WHEN (TO_SECONDS_TRUNC(EO.DATA_HORA_CONSERTO - EO.DATA_HORA)) <= EO.PRAZO
                         THEN 1
                     ELSE 0 END)                          AS QTD_RESOLVIDOS_DENTRO_PRAZO,
             TRUNC(EXTRACT(EPOCH FROM AVG(EO.DATA_HORA_CONSERTO -
                                          EO.DATA_HORA))) AS MEDIA_TEMPO_CONSERTO_SEGUNDOS
      FROM ESTRATIFICACAO_OS EO
               JOIN UNIDADE U ON EO.COD_UNIDADE = U.CODIGO
      WHERE EO.COD_UNIDADE = ANY (F_COD_UNIDADES)
        AND EO.DATA_HORA :: DATE >= F_DATA_INICIAL
        AND EO.DATA_HORA :: DATE <= F_DATA_FINAL
      GROUP BY U.CODIGO, EO.PERGUNTA, EO.ALTERNATIVA, EO.PRIORIDADE, EO.PRAZO) AS DADOS
ORDER BY DADOS.NOME_UNIDADE, ROUND((QTD_RESOLVIDOS_DENTRO_PRAZO / QTD_APONTADOS :: FLOAT) * 100) DESC
$$;

create or replace function public.func_checklist_os_relatorio_placas_maior_qtd_itens_abertos(f_cod_unidades bigint[], f_total_placas_para_buscar integer)
    returns TABLE
            (
                nome_unidade                      character varying,
                placa                             character varying,
                quantidade_itens_abertos          bigint,
                quantidade_itens_criticos_abertos bigint
            )
    language plpgsql
as
$$
DECLARE
    STATUS_ITENS_ABERTOS CHAR    := 'P';
    PRIORIDADE_CRITICA   VARCHAR := 'CRITICA';
BEGIN
    RETURN QUERY
        WITH PLACAS AS (
            SELECT C.PLACA_VEICULO           AS PLACA_VEICULO,
                   COUNT(COSI.CODIGO)        AS QUANTIDADE_ITENS_ABERTOS,
                   COUNT(CASE
                             WHEN CAP.PRIORIDADE = PRIORIDADE_CRITICA
                                 THEN 1 END) AS QUANTIDADE_ITENS_CRITICOS_ABERTOS
            FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                     JOIN CHECKLIST_ORDEM_SERVICO COS
                          ON COSI.COD_OS = COS.CODIGO
                              AND COSI.COD_UNIDADE = COS.COD_UNIDADE
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO
                     JOIN CHECKLIST C
                          ON C.CODIGO = COS.COD_CHECKLIST
            WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
              AND COSI.STATUS_RESOLUCAO = STATUS_ITENS_ABERTOS
            GROUP BY C.PLACA_VEICULO
            LIMIT F_TOTAL_PLACAS_PARA_BUSCAR
        )

        SELECT U.NOME AS NOME_UNIDADE,
               P.PLACA_VEICULO,
               P.QUANTIDADE_ITENS_ABERTOS,
               P.QUANTIDADE_ITENS_CRITICOS_ABERTOS
        FROM PLACAS P
                 JOIN VEICULO V ON V.PLACA = P.PLACA_VEICULO
                 JOIN UNIDADE U ON V.COD_UNIDADE = U.CODIGO
        ORDER BY P.QUANTIDADE_ITENS_ABERTOS DESC,
                 P.PLACA_VEICULO ASC
        LIMIT F_TOTAL_PLACAS_PARA_BUSCAR;
END;
$$;

create or replace function public.func_checklist_os_relatorio_produtividade_mecanicos(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                unidade                text,
                "MECÂNICO"             text,
                consertos              bigint,
                horas                  numeric,
                "HORAS POR CONSERTO"   numeric,
                "MINUTOS POR CONSERTO" numeric
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT U.NOME :: TEXT                              AS NOME_UNIDADE,
               C.NOME :: TEXT                              AS NOME_MECANICO,
               COUNT(COSI.CPF_MECANICO)                    AS CONSERTOS,
               SUM(COSI.TEMPO_REALIZACAO / 3600000)        AS HORAS,
               ROUND(AVG(COSI.TEMPO_REALIZACAO / 3600000)) AS HORAS_POR_CONSERTO,
               ROUND(AVG(COSI.TEMPO_REALIZACAO / 60000))   AS MINUTOS_POR_CONSERTO
        FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                 JOIN UNIDADE U ON U.CODIGO = COSI.COD_UNIDADE
                 JOIN COLABORADOR C ON C.CPF = COSI.CPF_MECANICO
        WHERE COSI.TEMPO_REALIZACAO IS NOT NULL
          AND COSI.TEMPO_REALIZACAO > 0
          AND COSI.COD_UNIDADE = ANY (F_COD_UNIDADES)
          AND (COSI.DATA_HORA_CONSERTO AT TIME ZONE TZ_UNIDADE(COSI.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
          AND (COSI.DATA_HORA_CONSERTO AT TIME ZONE TZ_UNIDADE(COSI.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
        GROUP BY U.CODIGO, COSI.CPF_MECANICO, C.NOME;
END;
$$;

create or replace function public.func_checklist_os_relatorio_qtd_itens_por_prioridade(f_cod_unidades bigint[], f_status_itens text)
    returns TABLE
            (
                prioridade text,
                quantidade bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH PRIORIDADES AS (
            SELECT CAP.PRIORIDADE :: TEXT AS PRIORIDADE
            FROM CHECKLIST_ALTERNATIVA_PRIORIDADE CAP
            ORDER BY CAP.PRAZO ASC
        )

        SELECT P.PRIORIDADE       AS PRIORIDADE,
               COUNT(COSI.CODIGO) AS QUANTIDADE
        FROM CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                 JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                      ON CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                          AND COSI.COD_UNIDADE = ANY (F_COD_UNIDADES)
                          AND COSI.STATUS_RESOLUCAO = F_STATUS_ITENS
                 RIGHT JOIN PRIORIDADES P
                            ON CAP.PRIORIDADE = P.PRIORIDADE
        GROUP BY P.PRIORIDADE
        ORDER BY CASE P.PRIORIDADE
                     WHEN 'CRITICA'
                         THEN 1
                     WHEN 'ALTA'
                         THEN 2
                     WHEN 'BAIXA'
                         THEN 3
                     END;
END;
$$;

create or replace function public.func_checklist_realizacao_diferentes_unidades_empresa_bloqueada(f_cod_empresa bigint)
    returns TABLE
            (
                realizacao_checklist_diferentes_unidades_bloqueado_empresa boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT EXISTS(SELECT CDUEB.COD_EMPRESA
                      FROM CHECKLIST_DIFERENTES_UNIDADES_EMPRESA_BLOQUEADA CDUEB
                      WHERE CDUEB.COD_EMPRESA = F_COD_EMPRESA);
END;
$$;

create or replace function public.func_checklist_relatorio_ambev_extrato_realizados_dia(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE"        text,
                "DATA"           text,
                "PLACA"          text,
                "CHECKS SAÍDA"   bigint,
                "CHECKS RETORNO" bigint
            )
    language sql
as
$$
WITH MAPAS AS (
    SELECT M.DATA AS DATA_MAPA,
           M.MAPA,
           M.PLACA
    FROM MAPA M
             JOIN VEICULO V ON V.PLACA = M.PLACA
    WHERE M.COD_UNIDADE = ANY (F_COD_UNIDADES)
      AND M.DATA >= F_DATA_INICIAL
      AND M.DATA <= F_DATA_FINAL
    ORDER BY M.DATA ASC),

     CHECKS AS (SELECT C.COD_UNIDADE                                                AS COD_UNIDADE,
                       (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE AS DATA,
                       C.PLACA_VEICULO                                              AS PLACA_VEICULO,
                       SUM(CASE
                               WHEN C.TIPO = 'S'
                                   THEN 1
                               ELSE 0 END)                                          AS CHECKS_SAIDA,
                       SUM(CASE
                               WHEN C.TIPO = 'R'
                                   THEN 1
                               ELSE 0 END)                                          AS CHECKS_RETORNO
                FROM CHECKLIST C
                         JOIN UNIDADE U ON C.COD_UNIDADE = U.CODIGO
                         LEFT JOIN MAPAS AS M
                                   ON M.DATA_MAPA = (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE
                                       AND M.PLACA = C.PLACA_VEICULO
                WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
                  AND (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
                  AND (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
                GROUP BY COD_UNIDADE, DATA, PLACA_VEICULO
                ORDER BY COD_UNIDADE, DATA, PLACA_VEICULO)

SELECT (SELECT NOME
        FROM UNIDADE U
        WHERE U.CODIGO = C.COD_UNIDADE) AS NOME_UNIDADE,
       TO_CHAR(C.DATA, 'DD/MM/YYYY')    AS DATA,
       C.PLACA_VEICULO,
       C.CHECKS_SAIDA,
       C.CHECKS_RETORNO
FROM CHECKS C
ORDER BY NOME_UNIDADE, DATA
$$;

create or replace function public.func_checklist_relatorio_estratificacao_respostas_nok(f_cod_unidades bigint[],
                                                                                        f_placa_veiculo character varying,
                                                                                        f_data_inicial date,
                                                                                        f_data_final date)
    returns TABLE
            (
                "UNIDADE"          text,
                "CODIGO CHECKLIST" bigint,
                "DATA"             character varying,
                "PLACA"            character varying,
                "TIPO"             text,
                "KM"               bigint,
                "NOME"             character varying,
                "PERGUNTA"         character varying,
                "ALTERNATIVA"      character varying,
                "RESPOSTA"         character varying,
                "PRIORIDADE"       character varying,
                "PRAZO EM HORAS"   integer
            )
    language sql
as
$$
SELECT U.NOME                                                                     AS NOME_UNIDADE,
       C.CODIGO                                                                   AS COD_CHECKLIST,
       FORMAT_TIMESTAMP(C.DATA_HORA_REALIZACAO_TZ_APLICADO, 'DD/MM/YYYY HH24:MI') AS DATA_HORA_CHECK,
       C.PLACA_VEICULO                                                            AS PLACA_VEICULO,
       CASE
           WHEN C.TIPO = 'S'
               THEN 'Saída'
           ELSE 'Retorno' END                                                     AS TIPO_CHECKLIST,
       C.KM_VEICULO                                                               AS KM_VEICULO,
       CO.NOME                                                                    AS NOME_REALIZADOR_CHECK,
       CP.PERGUNTA                                                                AS DESCRICAO_PERGUNTA,
       CAP.ALTERNATIVA                                                            AS DESCRICAO_ALTERNATIVA,
       CRN.RESPOSTA_OUTROS                                                        AS RESPOSTA,
       CAP.PRIORIDADE                                                             AS PRIORIDADE,
       PRIO.PRAZO                                                                 AS PRAZO
FROM CHECKLIST C
         JOIN VEICULO V
              ON V.PLACA = C.PLACA_VEICULO
         JOIN CHECKLIST_PERGUNTAS CP
              ON CP.COD_CHECKLIST_MODELO = C.COD_CHECKLIST_MODELO
         JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
              ON CAP.COD_PERGUNTA = CP.CODIGO
         JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE PRIO
              ON PRIO.PRIORIDADE :: TEXT = CAP.PRIORIDADE :: TEXT
         JOIN CHECKLIST_RESPOSTAS_NOK CRN
              ON C.CODIGO = CRN.COD_CHECKLIST
                  AND CRN.COD_ALTERNATIVA = CAP.CODIGO
         JOIN COLABORADOR CO
              ON CO.CPF = C.CPF_COLABORADOR
         JOIN UNIDADE U
              ON C.COD_UNIDADE = U.CODIGO
WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
  AND C.PLACA_VEICULO LIKE F_PLACA_VEICULO
  AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
  AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
ORDER BY U.NOME, C.DATA_HORA_SINCRONIZACAO DESC, C.CODIGO ASC
$$;

create or replace function public.func_checklist_relatorio_listagem_modelos_checklist(f_cod_unidades bigint[])
    returns TABLE
            (
                unidade                 text,
                "CÓDIGO DO CHECKLIST"   text,
                "NOME DO CHECKLIST"     text,
                ativo                   text,
                "CÓDIGO DA PERGUNTA"    text,
                pergunta                text,
                "CÓDIGO DA ALTERNATIVA" text,
                alternativa             text,
                "TIPO DE RESPOSTA"      text,
                prioridade              text
            )
    language sql
as
$$
SELECT U.NOME                                              AS NOME_UNIDADE,
       CM.CODIGO::TEXT                                     AS COD_MODELO_CHECKLIST,
       CM.NOME                                             AS NOME_MODELO,
       F_IF(CM.STATUS_ATIVO, 'SIM' :: TEXT, 'NÃO')         AS ATIVO,
       CP.CODIGO::TEXT                                     AS COD_PERGUNTA,
       CP.PERGUNTA                                         AS PERGUNTA,
       CAP.CODIGO::TEXT                                    AS COD_ALTERNATIVA,
       CAP.ALTERNATIVA                                     AS ALTERNATIVA,
       F_IF(CP.SINGLE_CHOICE, 'ÚNICA' :: TEXT, 'MÚLTIPLA') AS TIPO_DE_RESPOSTA,
       CAP.PRIORIDADE                                      AS PRIORIDADE
FROM CHECKLIST_PERGUNTAS CP
         JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
              ON CP.CODIGO = CAP.COD_PERGUNTA
         JOIN CHECKLIST_MODELO CM
              ON CAP.COD_VERSAO_CHECKLIST_MODELO = CM.COD_VERSAO_ATUAL
         JOIN UNIDADE U
              ON CM.COD_UNIDADE = U.CODIGO
WHERE CM.COD_UNIDADE = ANY (F_COD_UNIDADES)
ORDER BY U.NOME, CM.NOME, CP.PERGUNTA, CAP.ALTERNATIVA;
$$;

create or replace function public.func_checklist_relatorio_qtd_por_tipo(f_cod_unidades bigint[], f_data_hoje_utc date,
                                                                        f_dias_retroativos_para_buscar integer)
    returns TABLE
            (
                data                     date,
                data_formatada           text,
                total_checklists_saida   bigint,
                total_checklists_retorno bigint
            )
    language plpgsql
as
$$
DECLARE
    DATA_INICIAL       DATE := F_DATA_HOJE_UTC + INTERVAL '1' DAY - (INTERVAL '1' DAY * F_DIAS_RETROATIVOS_PARA_BUSCAR);
    DATA_FINAL         DATE := F_DATA_HOJE_UTC + INTERVAL '1' DAY;
    CHECK_TIPO_SAIDA   CHAR := 'S';
    CHECK_TIPO_RETORNO CHAR := 'R';
BEGIN
    RETURN QUERY
        WITH DIAS AS (
            SELECT G.DAY :: DATE AS DATA
            FROM GENERATE_SERIES(DATA_INICIAL, DATA_FINAL, '1 DAY') G(DAY)
            ORDER BY DATA
        ),

             CHECKS_DIA AS (
                 SELECT (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE AS DATA,
                        SUM(CASE
                                WHEN C.TIPO = CHECK_TIPO_SAIDA
                                    THEN 1
                                ELSE 0 END)                                             TOTAL_CHECKLISTS_SAIDA,
                        SUM(CASE
                                WHEN C.TIPO = CHECK_TIPO_RETORNO
                                    THEN 1
                                ELSE 0 END)                                             TOTAL_CHECKLISTS_RETORNO
                 FROM CHECKLIST C
                 WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
                   AND (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE BETWEEN DATA_INICIAL AND DATA_FINAL
                 GROUP BY DATA
                 ORDER BY DATA
             )

        SELECT D.DATA                      AS DATA,
               TO_CHAR(D.DATA, 'DD/MM')    AS DATA_FORMATADA,
               CD.TOTAL_CHECKLISTS_SAIDA   AS TOTAL_CHECKLISTS_SAIDA,
               CD.TOTAL_CHECKLISTS_RETORNO AS TOTAL_CHECKLISTS_RETORNO
        FROM DIAS D
                 LEFT JOIN CHECKS_DIA CD ON D.DATA = CD.DATA
        ORDER BY D.DATA;
END;
$$;

create or replace function public.func_checklist_relatorio_realizados_abaixo_tempo_definido(f_cod_unidades bigint[],
                                                                                            f_tempo_realizacao_millis bigint,
                                                                                            f_data_hoje_utc date,
                                                                                            f_dias_retroativos_para_buscar bigint)
    returns TABLE
            (
                unidade                                                    text,
                nome                                                       text,
                "QUANTIDADE CHECKLISTS REALIZADOS ABAIXO TEMPO ESPECIFICO" bigint,
                "QUANTIDADE CHECKLISTS REALIZADOS"                         bigint
            )
    language plpgsql
as
$$
DECLARE
    DATA_INICIAL DATE := F_DATA_HOJE_UTC + INTERVAL '1' DAY - (INTERVAL '1' DAY * F_DIAS_RETROATIVOS_PARA_BUSCAR);
    DATA_FINAL   DATE := F_DATA_HOJE_UTC + INTERVAL '1' DAY;
BEGIN
    RETURN QUERY
        WITH PRE_SELECT AS (
            SELECT U.NOME :: TEXT                                              AS NOME_UNIDADE,
                   CO.NOME :: TEXT                                             AS NOME_COLABORADOR,
                   COUNT(CL.CPF_COLABORADOR)
                   FILTER (WHERE TEMPO_REALIZACAO < F_TEMPO_REALIZACAO_MILLIS) AS REALIZADOS_ABAIXO_TEMPO_DEFINIDO,
                   COUNT(CL.CPF_COLABORADOR)                                   AS REALIZADOS
            FROM CHECKLIST CL
                     JOIN UNIDADE U
                          ON CL.COD_UNIDADE = U.CODIGO
                     JOIN COLABORADOR CO
                          ON CO.CPF = CL.CPF_COLABORADOR
            WHERE CL.COD_UNIDADE = ANY (F_COD_UNIDADES)
              AND (CL.DATA_HORA AT TIME ZONE TZ_UNIDADE(CL.COD_UNIDADE)) :: DATE BETWEEN DATA_INICIAL AND DATA_FINAL
            GROUP BY U.CODIGO, CO.CPF, CO.NOME
            ORDER BY REALIZADOS_ABAIXO_TEMPO_DEFINIDO DESC, CO.NOME ASC
        )
        SELECT PS.NOME_UNIDADE,
               PS.NOME_COLABORADOR,
               PS.REALIZADOS_ABAIXO_TEMPO_DEFINIDO,
               PS.REALIZADOS
        FROM PRE_SELECT PS
        WHERE PS.REALIZADOS_ABAIXO_TEMPO_DEFINIDO > 0;
END;
$$;

create or replace function public.func_checklist_relatorio_tempo_realizacao_motoristas(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE"                              text,
                "NOME"                                 text,
                "FUNÇÃO"                               text,
                "CHECKS SAÍDA"                         bigint,
                "CHECKS RETORNO"                       bigint,
                "TOTAL"                                bigint,
                "MÉDIA TEMPO DE REALIZAÇÃO (SEGUNDOS)" numeric
            )
    language sql
as
$$
SELECT U.NOME                                AS NOME_UNIDADE,
       CO.NOME                               AS NOME,
       F.NOME                                AS FUNCAO,
       SUM(CASE
               WHEN C.TIPO = 'S'
                   THEN 1
               ELSE 0 END)                   AS CHECKS_SAIDA,
       SUM(CASE
               WHEN C.TIPO = 'R'
                   THEN 1
               ELSE 0 END)                   AS CHECKS_RETORNO,
       COUNT(C.TIPO)                         AS TOTAL_CHECKS,
       ROUND(AVG(C.TEMPO_REALIZACAO) / 1000) AS MEDIA_SEGUNDOS_REALIZACAO
FROM CHECKLIST C
         JOIN UNIDADE U ON C.COD_UNIDADE = U.CODIGO
         JOIN COLABORADOR CO ON CO.CPF = C.CPF_COLABORADOR
         JOIN FUNCAO F ON F.CODIGO = CO.COD_FUNCAO AND F.COD_EMPRESA = CO.COD_EMPRESA
WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
  AND (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
  AND (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
GROUP BY U.CODIGO, CO.CPF, CO.NOME, F.CODIGO, F.NOME
ORDER BY U.NOME, CO.NOME
$$;

create or replace function suporte.func_colaborador_busca_por_permissao_empresa(f_cod_empresa bigint, f_cod_permissao bigint)
    returns TABLE
            (
                funcionalidade  text,
                permissao       text,
                cod_empresa     bigint,
                empresa         text,
                cod_unidade     bigint,
                unidade         text,
                cod_colaborador bigint,
                colaborador     text,
                cpf             bigint,
                data_nascimento date,
                cargo           text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT FPA.NOME :: TEXT  AS FUNCIONALIDADE,
               FP.FUNCAO :: TEXT AS PERMISSAO,
               E.CODIGO          AS COD_EMPRESA,
               E.NOME :: TEXT    AS EMPRESA,
               U.CODIGO          AS COD_UNIDADE,
               U.NOME :: TEXT    AS UNIDADE,
               C.CODIGO          AS COD_COLABORADOR,
               C.NOME :: TEXT    AS COLABORADOR,
               C.CPF,
               C.DATA_NASCIMENTO,
               F.NOME :: TEXT    AS CARGO
        FROM COLABORADOR C
                 LEFT JOIN CARGO_FUNCAO_PROLOG_V11 CFP ON CFP.COD_FUNCAO_COLABORADOR = C.COD_FUNCAO
            AND CFP.COD_UNIDADE = C.COD_UNIDADE
                 LEFT JOIN UNIDADE U ON U.CODIGO = C.COD_UNIDADE
                 LEFT JOIN EMPRESA E ON E.CODIGO = C.COD_EMPRESA
                 LEFT JOIN FUNCAO F ON F.CODIGO = C.COD_FUNCAO
                 LEFT JOIN FUNCAO_PROLOG_V11 FP ON FP.CODIGO = CFP.COD_FUNCAO_PROLOG
                 LEFT JOIN FUNCAO_PROLOG_AGRUPAMENTO FPA ON FPA.CODIGO = FP.COD_AGRUPAMENTO
        WHERE C.COD_EMPRESA = F_COD_EMPRESA
          AND C.STATUS_ATIVO = TRUE
          AND CFP.COD_FUNCAO_PROLOG = F_COD_PERMISSAO
        ORDER BY UNIDADE, COLABORADOR;
END;
$$;

create or replace function suporte.func_colaborador_busca_vincular_permissao(f_cod_empresa bigint)
    returns TABLE
            (
                funcionalidade  text,
                permissao       text,
                cod_empresa     bigint,
                empresa         text,
                cod_unidade     bigint,
                unidade         text,
                cod_colaborador bigint,
                colaborador     text,
                cpf             bigint,
                data_nascimento date,
                cargo           text
            )
    language plpgsql
as
$$
DECLARE
    F_COD_FUNCAO BIGINT := 329;
BEGIN
    RETURN QUERY
        SELECT *
        FROM SUPORTE.FUNC_COLABORADOR_BUSCA_POR_PERMISSAO_EMPRESA(F_COD_EMPRESA, F_COD_FUNCAO);
END;
$$;

create or replace function suporte.func_colaborador_deleta_colaborador(f_cod_unidade bigint, f_cod_colaborador bigint,
                                                                       f_cpf bigint,
                                                                       OUT aviso_colaborador_deletado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN

    IF ((SELECT COUNT(codigo)
         FROM COLABORADOR_DATA
         WHERE CODIGO = F_COD_COLABORADOR
           AND COD_UNIDADE = F_COD_UNIDADE
           AND CPF = F_CPF) <= 0)
    THEN
        RAISE EXCEPTION 'Nenhum colaborador encontrado com estes parâmetros: Código %, CPF % e Unidade %',
            F_COD_COLABORADOR, F_CPF, F_COD_UNIDADE;
    END IF;

    -- Deleta colaborador.
    UPDATE COLABORADOR_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = F_COD_COLABORADOR
      AND COD_UNIDADE = F_COD_UNIDADE
      AND CPF = F_CPF;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao deletar o colaborador de Código: %, CPF: % e Unidade: %',
            F_COD_COLABORADOR, F_CPF, F_COD_UNIDADE;
    END IF;

    SELECT 'COLABORADOR DELETADO: '
               || F_COD_COLABORADOR
               || ', CPF: '
               || F_CPF
               || ', CÓDIGO DA UNIDADE: '
               || F_COD_UNIDADE
    INTO AVISO_COLABORADOR_DELETADO;
END
$$;

create or replace function public.func_colaborador_relatorio_listagem_colaboradores_by_unidade(f_cod_unidades bigint[])
    returns TABLE
            (
                unidade                     text,
                cpf                         text,
                colaborador                 text,
                "DATA NASCIMENTO"           text,
                pis                         text,
                cargo                       text,
                setor                       text,
                equipe                      text,
                "STATUS"                    text,
                "DATA ADMISSÃO"             text,
                "DATA DEMISSÃO"             text,
                "QTD PERMISSÕES ASSOCIADAS" bigint,
                "MATRÍCULA AMBEV"           text,
                "MATRÍCULA TRANSPORTADORA"  text,
                "NÍVEL ACESSO INFORMAÇÃO"   text,
                "DATA/HORA CADASTRO"        text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT U.NOME :: TEXT                                                            AS NOME_UNIDADE,
               LPAD(CO.CPF :: TEXT, 11, '0')                                             AS CPF_COLABORADOR,
               CO.NOME :: TEXT                                                           AS NOME_COLABORADOR,
               COALESCE(TO_CHAR(CO.DATA_NASCIMENTO, 'DD/MM/YYYY'), '-')                  AS DATA_NASCIMENTO_COLABORADOR,
               COALESCE(LPAD(CO.PIS :: TEXT, 12, '0'), '-')                              AS PIS_COLABORADOR,
               F.NOME :: TEXT                                                            AS NOME_CARGO,
               SE.NOME :: TEXT                                                           AS NOME_SETOR,
               E.NOME :: TEXT                                                            AS NOME_EQUIPE,
               F_IF(CO.STATUS_ATIVO, 'ATIVO' :: TEXT, 'INATIVO' :: TEXT)                 AS STATUS_COLABORADOR,
               COALESCE(TO_CHAR(CO.DATA_ADMISSAO, 'DD/MM/YYYY'), '-')                    AS DATA_ADMISSAO_COLABORADOR,
               COALESCE(TO_CHAR(CO.DATA_DEMISSAO, 'DD/MM/YYYY'), '-')                    AS DATA_DEMISSAO_COLABORADOR,
               COUNT(*)
               FILTER (WHERE CFP.COD_UNIDADE IS NOT NULL
                   -- CONSIDERAMOS APENAS AS PERMISSÕES DE PILARES LIBERADOS PARA A UNIDADE DO COLABORADOR.
                   AND CFP.COD_PILAR_PROLOG IN (SELECT UPP.COD_PILAR
                                                FROM UNIDADE_PILAR_PROLOG UPP
                                                WHERE UPP.COD_UNIDADE = CO.COD_UNIDADE)) AS QTD_PERMISSOES_VINCULADAS,
               COALESCE(CO.MATRICULA_AMBEV :: TEXT,
                        '-')                                                             AS MATRICULA_AMBEV_COLABORADOR,
               COALESCE(CO.MATRICULA_TRANS :: TEXT,
                        '-')                                                             AS MATRICULA_TRANSPORTADORA_COLABORADOR,
               PE.DESCRICAO :: TEXT                                                      AS DESCRICAO_PERMISSAO,
               COALESCE(TO_CHAR(CO.DATA_HORA_CADASTRO AT TIME ZONE TZ_UNIDADE(CO.COD_UNIDADE),
                                'DD/MM/YYYY HH24:MI'),
                        '-')                                                             AS DATA_HORA_CADASTRO_COLABORADOR
        FROM COLABORADOR CO
                 JOIN UNIDADE U
                      ON CO.COD_UNIDADE = U.CODIGO
                 JOIN FUNCAO F
                      ON CO.COD_FUNCAO = F.CODIGO
                 JOIN SETOR SE
                      ON CO.COD_UNIDADE = SE.COD_UNIDADE AND CO.COD_SETOR = SE.CODIGO
                 JOIN EQUIPE E
                      ON CO.COD_EQUIPE = E.CODIGO
                 JOIN PERMISSAO PE
                      ON CO.COD_PERMISSAO = PE.CODIGO
                 JOIN CARGO_FUNCAO_PROLOG_V11 CFP
                      ON CO.COD_FUNCAO = CFP.COD_FUNCAO_COLABORADOR
                          AND CO.COD_UNIDADE = CFP.COD_UNIDADE
        WHERE CO.COD_UNIDADE = ANY (F_COD_UNIDADES)
        GROUP BY U.NOME,
                 CO.CPF,
                 CO.NOME,
                 F.NOME,
                 SE.NOME,
                 E.NOME,
                 CO.STATUS_ATIVO,
                 CO.COD_UNIDADE,
                 CO.DATA_NASCIMENTO,
                 CO.DATA_ADMISSAO,
                 CO.DATA_DEMISSAO,
                 CO.MATRICULA_AMBEV,
                 CO.MATRICULA_TRANS,
                 CO.PIS,
                 PE.DESCRICAO,
                 CO.DATA_HORA_CADASTRO
        ORDER BY U.NOME,
                 CO.NOME,
                 F.NOME,
                 CO.STATUS_ATIVO;
END;
$$;

create or replace function public.func_colaborador_verifica_possui_funcao_prolog(f_cod_colaborador bigint, f_cod_funcao_prolog integer) returns boolean
    language sql
as
$$
SELECT EXISTS(
               SELECT C.CODIGO
               FROM COLABORADOR C
                        JOIN CARGO_FUNCAO_PROLOG_V11 CARGO
                             ON C.COD_UNIDADE = CARGO.COD_UNIDADE
                                 AND C.COD_FUNCAO = CARGO.COD_FUNCAO_COLABORADOR
               WHERE C.CODIGO = F_COD_COLABORADOR
                 AND CARGO.COD_FUNCAO_PROLOG = F_COD_FUNCAO_PROLOG) AS TEM_PERMISSAO
$$;


create or replace function public.func_garante_novo_km_menor_que_atual_veiculo(f_cod_unidade_veiculo bigint, f_placa_veiculo text, f_novo_km bigint) returns void
    language plpgsql
as
$$
DECLARE
    F_COD_EMPRESA CONSTANT      BIGINT := (SELECT U.COD_EMPRESA
                                           FROM UNIDADE U
                                           WHERE U.CODIGO = F_COD_UNIDADE_VEICULO);
    F_KM_ATUAL_VEICULO CONSTANT BIGINT := (SELECT VD.KM
                                           FROM VEICULO_DATA VD
                                           WHERE VD.PLACA = F_PLACA_VEICULO
                                             AND VD.COD_UNIDADE IN
                                                 (SELECT U.CODIGO FROM UNIDADE U WHERE U.COD_EMPRESA = F_COD_EMPRESA));
BEGIN
    IF (F_KM_ATUAL_VEICULO IS NOT NULL AND F_NOVO_KM > F_KM_ATUAL_VEICULO)
    THEN
        RAISE EXCEPTION 'O Km enviado não pode ser maior que o Km atual do veículo : Km enviado %, Km atual %',
            F_NOVO_KM,
            F_KM_ATUAL_VEICULO;
    END IF;
END;
$$;

create or replace function public.func_garante_pneu_existe(f_cod_empresa bigint, f_cod_unidade bigint,
                                                           f_cod_pneu bigint, f_numero_fogo text) returns void
    language plpgsql
as
$$
BEGIN
    IF NOT EXISTS(SELECT P.CODIGO
                  FROM PNEU P
                  WHERE P.CODIGO_CLIENTE = F_NUMERO_FOGO
                    AND P.CODIGO = F_COD_PNEU
                    AND P.COD_UNIDADE = F_COD_UNIDADE
                    AND P.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'Pneu com número de fogo %, código %, não existe na unidade % - %', F_NUMERO_FOGO, F_COD_PNEU,
            F_COD_UNIDADE, (SELECT U.NOME
                            FROM UNIDADE U
                            WHERE U.CODIGO = F_COD_UNIDADE);
    END IF;
END;
$$;

create or replace function public.func_garante_veiculo_existe(f_cod_unidade_veiculo bigint, f_placa_veiculo text) returns void
    language plpgsql
as
$$
BEGIN
    IF NOT EXISTS(SELECT VD.CODIGO
                  FROM VEICULO_DATA VD
                  WHERE VD.PLACA = F_PLACA_VEICULO
                    AND VD.COD_UNIDADE = F_COD_UNIDADE_VEICULO)
    THEN
        RAISE EXCEPTION
            'Não foi possível encontrar o veículo com estes parâmetros: Unidade %, Placa %',
            F_COD_UNIDADE_VEICULO,
            F_PLACA_VEICULO;
    END IF;
END;
$$;

create or replace function public.func_get_data_fim_produtividade(f_ano integer, f_mes integer, f_cpf bigint, f_cod_unidade bigint) returns date
    language plpgsql
as
$$
DECLARE
BEGIN
    RETURN (func_get_data_inicio_produtividade(f_ano, f_mes, f_cpf, f_cod_unidade) + '1 month'::INTERVAL) +
           '-1 day'::INTERVAL;
END;
$$;

create or replace function public.func_get_data_inicio_produtividade(f_ano integer, f_mes integer, f_cod_unidade bigint) returns date
    language plpgsql
as
$$
DECLARE
    dia int;
BEGIN
    select (select dia_inicio_produtividade from unidade_funcao_produtividade where cod_unidade = f_cod_unidade)
    into dia;
    case
        when dia is null then
            raise notice 'Error';
        end case;
    RETURN CONCAT(f_ano, '-', f_mes, '-', dia);
END;
$$;

create or replace function public.func_get_data_inicio_produtividade(f_ano integer, f_mes integer, f_cpf bigint, f_cod_unidade bigint) returns date
    language plpgsql
as
$$
DECLARE
    dia               INT;
    error_msg         TEXT;
    cod_unidade_busca BIGINT;
BEGIN
    CASE WHEN f_cpf IS NULL THEN
        cod_unidade_busca := f_cod_unidade;
        ELSE
            cod_unidade_busca := (SELECT COD_UNIDADE FROM COLABORADOR WHERE CPF = f_cpf);
        END CASE;
    SELECT (SELECT dia_inicio_produtividade FROM unidade_funcao_produtividade WHERE cod_unidade = cod_unidade_busca)
    INTO dia;
    CASE
        WHEN dia IS NULL THEN
            error_msg := 'Unidade ' || cod_unidade_busca || ' não possui dia de inicio da produtividade';
            RAISE EXCEPTION '%', error_msg;

        WHEN f_mes = 1 AND dia >= 15 THEN
            RETURN CONCAT(f_ano - 1, '-', 12, '-', dia);

        WHEN f_mes <> 1 AND dia >= 15 THEN
            RETURN CONCAT(f_ano, '-', f_mes - 1, '-', dia);

        WHEN dia < 15 THEN
            RETURN CONCAT(f_ano, '-', f_mes, '-', dia);
        END CASE;
END;
$$;

create or replace function public.func_get_produtividade_colaborador(f_mes integer, f_ano integer, f_cpf bigint)
    returns TABLE
            (
                cod_unidade                integer,
                matricula_ambev            integer,
                data                       date,
                cpf                        bigint,
                nome_colaborador           character varying,
                data_nascimento            date,
                funcao                     character varying,
                cod_funcao                 bigint,
                nome_equipe                character varying,
                fator                      real,
                cargaatual                 character varying,
                entrega                    character varying,
                mapa                       integer,
                placa                      character varying,
                cxcarreg                   real,
                cxentreg                   real,
                qthlcarregados             real,
                qthlentregues              real,
                qtnfcarregadas             integer,
                qtnfentregues              integer,
                entregascompletas          integer,
                entregasnaorealizadas      integer,
                entregasparciais           integer,
                kmprevistoroad             real,
                kmsai                      integer,
                kmentr                     integer,
                tempoprevistoroad          integer,
                hrsai                      timestamp without time zone,
                hrentr                     timestamp without time zone,
                tempo_rota                 integer,
                tempointerno               integer,
                hrmatinal                  time without time zone,
                apontamentos_ok            bigint,
                total_tracking             bigint,
                tempo_largada              integer,
                meta_tracking              real,
                meta_tempo_rota_mapas      real,
                meta_caixa_viagem          real,
                meta_dev_hl                real,
                meta_dev_nf                real,
                meta_dev_pdv               real,
                meta_dispersao_km          real,
                meta_dispersao_tempo       real,
                meta_jornada_liquida_mapas real,
                meta_raio_tracking         real,
                meta_tempo_interno_mapas   real,
                meta_tempo_largada_mapas   real,
                meta_tempo_rota_horas      integer,
                meta_tempo_interno_horas   integer,
                meta_tempo_largada_horas   integer,
                meta_jornada_liquida_horas integer,
                valor_rota                 real,
                valor_recarga              real,
                valor_diferenca_eld        double precision,
                valor_as                   real,
                valor                      double precision
            )
    language sql
as
$$
SELECT *
FROM VIEW_PRODUTIVIDADE_EXTRATO
WHERE DATA BETWEEN func_get_data_inicio_produtividade(f_ano, f_mes, f_cpf, null) AND
    func_get_data_fim_produtividade(f_ano, f_mes, f_cpf, null)
  AND cpf = f_cpf
ORDER BY DATA ASC
$$;

create or replace function public.func_get_produtividade_consolidado_colaboradores(f_data_inicial date,
                                                                                   f_data_final date,
                                                                                   f_cod_unidade bigint, f_equipe text,
                                                                                   f_funcao text)
    returns TABLE
            (
                cpf             bigint,
                matricula_ambev integer,
                nome            text,
                data_nascimento date,
                funcao          text,
                mapas           bigint,
                caixas          real,
                valor           double precision
            )
    language sql
as
$$
SELECT cpf,
       matricula_ambev,
       nome_colaborador AS nome,
       data_nascimento,
       funcao,
       count(mapa)      as mapas,
       sum(cxentreg)    as caixas,
       sum(valor)       as valor
FROM VIEW_PRODUTIVIDADE_EXTRATO
WHERE data between (f_data_inicial AT TIME ZONE (SELECT TIMEZONE FROM func_get_time_zone_unidade(f_cod_unidade)))
    and (f_data_final AT TIME ZONE (SELECT TIMEZONE FROM func_get_time_zone_unidade(f_cod_unidade)))
  and cod_unidade = f_cod_unidade
  and nome_equipe like f_equipe
  and cod_funcao::text like f_funcao
GROUP BY 1, 2, 3, 4, 5
order by funcao, valor desc, nome
$$;

create or replace function public.func_intervalos_get_marcacoes_colaborador(f_cod_unidade bigint,
                                                                            f_cpf_colaborador bigint,
                                                                            f_cod_tipo_intervalo bigint, f_limit bigint,
                                                                            f_offset bigint)
    returns TABLE
            (
                cod_unidade                     bigint,
                cod_tipo_intervalo              bigint,
                nome_tipo_intervalo             text,
                cpf_colaborador                 bigint,
                data_hora_inicio                timestamp without time zone,
                data_hora_fim                   timestamp without time zone,
                fonte_data_hora_inicio          text,
                fonte_data_hora_fim             text,
                justificativa_tempo_recomendado text,
                justificativa_estouro           text,
                latitude_marcacao_inicio        text,
                latitude_marcacao_fim           text,
                longitude_marcacao_inicio       text,
                longitude_marcacao_fim          text
            )
    language sql
as
$$
SELECT I.COD_UNIDADE                                             AS COD_UNIDADE,
       I.COD_TIPO_INTERVALO                                      AS COD_TIPO_INTERVALO,
       IT.NOME                                                   AS NOME_TIPO_INTERVALO,
       I.CPF_COLABORADOR                                         AS CPF_COLABORADOR,
       I.DATA_HORA_INICIO AT TIME ZONE tz_unidade(I.COD_UNIDADE) AS DATA_HORA_INICIO,
       I.DATA_HORA_FIM AT TIME ZONE tz_unidade(I.COD_UNIDADE)    AS DATA_HORA_FIM,
       I.FONTE_DATA_HORA_INICIO                                  AS FONTE_DATA_HORA_INICIO,
       I.FONTE_DATA_HORA_FIM                                     AS FONTE_DATA_HORA_FIM,
       I.JUSTIFICATIVA_TEMPO_RECOMENDADO                         AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
       I.JUSTIFICATIVA_ESTOURO                                   AS JUSTIFICATIVA_ESTOURO,
       I.LATITUDE_MARCACAO_INICIO                                AS LATITUDE_MARCACAO_INICIO,
       I.LATITUDE_MARCACAO_FIM                                   AS LATITUDE_MARCACAO_FIM,
       I.LONGITUDE_MARCACAO_INICIO                               AS LONGITUDE_MARCACAO_INICIO,
       I.LONGITUDE_MARCACAO_FIM                                  AS LONGITUDE_MARCACAO_FIM
FROM FUNC_INTERVALOS_AGRUPADOS(f_cod_unidade, f_cpf_colaborador, f_cod_tipo_intervalo) AS I
         JOIN INTERVALO_TIPO AS IT
              ON I.COD_TIPO_INTERVALO = IT.CODIGO
ORDER BY COALESCE(DATA_HORA_INICIO, DATA_HORA_FIM) DESC
LIMIT f_limit OFFSET f_offset;
$$;

create or replace function public.func_marcacao_atualiza_infos_tipo_jornada_unidade(f_cod_unidade bigint, f_novo_cod_tipo_jornada bigint) returns boolean
    language plpgsql
as
$$
DECLARE
    QTDROWS BIGINT;
BEGIN
    DELETE FROM MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA WHERE COD_UNIDADE = F_COD_UNIDADE;
    DELETE FROM MARCACAO_TIPO_JORNADA WHERE COD_UNIDADE = F_COD_UNIDADE;

    INSERT INTO MARCACAO_TIPO_JORNADA (COD_UNIDADE, COD_TIPO_JORNADA) VALUES (F_COD_UNIDADE, F_NOVO_COD_TIPO_JORNADA);
    GET DIAGNOSTICS QTDROWS = ROW_COUNT;
    IF QTDROWS = 1
    THEN
        RETURN TRUE;
    ELSE
        RAISE EXCEPTION 'Erro ao inserir tipo como jornada. Unidade: % e Tipo: %', F_COD_UNIDADE, F_NOVO_COD_TIPO_JORNADA;
    END IF;
END;
$$;

create or replace function public.func_marcacao_busca_cod_marcacao(f_cod_unidade bigint, f_cpf_colaborador bigint,
                                                                   f_tipo_marcacao text,
                                                                   f_data_hora timestamp with time zone) returns bigint
    language sql
as
$$
SELECT I.CODIGO AS CODIGO
FROM INTERVALO I
WHERE I.COD_UNIDADE = F_COD_UNIDADE
  AND I.CPF_COLABORADOR = F_CPF_COLABORADOR
  AND I.DATA_HORA = F_DATA_HORA
  AND I.TIPO_MARCACAO = F_TIPO_MARCACAO;
$$;

create or replace function public.func_marcacao_busca_justificativas_ajustes(f_cod_empresa bigint, f_ativas boolean)
    returns TABLE
            (
                codigo            bigint,
                cod_empresa       bigint,
                nome              text,
                obriga_observacao boolean,
                status_ativo      boolean
            )
    language sql
as
$$
SELECT JA.CODIGO,
       JA.COD_EMPRESA,
       JA.NOME,
       JA.OBRIGA_OBSERVACAO,
       JA.STATUS_ATIVO
FROM MARCACAO_JUSTIFICATIVA_AJUSTE JA
WHERE (JA.COD_EMPRESA = F_COD_EMPRESA AND F_IF(F_ATIVAS IS NULL, TRUE, F_ATIVAS = JA.STATUS_ATIVO))
   OR (JA.COD_EMPRESA IS NULL AND JA.STATUS_ATIVO = TRUE);
$$;

create or replace function public.func_marcacao_busca_marcacao_em_andamento(f_cod_unidade bigint,
                                                                            f_cod_tipo_intervalo bigint,
                                                                            f_cpf_colaborador bigint)
    returns TABLE
            (
                cod_marcacao_por_unidade        bigint,
                codigo                          bigint,
                cod_unidade                     bigint,
                cod_tipo_intervalo              bigint,
                cpf_colaborador                 bigint,
                data_nascimento_colaborador     date,
                data_hora                       timestamp without time zone,
                tipo_marcacao                   text,
                fonte_data_hora                 text,
                justificativa_tempo_recomendado text,
                justificativa_estouro           text,
                latitude_marcacao               text,
                longitude_marcacao              text,
                valido                          boolean,
                foi_editado                     boolean,
                cod_colaborador_insercao        bigint,
                status_ativo                    boolean,
                data_hora_sincronizacao         timestamp without time zone
            )
    language sql
as
$$
WITH INTERVALO_MARCACAO AS (
    SELECT I.CODIGO_MARCACAO_POR_UNIDADE,
           I.CODIGO,
           I.COD_UNIDADE,
           I.COD_TIPO_INTERVALO,
           I.CPF_COLABORADOR,
           C.DATA_NASCIMENTO                                                AS DATA_NASCIMENTO_COLABORADOR,
           I.DATA_HORA AT TIME ZONE TZ_UNIDADE(I.COD_UNIDADE)               AS DATA_HORA,
           I.TIPO_MARCACAO,
           I.FONTE_DATA_HORA,
           I.JUSTIFICATIVA_TEMPO_RECOMENDADO,
           I.JUSTIFICATIVA_ESTOURO,
           I.LATITUDE_MARCACAO,
           I.LONGITUDE_MARCACAO,
           I.VALIDO,
           I.FOI_AJUSTADO,
           I.COD_COLABORADOR_INSERCAO,
           I.STATUS_ATIVO,
           I.DATA_HORA_SINCRONIZACAO AT TIME ZONE TZ_UNIDADE(I.COD_UNIDADE) AS DATA_HORA_SINCRONIZACAO
    FROM VIEW_INTERVALO I
             JOIN COLABORADOR C
                  ON I.CPF_COLABORADOR = C.CPF
    WHERE I.COD_UNIDADE = F_COD_UNIDADE
      AND I.COD_TIPO_INTERVALO = F_COD_TIPO_INTERVALO
      AND I.CPF_COLABORADOR = F_CPF_COLABORADOR
    ORDER BY I.CODIGO DESC
    LIMIT 1
)

SELECT *
FROM INTERVALO_MARCACAO IM
WHERE NOT EXISTS(SELECT MVIF.COD_MARCACAO_INICIO
                 FROM MARCACAO_VINCULO_INICIO_FIM MVIF
                 WHERE MVIF.COD_MARCACAO_INICIO = IM.CODIGO)
  AND IM.TIPO_MARCACAO = 'MARCACAO_INICIO'
  AND IM.VALIDO = TRUE
  AND IM.STATUS_ATIVO = TRUE;
$$;

create or replace function public.func_marcacao_busca_marcacao_vinculo_by_marcacao(f_cod_unidade bigint,
                                                                                   f_cod_tipo_intervalo bigint,
                                                                                   f_cpf_colaborador bigint) returns bigint
    language sql
as
$$
WITH INTERVALOS AS (
    SELECT I.*,
           (CASE
                WHEN ((SELECT CODIGO
                       FROM MARCACAO_VINCULO_INICIO_FIM MVIF
                       WHERE MVIF.COD_MARCACAO_INICIO = I.CODIGO
                          OR MVIF.COD_MARCACAO_FIM = I.CODIGO) IS NULL)
                    THEN FALSE
                ELSE TRUE END) AS POSSUI_VINCULO
    FROM INTERVALO I
    WHERE I.COD_UNIDADE = F_COD_UNIDADE
      AND I.COD_TIPO_INTERVALO = F_COD_TIPO_INTERVALO
      AND I.CPF_COLABORADOR = F_CPF_COLABORADOR
      AND I.STATUS_ATIVO = TRUE
      AND I.FOI_AJUSTADO = FALSE
    ORDER BY I.DATA_HORA DESC
),

     MARCACAO AS (
         SELECT I.CODIGO,
                I.TIPO_MARCACAO,
                I.POSSUI_VINCULO
         FROM INTERVALOS I
         LIMIT 1
     )

SELECT (CASE
            WHEN ((SELECT M.TIPO_MARCACAO FROM MARCACAO M) = 'MARCACAO_INICIO'
                AND NOT (SELECT POSSUI_VINCULO FROM MARCACAO))
                THEN (SELECT CODIGO FROM MARCACAO)
            ELSE NULL END) AS CODIGO;
$$;

create or replace function public.func_marcacao_calcula_total_segundos_em_horas_noturnas(f_data_hora_inicio timestamp with time zone,
                                                                                         f_data_hora_fim timestamp with time zone,
                                                                                         f_timezone_para_calculo text) returns bigint
    language plpgsql
as
$$
DECLARE
    RANGE_INICIO_FIM     TSTZRANGE;
    TOTAL_HORAS_NOTURNAS BIGINT;
    DATA_HORA_INICIO_TZ  TIMESTAMPTZ := F_DATA_HORA_INICIO AT TIME ZONE F_TIMEZONE_PARA_CALCULO;
    DATA_HORA_FIM_TZ     TIMESTAMPTZ := F_DATA_HORA_FIM AT TIME ZONE F_TIMEZONE_PARA_CALCULO;
BEGIN
    -- O range não pode ter o lower bound após o upper bound, por isso essa verificação.
    IF F_DATA_HORA_INICIO < F_DATA_HORA_FIM
    THEN
        RANGE_INICIO_FIM := TSTZRANGE(DATA_HORA_INICIO_TZ, DATA_HORA_FIM_TZ);
    ELSE
        RANGE_INICIO_FIM := TSTZRANGE(DATA_HORA_FIM_TZ, DATA_HORA_INICIO_TZ);
    END IF;

    WITH DIAS AS (
        SELECT GENERATE_SERIES(DATA_HORA_INICIO_TZ :: DATE,
                               DATA_HORA_FIM_TZ :: DATE + '1 DAY' :: INTERVAL,
                               '1 DAY') :: DATE AS DIA
    ),
         RANGES AS (
             SELECT *
             FROM DIAS
                      CROSS JOIN TSTZRANGE(((DIAS.DIA :: DATE || ' 22:00:00') :: TIMESTAMP) AT TIME ZONE
                                           F_TIMEZONE_PARA_CALCULO - '1 DAY' :: INTERVAL,
                                           ((DIAS.DIA :: DATE || ' 05:00:00') :: TIMESTAMP) AT TIME ZONE
                                           F_TIMEZONE_PARA_CALCULO) AS RANGE_VERIFICACAO_DIA
         )

    SELECT SUM(TO_SECONDS(COALESCE(UPPER(R.I) - LOWER(R.I), '0' :: INTERVAL)))
    FROM (SELECT *,
                 RANGE_INICIO_FIM * R.RANGE_VERIFICACAO_DIA AS I
          FROM RANGES R) R
    INTO TOTAL_HORAS_NOTURNAS;

    RETURN TOTAL_HORAS_NOTURNAS;
END;
$$;

create or replace function public.func_marcacao_get_colaboradores_em_descanso(f_cod_unidade bigint,
                                                                              f_cod_cargos bigint[],
                                                                              f_data_hora_atual_utc timestamp with time zone)
    returns TABLE
            (
                nome_colaborador               text,
                data_hora_inicio_ultima_viagem timestamp without time zone,
                data_hora_fim_ultima_viagem    timestamp without time zone,
                duracao_ultima_viagem          bigint,
                tempo_descanso_segundos        bigint,
                foi_ajustado_inicio            boolean,
                foi_ajustado_fim               boolean
            )
    language plpgsql
as
$$
DECLARE
    COD_TIPO_JORNADA BIGINT;
    TZ_UNIDADE       TEXT;
BEGIN
    SELECT U.TIMEZONE
    FROM UNIDADE U
    WHERE U.CODIGO = F_COD_UNIDADE
    INTO TZ_UNIDADE;

    SELECT VIT.CODIGO
    FROM VIEW_INTERVALO_TIPO VIT
    WHERE VIT.COD_UNIDADE = F_COD_UNIDADE
      AND VIT.TIPO_JORNADA
    INTO COD_TIPO_JORNADA;

    IF COD_TIPO_JORNADA IS NULL OR COD_TIPO_JORNADA <= 0
    THEN
        RAISE EXCEPTION 'Unidade não possui nenhum tipo de marcação definido como jornada';
    END IF;

    RETURN QUERY
        -- SELECT DISTINCT ON ( EXPRESSION [, ...] ) KEEPS ONLY THE FIRST ROW OF EACH SET OF ROWS WHERE THE GIVEN EXPRESSIONS EVALUATE TO EQUAL.
        -- DOCS: HTTPS://WWW.POSTGRESQL.ORG/DOCS/9.5/SQL-SELECT.HTML#SQL-DISTINCT
        WITH ULTIMA_MARCACAO_JORNADA_COLABORADORES AS (
            SELECT DISTINCT ON (F.CPF_COLABORADOR) INITCAP(C.NOME)       AS NOME,
                                                   F.DATA_HORA_INICIO    AS DATA_HORA_INICIO,
                                                   F.DATA_HORA_FIM       AS DATA_HORA_FIM,
                                                   F.COD_MARCACAO_INICIO AS COD_MARCACAO_INICIO,
                                                   F.COD_MARCACAO_FIM    AS COD_MARCACAO_FIM,
                                                   F.STATUS_ATIVO_INICIO AS STATUS_ATIVO_INICIO,
                                                   F.STATUS_ATIVO_FIM    AS STATUS_ATIVO_FIM,
                                                   F.FOI_AJUSTADO_INICIO AS FOI_AJUSTADO_INICIO,
                                                   F.FOI_AJUSTADO_FIM    AS FOI_AJUSTADO_FIM
            FROM FUNC_INTERVALOS_AGRUPADOS(F_COD_UNIDADE, NULL, COD_TIPO_JORNADA) F
                     JOIN COLABORADOR C
                          ON C.CPF = F.CPF_COLABORADOR
            WHERE C.COD_FUNCAO = ANY (F_COD_CARGOS)
              AND C.STATUS_ATIVO
            ORDER BY F.CPF_COLABORADOR,
                     COALESCE(F.COD_MARCACAO_INICIO, F.COD_MARCACAO_FIM) DESC
        )

        SELECT UMJC.NOME :: TEXT                                      AS NOME_COLABORADOR,
               UMJC.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE          AS DATA_HORA_INICIO_ULTIMA_VIAGEM,
               UMJC.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE             AS DATA_HORA_FIM_ULTIMA_VIAGEM,
               TO_SECONDS(UMJC.DATA_HORA_FIM - UMJC.DATA_HORA_INICIO) AS DURACAO_ULTIMA_VIAGEM,
               TO_SECONDS(F_DATA_HORA_ATUAL_UTC - UMJC.DATA_HORA_FIM) AS TEMPO_DESCANSO_SEGUNDOS,
               UMJC.FOI_AJUSTADO_INICIO                               AS FOI_AJUSTADO_INICIO,
               UMJC.FOI_AJUSTADO_FIM                                  AS FOI_AJUSTADO_FIM
        FROM ULTIMA_MARCACAO_JORNADA_COLABORADORES UMJC
        WHERE
          -- Precisamos filtrar isso apenas depois de pegarmos a última marcação de jornada de um colaborador,
          -- pois nesse caso pegaremos até mesmo marcações inativas e em andamento. Se fôssemos filtrar na CTE anterior,
          -- poderíamos acabar removendo antes as em andamento e inativas e trazer como última jornada do colaborador uma que
          -- pode ter sido finalizada a até um mês atrás. Ou mesmo uma que está inativa.

          -- Filtramos apenas por fim not null, pois iremos considerar como em descanso, marcações que tem apenas fim.
            UMJC.COD_MARCACAO_FIM IS NOT NULL
          -- Se apenas início ou fim estiverem ativos, queremos trazer essa linha.
          AND (UMJC.STATUS_ATIVO_INICIO OR UMJC.STATUS_ATIVO_FIM);
END;
$$;

create or replace function public.func_marcacao_get_colaboradores_jornada_em_andamento(f_cod_unidade bigint,
                                                                                       f_cod_cargos bigint[],
                                                                                       f_data_hora_atual_utc timestamp with time zone)
    returns TABLE
            (
                nome_colaborador                           text,
                cpf_colaborador                            bigint,
                cod_inicio_jornada                         bigint,
                data_hora_inicio_jornada                   timestamp without time zone,
                foi_ajustado_inicio_jornada                boolean,
                duracao_jornada_sem_descontos_segundos     bigint,
                descontos_jornada_bruta_segundos           bigint,
                duracao_jornada_bruta_segundos             bigint,
                descontos_jornada_liquida_segundos         bigint,
                duracao_jornada_liquida_segundos           bigint,
                cod_marcacao_inicio                        bigint,
                cod_marcacao_fim                           bigint,
                data_hora_inicio                           timestamp without time zone,
                data_hora_fim                              timestamp without time zone,
                marcacao_em_andamento                      boolean,
                duracao_marcacao_segundos                  bigint,
                foi_ajustado_inicio                        boolean,
                foi_ajustado_fim                           boolean,
                cod_tipo_marcacao                          bigint,
                nome_tipo_marcacao                         text,
                total_marcacoes_dentro_jornada_colaborador bigint
            )
    language plpgsql
as
$$
DECLARE
    COD_TIPO_JORNADA              BIGINT   := (SELECT VIT.CODIGO
                                               FROM VIEW_INTERVALO_TIPO VIT
                                               WHERE VIT.COD_UNIDADE = F_COD_UNIDADE
                                                 AND VIT.TIPO_JORNADA);
    TZ_UNIDADE                    TEXT     := (SELECT U.TIMEZONE
                                               FROM UNIDADE U
                                               WHERE U.CODIGO = F_COD_UNIDADE);
    COD_TIPOS_DESCONTADOS_BRUTA   BIGINT[] := (SELECT ARRAY_AGG(COD_TIPO_DESCONTADO)
                                               FROM MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA M
                                               WHERE M.COD_UNIDADE = F_COD_UNIDADE
                                                 AND M.DESCONTA_JORNADA_BRUTA);
    COD_TIPOS_DESCONTADOS_LIQUIDA BIGINT[] := (SELECT ARRAY_AGG(COD_TIPO_DESCONTADO)
                                               FROM MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA M
                                               WHERE M.COD_UNIDADE = F_COD_UNIDADE
                                                 AND M.DESCONTA_JORNADA_LIQUIDA);
BEGIN
    IF COD_TIPO_JORNADA IS NULL OR COD_TIPO_JORNADA <= 0
    THEN
        RAISE EXCEPTION 'Unidade não possui nenhum tipo de marcação definido como jornada';
    END IF;

    RETURN QUERY
        WITH MARCACOES AS (
            SELECT INITCAP(C.NOME)                        AS NOME_COLABORADOR,
                   C.CPF                                  AS CPF_COLABORADOR,
                   F.COD_MARCACAO_INICIO                  AS COD_MARCACAO_INICIO,
                   F.COD_MARCACAO_FIM                     AS COD_MARCACAO_FIM,
                   F.DATA_HORA_INICIO                     AS DATA_HORA_INICIO,
                   F.DATA_HORA_FIM                        AS DATA_HORA_FIM,
                   -- Algumas comparações abaixo assumem que o status será sempre diferente de NULL.
                   COALESCE(F.FOI_AJUSTADO_INICIO, FALSE) AS FOI_AJUSTADO_INICIO,
                   COALESCE(F.FOI_AJUSTADO_FIM, FALSE)    AS FOI_AJUSTADO_FIM,
                   COALESCE(F.STATUS_ATIVO_INICIO, FALSE) AS STATUS_ATIVO_INICIO,
                   COALESCE(F.STATUS_ATIVO_FIM, FALSE)    AS STATUS_ATIVO_FIM,
                   F.COD_TIPO_INTERVALO                   AS COD_TIPO_MARCACAO
            FROM FUNC_INTERVALOS_AGRUPADOS(F_COD_UNIDADE, NULL, NULL) F
                     JOIN COLABORADOR C
                          ON C.CPF = F.CPF_COLABORADOR
            WHERE C.COD_FUNCAO = ANY (F_COD_CARGOS)
              AND C.STATUS_ATIVO
        ),

             ULTIMA_MARCACAO_JORNADA_COLABORADORES AS (
                 SELECT DISTINCT ON (M.CPF_COLABORADOR) M.CPF_COLABORADOR     AS CPF_COLABORADOR,
                                                        M.NOME_COLABORADOR    AS NOME_COLABORADOR,
                                                        M.COD_MARCACAO_INICIO AS COD_INICIO_JORNADA,
                                                        M.COD_MARCACAO_FIM    AS COD_FIM_JORNADA,
                                                        M.DATA_HORA_INICIO    AS DATA_HORA_INICIO_JORNADA,
                                                        M.FOI_AJUSTADO_INICIO AS FOI_AJUSTADO_INICIO_JORNADA,
                                                        M.STATUS_ATIVO_INICIO AS STATUS_ATIVO_INICIO_JORNADA
                 FROM MARCACOES M
                 WHERE M.COD_TIPO_MARCACAO = COD_TIPO_JORNADA
                 ORDER BY M.CPF_COLABORADOR,
                          COALESCE(M.COD_MARCACAO_INICIO, M.COD_MARCACAO_FIM) DESC
             ),

             JORNADAS_EM_ABERTO AS (
                 SELECT UMJC.CPF_COLABORADOR             AS CPF_COLABORADOR,
                        UMJC.NOME_COLABORADOR            AS NOME_COLABORADOR,
                        UMJC.COD_INICIO_JORNADA          AS COD_INICIO_JORNADA,
                        UMJC.DATA_HORA_INICIO_JORNADA    AS DATA_HORA_INICIO_JORNADA,
                        UMJC.FOI_AJUSTADO_INICIO_JORNADA AS FOI_AJUSTADO_INICIO_JORNADA
                 FROM ULTIMA_MARCACAO_JORNADA_COLABORADORES UMJC
                 WHERE
                   -- Precisamos filtrar isso apenas depois de pegarmos a última marcação de jornada de um colaborador,
                   -- pois nesse caso pegaremos até mesmo marcações inativas e em andamento. Se fôssemos filtrar na CTE anterior,
                   -- poderíamos acabar removendo antes as em andamento e inativas e trazer como última jornada do colaborador uma que
                   -- pode ter sido finalizada a até um mês atrás. Ou mesmo uma que está inativa.
                     UMJC.COD_INICIO_JORNADA IS NOT NULL
                   AND UMJC.COD_FIM_JORNADA IS NULL
                   AND UMJC.STATUS_ATIVO_INICIO_JORNADA
             ),

             JORNADAS_COM_MARCACOES AS (
                 SELECT
                     -- Pegamos CPF e nome da jornada pois o colaborador pode não ter outras marcações.
                     JA.CPF_COLABORADOR                                          AS CPF_COLABORADOR,
                     JA.NOME_COLABORADOR                                         AS NOME_COLABORADOR,
                     M.COD_MARCACAO_INICIO                                       AS COD_MARCACAO_INICIO,
                     M.COD_MARCACAO_FIM                                          AS COD_MARCACAO_FIM,
                     M.DATA_HORA_INICIO                                          AS DATA_HORA_INICIO,
                     M.DATA_HORA_FIM                                             AS DATA_HORA_FIM,
                     M.FOI_AJUSTADO_INICIO                                       AS FOI_AJUSTADO_INICIO,
                     M.FOI_AJUSTADO_FIM                                          AS FOI_AJUSTADO_FIM,
                     M.STATUS_ATIVO_INICIO                                       AS STATUS_ATIVO_INICIO,
                     M.STATUS_ATIVO_FIM                                          AS STATUS_ATIVO_FIM,
                     M.COD_TIPO_MARCACAO                                         AS COD_TIPO_MARCACAO,
                     JA.COD_INICIO_JORNADA                                       AS COD_INICIO_JORNADA,
                     JA.DATA_HORA_INICIO_JORNADA                                 AS DATA_HORA_INICIO_JORNADA,
                     JA.FOI_AJUSTADO_INICIO_JORNADA                              AS FOI_AJUSTADO_INICIO_JORNADA,
                     F_DATA_HORA_ATUAL_UTC - JA.DATA_HORA_INICIO_JORNADA         AS DURACAO_JORNADA,
                     -- Precisamos garantir que só usamos na conta marcações de início e fim ativas. Se uma delas for inativa
                     -- o resultado será nulo. Isso não tem problema, pois na CTE seguinte, o SUM lida com o null usando um
                     -- COALESCE.
                     COALESCE(F_IF(M.STATUS_ATIVO_FIM, M.DATA_HORA_FIM, NULL),
                              F_DATA_HORA_ATUAL_UTC)
                         - F_IF(M.STATUS_ATIVO_INICIO, M.DATA_HORA_INICIO, NULL) AS DURACAO_MARCACAO
                 FROM JORNADAS_EM_ABERTO JA
                          LEFT JOIN MARCACOES M
                                    ON JA.CPF_COLABORADOR = M.CPF_COLABORADOR
                                        AND M.COD_TIPO_MARCACAO <> COD_TIPO_JORNADA
                                        -- Verifica se início e fim são após o início da jornada ou se apenas o início é após
                                        -- desde que não tenha fim, ou se é um fim avulso realizado no período da jornada.
                                        AND
                                       ((M.DATA_HORA_INICIO >= JA.DATA_HORA_INICIO_JORNADA
                                           AND M.DATA_HORA_FIM >= JA.DATA_HORA_INICIO_JORNADA
                                           AND M.DATA_HORA_FIM <= F_DATA_HORA_ATUAL_UTC)
                                           OR
                                        (M.DATA_HORA_INICIO >= JA.DATA_HORA_INICIO_JORNADA
                                            AND M.DATA_HORA_INICIO <= F_DATA_HORA_ATUAL_UTC
                                            AND M.DATA_HORA_FIM IS NULL)
                                           OR
                                        (M.DATA_HORA_INICIO IS NULL
                                            AND M.DATA_HORA_FIM >= JA.DATA_HORA_INICIO_JORNADA
                                            AND M.DATA_HORA_FIM <= F_DATA_HORA_ATUAL_UTC))
                 WHERE
                    -- Inserimos dentro da jornada apenas as marções que possuirem Início ou Fim ativos.
                    -- Não podemos fazer essa verificação na cte MARCACOES para não retirar as marcações de jornadas inativas
                    -- causando erro na busca. Importante lembrar que o colaborador pode ter uma jornada sem marcações dentro,
                    -- por isso o F_IF é necessário.
                     F_IF(M.COD_TIPO_MARCACAO IS NULL, TRUE, M.STATUS_ATIVO_INICIO)
                    OR F_IF(M.COD_TIPO_MARCACAO IS NULL, TRUE, M.STATUS_ATIVO_FIM)
                 ORDER BY JA.CPF_COLABORADOR, JA.DATA_HORA_INICIO_JORNADA, M.DATA_HORA_INICIO
             ),

             MARCACOES_E_DESCONTOS_JORNADA AS (
                 SELECT JCM.*,
                        -- Precisamos do coalesce pois esses dois SUMs podem retornar null, se retornarem null, quando formos
                        -- descontar esses valores no SELECT abaixo do tempo total da jornada, iremos tornar o tempo total da jornada
                        -- nulo também, o que está incorreto.
                        COALESCE(SUM(JCM.DURACAO_MARCACAO)
                                 FILTER (WHERE JCM.COD_TIPO_MARCACAO = ANY (COD_TIPOS_DESCONTADOS_BRUTA))
                                     OVER CPFS, INTERVAL '0') AS DESCONTOS_JORNADA_BRUTA,
                        COALESCE(SUM(JCM.DURACAO_MARCACAO)
                                 FILTER (WHERE JCM.COD_TIPO_MARCACAO = ANY (COD_TIPOS_DESCONTADOS_LIQUIDA))
                                     OVER CPFS, INTERVAL '0') AS DESCONTOS_JORNADA_LIQUIDA,
                        -- Marcações com início e fim contam como 2, avulsas 1, sem nada 0.
                        SUM(CASE
                                WHEN JCM.STATUS_ATIVO_INICIO AND JCM.STATUS_ATIVO_FIM
                                    THEN 2
                                WHEN ((JCM.STATUS_ATIVO_INICIO AND NOT JCM.STATUS_ATIVO_FIM) OR
                                      (NOT JCM.STATUS_ATIVO_INICIO AND JCM.STATUS_ATIVO_FIM))
                                    THEN 1
                                ELSE 0
                            END)
                        OVER CPFS                             AS TOTAL_MARCACOES_DENTRO_JORNADA_COLABORADOR
                 FROM JORNADAS_COM_MARCACOES JCM WINDOW CPFS AS (
                     PARTITION BY JCM.CPF_COLABORADOR )
             )

        SELECT M.NOME_COLABORADOR :: TEXT                                                    AS NOME_COLABORADOR,
               M.CPF_COLABORADOR                                                             AS CPF_COLABORADOR,
               M.COD_INICIO_JORNADA                                                          AS COD_INICIO_JORNADA,
               M.DATA_HORA_INICIO_JORNADA AT TIME ZONE TZ_UNIDADE                            AS DATA_HORA_INICIO_JORNADA,
               M.FOI_AJUSTADO_INICIO_JORNADA                                                 AS FOI_AJUSTADO_INICIO_JORNADA,
               TO_SECONDS(
                       M.DURACAO_JORNADA)                                                    AS DURACAO_JORNADA_SEM_DESCONTOS_SEGUNDOS,
               TO_SECONDS(M.DESCONTOS_JORNADA_BRUTA)                                         AS DESCONTOS_JORNADA_BRUTA_SEGUNDOS,
               TO_SECONDS(M.DURACAO_JORNADA
                   -
                          M.DESCONTOS_JORNADA_BRUTA)                                         AS DURACAO_JORNADA_BRUTA_SEGUNDOS,
               TO_SECONDS(M.DESCONTOS_JORNADA_LIQUIDA)                                       AS DESCONTOS_JORNADA_LIQUIDA_SEGUNDOS,
               -- A Jornada Líquida deve descontar tudo que foi descontado da bruta
               -- mais os descontos específicos da líquida.
               TO_SECONDS(M.DURACAO_JORNADA
                   - M.DESCONTOS_JORNADA_BRUTA
                   -
                          M.DESCONTOS_JORNADA_LIQUIDA)                                       AS DURACAO_JORNADA_LIQUIDA_SEGUNDOS,
               F_IF(M.STATUS_ATIVO_INICIO, M.COD_MARCACAO_INICIO, NULL)                      AS COD_MARCACAO_INICIO,
               F_IF(M.STATUS_ATIVO_FIM, M.COD_MARCACAO_FIM, NULL)                            AS COD_MARCACAO_FIM,
               F_IF(M.STATUS_ATIVO_INICIO, M.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE, NULL) AS DATA_HORA_INICIO,
               F_IF(M.STATUS_ATIVO_FIM, M.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE, NULL)       AS DATA_HORA_FIM,
               M.DATA_HORA_FIM IS NULL                                                       AS MARCACAO_EM_ANDAMENTO,
               TO_SECONDS(M.DURACAO_MARCACAO)                                                AS DURACAO_MARCACAO_SEGUNDOS,
               F_IF(M.STATUS_ATIVO_INICIO, M.FOI_AJUSTADO_INICIO, FALSE)                     AS FOI_AJUSTADO_INICIO,
               F_IF(M.STATUS_ATIVO_FIM, M.FOI_AJUSTADO_FIM, FALSE)                           AS FOI_AJUSTADO_FIM,
               M.COD_TIPO_MARCACAO                                                           AS COD_TIPO_MARCACAO,
               VIT.NOME :: TEXT                                                              AS NOME_TIPO_MARCACAO,
               M.TOTAL_MARCACOES_DENTRO_JORNADA_COLABORADOR                                  AS TOTAL_MARCACOES_DENTRO_JORNADA_COLABORADOR
        FROM MARCACOES_E_DESCONTOS_JORNADA M
                 -- LEFT JOIN pois jornada pode não ter marcações.
                 LEFT JOIN VIEW_INTERVALO_TIPO VIT
                           ON VIT.CODIGO = M.COD_TIPO_MARCACAO
        ORDER BY M.CPF_COLABORADOR, M.DATA_HORA_INICIO_JORNADA, COALESCE(M.DATA_HORA_INICIO, M.DATA_HORA_FIM);
END;
$$;

create or replace function public.func_marcacao_get_historico_ajustes(f_cod_marcacoes bigint[])
    returns TABLE
            (
                cod_marcacao            bigint,
                nome_responsavel_ajuste text,
                data_hora_ajuste        timestamp without time zone,
                justificativa_ajuste    text,
                observacao_ajuste       text,
                acao_ajuste             text,
                tipo_marcacao           text,
                data_hora_antiga        timestamp without time zone,
                data_hora_nova          timestamp without time zone
            )
    language sql
as
$$
SELECT MH.COD_MARCACAO                                                             AS COD_MARCACAO,
       C.NOME                                                                      AS NOME_RESPONSAVEL_AJUSTE,
       MA.DATA_HORA_AJUSTE AT TIME ZONE (TZ_UNIDADE(MA.COD_UNIDADE_AJUSTE))        AS DATA_HORA_AJUSTE,
       MJA.NOME                                                                    AS JUSTIFICATIVA_AJUSTE,
       MA.OBSERVACAO_AJUSTE                                                        AS OBSERVACAO_AJUSTE,
       MA.ACAO_AJUSTE                                                              AS ACAO_AJUSTE,
       I.TIPO_MARCACAO                                                             AS TIPO_MARCACAO,
       MH.DATA_HORA_ANTIGA AT TIME ZONE (TZ_UNIDADE(I.COD_UNIDADE))                AS DATA_HORA_ANTIGA,
       -- Esse select interno provavelmente atrasa a query, mas é uma solução muito simples.
       LEAD(MH.DATA_HORA_ANTIGA, 1, (SELECT DATA_HORA
                                     FROM INTERVALO
                                     WHERE CODIGO = MH.COD_MARCACAO))
       OVER (
           PARTITION BY MH.COD_MARCACAO ) AT TIME ZONE (TZ_UNIDADE(I.COD_UNIDADE)) AS DATA_HORA_NOVA
FROM MARCACAO_HISTORICO MH
         JOIN MARCACAO_AJUSTE MA ON MH.COD_AJUSTE = MA.CODIGO
         JOIN MARCACAO_JUSTIFICATIVA_AJUSTE MJA ON MA.COD_JUSTIFICATIVA_AJUSTE = MJA.CODIGO
         JOIN INTERVALO I ON MH.COD_MARCACAO = I.CODIGO
         JOIN COLABORADOR C ON MA.COD_COLABORADOR_AJUSTE = C.CODIGO
WHERE MH.COD_MARCACAO = ANY (F_COD_MARCACOES)
ORDER BY MA.DATA_HORA_AJUSTE ASC;
$$;

create or replace function public.func_marcacao_get_inconsistencias_tipo_fim_antes_inicio(f_cod_colaborador bigint, f_dia date)
    returns TABLE
            (
                cod_marcacao_inicio       bigint,
                data_hora_marcacao_inicio timestamp without time zone,
                cod_marcacao_fim          bigint,
                data_hora_marcacao_fim    timestamp without time zone,
                nome_colaborador          text
            )
    language plpgsql
as
$$
DECLARE
    CPF_COLABORADOR_FILTRO BIGINT := (SELECT C.CPF
                                      FROM COLABORADOR C
                                      WHERE C.CODIGO = F_COD_COLABORADOR);
BEGIN
    RETURN QUERY
        SELECT F.COD_MARCACAO_INICIO                                     AS COD_MARCACAO_INICIO,
               F.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE) AS DATA_HORA_INICIO,
               F.COD_MARCACAO_FIM                                        AS COD_MARCACAO_FIM,
               F.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE)    AS DATA_HORA_FIM,
               C.NOME :: TEXT                                            AS NOME_COLABORADOR
        FROM FUNC_INTERVALOS_AGRUPADOS(NULL, CPF_COLABORADOR_FILTRO, NULL) F
                 JOIN COLABORADOR C ON F.CPF_COLABORADOR = C.CPF
        WHERE F.DATA_HORA_FIM < F.DATA_HORA_INICIO
          AND F.DATA_HORA_INICIO IS NOT NULL
          AND F.DATA_HORA_FIM IS NOT NULL
          AND ((DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE)) :: DATE = F_DIA
            OR (DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE)) :: DATE = F_DIA);
END;
$$;

create or replace function public.func_marcacao_get_inconsistencias_tipo_sem_vinculo(f_cod_colaborador bigint, f_dia date)
    returns TABLE
            (
                cod_marcacao_sem_vinculo bigint,
                tipo_inicio_fim          text,
                nome_colaborador         text,
                data_hora_marcacao       timestamp without time zone
            )
    language plpgsql
as
$$
DECLARE
    CPF_COLABORADOR_FILTRO BIGINT := (SELECT C.CPF
                                      FROM COLABORADOR C
                                      WHERE C.CODIGO = F_COD_COLABORADOR);
    TIPO_MARCACAO_INICIO   TEXT   := 'MARCACAO_INICIO';
    TIPO_MARCACAO_FIM      TEXT   := 'MARCACAO_FIM';
BEGIN
    RETURN QUERY
        WITH MARCACOES_DIA AS (
            SELECT I.CODIGO        AS COD_MARCACAO,
                   I.TIPO_MARCACAO AS TIPO_MARCACAO,
                   I.DATA_HORA     AS DATA_HORA_MARCACAO,
                   I.COD_UNIDADE   AS COD_UNIDADE_MARCACAO,
                   C.NOME          AS NOME_COLABORADOR
            FROM INTERVALO I
                     JOIN COLABORADOR C ON I.CPF_COLABORADOR = C.CPF
            WHERE (I.DATA_HORA AT TIME ZONE TZ_UNIDADE(I.COD_UNIDADE)) :: DATE = F_DIA
              AND I.CPF_COLABORADOR = CPF_COLABORADOR_FILTRO
              AND I.STATUS_ATIVO = TRUE
        ),

             INICIOS AS (
                 SELECT *
                 FROM MARCACOES_DIA MD
                 WHERE MD.TIPO_MARCACAO = TIPO_MARCACAO_INICIO
             ),

             FINS AS (
                 SELECT *
                 FROM MARCACOES_DIA MD
                 WHERE MD.TIPO_MARCACAO = TIPO_MARCACAO_FIM
             )

        SELECT I.COD_MARCACAO                                                         AS COD_MARCACAO_SEM_VINCULO,
               I.TIPO_MARCACAO :: TEXT                                                AS TIPO_INICIO_FIM,
               I.NOME_COLABORADOR :: TEXT                                             AS NOME_COLABORADOR,
               (I.DATA_HORA_MARCACAO AT TIME ZONE TZ_UNIDADE(I.COD_UNIDADE_MARCACAO)) AS DATA_HORA_MARCACAO
        FROM INICIOS I
                 LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV
                           ON I.COD_MARCACAO = MV.COD_MARCACAO_INICIO
        WHERE MV.CODIGO IS NULL
        UNION ALL
        SELECT F.COD_MARCACAO                                                         AS COD_MARCACAO_SEM_VINCULO,
               F.TIPO_MARCACAO :: TEXT                                                AS TIPO_INICIO_FIM,
               F.NOME_COLABORADOR :: TEXT                                             AS NOME_COLABORADOR,
               (F.DATA_HORA_MARCACAO AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE_MARCACAO)) AS DATA_HORA_MARCACAO
        FROM FINS F
                 LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV
                           ON F.COD_MARCACAO = MV.COD_MARCACAO_FIM
        WHERE MV.CODIGO IS NULL;
END;
$$;

create or replace function public.func_marcacao_get_listagem_marcacoes(f_cod_unidade bigint, f_cpf_colaborador bigint,
                                                                       f_cod_tipo_intervalo bigint, f_data_inicial date,
                                                                       f_data_final date)
    returns TABLE
            (
                fonte_data_hora_inicio          text,
                fonte_data_hora_fim             text,
                justificativa_estouro           text,
                justificativa_tempo_recomendado text,
                latitude_marcacao_inicio        text,
                longitude_marcacao_inicio       text,
                latitude_marcacao_fim           text,
                longitude_marcacao_fim          text,
                cod_unidade                     bigint,
                cpf_colaborador                 text,
                nome_colaborador                text,
                cod_tipo_intervalo_por_unidade  bigint,
                cod_tipo_intervalo              bigint,
                nome_tipo_intervalo             text,
                icone_tipo_intervalo            text,
                tempo_recomendado_minutos       bigint,
                tempo_estouro_minutos           bigint,
                data_hora_inicio                timestamp without time zone,
                data_hora_fim                   timestamp without time zone,
                duracao_em_segundos             bigint,
                cod_marcacao_vinculo            bigint,
                cod_marcacao_inicio             bigint,
                cod_marcacao_fim                bigint,
                status_ativo_inicio             boolean,
                status_ativo_fim                boolean,
                foi_ajustado_inicio             boolean,
                foi_ajustado_fim                boolean,
                data_hora_sincronizacao_inicio  timestamp without time zone,
                data_hora_sincronizacao_fim     timestamp without time zone,
                tipo_jornada                    boolean
            )
    language plpgsql
as
$$
DECLARE
    F_TIME_ZONE_UNIDADE TEXT := TZ_UNIDADE(F_COD_UNIDADE);
BEGIN
    RETURN QUERY
        WITH INTERVALOS AS (
            SELECT IT.*
            FROM INTERVALO IT
            WHERE IT.COD_UNIDADE = F_COD_UNIDADE
              AND F_IF(F_CPF_COLABORADOR IS NULL, TRUE, IT.CPF_COLABORADOR = F_CPF_COLABORADOR)
              AND F_IF(F_COD_TIPO_INTERVALO IS NULL, TRUE, IT.COD_TIPO_INTERVALO = F_COD_TIPO_INTERVALO)
              AND ((IT.DATA_HORA AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE >= F_DATA_INICIAL
                AND (IT.DATA_HORA AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE <= F_DATA_FINAL)),
             INICIOS AS (
                 SELECT MI.COD_MARCACAO_INICIO                AS COD_MARCACAO_INICIO,
                        MV.COD_MARCACAO_FIM                   AS COD_MARCACAO_VINCULO,
                        I.FONTE_DATA_HORA                     AS FONTE_DATA_HORA_INICIO,
                        I.LATITUDE_MARCACAO                   AS LATITUDE_MARCACAO_INICIO,
                        I.LONGITUDE_MARCACAO                  AS LONGITUDE_MARCACAO_INICIO,
                        I.COD_UNIDADE                         AS COD_UNIDADE,
                        I.CPF_COLABORADOR                     AS CPF_COLABORADOR,
                        CO.NOME                               AS NOME_COLABORADOR,
                        I.COD_TIPO_INTERVALO                  AS COD_TIPO_INTERVALO,
                        VIT.NOME                              AS NOME_TIPO_INTERVALO,
                        VIT.ICONE                             AS ICONE_TIPO_INTERVALO,
                        VIT.TEMPO_RECOMENDADO_MINUTOS         AS TEMPO_RECOMENDADO_MINUTOS,
                        VIT.TEMPO_ESTOURO_MINUTOS             AS TEMPO_ESTOURO_MINUTOS,
                        I.DATA_HORA                           AS DATA_HORA,
                        I.CODIGO                              AS CODIGO_INICIO,
                        I.STATUS_ATIVO                        AS STATUS_ATIVO_INICIO,
                        I.FOI_AJUSTADO                        AS FOI_AJUSTADO_INICIO,
                        I.DATA_HORA_SINCRONIZACAO             AS DATA_HORA_SINCRONIZACAO_INICIO,
                        VIT.CODIGO_TIPO_INTERVALO_POR_UNIDADE AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        VIT.TIPO_JORNADA                      AS TIPO_JORNADA
                 FROM MARCACAO_INICIO MI
                          LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV ON MI.COD_MARCACAO_INICIO = MV.COD_MARCACAO_INICIO
                          JOIN INTERVALOS I ON MI.COD_MARCACAO_INICIO = I.CODIGO
                          JOIN COLABORADOR CO ON CO.CPF = I.CPF_COLABORADOR
                          JOIN VIEW_INTERVALO_TIPO VIT ON I.COD_TIPO_INTERVALO = VIT.CODIGO),
             FINS AS (
                 SELECT MF.COD_MARCACAO_FIM                   AS COD_MARCACAO_FIM,
                        MV.COD_MARCACAO_INICIO                AS COD_MARCACAO_VINCULO,
                        F.FONTE_DATA_HORA                     AS FONTE_DATA_HORA_FIM,
                        F.JUSTIFICATIVA_ESTOURO               AS JUSTIFICATIVA_ESTOURO,
                        F.JUSTIFICATIVA_TEMPO_RECOMENDADO     AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
                        F.LATITUDE_MARCACAO                   AS LATITUDE_MARCACAO_FIM,
                        F.LONGITUDE_MARCACAO                  AS LONGITUDE_MARCACAO_FIM,
                        F.COD_UNIDADE                         AS COD_UNIDADE,
                        F.CPF_COLABORADOR                     AS CPF_COLABORADOR,
                        CO.NOME                               AS NOME_COLABORADOR,
                        F.COD_TIPO_INTERVALO                  AS COD_TIPO_INTERVALO,
                        VIT.NOME                              AS NOME_TIPO_INTERVALO,
                        VIT.ICONE                             AS ICONE_TIPO_INTERVALO,
                        VIT.TEMPO_RECOMENDADO_MINUTOS         AS TEMPO_RECOMENDADO_MINUTOS,
                        VIT.TEMPO_ESTOURO_MINUTOS             AS TEMPO_ESTOURO_MINUTOS,
                        F.DATA_HORA                           AS DATA_HORA,
                        F.CODIGO                              AS CODIGO_FIM,
                        F.STATUS_ATIVO                        AS STATUS_ATIVO_FIM,
                        F.FOI_AJUSTADO                        AS FOI_AJUSTADO_FIM,
                        F.DATA_HORA_SINCRONIZACAO             AS DATA_HORA_SINCRONIZACAO_FIM,
                        VIT.CODIGO_TIPO_INTERVALO_POR_UNIDADE AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        VIT.TIPO_JORNADA                      AS TIPO_JORNADA
                 FROM MARCACAO_FIM MF
                          LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV ON MF.COD_MARCACAO_FIM = MV.COD_MARCACAO_FIM
                          JOIN INTERVALOS F ON MF.COD_MARCACAO_FIM = F.CODIGO
                          JOIN COLABORADOR CO ON CO.CPF = F.CPF_COLABORADOR
                          JOIN VIEW_INTERVALO_TIPO VIT ON F.COD_TIPO_INTERVALO = VIT.CODIGO)

        SELECT COALESCE(IC.FONTE_DATA_HORA_INICIO, IVI.FONTE_DATA_HORA) :: TEXT              AS FONTE_DATA_HORA_INICIO,
               COALESCE(F.FONTE_DATA_HORA_FIM, IVF.FONTE_DATA_HORA) :: TEXT                  AS FONTE_DATA_HORA_FIM,
               F.JUSTIFICATIVA_ESTOURO                                                       AS JUSTIFICATIVA_ESTOURO,
               F.JUSTIFICATIVA_TEMPO_RECOMENDADO                                             AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
               COALESCE(IC.LATITUDE_MARCACAO_INICIO, IVI.LATITUDE_MARCACAO)                  AS LATITUDE_MARCACAO_INICIO,
               COALESCE(IC.LONGITUDE_MARCACAO_INICIO, IVI.LONGITUDE_MARCACAO)                AS LONGITUDE_MARCACAO_INICIO,
               COALESCE(F.LATITUDE_MARCACAO_FIM, IVF.LATITUDE_MARCACAO)                      AS LATITUDE_MARCACAO_FIM,
               COALESCE(F.LONGITUDE_MARCACAO_FIM, IVF.LONGITUDE_MARCACAO)                    AS LONGITUDE_MARCACAO_FIM,
               COALESCE(IC.COD_UNIDADE, F.COD_UNIDADE)                                       AS COD_UNIDADE,
               LPAD(COALESCE(IC.CPF_COLABORADOR, F.CPF_COLABORADOR) :: TEXT, 11, '0')        AS CPF_COLABORADOR,
               COALESCE(IC.NOME_COLABORADOR, F.NOME_COLABORADOR) :: TEXT                     AS NOME_COLABORADOR,
               COALESCE(IC.COD_TIPO_INTERVALO_POR_UNIDADE,
                        F.COD_TIPO_INTERVALO_POR_UNIDADE)                                    AS COD_TIPO_INTERVALO_POR_UNIDADE,
               COALESCE(IC.COD_TIPO_INTERVALO, F.COD_TIPO_INTERVALO)                         AS COD_TIPO_INTERVALO,
               COALESCE(IC.NOME_TIPO_INTERVALO, F.NOME_TIPO_INTERVALO) :: TEXT               AS NOME_TIPO_INTERVALO,
               COALESCE(IC.ICONE_TIPO_INTERVALO, F.ICONE_TIPO_INTERVALO) :: TEXT             AS ICONE_TIPO_INTERVALO,
               COALESCE(IC.TEMPO_RECOMENDADO_MINUTOS, F.TEMPO_RECOMENDADO_MINUTOS) :: BIGINT AS TEMPO_RECOMENDADO_MINUTOS,
               COALESCE(IC.TEMPO_ESTOURO_MINUTOS, F.TEMPO_ESTOURO_MINUTOS) :: BIGINT         AS TEMPO_ESTOURO_MINUTOS,
               COALESCE(IC.DATA_HORA, IVI.DATA_HORA) AT TIME ZONE F_TIME_ZONE_UNIDADE        AS DATA_HORA_INICIO,
               COALESCE(F.DATA_HORA, IVF.DATA_HORA) AT TIME ZONE F_TIME_ZONE_UNIDADE         AS DATA_HORA_FIM,
               TO_SECONDS(COALESCE(F.DATA_HORA, IVF.DATA_HORA) -
                          COALESCE(IC.DATA_HORA, IVI.DATA_HORA))                             AS DURACAO_EM_SEGUNDOS,
               COALESCE(IC.COD_MARCACAO_VINCULO, F.COD_MARCACAO_VINCULO)                     AS COD_MARCACAO_VINCULO,
               COALESCE(IC.CODIGO_INICIO, IVI.CODIGO)                                        AS COD_MARCACAO_INICIO,
               COALESCE(F.CODIGO_FIM, IVF.CODIGO)                                            AS COD_MARCACAO_FIM,
               COALESCE(IC.STATUS_ATIVO_INICIO, IVI.STATUS_ATIVO)                            AS STATUS_ATIVO_INICIO,
               COALESCE(F.STATUS_ATIVO_FIM, IVF.STATUS_ATIVO)                                AS STATUS_ATIVO_FIM,
               COALESCE(IC.FOI_AJUSTADO_INICIO, IVI.FOI_AJUSTADO)                            AS FOI_AJUSTADO_INICIO,
               COALESCE(F.FOI_AJUSTADO_FIM, IVF.FOI_AJUSTADO)                                AS FOI_AJUSTADO_FIM,
               COALESCE(IC.DATA_HORA_SINCRONIZACAO_INICIO,
                        IVI.DATA_HORA_SINCRONIZACAO) AT TIME ZONE
               F_TIME_ZONE_UNIDADE                                                           AS DATA_HORA_SINCRONIZACAO_INICIO,
               COALESCE(F.DATA_HORA_SINCRONIZACAO_FIM, IVF.DATA_HORA_SINCRONIZACAO) AT TIME ZONE
               F_TIME_ZONE_UNIDADE                                                           AS DATA_HORA_SINCRONIZACAO_FIM,
               (F.TIPO_JORNADA = TRUE OR IC.TIPO_JORNADA = TRUE)                             AS TIPO_JORNADA
        FROM INICIOS IC
                 FULL OUTER JOIN FINS F ON IC.COD_MARCACAO_VINCULO = F.COD_MARCACAO_FIM
            -- Com esses últimos left joins com INTERVALO garantimos que será buscado inícios ou fins vinculados a marcações
            -- que estão fora do filtro de data aplicado na primeira CTE INTERVALOS.
            -- Exemplo: se filtramos de 01/01/19 a 31/01/19 e temos uma marcação iniciada em 31/01/19 e finalizada em 01/02/19,
            -- sem esses left joins, esse fim não seria buscado.
                 LEFT JOIN INTERVALO IVI ON IVI.CODIGO = F.COD_MARCACAO_VINCULO
                 LEFT JOIN INTERVALO IVF ON IVF.CODIGO = IC.COD_MARCACAO_VINCULO
        ORDER BY CPF_COLABORADOR,
                 COD_TIPO_INTERVALO,
                 COALESCE(DATA_HORA_INICIO, DATA_HORA_FIM);
END;
$$;

create or replace function public.func_marcacao_get_marcacoes_consolidadas_ajuste(f_cod_unidade bigint,
                                                                                  f_cod_tipo_marcacao bigint,
                                                                                  f_cod_colaborador bigint,
                                                                                  f_data_inicial date,
                                                                                  f_data_final date)
    returns TABLE
            (
                dia                             date,
                cod_colaborador                 bigint,
                nome_colaborador                character varying,
                total_marcacoes_colaborador_dia bigint,
                total_marcacoes_geral_dia       numeric
            )
    language plpgsql
as
$$
DECLARE
    CPF_COLABORADOR_FILTRO BIGINT := CASE
                                         WHEN F_COD_COLABORADOR IS NOT NULL
                                             THEN (SELECT C.CPF
                                                   FROM COLABORADOR C
                                                   WHERE C.CODIGO = F_COD_COLABORADOR) END;
BEGIN
    RETURN QUERY
        WITH MARCACOES_DIA AS (
            SELECT (I.DATA_HORA AT TIME ZONE TZ_UNIDADE(I.COD_UNIDADE)) :: DATE AS DIA,
                   I.CPF_COLABORADOR                                            AS CPF_COLABORADOR,
                   COUNT(I.CPF_COLABORADOR)                                     AS TOTAL_MARCACOES_COLABORADOR_DIA
            FROM INTERVALO I
                     JOIN COLABORADOR C
                          ON I.CPF_COLABORADOR = C.CPF
            WHERE I.COD_UNIDADE = F_COD_UNIDADE
              AND F_IF(F_COD_COLABORADOR IS NULL, TRUE, I.CPF_COLABORADOR = CPF_COLABORADOR_FILTRO)
              AND F_IF(F_COD_TIPO_MARCACAO IS NULL, TRUE, I.COD_TIPO_INTERVALO = F_COD_TIPO_MARCACAO)
              AND (I.DATA_HORA AT TIME ZONE TZ_UNIDADE(I.COD_UNIDADE)) :: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
            GROUP BY I.CPF_COLABORADOR, DIA
        )

        SELECT MD.DIA                             AS DIA,
               C.CODIGO                           AS COD_COLABORADOR,
               C.NOME                             AS NOME_COLABORADOR,
               MD.TOTAL_MARCACOES_COLABORADOR_DIA AS TOTAL_MARCACOES_COLABORADOR_DIA,
               SUM(MD.TOTAL_MARCACOES_COLABORADOR_DIA)
               OVER (PARTITION BY MD.DIA)         AS TOTAL_MARCACOES_GERAL_DIA
        FROM MARCACOES_DIA MD
                 JOIN COLABORADOR C ON MD.CPF_COLABORADOR = C.CPF
        ORDER BY MD.DIA DESC, C.NOME ASC;
END;
$$;

create or replace function public.func_marcacao_get_tempo_total_por_tipo_marcacao(f_cod_unidade bigint,
                                                                                  f_cod_tipo_intervalo bigint,
                                                                                  f_data_inicial date,
                                                                                  f_data_final date)
    returns TABLE
            (
                cpf_colaborador                   text,
                nome                              text,
                cargo                             text,
                cod_tipo_intervalo                text,
                nome_tipo_intervalo               text,
                tempo_total_millis                text,
                tempo_total_horas_noturnas_millis text
            )
    language plpgsql
as
$$
DECLARE
    TZ_UNIDADE TEXT := TZ_UNIDADE(F_COD_UNIDADE);
BEGIN
    RETURN QUERY
        WITH TIPOS_UNIDADE AS (
            SELECT C.CPF     AS CPF_COLABORADOR,
                   C.NOME    AS NOME_COLABORADOR,
                   F.NOME    AS NOME_CARGO,
                   IT.CODIGO AS COD_TIPO_MARCACAO,
                   IT.NOME   AS NOME_TIPO_MARCACAO
            FROM COLABORADOR C
                     JOIN FUNCAO F
                          ON C.COD_FUNCAO = F.CODIGO
                     JOIN INTERVALO_TIPO IT
                          ON C.COD_UNIDADE = IT.COD_UNIDADE
            WHERE IT.COD_UNIDADE = F_COD_UNIDADE
              AND F_IF(F_COD_TIPO_INTERVALO IS NULL, TRUE, IT.CODIGO = F_COD_TIPO_INTERVALO)
            ORDER BY C.CPF, IT.CODIGO
        ),
             TOTAIS_POR_TIPO AS (
                 SELECT *
                 FROM (SELECT C.CPF     AS CPF_COLABORADOR,
                              IT.CODIGO AS COD_TIPO_INTERVALO,
                              SUM(TO_SECONDS(I.DATA_HORA_FIM - I.DATA_HORA_INICIO))
                              OVER W    AS TEMPO_TOTAL_SEGUNDOS,
                              SUM(FUNC_MARCACAO_CALCULA_TOTAL_SEGUNDOS_EM_HORAS_NOTURNAS(I.DATA_HORA_INICIO,
                                                                                         I.DATA_HORA_FIM,
                                                                                         TZ_UNIDADE))
                              OVER W    AS TEMPO_TOTAL_HORAS_NOTURNAS_SEGUNDOS
                       FROM FUNC_INTERVALOS_AGRUPADOS(F_COD_UNIDADE, NULL, F_COD_TIPO_INTERVALO) AS I
                                JOIN COLABORADOR AS C
                                     ON I.CPF_COLABORADOR = C.CPF
                                LEFT JOIN INTERVALO_TIPO AS IT
                                          ON I.COD_TIPO_INTERVALO = IT.CODIGO
                       WHERE ((((I.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE)::DATE >= F_DATA_INICIAL)
                           AND (((I.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE)::DATE <= F_DATA_FINAL)))
                           OR
                              (((I.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE)::DATE >= F_DATA_INICIAL)
                                  AND ((I.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE)::DATE <= F_DATA_FINAL)))
                         -- Expurga marcações que não tem início ou fim.
                         AND I.DATA_HORA_INICIO IS NOT NULL
                         AND I.DATA_HORA_FIM IS NOT NULL
                         -- Retiramos do cálculo as marcações que foram desativadas.
                         AND I.STATUS_ATIVO_INICIO = TRUE
                         AND I.STATUS_ATIVO_FIM = TRUE
                       GROUP BY C.CPF, I.COD_TIPO_INTERVALO, I.DATA_HORA_FIM, I.DATA_HORA_INICIO, IT.CODIGO
                                WINDOW W AS (
                                    PARTITION BY C.CPF, IT.CODIGO)) AS T
                 GROUP BY T.CPF_COLABORADOR,
                          T.COD_TIPO_INTERVALO,
                          T.TEMPO_TOTAL_SEGUNDOS,
                          T.TEMPO_TOTAL_HORAS_NOTURNAS_SEGUNDOS
                 ORDER BY T.CPF_COLABORADOR, T.COD_TIPO_INTERVALO)

        SELECT LPAD(TU.CPF_COLABORADOR::TEXT, 11, '0')                AS CPF_COLABORADOR,
               TU.NOME_COLABORADOR::TEXT                              AS NOME_COLABORADOR,
               TU.NOME_CARGO::TEXT                                    AS NOME_CARGO,
               TU.COD_TIPO_MARCACAO::TEXT                             AS COD_TIPO_MARCACAO,
               TU.NOME_TIPO_MARCACAO::TEXT                            AS NOME_TIPO_MARCACAO,
               (TPT.TEMPO_TOTAL_SEGUNDOS * 1000)::TEXT                AS TEMPO_TOTAL_MILLIS,
               (TPT.TEMPO_TOTAL_HORAS_NOTURNAS_SEGUNDOS * 1000)::TEXT AS TEMPO_TOTAL_HORAS_NOTURNAS_MILLIS
        FROM TIPOS_UNIDADE TU
                 LEFT JOIN TOTAIS_POR_TIPO TPT
                           ON TU.CPF_COLABORADOR = TPT.CPF_COLABORADOR AND TU.COD_TIPO_MARCACAO = TPT.COD_TIPO_INTERVALO
        ORDER BY TU.CPF_COLABORADOR, TU.COD_TIPO_MARCACAO DESC;
END;
$$;

create or replace function public.func_marcacao_get_tipos_descontados_jornada_bruta_liquida(f_cod_unidade bigint)
    returns TABLE
            (
                cod_tipo_descontado      bigint,
                nome_tipo_descontado     text,
                desconta_jornada_bruta   boolean,
                desconta_jornada_liquida boolean
            )
    language sql
as
$$
SELECT M.COD_TIPO_DESCONTADO      AS COD_TIPO_DESCONTADO,
       VIT.NOME                   AS NOME_TIPO_DESCONTADO,
       M.DESCONTA_JORNADA_BRUTA   AS DESCONTA_JORNADA_BRUTA,
       M.DESCONTA_JORNADA_LIQUIDA AS DESCONTA_JORNADA_LIQUIDA
FROM MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA M
         JOIN VIEW_INTERVALO_TIPO VIT
              ON M.COD_TIPO_DESCONTADO = VIT.CODIGO
WHERE M.COD_UNIDADE = F_COD_UNIDADE;
$$;

create or replace function public.func_marcacao_insert_informacoes_ajuste(f_cod_marcacao_ajustada bigint,
                                                                          f_data_hora_inserida timestamp with time zone,
                                                                          f_cod_justificativa bigint,
                                                                          f_observacao_ajuste text,
                                                                          f_acao_ajuste character varying,
                                                                          f_token_responsavel_ajuste text,
                                                                          f_data_hora_ajuste timestamp with time zone) returns bigint
    language plpgsql
as
$$
DECLARE
    DATA_HORA_ATUAL_MARCACAO TIMESTAMP WITH TIME ZONE := (SELECT I.DATA_HORA
                                                          FROM INTERVALO I
                                                          WHERE I.CODIGO = F_COD_MARCACAO_AJUSTADA);
    COD_UNIDADE_AJUSTE       BIGINT;
    COD_COLABORADOR_AJUSTE   BIGINT;
    COD_AJUSTE_REALIZADO     BIGINT;
    COD_HISTORICO_MARCACAO   BIGINT;
BEGIN
    SELECT INTO COD_UNIDADE_AJUSTE, COD_COLABORADOR_AJUSTE COD_UNIDADE,
                                                           CODIGO
    FROM COLABORADOR C
    WHERE CPF = (SELECT CPF_COLABORADOR
                 FROM TOKEN_AUTENTICACAO
                 WHERE TOKEN = F_TOKEN_RESPONSAVEL_AJUSTE);

    -- APENAS PARA O CASO DE EDIÇÃO, TEREMOS UM DATA/HORA INSERIDA E PRECISAREMOS ATUALIZAR NA TABELA INTERVALO.
    IF (F_ACAO_AJUSTE = 'EDICAO')
    THEN
        UPDATE INTERVALO
        SET DATA_HORA = F_DATA_HORA_INSERIDA
        WHERE CODIGO = F_COD_MARCACAO_AJUSTADA;

        IF NOT FOUND
        THEN
            RAISE EXCEPTION 'Erro ao atualizar a data/hora da marcação: %', F_COD_MARCACAO_AJUSTADA;
        END IF;
    END IF;

    INSERT INTO MARCACAO_AJUSTE (COD_JUSTIFICATIVA_AJUSTE,
                                 OBSERVACAO_AJUSTE,
                                 ACAO_AJUSTE,
                                 COD_UNIDADE_AJUSTE,
                                 COD_COLABORADOR_AJUSTE,
                                 DATA_HORA_AJUSTE)
    VALUES (F_COD_JUSTIFICATIVA,
            F_OBSERVACAO_AJUSTE,
            F_ACAO_AJUSTE,
            COD_UNIDADE_AJUSTE,
            COD_COLABORADOR_AJUSTE,
            F_DATA_HORA_AJUSTE) RETURNING CODIGO
               INTO COD_AJUSTE_REALIZADO;

    IF NOT FOUND OR COD_AJUSTE_REALIZADO IS NULL OR COD_AJUSTE_REALIZADO <= 0
    THEN
        RAISE EXCEPTION 'Erro ao salvar informações na tabela MARCACAO_AJUSTE: %', COD_AJUSTE_REALIZADO;
    END IF;

    INSERT INTO MARCACAO_HISTORICO (COD_MARCACAO, COD_AJUSTE, DATA_HORA_ANTIGA)
    VALUES (F_COD_MARCACAO_AJUSTADA,
            COD_AJUSTE_REALIZADO,
            DATA_HORA_ATUAL_MARCACAO) RETURNING CODIGO
               INTO COD_HISTORICO_MARCACAO;

    IF NOT FOUND OR COD_HISTORICO_MARCACAO IS NULL OR COD_HISTORICO_MARCACAO <= 0
    THEN
        RAISE EXCEPTION 'Erro ao salvar informações na tabela MARCACAO_HISTORICO: %', COD_HISTORICO_MARCACAO;
    END IF;

    RETURN COD_HISTORICO_MARCACAO;
END;
$$;

create or replace function public.func_marcacao_insert_marcacao_avulsa_ajuste(f_data_hora_inserida timestamp with time zone,
                                                                              f_cod_marcacao_vinculo bigint,
                                                                              f_data_hora_atual timestamp with time zone,
                                                                              f_token_responsavel_insercao text) returns bigint
    language sql
as
$$
INSERT INTO INTERVALO (COD_UNIDADE,
                       COD_TIPO_INTERVALO,
                       CPF_COLABORADOR,
                       DATA_HORA,
                       TIPO_MARCACAO,
                       FONTE_DATA_HORA,
                       FOI_AJUSTADO,
                       DATA_HORA_SINCRONIZACAO,
                       COD_COLABORADOR_INSERCAO)
SELECT I.COD_UNIDADE,
       I.COD_TIPO_INTERVALO,
       I.CPF_COLABORADOR,
       F_DATA_HORA_INSERIDA,
       F_IF(I.TIPO_MARCACAO = 'MARCACAO_INICIO', 'MARCACAO_FIM'::TEXT, 'MARCACAO_INICIO'::TEXT),
       I.FONTE_DATA_HORA,
       TRUE,
       F_DATA_HORA_ATUAL,
       (SELECT C.CODIGO
        FROM COLABORADOR C
        WHERE CPF = (SELECT CPF_COLABORADOR
                     FROM TOKEN_AUTENTICACAO
                     WHERE TOKEN = F_TOKEN_RESPONSAVEL_INSERCAO))
FROM INTERVALO I
WHERE I.CODIGO = F_COD_MARCACAO_VINCULO RETURNING CODIGO AS NEW_COD_MARCACAO;
$$;

create or replace function public.func_marcacao_insert_marcacao_inconsistencia(f_cod_marcacao_inicio bigint, f_cod_marcacao_sincronizada bigint) returns boolean
    language plpgsql
as
$$
DECLARE
    COD_VINCULO_INICIO_FIM          BIGINT := (SELECT CODIGO
                                               FROM MARCACAO_VINCULO_INICIO_FIM
                                               WHERE COD_MARCACAO_INICIO = F_COD_MARCACAO_INICIO);
    COD_INCONSISTENCIA_INSERIDA     BIGINT;
    COD_VINCULO_INICIO_FIM_ALTERADA BIGINT;
BEGIN
    IF COD_VINCULO_INICIO_FIM IS NULL
    THEN
        RAISE EXCEPTION 'Erro ao buscar código de vínculo início/fim para mapear inconsistência';
    END IF;

    -- INSERIR INCONSISTÊNCIA
    INSERT INTO MARCACAO_INCONSISTENCIA(COD_MARCACAO_VINCULO_INICIO_FIM, COD_MARCACAO_INCONSISTENTE)
    VALUES (COD_VINCULO_INICIO_FIM, F_COD_MARCACAO_SINCRONIZADA) RETURNING CODIGO INTO COD_INCONSISTENCIA_INSERIDA;

    IF COD_INCONSISTENCIA_INSERIDA IS NULL
    THEN
        RAISE EXCEPTION 'Erro ao inserir marcação inconsistencia para a marcação: %', F_COD_MARCACAO_SINCRONIZADA;
    END IF;

    -- ALTERAR FLAG NA TABELA MARCACAO_VINCULO_INICIO_FIM - POSSUI_INCONSISTENCIA
    UPDATE MARCACAO_VINCULO_INICIO_FIM
    SET POSSUI_INCONSISTENCIA = TRUE
    WHERE CODIGO = COD_VINCULO_INICIO_FIM RETURNING CODIGO INTO COD_VINCULO_INICIO_FIM_ALTERADA;

    IF COD_VINCULO_INICIO_FIM_ALTERADA IS NULL
    THEN
        RAISE EXCEPTION
            'Erro ao setar flag possui_inconsistencia para a marcação: %', F_COD_MARCACAO_SINCRONIZADA;
    END IF;

    RETURN TRUE;
END;
$$;

create or replace function public.func_marcacao_insert_marcacao_inicio_fim(f_cod_colaborador_marcacao bigint,
                                                                           f_cod_tipo_marcacao bigint,
                                                                           f_data_hora_inicio timestamp with time zone,
                                                                           f_data_hora_fim timestamp with time zone,
                                                                           f_data_hora_atual timestamp with time zone,
                                                                           f_token_responsavel_insercao text)
    returns TABLE
            (
                cod_marcacao_inicio bigint,
                cod_marcacao_fim    bigint
            )
    language plpgsql
as
$$
DECLARE
    CPF_COLABORADOR_MARCACAO         BIGINT;
    COD_UNIDADE_COLABORADOR_MARCACAO BIGINT;
    COD_COLABORADOR_INSERCAO         BIGINT := (SELECT CODIGO
                                                FROM COLABORADOR
                                                WHERE CPF = (SELECT CPF_COLABORADOR
                                                             FROM TOKEN_AUTENTICACAO
                                                             WHERE TOKEN = F_TOKEN_RESPONSAVEL_INSERCAO));
    TIPO_INICIO                      TEXT   := 'MARCACAO_INICIO';
    TIPO_FIM                         TEXT   := 'MARCACAO_FIM';
    FONTE_DATA_HORA_SERVIDOR         TEXT   := 'SERVIDOR';
    CODIGO_INICIO                    BIGINT;
    CODIGO_FIM                       BIGINT;
BEGIN

    SELECT INTO CPF_COLABORADOR_MARCACAO, COD_UNIDADE_COLABORADOR_MARCACAO CPF,
                                                                           COD_UNIDADE
    FROM COLABORADOR C
    WHERE C.CODIGO = F_COD_COLABORADOR_MARCACAO;

    INSERT INTO INTERVALO (COD_UNIDADE,
                           COD_TIPO_INTERVALO,
                           CPF_COLABORADOR,
                           DATA_HORA,
                           TIPO_MARCACAO,
                           FONTE_DATA_HORA,
                           FOI_AJUSTADO,
                           DATA_HORA_SINCRONIZACAO,
                           COD_COLABORADOR_INSERCAO)
    VALUES (COD_UNIDADE_COLABORADOR_MARCACAO,
            F_COD_TIPO_MARCACAO,
            CPF_COLABORADOR_MARCACAO,
            F_DATA_HORA_INICIO,
            TIPO_INICIO,
            FONTE_DATA_HORA_SERVIDOR,
            TRUE,
            F_DATA_HORA_ATUAL,
            COD_COLABORADOR_INSERCAO) RETURNING CODIGO
               INTO CODIGO_INICIO;

    IF CODIGO_INICIO IS NULL OR CODIGO_INICIO <= 0
    THEN
        RAISE EXCEPTION 'Erro ao inserir marcação de início';
    END IF;

    INSERT INTO INTERVALO (COD_UNIDADE,
                           COD_TIPO_INTERVALO,
                           CPF_COLABORADOR,
                           DATA_HORA,
                           TIPO_MARCACAO,
                           FONTE_DATA_HORA,
                           FOI_AJUSTADO,
                           DATA_HORA_SINCRONIZACAO,
                           COD_COLABORADOR_INSERCAO)
    VALUES (COD_UNIDADE_COLABORADOR_MARCACAO,
            F_COD_TIPO_MARCACAO,
            CPF_COLABORADOR_MARCACAO,
            F_DATA_HORA_FIM,
            TIPO_FIM,
            FONTE_DATA_HORA_SERVIDOR,
            TRUE,
            F_DATA_HORA_ATUAL,
            COD_COLABORADOR_INSERCAO) RETURNING CODIGO
               INTO CODIGO_FIM;

    IF CODIGO_FIM IS NULL OR CODIGO_FIM <= 0
    THEN
        RAISE EXCEPTION 'Erro ao inserir marcação de fim';
    END IF;

    RETURN QUERY SELECT CODIGO_INICIO,
                        CODIGO_FIM;
END;
$$;

create or replace function public.func_marcacao_relatorio_folha_ponto_jornada(f_cod_unidade bigint,
                                                                              f_cod_tipo_intervalo bigint,
                                                                              f_cpf_colaborador bigint,
                                                                              f_data_inicial date, f_data_final date,
                                                                              f_apenas_colaboradores_ativos boolean,
                                                                              f_time_zone_unidade text)
    returns TABLE
            (
                cpf_colaborador                text,
                nome_colaborador               text,
                cod_marcacao_jornada           bigint,
                dia_base                       date,
                cod_tipo_intervalo             bigint,
                cod_tipo_intervalo_por_unidade bigint,
                data_hora_inicio               timestamp without time zone,
                data_hora_fim                  timestamp without time zone,
                diferenca_marcacoes_segundos   bigint,
                tempo_noturno_em_segundos      bigint,
                marcacao_inicio_ajustada       boolean,
                marcacao_fim_ajustada          boolean,
                trocou_dia                     boolean,
                tipo_jornada                   boolean,
                desconta_jornada_bruta         boolean,
                desconta_jornada_liquida       boolean
            )
    language plpgsql
as
$$
DECLARE
    COD_TIPOS_DESCONTADOS_BRUTA   BIGINT[] := (SELECT ARRAY_AGG(COD_TIPO_DESCONTADO)
                                               FROM MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA M
                                               WHERE M.COD_UNIDADE = F_COD_UNIDADE
                                                 AND M.DESCONTA_JORNADA_BRUTA);
    COD_TIPOS_DESCONTADOS_LIQUIDA BIGINT[] := (SELECT ARRAY_AGG(COD_TIPO_DESCONTADO)
                                               FROM MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA M
                                               WHERE M.COD_UNIDADE = F_COD_UNIDADE
                                                 AND M.DESCONTA_JORNADA_LIQUIDA);
    -- Usamos o 'E' no começo das duas linhas para escapar os \n.
    ERROR_MESSAGE_TSTZRANGE       TEXT     :=
                    E'Erro!\nA marcação do colaborador <b>%s</b> possui fim antes do início, ' ||
                    E'impossibilitando a geração do relatório.\n<b>Início: %s  </b>\n<b>Fim: %s  </b>\n\n' ||
                    '<a href="https://prologapp.zendesk.com/hc/pt-br/articles/360002008792-Relat%%C3%%B3rios-Controle-de-Jornada#%%E2%%80%%9Cfolha" ' ||
                    'target="_blank">Clique aqui para mais informações </ a >';
    ERROR_DATE_FORMAT             TEXT     := 'DD/MM/YYYY HH24:MI:SS';
BEGIN
    RETURN QUERY
        WITH TODAS_MARCACOES_UNIDADE AS (
            SELECT C.NOME                                                   AS NOME_COLABORADOR,
                   F.CPF_COLABORADOR                                        AS CPF_COLABORADOR,
                   F.COD_TIPO_INTERVALO                                     AS COD_TIPO_INTERVALO,
                   F.COD_TIPO_INTERVALO_POR_UNIDADE                         AS COD_TIPO_INTERVALO_POR_UNIDADE,
                   F_IF(F.STATUS_ATIVO_INICIO, F.COD_MARCACAO_INICIO, NULL) AS COD_MARCACAO_INICIO,
                   F_IF(F.STATUS_ATIVO_FIM, F.COD_MARCACAO_FIM, NULL)       AS COD_MARCACAO_FIM,
                   F_IF(F.STATUS_ATIVO_INICIO, F.DATA_HORA_INICIO, NULL)    AS DATA_HORA_INICIO,
                   F_IF(F.STATUS_ATIVO_FIM, F.DATA_HORA_FIM, NULL)          AS DATA_HORA_FIM,
                   F_IF(F.STATUS_ATIVO_INICIO, F.FOI_AJUSTADO_INICIO, NULL) AS FOI_AJUSTADO_INICIO,
                   F_IF(F.STATUS_ATIVO_FIM, F.FOI_AJUSTADO_FIM, NULL)       AS FOI_AJUSTADO_FIM,
                   F.TIPO_JORNADA                                           AS TIPO_JORNADA
            FROM FUNC_INTERVALOS_AGRUPADOS(F_COD_UNIDADE, F_CPF_COLABORADOR, F_COD_TIPO_INTERVALO) AS F
                     -- O JOIN com colaborador é feito na primeira CTE para além de evitarmos processar colaboradores inativos
                     -- (caso esse seja o filtro), também evitarmos de dar um erro de TSRANGE para um colaborador inativo.
                     JOIN COLABORADOR C
                          ON F.CPF_COLABORADOR = C.CPF
            WHERE (F.STATUS_ATIVO_INICIO OR F.STATUS_ATIVO_FIM)
              AND F_IF(F_APENAS_COLABORADORES_ATIVOS IS NULL, TRUE, C.STATUS_ATIVO)
        ),

             -- MARCAÇÕES DE JORNADA QUE POSSUEM INÍCIO E FIM MARCADOS.
             APENAS_JORNADAS_COMPLETAS AS (
                 SELECT TDU.NOME_COLABORADOR                               AS NOME_COLABORADOR,
                        TDU.COD_MARCACAO_INICIO                            AS COD_MARCACAO_JORNADA,
                        TZ_DATE(TDU.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                             AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                 AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                            AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                               AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                               AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                  AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                            AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                               AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                   AS TIPO_JORNADA
                 FROM TODAS_MARCACOES_UNIDADE TDU
                 WHERE TDU.TIPO_JORNADA = TRUE
                   AND TDU.DATA_HORA_INICIO IS NOT NULL
                   AND TDU.DATA_HORA_FIM IS NOT NULL
                   AND ((TZ_DATE(TDU.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
                     OR
                         TZ_DATE(TDU.DATA_HORA_FIM, F_TIME_ZONE_UNIDADE) BETWEEN F_DATA_INICIAL AND F_DATA_FINAL)
                     OR
                        (TZ_DATE(TDU.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) < F_DATA_INICIAL
                            AND TZ_DATE(TDU.DATA_HORA_FIM, F_TIME_ZONE_UNIDADE) > F_DATA_FINAL))
             ),

             -- MARCAÇÕES DE JORNADA QUE NÃO POSSUEM INÍCIO OU NÃO POSSUEM FIM.
             APENAS_JORNADAS_INCOMPLETAS AS (
                 SELECT TDU.NOME_COLABORADOR                                                            AS NOME_COLABORADOR,
                        COALESCE(TDU.COD_MARCACAO_INICIO, TDU.COD_MARCACAO_FIM)                         AS COD_MARCACAO_JORNADA,
                        TZ_DATE(COALESCE(TDU.DATA_HORA_INICIO, TDU.DATA_HORA_FIM), F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                                             AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                                                          AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                                              AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                                                         AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                                                            AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                                                            AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                                               AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                                                         AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                                                            AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                                                AS TIPO_JORNADA
                 FROM TODAS_MARCACOES_UNIDADE TDU
                 WHERE TDU.TIPO_JORNADA = TRUE
                   AND (TDU.DATA_HORA_INICIO IS NULL
                     OR TDU.DATA_HORA_FIM IS NULL)
                   AND TZ_DATE(COALESCE(TDU.DATA_HORA_INICIO, TDU.DATA_HORA_FIM), F_TIME_ZONE_UNIDADE)
                     BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
             ),

             -- MARCAÇÕES QUE NÃO SÃO JORNADAS MAS TÊM INÍCIO E FIM DENTRO DE ALGUMA JORNADA.
             MARCACOES_COMPLETAS_DENTRO_JORNADA AS (
                 SELECT TDU.NOME_COLABORADOR                               AS NOME_COLABORADOR,
                        AJC.COD_MARCACAO_INICIO                            AS COD_MARCACAO_JORNADA,
                        TZ_DATE(AJC.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                             AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                 AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                            AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                               AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                               AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                  AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                            AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                               AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                   AS TIPO_JORNADA
                 FROM APENAS_JORNADAS_COMPLETAS AJC
                          JOIN TODAS_MARCACOES_UNIDADE TDU
                               ON PROLOG_TSTZRANGE(
                                          AJC.DATA_HORA_INICIO,
                                          AJC.DATA_HORA_FIM,
                                          FORMAT(
                                                  ERROR_MESSAGE_TSTZRANGE,
                                                  TDU.NOME_COLABORADOR,
                                                  TO_CHAR(AJC.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT),
                                                  TO_CHAR(AJC.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT)))
                                      @> PROLOG_TSTZRANGE(
                                          TDU.DATA_HORA_INICIO,
                                          TDU.DATA_HORA_FIM,
                                          FORMAT(
                                                  ERROR_MESSAGE_TSTZRANGE,
                                                  TDU.NOME_COLABORADOR,
                                                  TO_CHAR(TDU.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT),
                                                  TO_CHAR(TDU.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT)))
                                   AND AJC.CPF_COLABORADOR = TDU.CPF_COLABORADOR
                                   AND (TDU.TIPO_JORNADA IS NULL OR TDU.TIPO_JORNADA = FALSE)
                                   AND TDU.DATA_HORA_INICIO IS NOT NULL
                                   AND TDU.DATA_HORA_FIM IS NOT NULL
             ),

             -- MARCAÇÕES QUE NÃO SÃO JORNADAS MAS TÊM INÍCIO DENTRO DE ALGUMA JORNADA.
             MARCACOES_COMPLETAS_INICIO_DENTRO_JORNADA AS (
                 SELECT TDU.NOME_COLABORADOR                               AS NOME_COLABORADOR,
                        NULL :: BIGINT                                     AS COD_MARCACAO_JORNADA,
                        TZ_DATE(AJC.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                             AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                 AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                            AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                               AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                               AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                  AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                            AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                               AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                   AS TIPO_JORNADA
                 FROM APENAS_JORNADAS_COMPLETAS AJC
                          JOIN TODAS_MARCACOES_UNIDADE TDU
                               ON PROLOG_TSTZRANGE(
                                          AJC.DATA_HORA_INICIO,
                                          AJC.DATA_HORA_FIM,
                                          FORMAT(
                                                  ERROR_MESSAGE_TSTZRANGE,
                                                  TDU.NOME_COLABORADOR,
                                                  TO_CHAR(AJC.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT),
                                                  TO_CHAR(AJC.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT)))
                                      @> TDU.DATA_HORA_INICIO
                                   AND AJC.CPF_COLABORADOR = TDU.CPF_COLABORADOR
                 WHERE TDU.DATA_HORA_INICIO IS NOT NULL
                   AND TDU.DATA_HORA_FIM IS NOT NULL
                   AND (TDU.TIPO_JORNADA IS NULL OR TDU.TIPO_JORNADA = FALSE)
                   -- Se uma marcação está na CTE MARCACOES_COMPLETAS_DENTRO_JORNADA, ela com certeza será trazida nessa query,
                   -- mas precisamos garantir que não será retornada nesse caso.
                   AND (NOT EXISTS(SELECT MCDJ.COD_MARCACAO_INICIO
                                   FROM MARCACOES_COMPLETAS_DENTRO_JORNADA MCDJ
                                   WHERE MCDJ.COD_MARCACAO_INICIO = TDU.COD_MARCACAO_INICIO))
             ),

             -- MARCAÇÕES QUE NÃO SÃO JORNADAS MAS TÊM FIM DENTRO DE ALGUMA JORNADA.
             MARCACOES_COMPLETAS_FIM_DENTRO_JORNADA AS (
                 SELECT TDU.NOME_COLABORADOR                               AS NOME_COLABORADOR,
                        NULL :: BIGINT                                     AS COD_MARCACAO_JORNADA,
                        TZ_DATE(AJC.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                             AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                 AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                            AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                               AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                               AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                  AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                            AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                               AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                   AS TIPO_JORNADA
                 FROM APENAS_JORNADAS_COMPLETAS AJC
                          JOIN TODAS_MARCACOES_UNIDADE TDU
                               ON PROLOG_TSTZRANGE(
                                          AJC.DATA_HORA_INICIO,
                                          AJC.DATA_HORA_FIM,
                                          FORMAT(
                                                  ERROR_MESSAGE_TSTZRANGE,
                                                  TDU.NOME_COLABORADOR,
                                                  TO_CHAR(AJC.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT),
                                                  TO_CHAR(AJC.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                          ERROR_DATE_FORMAT)))
                                      @> TDU.DATA_HORA_FIM
                                   AND AJC.CPF_COLABORADOR = TDU.CPF_COLABORADOR
                 WHERE TDU.DATA_HORA_INICIO IS NOT NULL
                   AND TDU.DATA_HORA_FIM IS NOT NULL
                   AND (TDU.TIPO_JORNADA IS NULL OR TDU.TIPO_JORNADA = FALSE)
                   -- Se uma marcação está na CTE MARCACOES_COMPLETAS_DENTRO_JORNADA, ela com certeza será trazida nessa query,
                   -- mas precisamos garantir que não será retornada nesse caso.
                   AND (NOT EXISTS(SELECT MCDJ.COD_MARCACAO_FIM
                                   FROM MARCACOES_COMPLETAS_DENTRO_JORNADA MCDJ
                                   WHERE MCDJ.COD_MARCACAO_FIM = TDU.COD_MARCACAO_FIM))
                   -- Se uma marcação teve início dentro de uma jornada e fim dentro de outra, então ela foi adiciona à uma
                   -- jornada na CTE MARCACOES_INICIO_DENTRO_JORNADA e agora seria adicionada novamente a outra jornada,
                   -- precisamos impedir isso de acontecer.
                   AND (NOT EXISTS(SELECT MCIDJ.COD_MARCACAO_FIM
                                   FROM MARCACOES_COMPLETAS_INICIO_DENTRO_JORNADA MCIDJ
                                   WHERE MCIDJ.COD_MARCACAO_FIM = TDU.COD_MARCACAO_FIM))
             ),

             -- MARCAÇÕES QUE OU NÃO POSSUEM INÍCIO OU NÃO POSSUEM FIM MAS ESTÃO DENTRO DE UMA JORNADA.
             MARCACOES_INCOMPLETAS_DENTRO_JORNADA AS (
                 SELECT TDU.NOME_COLABORADOR                               AS NOME_COLABORADOR,
                        NULL :: BIGINT                                     AS COD_MARCACAO_JORNADA,
                        TZ_DATE(AJC.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                             AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                 AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                            AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                               AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                               AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                  AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                            AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                               AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                   AS TIPO_JORNADA
                 FROM APENAS_JORNADAS_COMPLETAS AJC
                          JOIN TODAS_MARCACOES_UNIDADE TDU
                               ON (TDU.DATA_HORA_INICIO IS NULL OR TDU.DATA_HORA_FIM IS NULL)
                                   AND PROLOG_TSTZRANGE(
                                               AJC.DATA_HORA_INICIO,
                                               AJC.DATA_HORA_FIM,
                                               FORMAT(
                                                       ERROR_MESSAGE_TSTZRANGE,
                                                       TDU.NOME_COLABORADOR,
                                                       TO_CHAR(AJC.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                               ERROR_DATE_FORMAT),
                                                       TO_CHAR(AJC.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE,
                                                               ERROR_DATE_FORMAT)))
                                      @> COALESCE(TDU.DATA_HORA_INICIO, TDU.DATA_HORA_FIM)
                                   AND AJC.CPF_COLABORADOR = TDU.CPF_COLABORADOR
             ),

             -- MARCAÇÕES QUE NÃO SÃO JORNADAS E NÃO TÊM INÍCIO E NEM FIM DENTRO DE NENHUMA JORNADA.
             MARCACOES_COMPLETAS_FORA_JORNADA AS (
                 SELECT TDU.NOME_COLABORADOR                               AS NOME_COLABORADOR,
                        NULL :: BIGINT                                     AS COD_MARCACAO_JORNADA,
                        TZ_DATE(TDU.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                             AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                 AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                            AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                               AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                               AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                  AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                            AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                               AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                   AS TIPO_JORNADA
                 FROM TODAS_MARCACOES_UNIDADE TDU
                 WHERE (TDU.TIPO_JORNADA IS NULL OR TDU.TIPO_JORNADA = FALSE)
                   AND TDU.DATA_HORA_INICIO IS NOT NULL
                   AND TDU.DATA_HORA_FIM IS NOT NULL
                   AND ((TZ_DATE(TDU.DATA_HORA_INICIO, F_TIME_ZONE_UNIDADE) BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
                     OR
                         TZ_DATE(TDU.DATA_HORA_FIM, F_TIME_ZONE_UNIDADE) BETWEEN F_DATA_INICIAL AND F_DATA_FINAL))
                   AND ((NOT EXISTS(SELECT MCDJ.COD_MARCACAO_INICIO
                                    FROM MARCACOES_COMPLETAS_DENTRO_JORNADA MCDJ
                                    WHERE MCDJ.COD_MARCACAO_INICIO = TDU.COD_MARCACAO_INICIO))
                     AND
                        (NOT EXISTS(SELECT MCDJ.COD_MARCACAO_FIM
                                    FROM MARCACOES_COMPLETAS_DENTRO_JORNADA MCDJ
                                    WHERE MCDJ.COD_MARCACAO_FIM = TDU.COD_MARCACAO_FIM)))
                   AND ((NOT EXISTS(SELECT MCIDJ.COD_MARCACAO_INICIO
                                    FROM MARCACOES_COMPLETAS_INICIO_DENTRO_JORNADA MCIDJ
                                    WHERE MCIDJ.COD_MARCACAO_INICIO = TDU.COD_MARCACAO_INICIO))
                     AND
                        (NOT EXISTS(SELECT MCIDJ.COD_MARCACAO_FIM
                                    FROM MARCACOES_COMPLETAS_INICIO_DENTRO_JORNADA MCIDJ
                                    WHERE MCIDJ.COD_MARCACAO_FIM = TDU.COD_MARCACAO_FIM)))
                   AND ((NOT EXISTS(SELECT MCFDJ.COD_MARCACAO_INICIO
                                    FROM MARCACOES_COMPLETAS_FIM_DENTRO_JORNADA MCFDJ
                                    WHERE MCFDJ.COD_MARCACAO_INICIO = TDU.COD_MARCACAO_INICIO))
                     AND
                        (NOT EXISTS(SELECT MCFDJ.COD_MARCACAO_FIM
                                    FROM MARCACOES_COMPLETAS_FIM_DENTRO_JORNADA MCFDJ
                                    WHERE MCFDJ.COD_MARCACAO_FIM = TDU.COD_MARCACAO_FIM)))
             ),

             -- MARCAÇÕES QUE POSSUEM APENAS INÍCIO OU FIM, NÃO AMBOS, E ESTÃO FORA DE JORNADA.
             MARCACOES_INCOMPLETAS_FORA_JORNADA AS (
                 SELECT TDU.NOME_COLABORADOR                                                            AS NOME_COLABORADOR,
                        NULL :: BIGINT                                                                  AS COD_MARCACAO_JORNADA,
                        TZ_DATE(COALESCE(TDU.DATA_HORA_INICIO, TDU.DATA_HORA_FIM), F_TIME_ZONE_UNIDADE) AS DIA_BASE,
                        TDU.CPF_COLABORADOR                                                             AS CPF_COLABORADOR,
                        TDU.COD_TIPO_INTERVALO                                                          AS COD_TIPO_INTERVALO,
                        TDU.COD_TIPO_INTERVALO_POR_UNIDADE                                              AS COD_TIPO_INTERVALO_POR_UNIDADE,
                        TDU.COD_MARCACAO_INICIO                                                         AS COD_MARCACAO_INICIO,
                        TDU.COD_MARCACAO_FIM                                                            AS COD_MARCACAO_FIM,
                        TDU.DATA_HORA_INICIO                                                            AS DATA_HORA_INICIO,
                        TDU.DATA_HORA_FIM                                                               AS DATA_HORA_FIM,
                        TDU.FOI_AJUSTADO_INICIO                                                         AS FOI_AJUSTADO_INICIO,
                        TDU.FOI_AJUSTADO_FIM                                                            AS FOI_AJUSTADO_FIM,
                        TDU.TIPO_JORNADA                                                                AS TIPO_JORNADA
                 FROM TODAS_MARCACOES_UNIDADE TDU
                 WHERE (TDU.DATA_HORA_INICIO IS NULL OR TDU.DATA_HORA_FIM IS NULL)
                   AND (TDU.TIPO_JORNADA IS NULL OR TDU.TIPO_JORNADA = FALSE)
                   AND TZ_DATE(COALESCE(TDU.DATA_HORA_INICIO, TDU.DATA_HORA_FIM), F_TIME_ZONE_UNIDADE)
                     BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
                   -- Nossa maneira de garantir que a marcação está fora de jornada, é garantindo que ela não está dentro
                   -- através das CTEs criadas anteriormente que contém as marcações incompletas dentro de jornada.
                   AND (NOT EXISTS(SELECT COALESCE(MIDJ.COD_MARCACAO_INICIO, MIDJ.COD_MARCACAO_FIM)
                                   FROM MARCACOES_INCOMPLETAS_DENTRO_JORNADA MIDJ
                                        -- Se nossas marcações de início e fim tivessem códigos diferentes, isso não funcionaria,
                                        -- mas como o código é sequencial, não importa se compararmos um início com um fim ou
                                        -- vice versa, porque os códigos não vão bater.
                                   WHERE COALESCE(MIDJ.COD_MARCACAO_INICIO, MIDJ.COD_MARCACAO_FIM) =
                                         COALESCE(TDU.COD_MARCACAO_INICIO, TDU.COD_MARCACAO_FIM)))
             ),

             TODAS_MARCACOES AS (
                 SELECT *
                 FROM APENAS_JORNADAS_COMPLETAS
                 UNION ALL
                 SELECT *
                 FROM APENAS_JORNADAS_INCOMPLETAS
                 UNION ALL
                 SELECT *
                 FROM MARCACOES_COMPLETAS_DENTRO_JORNADA
                 UNION ALL
                 SELECT *
                 FROM MARCACOES_COMPLETAS_INICIO_DENTRO_JORNADA
                 UNION ALL
                 SELECT *
                 FROM MARCACOES_COMPLETAS_FIM_DENTRO_JORNADA
                 UNION ALL
                 SELECT *
                 FROM MARCACOES_COMPLETAS_FORA_JORNADA
                 UNION ALL
                 SELECT *
                 FROM MARCACOES_INCOMPLETAS_DENTRO_JORNADA
                 UNION ALL
                 SELECT *
                 FROM MARCACOES_INCOMPLETAS_FORA_JORNADA
             )

        SELECT LPAD(TM.CPF_COLABORADOR :: TEXT, 11, '0')                          AS CPF_COLABORADOR,
               TM.NOME_COLABORADOR :: TEXT                                        AS NOME_COLABORADOR,
               TM.COD_MARCACAO_JORNADA                                            AS COD_MARCACAO_JORNADA,
               TM.DIA_BASE                                                        AS DIA_BASE,
               TM.COD_TIPO_INTERVALO                                              AS COD_TIPO_INTERVALO,
               TM.COD_TIPO_INTERVALO_POR_UNIDADE                                  AS COD_TIPO_INTERVALO_POR_UNIDADE,
               TM.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE               AS DATA_HORA_INICIO,
               TM.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE                  AS DATA_HORA_FIM,
               TO_SECONDS(TM.DATA_HORA_FIM - TM.DATA_HORA_INICIO)                 AS DIFERENCA_MARCACOES_SEGUNDOS,
               COALESCE(
                       FUNC_MARCACAO_CALCULA_TOTAL_SEGUNDOS_EM_HORAS_NOTURNAS(TM.DATA_HORA_INICIO,
                                                                              TM.DATA_HORA_FIM,
                                                                              F_TIME_ZONE_UNIDADE),
                       0)                                                         AS TEMPO_NOTURNO_EM_SEGUNDOS,
               TM.FOI_AJUSTADO_INICIO                                             AS FOI_AJUSTADO_INICIO,
               TM.FOI_AJUSTADO_FIM                                                AS FOI_AJUSTADO_FIM,
               TM.DATA_HORA_INICIO IS NOT NULL AND TM.DATA_HORA_FIM IS NOT NULL
                   AND (TM.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE
                   != (TM.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE AS TROCOU_DIA,
               TM.TIPO_JORNADA                                                    AS TIPO_JORNADA,
               TM.COD_TIPO_INTERVALO = ANY (COD_TIPOS_DESCONTADOS_BRUTA)          AS DESCONTA_JORNADA_BRUTA,
               TM.COD_TIPO_INTERVALO = ANY (COD_TIPOS_DESCONTADOS_LIQUIDA)        AS DESCONTA_JORNADA_LIQUIDA
        FROM TODAS_MARCACOES AS TM
        ORDER BY TM.CPF_COLABORADOR,
                 TM.DIA_BASE,
                 TM.COD_MARCACAO_JORNADA ASC,
                 COALESCE(TM.DATA_HORA_INICIO, TM.DATA_HORA_FIM) ASC;
END;
$$;

create or replace function public.func_marcacao_remove_infos_tipo_jornada_unidade(f_cod_unidade bigint, f_cod_tipo_editado bigint) returns boolean
    language plpgsql
as
$$
BEGIN
    IF (SELECT TIPO_JORNADA
        FROM VIEW_INTERVALO_TIPO VIT
        WHERE VIT.CODIGO = F_COD_TIPO_EDITADO)
    THEN
        DELETE FROM MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA WHERE COD_UNIDADE = F_COD_UNIDADE;
        DELETE FROM MARCACAO_TIPO_JORNADA WHERE COD_UNIDADE = F_COD_UNIDADE;
    END IF;
    RETURN TRUE;
END;
$$;

create or replace function public.func_marcacao_verifica_unidade_tem_tipo_jornada(f_cod_unidade bigint) returns boolean
    language plpgsql
as
$$
BEGIN
    RETURN EXISTS(SELECT MTJ.COD_TIPO_JORNADA
                  FROM MARCACAO_TIPO_JORNADA MTJ
                  WHERE MTJ.COD_UNIDADE = F_COD_UNIDADE);
END;
$$;

create or replace function suporte.func_pneu_altera_pressao_ideal_by_dimensao(f_cod_empresa bigint,
                                                                              f_cod_unidade bigint,
                                                                              f_cod_dimensao bigint,
                                                                              f_nova_pressao_recomendada bigint,
                                                                              f_qtd_pneus_impactados bigint,
                                                                              OUT aviso_pressao_alterada text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_REAL_PNEUS_IMPACTADOS  BIGINT;
    PRESSAO_MINIMA_RECOMENDADA BIGINT := 25;
    PRESSAO_MAXIMA_RECOMENDADA BIGINT := 150;
BEGIN
    --Verifica se a pressao informada está dentro das recomendadas.
    IF (F_NOVA_PRESSAO_RECOMENDADA NOT BETWEEN PRESSAO_MINIMA_RECOMENDADA AND PRESSAO_MAXIMA_RECOMENDADA)
    THEN
        RAISE EXCEPTION 'Pressão recomendada não está dentro dos valores pré-estabelecidos.
                        Mínima Recomendada: % ---- Máxima Recomendada: %', PRESSAO_MINIMA_RECOMENDADA,
            PRESSAO_MAXIMA_RECOMENDADA;
    END IF;

    -- Verifica se a empresa existe.
    IF NOT EXISTS(SELECT E.CODIGO
                  FROM EMPRESA E
                  WHERE E.CODIGO = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'Empresa de código % não existe!', F_COD_EMPRESA;
    END IF;

    -- Verifica se a unidade existe.
    IF NOT EXISTS(SELECT U.CODIGO
                  FROM UNIDADE U
                  WHERE U.CODIGO = F_COD_UNIDADE)
    THEN
        RAISE EXCEPTION 'Unidade de código % não existe!', F_COD_UNIDADE;
    END IF;

    -- Verifica se existe a dimensão informada.
    IF NOT EXISTS(SELECT DM.CODIGO
                  FROM DIMENSAO_PNEU DM
                  WHERE DM.CODIGO = F_COD_DIMENSAO)
    THEN
        RAISE EXCEPTION 'Dimensao de código % não existe!', F_COD_DIMENSAO;
    END IF;

    -- Verifica se a unidade é da empresa informada.
    IF NOT EXISTS(SELECT U.CODIGO
                  FROM UNIDADE U
                  WHERE U.CODIGO = F_COD_UNIDADE
                    AND U.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'A unidade % não pertence a empresa %!', F_COD_UNIDADE, F_COD_EMPRESA;
    END IF;

    -- Verifica se algum pneu possui dimensão informada.
    IF NOT EXISTS(SELECT P.COD_DIMENSAO
                  FROM PNEU P
                  WHERE P.COD_DIMENSAO = F_COD_DIMENSAO
                    AND P.COD_UNIDADE = F_COD_UNIDADE
                    AND P.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'Não existem pneus com a dimensão % na unidade %', F_COD_DIMENSAO, F_COD_UNIDADE;
    END IF;

    -- Verifica quantidade de pneus impactados.
    SELECT COUNT(P.CODIGO)
    FROM PNEU P
    WHERE P.COD_DIMENSAO = F_COD_DIMENSAO
      AND P.COD_UNIDADE = F_COD_UNIDADE
      AND P.COD_EMPRESA = F_COD_EMPRESA
    INTO QTD_REAL_PNEUS_IMPACTADOS;
    IF (QTD_REAL_PNEUS_IMPACTADOS <> F_QTD_PNEUS_IMPACTADOS)
    THEN
        RAISE EXCEPTION 'A quantidade de pneus informados como impactados pela mudança de pressão (%) não condiz com a
                       quantidade real de pneus que serão afetados!', F_QTD_PNEUS_IMPACTADOS;
    END IF;

    UPDATE PNEU
    SET PRESSAO_RECOMENDADA = F_NOVA_PRESSAO_RECOMENDADA
    WHERE COD_DIMENSAO = F_COD_DIMENSAO
      AND COD_UNIDADE = F_COD_UNIDADE
      AND COD_EMPRESA = F_COD_EMPRESA;

    SELECT CONCAT('Pressão recomendada dos pneus com dimensão ',
                  F_COD_DIMENSAO,
                  ' da unidade ',
                  F_COD_UNIDADE,
                  ' alterada para ',
                  F_NOVA_PRESSAO_RECOMENDADA,
                  ' psi')
    INTO AVISO_PRESSAO_ALTERADA;
END;
$$;

create or replace function suporte.func_pneu_altera_pressao_ideal_by_numero_fogo(f_cod_empresa bigint,
                                                                                 f_cod_unidade bigint,
                                                                                 f_numero_fogo text,
                                                                                 f_nova_pressao_recomendada bigint,
                                                                                 OUT aviso_pressao_alterada text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS     BIGINT;
    PRESSAO_MINIMA_RECOMENDADA BIGINT := 25;
    PRESSAO_MAXIMA_RECOMENDADA BIGINT := 150;
BEGIN
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE);

    --Verifica se a pressao informada está dentro das recomendadas.
    IF (F_NOVA_PRESSAO_RECOMENDADA NOT BETWEEN PRESSAO_MINIMA_RECOMENDADA AND PRESSAO_MAXIMA_RECOMENDADA)
    THEN
        RAISE EXCEPTION 'Pressão recomendada não está dentro dos valores pré-estabelecidos.
                        Mínima Recomendada: % ---- Máxima Recomendada: %', PRESSAO_MINIMA_RECOMENDADA,
            PRESSAO_MAXIMA_RECOMENDADA;
    END IF;

    -- Verifica se existe o número de fogo informado.
    IF NOT EXISTS(SELECT PD.CODIGO
                  FROM PNEU PD
                  WHERE PD.CODIGO_CLIENTE = F_NUMERO_FOGO
                    AND PD.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'Número de fogo % não está cadastrado na empresa %!', F_NUMERO_FOGO, F_COD_EMPRESA;
    END IF;

    UPDATE PNEU
    SET PRESSAO_RECOMENDADA = F_NOVA_PRESSAO_RECOMENDADA
    WHERE CODIGO_CLIENTE = F_NUMERO_FOGO
      AND COD_UNIDADE = F_COD_UNIDADE
      AND COD_EMPRESA = F_COD_EMPRESA;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao atualizar a pressão recomendada com estes parâemtros:
                     Empresa %, Unidade %, Número de fogo %, Nova pressão %',
            F_COD_EMPRESA,
            F_COD_UNIDADE,
            F_NUMERO_FOGO,
            F_NOVA_PRESSAO_RECOMENDADA;
    END IF;

    SELECT CONCAT('Pressão recomendada do pneu com número de fogo ',
                  F_NUMERO_FOGO,
                  ' da empresa ',
                  F_COD_EMPRESA,
                  ' da unidade ',
                  F_COD_UNIDADE,
                  ' alterada para ',
                  F_NOVA_PRESSAO_RECOMENDADA,
                  ' psi')
    INTO AVISO_PRESSAO_ALTERADA;
END;
$$;

create or replace function suporte.func_pneu_deleta_pneu(f_cod_unidade bigint, f_codigo bigint, f_codigo_cliente text,
                                                         OUT aviso_pneu_deletado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
    F_STATUS_PNEU_ANALISE  TEXT := 'ANALISE';
BEGIN

    -- Verifica se o pneu existe.
    IF ((SELECT COUNT(CODIGO)
         FROM PNEU_DATA
         WHERE CODIGO = F_CODIGO
           AND COD_UNIDADE = F_COD_UNIDADE
           AND CODIGO_CLIENTE = F_CODIGO_CLIENTE) <= 0)
    THEN
        RAISE EXCEPTION 'Nenhum pneu encontrado com estes parâmetros: Código %, Código cliente % e Unidade %',
            F_CODIGO, F_CODIGO_CLIENTE, F_COD_UNIDADE;
    END IF;

    -- Verifica se o pneu está aplicado.
    IF ((SELECT COUNT(VP.PLACA)
         FROM VEICULO_PNEU VP
         WHERE VP.COD_PNEU = F_CODIGO
           AND VP.COD_UNIDADE = F_COD_UNIDADE) > 0)
    THEN
        RAISE EXCEPTION 'O pneu não pode ser deletado pois está aplicado! Parâmetros: Código %, Código cliente % e
            Unidade %', F_CODIGO, F_CODIGO_CLIENTE, F_COD_UNIDADE;
    END IF;

    -- Verifica se o pneu está em análise.
    IF ((SELECT COUNT(codigo)
         FROM PNEU_DATA
         WHERE CODIGO = F_CODIGO
           AND COD_UNIDADE = F_COD_UNIDADE
           AND CODIGO_CLIENTE = F_CODIGO_CLIENTE
           AND STATUS = F_STATUS_PNEU_ANALISE) > 0)
    THEN
        RAISE EXCEPTION 'O pneu não pode ser deletado pois está em análise! Parâmetros: Código %, Código cliente % e
            Unidade %', F_CODIGO, F_CODIGO_CLIENTE, F_COD_UNIDADE;
    END IF;

    -- Deleta pneu.
    UPDATE PNEU_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = F_CODIGO
      AND COD_UNIDADE = F_COD_UNIDADE
      AND CODIGO_CLIENTE = F_CODIGO_CLIENTE;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao deletar o pneu de Código %, Código cliente % e Unidade %',
            F_CODIGO, F_CODIGO_CLIENTE, F_COD_UNIDADE;
    END IF;

    SELECT 'PNEU DELETADO: '
               || F_CODIGO
               || ', CÓDIGO DO CLIENTE: '
               || F_CODIGO_CLIENTE
               || ', CÓDIGO DA UNIDADE: '
               || F_COD_UNIDADE
    INTO AVISO_PNEU_DELETADO;
END
$$;

create or replace function public.func_pneu_format_dimensao(f_largura integer, f_altura integer, f_aro real) returns text
    language plpgsql
as
$$
BEGIN
    RETURN (((F_LARGURA || '/' :: TEXT) || F_ALTURA) || ' R' :: TEXT) || F_ARO;
END;
$$;

create or replace function public.func_pneu_format_sulco(f_sulco real) returns text
    language plpgsql
as
$$
BEGIN
    RETURN REPLACE(COALESCE(TRUNC(F_SULCO :: NUMERIC, 2) :: TEXT, '-'), '.', ',');
END;
$$;

create or replace function public.func_pneu_get_nivel_desgaste_irregular(f_variacao real,
                                                                         f_tipo_desgaste_analisado pneu_desgaste_irregular_type) returns pneu_desgaste_irregular_nivel_type
    language plpgsql
as
$$
BEGIN
    IF F_VARIACAO <= 0
    THEN
        RETURN NULL :: PNEU_DESGASTE_IRREGULAR_NIVEL_TYPE;
    END IF;

    IF F_VARIACAO :: NUMERIC <@ (SELECT FAIXA_DESGASTE_BAIXO_MILIMETROS
                                 FROM PNEU_NIVEL_DESGASTE_IRREGULAR_PADRAO_PROLOG
                                 WHERE TIPO_DESGASTE_IRREGULAR = F_TIPO_DESGASTE_ANALISADO)
    THEN
        RETURN 'BAIXO' :: PNEU_DESGASTE_IRREGULAR_NIVEL_TYPE;
    ELSEIF F_VARIACAO :: NUMERIC <@ (SELECT FAIXA_DESGASTE_MODERADO_MILIMETROS
                                     FROM PNEU_NIVEL_DESGASTE_IRREGULAR_PADRAO_PROLOG
                                     WHERE TIPO_DESGASTE_IRREGULAR = F_TIPO_DESGASTE_ANALISADO)
    THEN
        RETURN 'MODERADO' :: PNEU_DESGASTE_IRREGULAR_NIVEL_TYPE;
    ELSEIF F_VARIACAO :: NUMERIC <@ (SELECT FAIXA_DESGASTE_ACENTUADO_MILIMETROS
                                     FROM PNEU_NIVEL_DESGASTE_IRREGULAR_PADRAO_PROLOG
                                     WHERE TIPO_DESGASTE_IRREGULAR = F_TIPO_DESGASTE_ANALISADO)
    THEN
        RETURN 'ACENTUADO' :: PNEU_DESGASTE_IRREGULAR_NIVEL_TYPE;
    END IF;
END;
$$;

create or replace function public.func_pneu_get_primeira_ultima_afericao(f_cod_pneu bigint)
    returns TABLE
            (
                cod_pneu                               bigint,
                data_hora_primeira_afericao            timestamp with time zone,
                cod_primeira_afericao                  bigint,
                cod_unidade_primeira_afericao          bigint,
                tipo_processo_coleta_primeira_afericao text,
                data_hora_ultima_afericao              timestamp with time zone,
                cod_ultima_afericao                    bigint,
                cod_unidade_ultima_afericao            bigint,
                tipo_processo_coleta_ultima_afericao   text,
                quantidade_afericoes_pneu              integer
            )
    language sql
as
$$
WITH DADOS_AFERICAO AS (
    SELECT A.CODIGO                        AS COD_AFERICAO,
           A.COD_UNIDADE                   AS COD_UNIDADE_AFERICAO,
           A.DATA_HORA                     AS DATA_HORA_AFERICAO,
           A.TIPO_PROCESSO_COLETA          AS TIPO_PROCESSO_COLETA_AFERICAO,
           AV.COD_PNEU                     AS COD_PNEU,
           AV.ALTURA_SULCO_CENTRAL_INTERNO,
           AV.ALTURA_SULCO_CENTRAL_EXTERNO,
           AV.ALTURA_SULCO_EXTERNO,
           AV.ALTURA_SULCO_INTERNO,
           ROW_NUMBER()
           OVER (
               PARTITION BY AV.COD_PNEU
               ORDER BY A.DATA_HORA ASC )  AS ROW_NUMBER_ASC,
           ROW_NUMBER()
           OVER (
               PARTITION BY AV.COD_PNEU
               ORDER BY A.DATA_HORA DESC ) AS ROW_NUMBER_DESC
    FROM AFERICAO A
             INNER JOIN AFERICAO_VALORES AV ON A.CODIGO = AV.COD_AFERICAO
    WHERE AV.COD_PNEU = F_COD_PNEU),


     PRIMEIRA_AFERICAO AS (
         SELECT DA.COD_PNEU,
                DA.COD_AFERICAO,
                DA.COD_UNIDADE_AFERICAO,
                DA.TIPO_PROCESSO_COLETA_AFERICAO,
                DA.DATA_HORA_AFERICAO
         FROM DADOS_AFERICAO DA
         WHERE DA.ROW_NUMBER_ASC = 1
           AND DA.COD_PNEU = F_COD_PNEU),


     ULTIMA_AFERICAO AS (
         SELECT DA.COD_PNEU,
                DA.COD_AFERICAO,
                DA.COD_UNIDADE_AFERICAO,
                DA.TIPO_PROCESSO_COLETA_AFERICAO,
                DA.DATA_HORA_AFERICAO
         FROM DADOS_AFERICAO DA
         WHERE DA.ROW_NUMBER_DESC = 1
           AND DA.COD_PNEU = F_COD_PNEU),


     ANALISES_AFERICOES AS (
         SELECT DA.COD_PNEU,
                COUNT(COD_PNEU) :: INTEGER AS QUANTIDADE_AFERICOES_PNEU
         FROM DADOS_AFERICAO DA
         WHERE DA.COD_PNEU = F_COD_PNEU
         GROUP BY DA.COD_PNEU
     )
SELECT AA.COD_PNEU                      AS COD_PNEU,
       PA.DATA_HORA_AFERICAO            AS DATA_HORA_PRIMEIRA_AFERICAO,
       PA.COD_AFERICAO                  AS COD_PRIMEIRA_AFERICAO,
       PA.COD_UNIDADE_AFERICAO          AS COD_UNIDADE_PRIMEIRA_AFERICAO,
       PA.TIPO_PROCESSO_COLETA_AFERICAO AS TIPO_PROCESSO_COLETA_PRIMEIRA_AFERICAO,
       UA.DATA_HORA_AFERICAO            AS DATA_HORA_ULTIMA_AFERICAO,
       UA.COD_AFERICAO                  AS COD_ULTIMA_AFERICAO,
       UA.COD_UNIDADE_AFERICAO          AS COD_UNIDADE_ULTIMA_AFERICAO,
       UA.TIPO_PROCESSO_COLETA_AFERICAO AS TIPO_PROCESSO_COLETA_ULTIMA_AFERICAO,
       AA.QUANTIDADE_AFERICOES_PNEU     AS QUANTIDADE_AFERICOES_PNEU
FROM ANALISES_AFERICOES AA
         INNER JOIN PRIMEIRA_AFERICAO PA
                    ON PA.COD_PNEU = AA.COD_PNEU
         INNER JOIN ULTIMA_AFERICAO UA
                    ON UA.COD_PNEU = AA.COD_PNEU
WHERE AA.COD_PNEU = F_COD_PNEU
ORDER BY AA.COD_PNEU;
$$;

create or replace function public.func_pneu_get_primeira_ultima_afericao_por_vida(f_cod_pneu bigint)
    returns TABLE
            (
                cod_pneu                       bigint,
                data_hora_primeira_afericao    timestamp with time zone,
                cod_primeira_afericao          bigint,
                cod_unidade_primeira_afericao  bigint,
                data_hora_ultima_afericao      timestamp with time zone,
                cod_ultima_afericao            bigint,
                cod_unidade_ultima_afericao    bigint,
                vida_analisada_pneu            integer,
                quantidade_afericoes_pneu_vida integer,
                maior_sulco_aferido_vida       real,
                menor_sulco_aferido_vida       real
            )
    language sql
as
$$
WITH DADOS_AFERICAO AS (
    SELECT A.CODIGO                        AS COD_AFERICAO,
           A.COD_UNIDADE                   AS COD_UNIDADE_AFERICAO,
           A.DATA_HORA                     AS DATA_HORA_AFERICAO,
           A.TIPO_PROCESSO_COLETA          AS TIPO_PROCESSO_COLETA_AFERICAO,
           AV.COD_PNEU                     AS COD_PNEU,
           AV.VIDA_MOMENTO_AFERICAO        AS VIDA_MOMENTO_AFERICAO,
           AV.ALTURA_SULCO_CENTRAL_INTERNO,
           AV.ALTURA_SULCO_CENTRAL_EXTERNO,
           AV.ALTURA_SULCO_EXTERNO,
           AV.ALTURA_SULCO_INTERNO,
           ROW_NUMBER()
           OVER (
               PARTITION BY AV.COD_PNEU, AV.VIDA_MOMENTO_AFERICAO
               ORDER BY A.DATA_HORA ASC )  AS ROW_NUMBER_ASC,
           ROW_NUMBER()
           OVER (
               PARTITION BY AV.COD_PNEU, AV.VIDA_MOMENTO_AFERICAO
               ORDER BY A.DATA_HORA DESC ) AS ROW_NUMBER_DESC
    FROM AFERICAO A
             INNER JOIN AFERICAO_VALORES AV ON A.CODIGO = AV.COD_AFERICAO
    WHERE AV.COD_PNEU = F_COD_PNEU),


     PRIMEIRA_AFERICAO AS (
         SELECT DA.COD_PNEU,
                DA.VIDA_MOMENTO_AFERICAO,
                DA.COD_AFERICAO,
                DA.COD_UNIDADE_AFERICAO,
                DA.DATA_HORA_AFERICAO
         FROM DADOS_AFERICAO DA
         WHERE DA.ROW_NUMBER_ASC = 1
           AND DA.COD_PNEU = F_COD_PNEU),


     ULTIMA_AFERICAO AS (
         SELECT DA.COD_PNEU,
                DA.VIDA_MOMENTO_AFERICAO,
                DA.COD_AFERICAO,
                DA.COD_UNIDADE_AFERICAO,
                DA.DATA_HORA_AFERICAO
         FROM DADOS_AFERICAO DA
         WHERE DA.ROW_NUMBER_DESC = 1
           AND DA.COD_PNEU = F_COD_PNEU),


     ANALISES_AFERICOES AS (
         SELECT DA.COD_PNEU,
                DA.VIDA_MOMENTO_AFERICAO            AS VIDA_ANALISADA_PNEU,
                COUNT(COD_PNEU) :: INTEGER          AS QUANTIDADE_AFERICOES_PNEU_VIDA,
                MAX(GREATEST(ALTURA_SULCO_EXTERNO, ALTURA_SULCO_CENTRAL_EXTERNO, ALTURA_SULCO_CENTRAL_INTERNO,
                             ALTURA_SULCO_INTERNO)) AS MAIOR_SULCO_AFERIDO_VIDA,
                MIN(LEAST(ALTURA_SULCO_EXTERNO, ALTURA_SULCO_CENTRAL_EXTERNO, ALTURA_SULCO_CENTRAL_INTERNO,
                          ALTURA_SULCO_INTERNO))    AS MENOR_SULCO_AFERIDO_VIDA
         FROM DADOS_AFERICAO DA
         WHERE DA.COD_PNEU = F_COD_PNEU
         GROUP BY DA.COD_PNEU, DA.VIDA_MOMENTO_AFERICAO
     )
SELECT AA.COD_PNEU                       AS COD_PNEU,
       PA.DATA_HORA_AFERICAO             AS DATA_HORA_PRIMEIRA_AFERICAO,
       PA.COD_AFERICAO                   AS COD_PRIMEIRA_AFERICAO,
       PA.COD_UNIDADE_AFERICAO           AS COD_UNIDADE_PRIMEIRA_AFERICAO,
       UA.DATA_HORA_AFERICAO             AS DATA_HORA_ULTIMA_AFERICAO,
       UA.COD_AFERICAO                   AS COD_ULTIMA_AFERICAO,
       UA.COD_UNIDADE_AFERICAO           AS COD_UNIDADE_ULTIMA_AFERICAO,
       AA.VIDA_ANALISADA_PNEU            AS VIDA_ANALISADA_PNEU,
       AA.QUANTIDADE_AFERICOES_PNEU_VIDA AS QUANTIDADE_AFERICOES_PNEU_VIDA,
       AA.MAIOR_SULCO_AFERIDO_VIDA       AS MAIOR_SULCO_AFERIDO_VIDA,
       AA.MENOR_SULCO_AFERIDO_VIDA       AS MENOR_SULCO_AFERIDO_VIDA
FROM ANALISES_AFERICOES AA
         INNER JOIN PRIMEIRA_AFERICAO PA
                    ON PA.COD_PNEU = AA.COD_PNEU
                        AND PA.VIDA_MOMENTO_AFERICAO = AA.VIDA_ANALISADA_PNEU
         INNER JOIN ULTIMA_AFERICAO UA
                    ON UA.COD_PNEU = AA.COD_PNEU
                        AND UA.VIDA_MOMENTO_AFERICAO = AA.VIDA_ANALISADA_PNEU
WHERE AA.COD_PNEU = F_COD_PNEU
ORDER BY AA.COD_PNEU, AA.VIDA_ANALISADA_PNEU;
$$;

create or replace function public.func_pneu_relatorio_km_rodado_por_vida(f_cod_unidades bigint[])
    returns TABLE
            (
                "UNIDADE ALOCADO"          text,
                "PNEU"                     text,
                "VIDA"                     integer,
                "KM RODADO VIDA"           numeric,
                "KM RODADO TODAS AS VIDAS" numeric
            )
    language sql
as
$$
SELECT U.NOME                         AS UNIDADE_ALOCADO,
       P.CODIGO_CLIENTE               AS COD_PNEU,
       VP.VIDA_PNEU                   AS VIDA,
       VP.KM_RODADO_VIDA              AS KM_RODADO_VIDA,
       VP.TOTAL_KM_RODADO_TODAS_VIDAS AS KM_RODADO_TODAS_VIDAS
FROM VIEW_PNEU_KM_RODADO_TOTAL VP
         JOIN PNEU P
              ON P.CODIGO = VP.COD_PNEU
         JOIN UNIDADE U
              ON U.CODIGO = P.COD_UNIDADE
WHERE P.COD_UNIDADE = ANY (F_COD_UNIDADES)
ORDER BY U.CODIGO ASC, P.CODIGO_CLIENTE ASC, VP.VIDA_PNEU ASC;
$$;

create or replace function public.func_pneu_relatorio_menor_sulco_e_pressao_pneus(f_cod_unidades bigint[])
    returns TABLE
            (
                cod_pneu         bigint,
                cod_pneu_cliente text,
                pressao_atual    numeric,
                menor_sulco      numeric
            )
    language sql
as
$$
SELECT P.CODIGO                                                                                   AS COD_PNEU,
       P.CODIGO_CLIENTE                                                                           AS COD_PNEU_CLIENTE,
       TRUNC(P.PRESSAO_ATUAL :: NUMERIC, 2)                                                       AS PRESSAO_ATUAL,
       TRUNC(LEAST(P.ALTURA_SULCO_INTERNO, P.ALTURA_SULCO_EXTERNO,
                   P.ALTURA_SULCO_CENTRAL_EXTERNO, P.ALTURA_SULCO_CENTRAL_INTERNO) :: NUMERIC, 2) AS MENOR_SULCO
FROM PNEU P
WHERE P.COD_UNIDADE = ANY (F_COD_UNIDADES)
ORDER BY MENOR_SULCO ASC
$$;

create or replace function public.func_pneu_relatorio_qtd_afericoes_por_tipo_medicao_coletada(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                data_referencia            date,
                data_referencia_formatada  text,
                qtd_afericao_pressao       numeric,
                qtd_afericao_sulco         numeric,
                qtd_afericao_sulco_pressao numeric
            )
    language plpgsql
as
$$
DECLARE
    DATE_FORMAT                    TEXT := 'DD/MM';
    MEDICAO_COLETADA_PRESSAO       TEXT := 'PRESSAO';
    MEDICAO_COLETADA_SULCO         TEXT := 'SULCO';
    MEDICAO_COLETADA_SULCO_PRESSAO TEXT := 'SULCO_PRESSAO';
BEGIN
    RETURN QUERY
        SELECT DADOS.DATA_REFERENCIA                AS DATA_REFERENCIA,
               DADOS.DATA_REFERENCIA_FORMATADA      AS DATA_REFERENCIA_FORMATADA,
               SUM(DADOS.QT_AFERICAO_PRESSAO)       AS QTD_AFERICAO_PRESSAO,
               SUM(DADOS.QT_AFERICAO_SULCO)         AS QTD_AFERICAO_SULCO,
               SUM(DADOS.QT_AFERICAO_SULCO_PRESSAO) AS QTD_AFERICAO_SULCO_PRESSAO
        FROM (SELECT (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)) :: DATE               AS DATA_REFERENCIA,
                     TO_CHAR((A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)),
                             DATE_FORMAT)                                                       AS DATA_REFERENCIA_FORMATADA,
                     SUM(CASE
                             WHEN A.TIPO_MEDICAO_COLETADA = MEDICAO_COLETADA_PRESSAO
                                 THEN 1
                             ELSE 0 END)                                                        AS QT_AFERICAO_PRESSAO,
                     SUM(CASE
                             WHEN A.TIPO_MEDICAO_COLETADA = MEDICAO_COLETADA_SULCO
                                 THEN 1
                             ELSE 0 END)                                                        AS QT_AFERICAO_SULCO,
                     SUM(CASE
                             WHEN A.TIPO_MEDICAO_COLETADA = MEDICAO_COLETADA_SULCO_PRESSAO
                                 THEN 1
                             ELSE 0 END)                                                        AS QT_AFERICAO_SULCO_PRESSAO
              FROM AFERICAO A
              WHERE A.COD_UNIDADE = ANY (F_COD_UNIDADES)
                AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
                AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
              GROUP BY A.DATA_HORA, DATA_REFERENCIA_FORMATADA, A.COD_UNIDADE
              ORDER BY A.DATA_HORA :: DATE ASC) AS DADOS
        GROUP BY DADOS.DATA_REFERENCIA, DADOS.DATA_REFERENCIA_FORMATADA
        ORDER BY DADOS.DATA_REFERENCIA ASC;
END;
$$;

create or replace function public.func_pneu_relatorio_quantidade_kms_rodados_com_servicos_abertos(f_cod_unidades bigint[])
    returns TABLE
            (
                placa_veiculo text,
                total_km      bigint
            )
    language plpgsql
as
$$
DECLARE
    TIPO_SERVICO_CALIBRAGEM TEXT := 'calibragem';
    TIPO_SERVICO_INSPECAO   TEXT := 'inspecao';
BEGIN
    RETURN QUERY
        WITH DADOS AS (SELECT DISTINCT ON (A.PLACA_VEICULO) A.PLACA_VEICULO,
                                                            AM.KM_MOMENTO_CONSERTO - A.KM_VEICULO AS TOTAL_KM
                       FROM AFERICAO_MANUTENCAO AM
                                JOIN AFERICAO A ON A.CODIGO = AM.COD_AFERICAO
                                JOIN VEICULO_PNEU VP ON VP.PLACA = A.PLACA_VEICULO
                           AND AM.COD_PNEU = VP.COD_PNEU
                           AND AM.COD_UNIDADE = VP.COD_UNIDADE
                       WHERE AM.COD_UNIDADE = ANY (F_COD_UNIDADES)
                         AND AM.DATA_HORA_RESOLUCAO IS NOT NULL
                         AND (AM.TIPO_SERVICO IN (TIPO_SERVICO_CALIBRAGEM, TIPO_SERVICO_INSPECAO))
        )

        SELECT D.PLACA_VEICULO :: TEXT AS PLACA_VEICULO,
               D.TOTAL_KM              AS TOTAL_KM
        FROM DADOS D
        WHERE D.TOTAL_KM > 0
        ORDER BY TOTAL_KM DESC;
END;
$$;

create or replace function public.func_pneu_relatorio_status_placas_afericao(f_cod_unidades bigint[],
                                                                             f_data_hora_atual_utc timestamp with time zone)
    returns TABLE
            (
                total_vencidas bigint,
                total_no_prazo bigint
            )
    language plpgsql
as
$$
DECLARE
    QTD_PLACAS_ATIVAS BIGINT := (SELECT COUNT(V.PLACA)
                                 FROM VEICULO V
                                 WHERE V.COD_UNIDADE = ANY (F_COD_UNIDADES)
                                   AND V.STATUS_ATIVO = TRUE);
BEGIN
    RETURN QUERY
        WITH QTD_PLACAS_VENCIDAS AS (
            SELECT (SELECT COUNT(PLACA)
                    FROM FUNC_AFERICAO_RELATORIO_QTD_DIAS_PLACAS_VENCIDAS(F_COD_UNIDADES,
                                                                          F_DATA_HORA_ATUAL_UTC)) AS QTD_VENCIDAS
        )

        SELECT QPV.QTD_VENCIDAS                     AS QTD_VENCIDAS,
               QTD_PLACAS_ATIVAS - QPV.QTD_VENCIDAS AS QTD_PRAZO
        FROM QTD_PLACAS_VENCIDAS QPV;
END;
$$;

create or replace function public.func_pneu_relatorio_validade_dot(f_cod_unidades bigint[], f_data_atual timestamp without time zone)
    returns TABLE
            (
                "UNIDADE"         text,
                "COD PNEU"        text,
                "PLACA"           text,
                "POSIÇÃO"         text,
                "DOT CADASTRADO"  text,
                "DOT VÁLIDO"      text,
                "TEMPO DE USO"    text,
                "TEMPO RESTANTE"  text,
                "DATA VENCIMENTO" text,
                "VENCIDO"         text,
                "DATA GERAÇÃO"    text
            )
    language plpgsql
as
$$
DECLARE
    DATE_FORMAT        TEXT := 'YY "ano(s)" MM "mes(es)" DD "dia(s)"';
    DIA_MES_ANO_FORMAT TEXT := 'DD/MM/YYYY';
    DATA_HORA_FORMAT   TEXT := 'DD/MM/YYYY HH24:MI';
    DATE_CONVERTER     TEXT := 'YYYYWW';
    PREFIXO_ANO        TEXT := SUBSTRING(F_DATA_ATUAL::TEXT, 1, 2);
BEGIN
    RETURN QUERY
        WITH INFORMACOES_PNEU AS (
            SELECT P.CODIGO_CLIENTE                               AS COD_PNEU,
                   P.DOT                                          AS DOT_CADASTRADO,
                   -- Remove letras, characteres especiais e espaços do dot.
                   -- A flag 'g' indica que serão removidas todas as aparições do padrão específicado não somente o primeiro caso.
                   TRIM(REGEXP_REPLACE(P.DOT, '[^0-9]', '', 'g')) AS DOT_LIMPO,
                   P.COD_UNIDADE                                  AS COD_UNIDADE,
                   U.NOME                                         AS UNIDADE,
                   VP.PLACA                                       AS PLACA_APLICADO,
                   PPNE.NOMENCLATURA                              AS POSICAO_PNEU
            FROM PNEU P
                     JOIN UNIDADE U ON P.COD_UNIDADE = U.CODIGO
                     JOIN EMPRESA E ON E.CODIGO = U.COD_EMPRESA
                     LEFT JOIN VEICULO_PNEU VP ON VP.COD_PNEU = P.CODIGO
                     LEFT JOIN VEICULO V ON VP.PLACA = V.PLACA AND VP.COD_UNIDADE = V.COD_UNIDADE
                     LEFT JOIN VEICULO_TIPO VT
                               ON V.COD_TIPO = VT.CODIGO
                     LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
                     LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
                AND PPNE.COD_DIAGRAMA = VD.CODIGO
                AND PPNE.POSICAO_PROLOG = VP.POSICAO
            WHERE P.COD_UNIDADE = ANY (F_COD_UNIDADES)
        ),

             DATA_DOT AS (
                 SELECT IP.COD_PNEU,
                        -- Transforma o DOT_FORMATADO em data
                        CASE
                            WHEN (CHAR_LENGTH(IP.DOT_LIMPO) = 4)
                                THEN
                                TO_DATE(CONCAT(PREFIXO_ANO, (SUBSTRING(IP.DOT_LIMPO, 3, 4)),
                                               (SUBSTRING(IP.DOT_LIMPO, 1, 2))),
                                        DATE_CONVERTER)
                            ELSE NULL END AS DOT_EM_DATA
                 FROM INFORMACOES_PNEU IP
             ),

             VENCIMENTO_DOT AS (
                 SELECT DD.COD_PNEU,
                        -- Verifica se a data do DOT que foi transformado é menor ou igual a data atual. Se for maior está errado,
                        -- então retornará NULL, senão somará 5 dias e 5 anos à data do dot para gerar a data de vencimento.
                        -- O vencimento de um pneu é de 5 anos, como o DOT é fornecido em "SEMANA DO ANO/ANO", para que o vencimento
                        -- tenha seu prazo máximo (1 dia antes da próxima semana) serão adicionados + 5 dias ao cálculo.
                        CASE
                            WHEN DD.DOT_EM_DATA <= (F_DATA_ATUAL::DATE)
                                THEN DD.DOT_EM_DATA + INTERVAL '5 DAYS 5 YEARS'
                            ELSE NULL END AS DATA_VENCIMENTO
                 FROM DATA_DOT DD
             ),

             CALCULOS AS (
                 SELECT DD.COD_PNEU,
                        -- Verifica se o dot é válido
                        -- Apenas os DOTs que, após formatados, possuiam tamanho = 4 tiveram data de vencimento gerada, portanto
                        -- podemos considerar inválidos os que possuem vencimento = null.
                        CASE WHEN VD.DATA_VENCIMENTO IS NULL THEN 'INVÁLIDO' ELSE 'VÁLIDO' END        AS DOT_VALIDO,
                        -- Cálculo tempo de uso
                        CASE
                            WHEN VD.DATA_VENCIMENTO IS NULL
                                THEN NULL
                            ELSE
                                TO_CHAR(AGE((F_DATA_ATUAL :: DATE), DD.DOT_EM_DATA), DATE_FORMAT) END AS TEMPO_DE_USO,
                        -- Cálculo dias restantes
                        TO_CHAR(AGE(VD.DATA_VENCIMENTO, F_DATA_ATUAL), DATE_FORMAT)                   AS TEMPO_RESTANTE,
                        -- Boolean vencimento (Se o inteiro for negativo, então o dot está vencido, senão não está vencido.
                        F_IF(((VD.DATA_VENCIMENTO::DATE) - (F_DATA_ATUAL::DATE)) < 0, TRUE, FALSE)    AS VENCIDO
                 FROM DATA_DOT DD
                          JOIN VENCIMENTO_DOT VD ON DD.COD_PNEU = VD.COD_PNEU
             )
        SELECT IP.UNIDADE::TEXT,
               IP.COD_PNEU::TEXT,
               COALESCE(IP.PLACA_APLICADO::TEXT, '-'),
               COALESCE(IP.POSICAO_PNEU::TEXT, '-'),
               COALESCE(IP.DOT_CADASTRADO::TEXT, '-'),
               CA.DOT_VALIDO,
               COALESCE(CA.TEMPO_DE_USO, '-'),
               COALESCE(CA.TEMPO_RESTANTE, '-'),
               COALESCE(TO_CHAR(VD.DATA_VENCIMENTO, DIA_MES_ANO_FORMAT)::TEXT, '-'),
               F_IF(CA.VENCIDO, 'SIM' :: TEXT, 'NÃO' :: TEXT),
               TO_CHAR(F_DATA_ATUAL, DATA_HORA_FORMAT)::TEXT
        FROM INFORMACOES_PNEU IP
                 JOIN VENCIMENTO_DOT VD ON IP.COD_PNEU = VD.COD_PNEU
                 JOIN CALCULOS CA ON CA.COD_PNEU = VD.COD_PNEU AND CA.COD_PNEU = IP.COD_PNEU
        ORDER BY VD.DATA_VENCIMENTO ASC, IP.PLACA_APLICADO;
END;
$$;

create or replace function suporte.func_pneu_retorna_pneu_do_descarte(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                      f_cod_pneu bigint,
                                                                      f_numero_fogo_pneu character varying,
                                                                      OUT aviso_pneu_retornado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    F_STATUS_PNEU_ESTOQUE       VARCHAR := 'ESTOQUE';
    F_STATUS_PNEU_DESCARTE      VARCHAR := 'DESCARTE';
    F_STATUS_PNEU_EM_USO        VARCHAR := 'EM_USO';
    F_STATUS_ORIGEM_PNEU        VARCHAR;
    F_STATUS_DESTINO_PNEU       VARCHAR;
    F_COD_MOVIMENTACAO_PROCESSO BIGINT;
    F_COD_MOVIMENTACAO          BIGINT;
BEGIN
    -- VERIFICA SE UNIDADE EXISTE, SE EMPRESA EXISTE E SE UNIDADE PERTENCE A EMPRESA.
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE);

    -- VERIFICA SE PNEU EXISTE NA UNIDADE.
    PERFORM FUNC_GARANTE_PNEU_EXISTE(F_COD_EMPRESA, F_COD_UNIDADE, F_COD_PNEU, F_NUMERO_FOGO_PNEU);

    -- VERIFICA SE O STATUS DO PNEU ESTÁ COMO 'DESCARTE'.
    IF (SELECT P.STATUS
        FROM PNEU P
        WHERE P.CODIGO_CLIENTE = F_NUMERO_FOGO_PNEU
          AND P.CODIGO = F_COD_PNEU
          AND P.COD_UNIDADE = F_COD_UNIDADE) != F_STATUS_PNEU_DESCARTE
    THEN
        RAISE EXCEPTION 'Pneu de número de fogo %, com código % da unidade %, não está com status = %!',
            F_NUMERO_FOGO_PNEU, F_COD_PNEU, F_COD_UNIDADE, F_STATUS_PNEU_DESCARTE;
    END IF;

    -- VAI PEGAR AS INFORMAÇÕES DA ÚLTIMA MOVIMENTAÇÃO DO PNEU ASSUMINDO QUE FOI PARA DESCARTE.
    -- NA SEQUÊNCIA ISSO SERÁ VALIDADO.
    SELECT M.CODIGO                    AS COD_MOVIMENTACAO,
           M.COD_MOVIMENTACAO_PROCESSO AS COD_MOVIMENTACAO_PROCESSO,
           MO.TIPO_ORIGEM              AS TIPO_ORIGEM,
           MD.TIPO_DESTINO             AS TIPO_DESTINO
    FROM MOVIMENTACAO M
             JOIN MOVIMENTACAO_DESTINO MD ON M.CODIGO = MD.COD_MOVIMENTACAO
             JOIN MOVIMENTACAO_ORIGEM MO ON M.CODIGO = MO.COD_MOVIMENTACAO
    WHERE M.COD_PNEU = F_COD_PNEU
      AND M.COD_UNIDADE = F_COD_UNIDADE
    ORDER BY M.CODIGO DESC
    LIMIT 1
    INTO F_COD_MOVIMENTACAO, F_COD_MOVIMENTACAO_PROCESSO, F_STATUS_ORIGEM_PNEU, F_STATUS_DESTINO_PNEU;

    -- GARANTE QUE A ÚLTIMA MOVIMENTAÇÃO DO PNEU TENHA SIDO PARA DESCARTE.
    IF F_STATUS_DESTINO_PNEU != F_STATUS_PNEU_DESCARTE
    THEN
        RAISE EXCEPTION '[INCONSISTÊNCIA] A ultima movimentação do pneu de número de fogo %, com código % da unidade %,
      não foi para %!',
            F_NUMERO_FOGO_PNEU, F_COD_PNEU, F_COD_UNIDADE, F_STATUS_PNEU_DESCARTE;
    END IF;

    -- DELETA A MOVIMENTAÇÃO QUE MOVEU O PNEU PARA O DESCARTE SE A ORIGEM NÃO FOR 'EM_USO', CASO SEJA, MODIFICA
    -- DESTINO PARA 'ESTOQUE'.
    -- ISSO É FEITO PORQUE UM PNEU QUE ESTAVA APLICADO, NÃO PODE VOLTAR AO VEÍCULO, JÁ QUE PODERÍAMOS ESBARRAR NO CASO
    -- ONDE JÁ EXISTE OUTRO PNEU NA POSIÇÃO QUE ELE ESTAVA ANTES.
    IF F_STATUS_ORIGEM_PNEU != F_STATUS_PNEU_EM_USO
    THEN
        DELETE
        FROM MOVIMENTACAO M
        WHERE M.CODIGO = F_COD_MOVIMENTACAO
          AND M.COD_MOVIMENTACAO_PROCESSO = F_COD_MOVIMENTACAO_PROCESSO
          AND M.COD_PNEU = F_COD_PNEU
          AND M.COD_UNIDADE = F_COD_UNIDADE;
        -- VERIFICA SE MOVIMENTACAO ERA A UNICA EXISTENTE NO PROCESSO.
        IF NOT EXISTS(
                SELECT M.CODIGO FROM MOVIMENTACAO M WHERE M.COD_MOVIMENTACAO_PROCESSO = F_COD_MOVIMENTACAO_PROCESSO)
        THEN
            -- DELETA PROCESSO DE MOVIMENTACAO.
            DELETE FROM MOVIMENTACAO_PROCESSO WHERE CODIGO = F_COD_MOVIMENTACAO_PROCESSO;
        END IF;
    ELSE
        UPDATE MOVIMENTACAO_DESTINO
        SET TIPO_DESTINO          = F_STATUS_PNEU_ESTOQUE,
            COD_MOTIVO_DESCARTE   = NULL,
            URL_IMAGEM_DESCARTE_1 = NULL,
            URL_IMAGEM_DESCARTE_2 = NULL,
            URL_IMAGEM_DESCARTE_3 = NULL
        WHERE COD_MOVIMENTACAO = F_COD_MOVIMENTACAO;
    END IF;

    -- ALTERA STATUS DO PNEU.
    IF F_STATUS_ORIGEM_PNEU != F_STATUS_PNEU_EM_USO
    THEN
        UPDATE PNEU
        SET STATUS = F_STATUS_ORIGEM_PNEU
        WHERE CODIGO = F_COD_PNEU
          AND CODIGO_CLIENTE = F_NUMERO_FOGO_PNEU
          AND COD_UNIDADE = F_COD_UNIDADE
          AND COD_EMPRESA = F_COD_EMPRESA;
    ELSE
        UPDATE PNEU
        SET STATUS = F_STATUS_PNEU_ESTOQUE
        WHERE CODIGO = F_COD_PNEU
          AND CODIGO_CLIENTE = F_NUMERO_FOGO_PNEU
          AND COD_UNIDADE = F_COD_UNIDADE
          AND COD_EMPRESA = F_COD_EMPRESA;
    END IF;

    SELECT CONCAT('Pneu retornado para ', (SELECT P.STATUS FROM PNEU P WHERE P.CODIGO = F_COD_PNEU),
                  ', Código: ', F_COD_PNEU,
                  ', Número de fogo: ', F_NUMERO_FOGO_PNEU,
                  ', Unidade: ', F_COD_UNIDADE, ' - ', (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE),
                  ', Empresa: ', F_COD_EMPRESA, ' - ', (SELECT E.NOME FROM EMPRESA E WHERE E.CODIGO = F_COD_EMPRESA))
    INTO AVISO_PNEU_RETORNADO;
END;
$$;

create or replace function public.func_pneu_transferencia_alterar_unidade_alocado(f_cod_unidade_origem bigint,
                                                                                  f_cod_unidade_destino bigint,
                                                                                  f_cod_pneus bigint[]) returns bigint
    language plpgsql
as
$$
DECLARE
    QTD_ROWS BIGINT;
BEGIN
    UPDATE PNEU
    SET COD_UNIDADE = F_COD_UNIDADE_DESTINO
    WHERE COD_UNIDADE = F_COD_UNIDADE_ORIGEM
      AND CODIGO = ANY (F_COD_PNEUS);
    GET DIAGNOSTICS QTD_ROWS = ROW_COUNT;
    RETURN QTD_ROWS;
END;
$$;

create or replace function public.func_pneu_transferencia_insert_informacoes(f_cod_processo_transferencia bigint, f_cod_pneus bigint[]) returns bigint
    language plpgsql
as
$$
DECLARE
    QTD_ROWS BIGINT;
BEGIN
    WITH INFORMACOES_PNEUS AS (
        SELECT P.CODIGO,
               P.ALTURA_SULCO_INTERNO,
               P.ALTURA_SULCO_CENTRAL_INTERNO,
               P.ALTURA_SULCO_CENTRAL_EXTERNO,
               P.ALTURA_SULCO_EXTERNO,
               P.PRESSAO_ATUAL,
               P.VIDA_ATUAL,
               (SELECT VP.POSICAO FROM VEICULO_PNEU VP WHERE VP.COD_PNEU = P.CODIGO) AS POSICAO
        FROM PNEU P
        WHERE P.CODIGO = ANY (F_COD_PNEUS)
    )

    INSERT
    INTO PNEU_TRANSFERENCIA_INFORMACOES (COD_PROCESSO_TRANSFERENCIA,
                                         COD_PNEU,
                                         ALTURA_SULCO_INTERNO,
                                         ALTURA_SULCO_CENTRAL_INTERNO,
                                         ALTURA_SULCO_CENTRAL_EXTERNO,
                                         ALTURA_SULCO_EXTERNO,
                                         PSI,
                                         VIDA_MOMENTO_TRANSFERENCIA,
                                         POSICAO_PNEU_TRANSFERENCIA)
    SELECT F_COD_PROCESSO_TRANSFERENCIA,
           IP.CODIGO,
           IP.ALTURA_SULCO_INTERNO,
           IP.ALTURA_SULCO_CENTRAL_INTERNO,
           IP.ALTURA_SULCO_CENTRAL_EXTERNO,
           IP.ALTURA_SULCO_EXTERNO,
           IP.PRESSAO_ATUAL,
           IP.VIDA_ATUAL,
           IP.POSICAO
    FROM INFORMACOES_PNEUS IP;
    GET DIAGNOSTICS QTD_ROWS = ROW_COUNT;
    RETURN QTD_ROWS;
END;
$$;

create or replace function public.func_pneu_transferencia_listagem(f_cod_unidades_origem bigint[],
                                                                   f_cod_unidades_destino bigint[], f_data_inicial date,
                                                                   f_data_final date)
    returns TABLE
            (
                cod_processo_transferencia_pneu    bigint,
                regional_origem                    text,
                unidade_origem                     text,
                regional_destino                   text,
                unidade_destino                    text,
                nome_colaborador                   text,
                data_hora_transferencia            timestamp without time zone,
                observacao                         text,
                tipo_processo_transferencia        tipo_processo_transferencia_pneu,
                cod_processo_transferencia_veiculo bigint,
                placa_transferida                  text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH REGIONAL_ORIGEM AS (
            SELECT R.REGIAO AS REGIAO_ORIGEM,
                   U.NOME   AS UNIDADE_ORIGEM,
                   U.CODIGO AS COD_UNIDADE_ORIGEM
            FROM REGIONAL R
                     JOIN UNIDADE U ON R.CODIGO = u.COD_REGIONAL
            WHERE U.CODIGO = ANY (F_COD_UNIDADES_ORIGEM)
        ),
             REGIONAL_DESTINO AS (
                 SELECT R.REGIAO AS REGIAO_DESTINO,
                        U.NOME   AS UNIDADE_DESTINO,
                        U.CODIGO AS COD_UNIDADE_DESTINO
                 FROM REGIONAL R
                          JOIN UNIDADE U ON R.CODIGO = u.COD_REGIONAL
                 WHERE U.CODIGO = ANY (F_COD_UNIDADES_DESTINO)
             )

        SELECT PTP.CODIGO                                               AS COD_PROCESSO_TRANSFERENCIA_PNEU,
               RO.REGIAO_ORIGEM :: TEXT                                 AS REGIAO_ORIGEM,
               RO.UNIDADE_ORIGEM :: TEXT                                AS UNIDADE_ORIGEM,
               RD.REGIAO_DESTINO :: TEXT                                AS REGIAO_DESTINO,
               RD.UNIDADE_DESTINO :: TEXT                               AS UNIDADE_DESTINO,
               CO.NOME :: TEXT                                          AS NOME_COLABORADOR,
               PTP.DATA_HORA_TRANSFERENCIA_PROCESSO
                   AT TIME ZONE TZ_UNIDADE(PTP.COD_UNIDADE_COLABORADOR) AS DATA_HORA_TRANSFERENCIA_PROCESSO,
               PTP.OBSERVACAO :: TEXT                                   AS OBSERVACAO,
               PTP.TIPO_PROCESSO_TRANSFERENCIA                          AS TIPO_PROCESSO_TRANSFERENCIA,
               VTI.COD_PROCESSO_TRANSFERENCIA                           AS COD_PROCESSO_TRANSFERENCIA_VEICULO,
               V.PLACA :: TEXT                                          AS PLACA_TRANSFERIDA
        FROM PNEU_TRANSFERENCIA_PROCESSO PTP
                 JOIN REGIONAL_ORIGEM RO ON RO.COD_UNIDADE_ORIGEM = PTP.COD_UNIDADE_ORIGEM
                 JOIN REGIONAL_DESTINO RD ON RD.COD_UNIDADE_DESTINO = PTP.COD_UNIDADE_DESTINO
                 JOIN COLABORADOR CO ON CO.CODIGO = PTP.COD_COLABORADOR
                 LEFT JOIN VEICULO_TRANSFERENCIA_VINCULO_PROCESSO_PNEU VTVPP
                           ON PTP.CODIGO = VTVPP.COD_PROCESSO_TRANSFERENCIA_PNEU
                 LEFT JOIN VEICULO_TRANSFERENCIA_INFORMACOES VTI
                           ON VTVPP.COD_VEICULO_TRANSFERENCIA_INFORMACOES = VTI.CODIGO
                 LEFT JOIN VEICULO V ON VTI.COD_VEICULO = V.CODIGO
        WHERE PTP.COD_UNIDADE_ORIGEM = ANY (F_COD_UNIDADES_ORIGEM)
          AND PTP.COD_UNIDADE_DESTINO = ANY (F_COD_UNIDADES_DESTINO)
          AND (DATA_HORA_TRANSFERENCIA_PROCESSO AT TIME ZONE TZ_UNIDADE(PTP.COD_UNIDADE_COLABORADOR)) :: DATE
            BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
        ORDER BY DATA_HORA_TRANSFERENCIA_PROCESSO DESC;
END;
$$;

create or replace function public.func_pneu_transferencia_visualizacao(f_cod_processo_transferencia bigint)
    returns TABLE
            (
                cod_processo_transferencia_pneu    bigint,
                regional_origem                    text,
                unidade_origem                     text,
                regional_destino                   text,
                unidade_destino                    text,
                nome_colaborador                   text,
                data_hora_transferencia            timestamp without time zone,
                observacao                         text,
                tipo_processo_transferencia        tipo_processo_transferencia_pneu,
                cod_processo_transferencia_veiculo bigint,
                placa_transferida                  text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH TRANSFERENCIA_PROCESSO AS (
            SELECT PTP.CODIGO                           AS COD_PROCESSO_TRANSFERENCIA_PNEU,
                   PTP.COD_UNIDADE_ORIGEM               AS COD_UNIDADE_ORIGEM,
                   UO.NOME                              AS UNIDADE_ORIGEM,
                   RO.REGIAO                            AS REGIONAL_ORIGEM,
                   PTP.COD_UNIDADE_DESTINO              AS COD_UNIDADE_DESTINO,
                   UD.NOME                              AS UNIDADE_DESTINO,
                   RD.REGIAO                            AS REGIONAL_DESTINO,
                   PTP.COD_UNIDADE_COLABORADOR          AS COD_UNIDADE_COLABORADOR,
                   CO.NOME                              AS NOME_COLABORADOR,
                   PTP.DATA_HORA_TRANSFERENCIA_PROCESSO AS DATA_HORA_TRANSFERENCIA_PROCESSO,
                   PTP.OBSERVACAO                       AS OBSERVACAO,
                   PTP.TIPO_PROCESSO_TRANSFERENCIA      AS TIPO_PROCESSO_TRANSFERENCIA,
                   VTI.COD_PROCESSO_TRANSFERENCIA       AS COD_PROCESSO_TRANSFERENCIA_VEICULO,
                   V.PLACA                              AS PLACA_TRANSFERIDA
            FROM PNEU_TRANSFERENCIA_PROCESSO PTP
                     JOIN COLABORADOR CO ON PTP.COD_COLABORADOR = CO.CODIGO
                     JOIN UNIDADE UO ON UO.CODIGO = PTP.COD_UNIDADE_ORIGEM
                     JOIN REGIONAL RO ON UO.COD_REGIONAL = RO.CODIGO
                     JOIN UNIDADE UD ON UD.CODIGO = PTP.COD_UNIDADE_DESTINO
                     JOIN REGIONAL RD ON UD.COD_REGIONAL = RD.CODIGO
                     LEFT JOIN VEICULO_TRANSFERENCIA_VINCULO_PROCESSO_PNEU VTVPP
                               ON PTP.CODIGO = VTVPP.COD_PROCESSO_TRANSFERENCIA_PNEU
                     LEFT JOIN VEICULO_TRANSFERENCIA_INFORMACOES VTI
                               ON VTVPP.COD_VEICULO_TRANSFERENCIA_INFORMACOES = VTI.CODIGO
                     LEFT JOIN VEICULO V ON VTI.COD_VEICULO = V.CODIGO
            WHERE PTP.CODIGO = F_COD_PROCESSO_TRANSFERENCIA
        )

        SELECT TP.COD_PROCESSO_TRANSFERENCIA_PNEU                      AS COD_PROCESSO_TRANSFERENCIA_PNEU,
               TP.REGIONAL_ORIGEM :: TEXT                              AS REGIONAL_ORIGEM,
               TP.UNIDADE_ORIGEM :: TEXT                               AS UNIDADE_ORIGEM,
               TP.REGIONAL_DESTINO :: TEXT                             AS REGIONAL_DESTINO,
               TP.UNIDADE_DESTINO :: TEXT                              AS UNIDADE_DESTINO,
               TP.NOME_COLABORADOR :: TEXT                             AS NOME_COLABORADOR,
               TP.DATA_HORA_TRANSFERENCIA_PROCESSO
                   AT TIME ZONE TZ_UNIDADE(TP.COD_UNIDADE_COLABORADOR) AS DATA_HORA_TRANSFERENCIA_PROCESSO,
               TP.OBSERVACAO :: TEXT                                   AS OBSERVACAO,
               TP.TIPO_PROCESSO_TRANSFERENCIA                          AS TIPO_PROCESSO_TRANSFERENCIA,
               TP.COD_PROCESSO_TRANSFERENCIA_VEICULO                   AS COD_PROCESSO_TRANSFERENCIA_VEICULO,
               TP.PLACA_TRANSFERIDA :: TEXT                            AS PLACA_TRANSFERIDA
        FROM TRANSFERENCIA_PROCESSO TP
        WHERE TP.COD_PROCESSO_TRANSFERENCIA_PNEU = F_COD_PROCESSO_TRANSFERENCIA;
END;
$$;

create or replace function public.func_pneu_verifica_desgaste_irregular(f_cod_pneu bigint, f_sulco_externo real,
                                                                        f_sulco_central_externo real,
                                                                        f_sulco_central_interno real,
                                                                        f_sulco_interno real)
    returns TABLE
            (
                cod_pneu                 bigint,
                tem_desgaste_irregular   boolean,
                tipo_desgaste_irregular  pneu_desgaste_irregular_type,
                nivel_desgaste_irregular pneu_desgaste_irregular_nivel_type
            )
    language plpgsql
as
$$
DECLARE
    -- Esse array irá salvar os níveis de desgaste encontrados em um mesmo pneu.
    -- Ex.: Para um desgaste central, o sulco central em relação ao sulco externo pode ter um desgaste MODERADO. Porém,
    -- em relação ao interno pode ter um desgaste ACENTUADO. Nesse array será salvo os dois níveis.
    TT PNEU_DESGASTE_IRREGULAR_NIVEL_TYPE[];
BEGIN

    -- DESGASTE_OMBROS_BANDA_RODAGEM
    IF (F_SULCO_EXTERNO < F_SULCO_CENTRAL_EXTERNO AND F_SULCO_EXTERNO < F_SULCO_CENTRAL_INTERNO)
        AND (F_SULCO_INTERNO < F_SULCO_CENTRAL_EXTERNO AND F_SULCO_INTERNO < F_SULCO_CENTRAL_INTERNO)
    THEN
        -- Verfica a variação do sulco externo com relação aos centrais.
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_EXTERNO - F_SULCO_EXTERNO,
                                                                       'DESGASTE_OMBROS_BANDA_RODAGEM'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_INTERNO - F_SULCO_EXTERNO,
                                                                       'DESGASTE_OMBROS_BANDA_RODAGEM'))
        INTO TT;

        -- Verfica a variação do sulco interno com relação aos centrais.
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_EXTERNO - F_SULCO_INTERNO,
                                                                       'DESGASTE_OMBROS_BANDA_RODAGEM'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_INTERNO - F_SULCO_INTERNO,
                                                                       'DESGASTE_OMBROS_BANDA_RODAGEM'))
        INTO TT;
        RETURN QUERY
            SELECT F_COD_PNEU,
                   TRUE,
                   'DESGASTE_OMBROS_BANDA_RODAGEM' :: PNEU_DESGASTE_IRREGULAR_TYPE,
                   -- Nesse momento, o array irá conter todos os níveis de desgaste encontrados no pneu analisado. Incluindo nulls,
                   -- caso a variação seja <= 0. Nós pegamos o nível mais alto de desgaste encontrado e retornamos como o nível
                   -- de desgaste do pneu. O que esse SELECT faz é transformar o array em várias linhas usando UNNEST, ordenar pelo
                   -- ENUM e pegar apenas o nível mais alto usando LIMIT 1.
                   -- Atente-se para algumas coisas importantes:
                   -- 1 - ORDER BY NIVEL só funciona pois o PG ordena um enum com base na ordem em que os elementos foram criados
                   -- nesse enum. E nós criamos como BAIXO, MODERADO, ACENTUADO. Por isso ORDER BY NIVEL DESC funciona.
                   -- 2 - É imprescindível manter o NULLS LAST. Isso porque se o nível de desgaste for null, caso variação <= 0, como
                   -- falado acima, o ORDER BY faria esses valores nulls ficarem primeiro e nós acabaríamos retornando eles como o nível
                   -- de desgaste do pneu.
                   (SELECT UNNEST(TT) AS NIVEL ORDER BY NIVEL DESC NULLS LAST LIMIT 1);
        RETURN;
    END IF;

    -- DESGASTE_CENTRALIZADO
    IF (F_SULCO_CENTRAL_EXTERNO < F_SULCO_EXTERNO AND F_SULCO_CENTRAL_EXTERNO < F_SULCO_INTERNO)
        AND (F_SULCO_CENTRAL_INTERNO < F_SULCO_EXTERNO AND F_SULCO_CENTRAL_INTERNO < F_SULCO_INTERNO)
    THEN
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_EXTERNO - F_SULCO_CENTRAL_EXTERNO,
                                                                       'DESGASTE_CENTRALIZADO'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_INTERNO - F_SULCO_CENTRAL_EXTERNO,
                                                                       'DESGASTE_CENTRALIZADO'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_EXTERNO - F_SULCO_CENTRAL_INTERNO,
                                                                       'DESGASTE_CENTRALIZADO'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_INTERNO - F_SULCO_CENTRAL_INTERNO,
                                                                       'DESGASTE_CENTRALIZADO'))
        INTO TT;
        RETURN QUERY
            SELECT F_COD_PNEU,
                   TRUE,
                   'DESGASTE_CENTRALIZADO' :: PNEU_DESGASTE_IRREGULAR_TYPE,
                   (SELECT UNNEST(TT) AS NIVEL ORDER BY NIVEL DESC NULLS LAST LIMIT 1);
        RETURN;
    END IF;

    -- DESGASTE_ACENTUADO_UM_OMBRO_PNEU
    IF (F_SULCO_EXTERNO < F_SULCO_CENTRAL_EXTERNO
        AND F_SULCO_EXTERNO < F_SULCO_CENTRAL_INTERNO
        AND F_SULCO_EXTERNO < F_SULCO_INTERNO)
        OR (F_SULCO_INTERNO < F_SULCO_CENTRAL_EXTERNO
            AND F_SULCO_INTERNO < F_SULCO_CENTRAL_INTERNO
            AND F_SULCO_INTERNO < F_SULCO_EXTERNO)
    THEN
        -- Verifica a variação do sulco externo com relação a todos os outros sulcos.
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_EXTERNO - F_SULCO_EXTERNO,
                                                                       'DESGASTE_ACENTUADO_UM_OMBRO_PNEU'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_INTERNO - F_SULCO_EXTERNO,
                                                                       'DESGASTE_ACENTUADO_UM_OMBRO_PNEU'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_INTERNO - F_SULCO_EXTERNO,
                                                                       'DESGASTE_ACENTUADO_UM_OMBRO_PNEU'))
        INTO TT;

        -- Verifica a variação do sulco interno com relação a todos os outros sulcos.
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_EXTERNO - F_SULCO_INTERNO,
                                                                       'DESGASTE_ACENTUADO_UM_OMBRO_PNEU'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_CENTRAL_INTERNO - F_SULCO_INTERNO,
                                                                       'DESGASTE_ACENTUADO_UM_OMBRO_PNEU'))
        INTO TT;
        SELECT ARRAY_APPEND(TT, FUNC_PNEU_GET_NIVEL_DESGASTE_IRREGULAR(F_SULCO_EXTERNO - F_SULCO_INTERNO,
                                                                       'DESGASTE_ACENTUADO_UM_OMBRO_PNEU'))
        INTO TT;

        RETURN QUERY
            SELECT F_COD_PNEU,
                   TRUE,
                   'DESGASTE_ACENTUADO_UM_OMBRO_PNEU' :: PNEU_DESGASTE_IRREGULAR_TYPE,
                   (SELECT UNNEST(TT) AS NIVEL ORDER BY NIVEL DESC NULLS LAST LIMIT 1);
        RETURN;
    END IF;

    RETURN QUERY
        SELECT F_COD_PNEU,
               FALSE,
               NULL :: PNEU_DESGASTE_IRREGULAR_TYPE,
               NULL :: PNEU_DESGASTE_IRREGULAR_NIVEL_TYPE;
END;
$$;

create or replace function public.func_pneus_get_listagem_pneus_movimentacoes_analise(f_cod_unidade bigint)
    returns TABLE
            (
                codigo                       bigint,
                codigo_cliente               text,
                dot                          text,
                valor                        real,
                cod_unidade_alocado          bigint,
                cod_regional_alocado         bigint,
                pneu_novo_nunca_rodado       boolean,
                cod_marca_pneu               bigint,
                nome_marca_pneu              text,
                cod_modelo_pneu              bigint,
                nome_modelo_pneu             text,
                qt_sulcos_modelo_pneu        smallint,
                cod_marca_banda              bigint,
                nome_marca_banda             text,
                altura_sulcos_modelo_pneu    real,
                cod_modelo_banda             bigint,
                nome_modelo_banda            text,
                qt_sulcos_modelo_banda       smallint,
                altura_sulcos_modelo_banda   real,
                valor_banda                  real,
                altura                       integer,
                largura                      integer,
                aro                          real,
                cod_dimensao                 bigint,
                altura_sulco_central_interno real,
                altura_sulco_central_externo real,
                altura_sulco_interno         real,
                altura_sulco_externo         real,
                pressao_recomendada          real,
                pressao_atual                real,
                status                       text,
                vida_atual                   integer,
                vida_total                   integer,
                posicao_pneu                 integer,
                posicao_aplicado_cliente     text,
                cod_veiculo_aplicado         bigint,
                placa_aplicado               text,
                cod_movimentacao             bigint,
                cod_recapadora               bigint,
                nome_recapadora              text,
                cod_empresa_recapadora       bigint,
                recapadora_ativa             boolean,
                cod_coleta                   text
            )
    language sql
as
$$
WITH MOVIMENTACOES_ANALISE AS (
    SELECT INNER_TABLE.CODIGO                 AS COD_MOVIMENTACAO,
           INNER_TABLE.COD_PNEU               AS COD_PNEU,
           INNER_TABLE.COD_RECAPADORA_DESTINO AS COD_RECAPADORA,
           INNER_TABLE.NOME                   AS NOME_RECAPADORA,
           INNER_TABLE.COD_EMPRESA            AS COD_EMPRESA_RECAPADORA,
           INNER_TABLE.ATIVA                  AS RECAPADORA_ATIVA,
           INNER_TABLE.COD_COLETA             AS COD_COLETA
    FROM (SELECT MOV.CODIGO,
                 MOV.COD_PNEU,
                 MAX(MOV.CODIGO)
                 OVER (
                     PARTITION BY COD_PNEU ) AS MAX_COD_MOVIMENTACAO,
                 MD.COD_RECAPADORA_DESTINO,
                 REC.NOME,
                 REC.COD_EMPRESA,
                 REC.ATIVA,
                 MD.COD_COLETA
          FROM MOVIMENTACAO AS MOV
                   JOIN MOVIMENTACAO_DESTINO AS MD ON MOV.CODIGO = MD.COD_MOVIMENTACAO
                   LEFT JOIN RECAPADORA AS REC ON MD.COD_RECAPADORA_DESTINO = REC.CODIGO
          WHERE COD_UNIDADE = f_cod_unidade
            AND MD.TIPO_DESTINO = 'ANALISE') AS INNER_TABLE
    WHERE CODIGO = INNER_TABLE.MAX_COD_MOVIMENTACAO
)

SELECT FUNC.*,
       MA.COD_MOVIMENTACAO,
       MA.COD_RECAPADORA,
       MA.NOME_RECAPADORA,
       MA.COD_EMPRESA_RECAPADORA,
       MA.RECAPADORA_ATIVA,
       MA.COD_COLETA
FROM func_pneu_get_listagem_pneus_by_status(f_cod_unidade, 'ANALISE') AS FUNC
         JOIN MOVIMENTACOES_ANALISE MA ON MA.COD_PNEU = FUNC.CODIGO;
$$;

create or replace function public.func_pneus_incrementa_vida_pneu(f_cod_pneu bigint, f_cod_modelo_banda bigint) returns boolean
    language plpgsql
as
$$
DECLARE
    altura_sulco_banda REAL;
    vida_nova_pneu     INTEGER;
BEGIN
    altura_sulco_banda = (SELECT MB.ALTURA_SULCOS FROM MODELO_BANDA AS MB WHERE CODIGO = f_cod_modelo_banda);
    vida_nova_pneu = (SELECT P.VIDA_ATUAL FROM PNEU AS P WHERE CODIGO = f_cod_pneu) + 1;
    UPDATE PNEU AS P
    SET VIDA_ATUAL                   = vida_nova_pneu,
        VIDA_TOTAL                   = (CASE
                                            WHEN (vida_nova_pneu > P.VIDA_TOTAL) THEN vida_nova_pneu
                                            ELSE P.VIDA_TOTAL END),
        COD_MODELO_BANDA             = f_cod_modelo_banda,
        ALTURA_SULCO_INTERNO         = altura_sulco_banda,
        ALTURA_SULCO_CENTRAL_INTERNO = altura_sulco_banda,
        ALTURA_SULCO_CENTRAL_EXTERNO = altura_sulco_banda,
        ALTURA_SULCO_EXTERNO         = altura_sulco_banda,
        PNEU_NOVO_NUNCA_RODADO       = FALSE
    WHERE CODIGO = f_cod_pneu;
    RETURN TRUE;
END;
$$;

create or replace function public.func_pneus_update_banda_pneu(f_cod_pneu bigint, f_cod_modelo_banda bigint, f_custo_banda real) returns boolean
    language plpgsql
as
$$
DECLARE
    F_COD_SERVICO_REALIZADO BIGINT;
BEGIN
    F_COD_SERVICO_REALIZADO = (
        SELECT CODIGO
        FROM PNEU_SERVICO_REALIZADO PSR
                 JOIN PNEU_SERVICO_REALIZADO_INCREMENTA_VIDA PSRIV
                      ON PSR.CODIGO = PSRIV.COD_SERVICO_REALIZADO
                          AND PSR.FONTE_SERVICO_REALIZADO = PSRIV.FONTE_SERVICO_REALIZADO
        WHERE PSR.COD_PNEU = F_COD_PNEU
        ORDER BY CODIGO DESC
        LIMIT 1);
    UPDATE PNEU_SERVICO_REALIZADO
    SET CUSTO = F_CUSTO_BANDA
    WHERE CODIGO = F_COD_SERVICO_REALIZADO;
    UPDATE PNEU_SERVICO_REALIZADO_INCREMENTA_VIDA
    SET COD_MODELO_BANDA = F_COD_MODELO_BANDA
    WHERE COD_SERVICO_REALIZADO = F_COD_SERVICO_REALIZADO;

    -- FOUND será true se alguma linha foi modificada pela query executada.
    IF FOUND THEN
        RETURN TRUE;
    ELSE
        RETURN FALSE;
    END IF;
END;
$$;

create or replace function public.func_pre_contracheque_deleta_itens(f_cod_itens bigint[]) returns bigint
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN
    IF ((SELECT COUNT(CODIGO) FROM PRE_CONTRACHEQUE_ITENS WHERE CODIGO = ANY (F_COD_ITENS)) <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR('Os itens selecionados não foram encontrados. Por favor, filtre novamente.');
    END IF;

    -- DELETA ITENS DO PRÉ-CONTRACHEQUE IMPORTADO.
    DELETE FROM PRE_CONTRACHEQUE_ITENS WHERE CODIGO = ANY (F_COD_ITENS);

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    RETURN QTD_LINHAS_ATUALIZADAS;
END;
$$;

create or replace function public.func_quiz_get_listagem_modelos(f_cod_unidade bigint, f_data_hora_atual_utc timestamp with time zone)
    returns TABLE
            (
                cod_modelo_quiz             bigint,
                nome_modelo_quiz            text,
                cod_unidade_modelo_quiz     bigint,
                nome_cargo_liberado         text,
                porcentagem_aprovacao       real,
                qtd_perguntas               bigint,
                tem_material_apoio          boolean,
                esta_aberto_para_realizacao boolean
            )
    language sql
as
$$
SELECT QM.CODIGO                                       AS COD_MODELO_QUIZ,
       QM.NOME :: TEXT                                 AS NOME_MODELO_QUIZ,
       QM.COD_UNIDADE                                  AS COD_UNIDADE_MODELO_QUIZ,
       F.NOME :: TEXT                                  AS NOME_CARGO_LIBERADO,
       QM.PORCENTAGEM_APROVACAO                        AS PORCENTAGEM_APROVACAO,
       (SELECT COUNT(*)
        FROM QUIZ_PERGUNTAS QP
        WHERE QP.COD_MODELO = QM.CODIGO)               AS QTD_PERGUNTAS,
       QMT.COD_TREINAMENTO IS NOT NULL                 AS TEM_MATERIAL_APOIO,
       QM.DATA_HORA_FECHAMENTO > F_DATA_HORA_ATUAL_UTC AS ESTA_ABERTO_PARA_REALIZACAO
FROM QUIZ_MODELO QM
         LEFT JOIN QUIZ_MODELO_TREINAMENTO QMT
                   ON QM.CODIGO = QMT.COD_MODELO_QUIZ
         LEFT JOIN QUIZ_MODELO_FUNCAO QMF
                   ON QM.CODIGO = QMF.COD_MODELO
         LEFT JOIN FUNCAO F
                   ON F.CODIGO = QMF.COD_FUNCAO_COLABORADOR
WHERE QM.COD_UNIDADE = F_COD_UNIDADE
ORDER BY COD_MODELO_QUIZ ASC, NOME_CARGO_LIBERADO ASC
$$;

create or replace function public.func_quiz_relatorio_estratificacao_realizacao(f_cod_unidade bigint,
                                                                                f_cod_modelo bigint,
                                                                                f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "MAT PROMAX"               text,
                "MAT RH"                   text,
                "NOME"                     text,
                "CARGO"                    text,
                "REALIZADOS"               bigint,
                "APROVADOS"                bigint,
                "PORCENTAGEM DE APROVAÇÃO" text,
                "MÁXIMO DE ACERTOS"        integer,
                "MÍNIMO DE ACERTOS"        integer
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT C.MATRICULA_AMBEV :: TEXT                                     AS MAT_PROMAX,
               C.MATRICULA_TRANS :: TEXT                                     AS MAT_RH,
               INITCAP(C.NOME)                                               AS NOME_COLABORADOR,
               F.NOME :: TEXT                                                AS CARGO,
               COALESCE(REALIZADOS.REALIZADOS, REALIZADOS.REALIZADOS, 0)     AS REALIZADOS,
               COALESCE(REALIZADOS.QT_APROVADOS, REALIZADOS.QT_APROVADOS, 0) AS APROVADOS,
               CASE
                   WHEN COALESCE(REALIZADOS.REALIZADOS, REALIZADOS.REALIZADOS, 0) > 0
                       THEN
                           ROUND(
                                       (COALESCE(REALIZADOS.QT_APROVADOS, REALIZADOS.QT_APROVADOS, 0) /
                                        COALESCE(REALIZADOS.REALIZADOS, REALIZADOS.REALIZADOS, 0) :: NUMERIC) * 100) ||
                           '%'
                   ELSE 0 || '%' END                                         AS PORCENTAGEM_APROVACAO,
               COALESCE(REALIZADOS.MAX_ACERTOS, REALIZADOS.MAX_ACERTOS, 0)   AS MAXIMO_ACERTOS,
               COALESCE(REALIZADOS.MIN_ACERTOS, REALIZADOS.MIN_ACERTOS, 0)   AS MINIMO_ACERTOS
        FROM COLABORADOR C
                 JOIN FUNCAO F ON F.CODIGO = C.COD_FUNCAO AND F.COD_EMPRESA = C.COD_EMPRESA
                 LEFT JOIN
             (SELECT C.CPF              AS CPF_REALIZADOS,
                     COUNT(C.CPF)       AS REALIZADOS,
                     SUM(
                             CASE
                                 WHEN (Q.QT_CORRETAS :: REAL / (Q.QT_CORRETAS + Q.QT_ERRADAS) :: REAL) >=
                                      QM.PORCENTAGEM_APROVACAO
                                     THEN 1
                                 ELSE 0
                                 END
                         )              AS QT_APROVADOS,
                     MAX(Q.QT_CORRETAS) AS MAX_ACERTOS,
                     MIN(Q.QT_CORRETAS) AS MIN_ACERTOS
              FROM COLABORADOR C
                       LEFT JOIN QUIZ Q ON Q.CPF_COLABORADOR = C.CPF
                       JOIN QUIZ_MODELO QM ON QM.CODIGO = Q.COD_MODELO AND QM.COD_UNIDADE = Q.COD_UNIDADE
              WHERE F_IF(F_COD_MODELO IS NULL, TRUE, Q.COD_MODELO = F_COD_MODELO)
                AND (Q.DATA_HORA AT TIME ZONE TZ_UNIDADE(Q.COD_UNIDADE)) :: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
              GROUP BY 1) AS REALIZADOS ON CPF_REALIZADOS = C.CPF
        WHERE C.STATUS_ATIVO = TRUE
          AND C.COD_UNIDADE = F_COD_UNIDADE
        ORDER BY REALIZADOS DESC;
END;
$$;

create or replace function public.func_quiz_relatorio_estratificacao_respostas(f_cod_unidade bigint, f_cod_modelo bigint)
    returns TABLE
            (
                "QUIZ"        text,
                "PERGUNTA"    text,
                "RESPOSTA"    text,
                "TOTAL"       bigint,
                "ACERTOS"     bigint,
                "PORCENTAGEM" text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT QM.NOME :: TEXT                                         AS QUIZ,
               QP.PERGUNTA                                             AS PERGUNTA_QUIZ,
               QAP.ALTERNATIVA                                         AS RESPOSTA,
               COUNT(QAP.ALTERNATIVA)                                  AS TOTAL,
               SUM(CASE
                       WHEN QAP.CORRETA = TRUE AND QR.SELECIONADA = TRUE
                           THEN 1
                       ELSE 0 END)                                     AS ACERTOS,
               ROUND((SUM(CASE
                              WHEN QAP.CORRETA = TRUE AND QR.SELECIONADA = TRUE
                                  THEN 1
                              ELSE 0 END) :: FLOAT /
                      COUNT(QAP.ALTERNATIVA) * 100) :: NUMERIC) || '%' AS PORCENTAGEM
        FROM QUIZ Q
                 JOIN QUIZ_MODELO QM ON QM.CODIGO = Q.COD_MODELO
                 JOIN QUIZ_PERGUNTAS QP ON QP.COD_MODELO = Q.COD_MODELO
                 JOIN QUIZ_ALTERNATIVA_PERGUNTA QAP ON QAP.COD_PERGUNTA = QP.CODIGO
                 JOIN QUIZ_RESPOSTAS QR ON QR.COD_QUIZ = Q.CODIGO
        WHERE QAP.CORRETA = TRUE
          AND Q.COD_UNIDADE = F_COD_UNIDADE
          AND F_IF(F_COD_MODELO IS NULL, TRUE, Q.COD_MODELO = F_COD_MODELO)
        GROUP BY QUIZ, PERGUNTA, ALTERNATIVA
        ORDER BY QUIZ, PORCENTAGEM DESC;
END;
$$;

create or replace function public.func_quiz_relatorio_extrato_geral(f_cod_unidade bigint, f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "DATA DE REALIZAÇÃO" text,
                "QUIZ"               text,
                "NOME"               text,
                "CARGO"              text,
                "QTD CORRETAS"       integer,
                "QTD ERRADAS"        integer,
                "TOTAL PERGUNTAS"    integer,
                "NOTA 0 A 10"        numeric,
                "AVALIAÇÃO"          text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT FORMAT_WITH_TZ(Q.DATA_HORA, TZ_UNIDADE(Q.COD_UNIDADE), 'DD/MM/YYYY HH24:MI')          AS DATA_REALIZACAO,
               QM.NOME :: TEXT                                                                       AS QUIZ,
               INITCAP(C.NOME)                                                                       AS NOME,
               F.NOME :: TEXT                                                                        AS CARGO,
               Q.QT_CORRETAS                                                                         AS QTD_CORRETAS,
               Q.QT_ERRADAS                                                                          AS QTD_ERRADAS,
               Q.QT_CORRETAS + Q.QT_ERRADAS                                                          AS TOTAL_PERGUNTAS,
               TRUNC(((Q.QT_CORRETAS / (Q.QT_CORRETAS + Q.QT_ERRADAS) :: FLOAT) * 10) :: NUMERIC, 2) AS NOTA,
               CASE
                   WHEN (Q.QT_CORRETAS / (Q.QT_CORRETAS + Q.QT_ERRADAS) :: FLOAT) > QM.PORCENTAGEM_APROVACAO
                       THEN
                       'APROVADO'
                   ELSE 'REPROVADO' END                                                              AS AVALIACAO
        FROM QUIZ Q
                 JOIN QUIZ_MODELO QM ON Q.COD_MODELO = QM.CODIGO AND Q.COD_UNIDADE = QM.COD_UNIDADE
                 JOIN COLABORADOR C ON C.CPF = Q.CPF_COLABORADOR AND C.COD_UNIDADE = Q.COD_UNIDADE
                 JOIN UNIDADE U ON U.CODIGO = C.COD_UNIDADE AND U.CODIGO = Q.COD_UNIDADE
                 JOIN FUNCAO F ON F.CODIGO = C.COD_FUNCAO AND F.COD_EMPRESA = U.COD_EMPRESA
        WHERE Q.COD_UNIDADE = F_COD_UNIDADE
          AND (Q.DATA_HORA AT TIME ZONE TZ_UNIDADE(Q.COD_UNIDADE)) :: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
        ORDER BY Q.DATA_HORA DESC;
END;
$$;

create or replace function public.func_quiz_relatorio_realizacao_cargo(f_cod_unidade bigint, f_cod_modelo bigint)
    returns TABLE
            (
                "QUIZ"                         text,
                "CARGO"                        text,
                "COLABORADORES CADASTRADOS"    bigint,
                "COLABORADORES QUE REALIZARAM" bigint,
                "PROPORÇÃO"                    text
            )
    language sql
as
$$
SELECT QM.NOME,
       F.NOME,
       REALIZAR.TOTAL_DEVERIAM_TER_REALIZADO,
       COALESCE(REALIZADOS.TOTAL_REALIZARAM, 0) AS REALIZARAM,
       TRUNC((COALESCE(REALIZADOS.TOTAL_REALIZARAM, 0) / REALIZAR.TOTAL_DEVERIAM_TER_REALIZADO :: FLOAT) * 100) || '%'
FROM QUIZ_MODELO_FUNCAO QMF
         JOIN QUIZ_MODELO QM ON QM.CODIGO = QMF.COD_MODELO AND QM.COD_UNIDADE = QMF.COD_UNIDADE
         JOIN UNIDADE U ON U.CODIGO = QMF.COD_UNIDADE
         JOIN FUNCAO F ON F.CODIGO = QMF.COD_FUNCAO_COLABORADOR AND U.COD_EMPRESA = F.COD_EMPRESA
         JOIN (SELECT QMF.COD_MODELO,
                      QMF.COD_FUNCAO_COLABORADOR AS COD_FUNCAO_DEVERIAM,
                      COUNT(C.CPF)               AS TOTAL_DEVERIAM_TER_REALIZADO
               FROM QUIZ_MODELO_FUNCAO QMF
                        JOIN COLABORADOR C
                             ON C.COD_FUNCAO = QMF.COD_FUNCAO_COLABORADOR AND C.COD_UNIDADE = QMF.COD_UNIDADE AND
                                C.STATUS_ATIVO IS TRUE
               WHERE QMF.COD_UNIDADE = F_COD_UNIDADE
                 AND F_IF(F_COD_MODELO IS NULL, TRUE, QMF.COD_MODELO = F_COD_MODELO)
               GROUP BY 1, 2) AS REALIZAR
              ON QMF.COD_FUNCAO_COLABORADOR = REALIZAR.COD_FUNCAO_DEVERIAM AND QMF.COD_MODELO = REALIZAR.COD_MODELO
         LEFT JOIN (SELECT CALCULO.COD_MODELO,
                           CALCULO.COD_FUNCAO AS COD_FUNCAO_REALIZARAM,
                           COUNT(CALCULO.CPF) AS TOTAL_REALIZARAM
                    FROM (SELECT Q.COD_MODELO,
                                 C.CPF,
                                 C.COD_FUNCAO,
                                 COUNT(C.COD_FUNCAO)
                          FROM QUIZ Q
                                   JOIN COLABORADOR C ON C.CPF = Q.CPF_COLABORADOR AND C.STATUS_ATIVO IS TRUE
                          WHERE Q.COD_UNIDADE = F_COD_UNIDADE
                            AND F_IF(F_COD_MODELO IS NULL, TRUE, Q.COD_MODELO = F_COD_MODELO)
                          GROUP BY 1, 2, 3) AS CALCULO
                    GROUP BY 1, 2) AS REALIZADOS
                   ON QMF.COD_FUNCAO_COLABORADOR = REALIZADOS.COD_FUNCAO_REALIZARAM AND
                      REALIZADOS.COD_MODELO = QMF.COD_MODELO
WHERE QMF.COD_UNIDADE = F_COD_UNIDADE
  AND F_IF(F_COD_MODELO IS NULL, TRUE, QMF.COD_MODELO = F_COD_MODELO)
ORDER BY QM.NOME, F.NOME;
$$;

create or replace function public.func_quiz_relatorio_respostas_realizados(f_cod_unidade bigint, f_cod_modelo bigint,
                                                                           f_cpf bigint, f_data_inicial date,
                                                                           f_data_final date,
                                                                           f_apenas_selecionadas boolean)
    returns TABLE
            (
                "QUIZ"               text,
                "DATA DE REALIZAÇÃO" text,
                "COLABORADOR"        text,
                "CPF"                text,
                "PERGUNTA"           text,
                "ALTERNATIVA"        text,
                "SELECIONADA"        text,
                "CORRETA"            text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT QM.NOME :: TEXT                                                              AS MODELO,
               FORMAT_WITH_TZ(Q.DATA_HORA, TZ_UNIDADE(Q.COD_UNIDADE), 'DD/MM/YYYY HH24:MI') AS DATA_HORA,
               C.NOME :: TEXT                                                               AS COLABORADOR,
               LPAD(C.CPF :: TEXT, 11, '0')                                                 AS CPF_COLABORADOR,
               QP.PERGUNTA :: TEXT                                                          AS PERGUNTA,
               QAP.ALTERNATIVA :: TEXT                                                      AS ALTERNATIVA,
               F_IF(QR.SELECIONADA, 'Sim' :: TEXT, 'Não' :: TEXT)                           AS SELECIONADA,
               F_IF(QAP.CORRETA, 'Sim' :: TEXT, 'Não' :: TEXT)                              AS CORRETA
        FROM QUIZ Q
                 LEFT JOIN QUIZ_MODELO QM ON (QM.CODIGO = Q.COD_MODELO)
                 LEFT JOIN COLABORADOR C ON (C.CPF = Q.CPF_COLABORADOR)
                 LEFT JOIN QUIZ_RESPOSTAS QR ON (Q.CODIGO = QR.COD_QUIZ)
                 LEFT JOIN QUIZ_PERGUNTAS QP ON (QP.CODIGO = QR.COD_PERGUNTA)
                 LEFT JOIN QUIZ_ALTERNATIVA_PERGUNTA QAP
                           ON (QR.COD_PERGUNTA = QAP.COD_PERGUNTA AND QR.COD_ALTERNATIVA = QAP.CODIGO)
        WHERE Q.COD_UNIDADE = F_COD_UNIDADE
          AND F_IF(F_COD_MODELO IS NULL, TRUE, Q.COD_MODELO = F_COD_MODELO)
          AND F_IF(F_CPF IS NULL, TRUE, Q.CPF_COLABORADOR = F_CPF)
          AND (Q.DATA_HORA AT TIME ZONE TZ_UNIDADE(Q.COD_UNIDADE)) :: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
          AND F_IF(F_APENAS_SELECIONADAS IS TRUE, QR.SELECIONADA, TRUE)
        ORDER BY Q.DATA_HORA, QAP.CORRETA DESC, QR.SELECIONADA;
END;
$$;

create or replace function public.func_relato_get_alternativas(f_cod_unidade bigint, f_cod_setor bigint, f_status_ativo boolean)
    returns TABLE
            (
                codigo       bigint,
                alternativa  text,
                status_ativo boolean
            )
    language sql
as
$$
SELECT RA.CODIGO       AS CODIGO,
       RA.ALTERNATIVA  AS ALTERNATIVA,
       RA.STATUS_ATIVO AS STATUS_ATIVO
FROM RELATO_ALTERNATIVA RA
WHERE RA.COD_UNIDADE = F_COD_UNIDADE
  AND (RA.COD_SETOR IS NULL OR F_IF(F_COD_SETOR IS NOT NULL, F_COD_SETOR = RA.COD_SETOR, TRUE))
  AND F_IF(F_STATUS_ATIVO IS NOT NULL, F_STATUS_ATIVO = RA.STATUS_ATIVO, TRUE)
ORDER BY RA.ALTERNATIVA ASC;
$$;

create or replace function public.func_relato_relatorio_qtd_relatos_pendentes_by_status(f_cod_unidades bigint[])
    returns TABLE
            (
                "QTD_PENDENTES_CLASSIFICACAO" bigint,
                "QTD_PENDENTES_FECHAMENTO"    bigint
            )
    language plpgsql
as
$$
DECLARE
    RELATO_PENDENTE_CLASSIFICACAO VARCHAR := 'PENDENTE_CLASSIFICACAO';
    RELATO_PENDENTE_FECHAMENTO    VARCHAR := 'PENDENTE_FECHAMENTO';
BEGIN
    RETURN QUERY
        SELECT COUNT(R.STATUS)
               FILTER (WHERE R.STATUS = RELATO_PENDENTE_CLASSIFICACAO) AS QTD_PENDENTES_CLASSIFICACAO,
               COUNT(R.STATUS)
               FILTER (WHERE R.STATUS = RELATO_PENDENTE_FECHAMENTO)    AS QTD_PENDENTES_FECHAMENTO
        FROM RELATO R
        WHERE R.COD_UNIDADE = ANY (F_COD_UNIDADES);
END;
$$;

create or replace function public.func_relatorio_acessos_produtividade_estratificado(f_cod_unidade bigint,
                                                                                     f_data_inicial date,
                                                                                     f_data_final date, f_cpf text)
    returns TABLE
            (
                "NOME"               text,
                "CARGO"              text,
                "EQUIPE"             text,
                "DATA DO ACESSO"     text,
                "PERÍODO CONSULTADO" text
            )
    language sql
as
$$
SELECT C.NOME, F.NOME, E.nome, TO_CHAR(AP.data_hora_consulta, 'DD/MM/YYYY HH24:MI'), AP.mes_ano_consultado
FROM acessos_produtividade AP
         JOIN COLABORADOR C ON C.CPF = AP.cpf_colaborador
         JOIN EQUIPE E ON E.CODIGO = C.cod_equipe AND E.cod_unidade = C.COD_UNIDADE
         JOIN FUNCAO F ON F.CODIGO = C.COD_FUNCAO AND F.COD_EMPRESA = C.cod_empresa
WHERE AP.cpf_colaborador :: TEXT LIKE f_cpf
  AND AP.data_hora_consulta :: DATE BETWEEN (f_data_inicial AT TIME ZONE
                                             (SELECT TIMEZONE FROM func_get_time_zone_unidade(f_cod_unidade)))
    AND (f_data_final AT TIME ZONE (SELECT TIMEZONE FROM func_get_time_zone_unidade(f_cod_unidade)))
  AND AP.cod_unidade = f_cod_unidade
ORDER BY AP.data_hora_consulta
$$;

create or replace function public.func_relatorio_aderencia_intervalo_colaborador(f_cod_unidade bigint,
                                                                                 f_data_inicial date, f_data_final date,
                                                                                 f_cpf text)
    returns TABLE
            (
                "NOME"                  text,
                "FUNÇÃO"                text,
                "EQUIPE"                text,
                "INTERVALOS PREVISTOS"  bigint,
                "INTERVALOS REALIZADOS" bigint,
                "ADERÊNCIA"             text
            )
    language sql
as
$$
select c.nome,
       f.nome,
       e.nome,
       count(dados.mapa)                                                     AS intervalos_previstos,
       sum(case when dados.tempo_decorrido_minutos <> '-' then 1 else 0 end) as intevalos_realizados,
       case
           when count(dados.mapa) > 0 then
               trunc((sum(case when dados.tempo_decorrido_minutos <> '-' then 1 else 0 end)::float /
                      count(dados.mapa)) * 100)
           else 0 end || '%'                                                 as aderencia_intervalo
from colaborador c
         join unidade u on u.codigo = c.cod_unidade
         join funcao f on f.codigo = c.cod_funcao and f.cod_empresa = u.cod_empresa
         join equipe e on e.codigo = c.cod_equipe and e.cod_unidade = c.cod_unidade
         left join view_intervalo_mapa_colaborador as dados on dados.cpf = c.cpf
where c.cod_unidade = f_cod_unidade
  and c.cpf::text like f_cpf
  and dados.data between f_data_inicial and f_data_final
  and c.cod_funcao in (select COD_CARGO from intervalo_tipo_cargo where COD_UNIDADE = f_cod_unidade)
group by c.cpf, c.nome, e.nome, f.nome
order by case
             when count(dados.mapa) > 0 then
                 trunc((sum(case when dados.tempo_decorrido_minutos <> '-' then 1 else 0 end)::float /
                        count(dados.mapa)) * 100)
             else 0 end desc
$$;


create or replace function public.func_relatorio_consolidado_mapas_indicadores(f_data_inicial date, f_data_final date,
                                                                               f_cpf text, f_cod_unidade text,
                                                                               f_cod_equipe text, f_cod_empresa bigint,
                                                                               f_cod_regional text)
    returns TABLE
            (
                "NOME"                          text,
                "EQUIPE"                        text,
                "FUNÇÃO"                        text,
                "TOTAL MAPAS REALIZADOS"        bigint,
                "HL CARREGADOS"                 numeric,
                "HL ENTREGUES"                  numeric,
                "HL DEVOLVIDOS"                 numeric,
                "RESULTADO DEV HL"              text,
                "META DEV HL"                   text,
                "BATEU DEV HL"                  text,
                "GOLS DEV HL"                   bigint,
                "NF CARREGADAS"                 bigint,
                "NF ENTREGUES"                  bigint,
                "NF DEVOLVIDAS"                 bigint,
                "RESULTADO DEV NF"              text,
                "META DEV NF"                   text,
                "BATEU DEV NF"                  text,
                "GOLS DEV NF"                   bigint,
                "PDVS CARREGADOS"               bigint,
                "PDVS ENTREGUES"                bigint,
                "RESULTADO DEV PDV"             text,
                "META DEV PDV"                  text,
                "BATEU DEV PDV"                 text,
                "GOLS DEV PDV"                  bigint,
                "KM PLANEJADO"                  numeric,
                "KM PERCORRIDO"                 bigint,
                "KM DISPERSO"                   numeric,
                "RESULTADO DISPERSAO KM"        text,
                "META DISPERSAO KM"             text,
                "BATEU DISPERSAO KM"            text,
                "GOLS DISPERSAO KM"             bigint,
                "MEDIA TEMPO LARGADA"           text,
                "MAPAS VÁLIDOS TEMPO LARGADA"   bigint,
                "MAPAS BATERAM TEMPO LARGADA"   bigint,
                "RESULTADO TEMPO LARGADA"       text,
                "META TEMPO LARGADA"            text,
                "BATEU TEMPO LARGADA"           text,
                "GOLS TEMPO LARGADA"            bigint,
                "MEDIA TEMPO EM ROTA"           text,
                "MAPAS VÁLIDOS TEMPO EM ROTA"   bigint,
                "MAPAS BATERAM TEMPO EM ROTA"   bigint,
                "RESULTADO TEMPO EM ROTA"       text,
                "META TEMPO EM ROTA"            text,
                "BATEU TEMPO EM ROTA"           text,
                "GOLS TEMPO EM ROTA"            bigint,
                "MEDIA TEMPO INTERNO"           text,
                "MAPAS VÁLIDOS TEMPO INTERNO"   bigint,
                "MAPAS BATERAM TEMPO INTERNO"   bigint,
                "RESULTADO TEMPO INTERNO"       text,
                "META TEMPO INTERNO"            text,
                "BATEU TEMPO INTERNO"           text,
                "GOLS TEMPO INTERNO"            bigint,
                "MEDIA JORNADA"                 text,
                "MAPAS VÁLIDOS JORNADA"         bigint,
                "MAPAS BATERAM JORNADA"         bigint,
                "RESULTADO JORNADA"             text,
                "META JORNADA"                  text,
                "BATEU JORNADA"                 text,
                "GOLS JORNADA"                  bigint,
                "MEDIA TEMPO PLANEJADO"         text,
                "MAPAS VÁLIDOS DISPERSAO TEMPO" bigint,
                "MAPAS BATERAM DISP TEMPO"      bigint,
                "RESULTADO DISP TEMPO"          text,
                "META DISP TEMPO"               text,
                "BATEU DISP TEMPO"              text,
                "GOLS DISP TEMPO"               bigint,
                "TOTAL TRACKING"                numeric,
                "TOTAL OK"                      numeric,
                "TOTAL NOK"                     numeric,
                "RESULTADO TRACKING"            text,
                "META TRACKING"                 text,
                "BATEU TRACKING"                text,
                "GOLS TRACKING"                 bigint,
                "TOTAL DE GOLS GERAL"           bigint
            )
    language sql
as
$$
select dados.nome,
       dados.equipe,
       dados.funcao,
       dados.total_mapas,
       trunc(dados.hl_carregados_total::numeric, 2)                               as hl_carregados_total,
       trunc((dados.hl_carregados_total - dados.hl_devolvidos_total)::numeric, 2) as hl_entregues_total,
       trunc(dados.hl_devolvidos_total::numeric, 2)                               as hl_devolvidos_total,
       case
           when dados.hl_carregados_total > 0 then
               trunc(((dados.hl_devolvidos_total / dados.hl_carregados_total) * 100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_dev_hl,
       trunc((dados.meta_dev_hl * 100)::numeric, 2) || '%'                        as meta_dev_hl,
       case
           when dados.hl_carregados_total > 0 and
                ((dados.hl_devolvidos_total / dados.hl_carregados_total) <= dados.meta_dev_hl) then 'SIM'
           else 'NÃO' end                                                         as bateu_dev_hl,
       dados.gols_dev_hl,
       dados.nf_carregadas_total,
       dados.nf_carregadas_total - dados.nf_devolvidas_total                      as nf_entregues_total,
       dados.nf_devolvidas_total,
       case
           when dados.nf_carregadas_total > 0 then
               trunc(((dados.nf_devolvidas_total::float / dados.nf_carregadas_total) * 100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_dev_nf,
       trunc((dados.meta_dev_nf * 100)::numeric, 2) || '%'                        as meta_dev_nf,
       case
           when dados.nf_carregadas_total > 0 and
                ((dados.nf_devolvidas_total / dados.nf_carregadas_total) <= dados.meta_dev_nf) then 'SIM'
           else 'NÃO' end,
       dados.gols_dev_nf,
       dados.pdv_carregados_total,
       dados.pdv_carregados_total - dados.pdv_devolvidos_total                    as pdv_entregues,
       case
           when dados.pdv_carregados_total > 0 then
               trunc(((dados.pdv_devolvidos_total / dados.pdv_carregados_total::float) * 100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_dev_pdv,
       trunc((dados.meta_dev_pdv * 100)::numeric, 2) || '%'                       as meta_dev_pdv,
       case
           when dados.pdv_carregados_total > 0 and
                ((dados.pdv_devolvidos_total / dados.pdv_carregados_total) <= dados.meta_dev_pdv) then 'SIM'
           else 'NÃO' end                                                         as bateu_dev_pdv,
       dados.gols_dev_pdv,
       trunc(dados.km_planejado_total::numeric, 2),
       dados.km_percorrido_total,
       trunc((dados.km_percorrido_total - dados.km_planejado_total)::numeric, 2)  as km_disperso,
       trunc(((CASE
                   WHEN dados.km_planejado_total > 0
                       THEN (dados.km_percorrido_total - dados.km_planejado_total) / dados.km_planejado_total
                   ELSE 0 END) * 100)::numeric, 2) || '% '                        AS resultado_disp_km,
       trunc((dados.meta_dispersao_km * 100)::numeric, 2) || '%'                  as meta_disp_km,
       case
           when (CASE
                     WHEN dados.km_planejado_total > 0
                         THEN (dados.km_percorrido_total - dados.km_planejado_total) / dados.km_planejado_total
                     ELSE 0 END) <= dados.meta_dev_pdv then 'SIM'
           else 'NÃO' end                                                         as bateu_disp_km,
       dados.gols_dispersao_km,
       dados.media_tempo_largada,
       dados.total_mapas_validos_tempo_largada,
       dados.total_mapas_bateu_tempo_largada,
       case
           when dados.total_mapas_validos_tempo_largada > 0 then
               trunc(((dados.total_mapas_bateu_tempo_largada / dados.total_mapas_validos_tempo_largada::float) *
                      100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_tempo_largada,
       trunc((dados.meta_tempo_largada_mapas * 100)::numeric, 2) || '%'           as meta_tempo_largada,
       case
           when dados.total_mapas_validos_tempo_largada > 0 and
                ((dados.total_mapas_bateu_tempo_largada / dados.total_mapas_validos_tempo_largada::float) >=
                 dados.meta_tempo_largada_mapas)
               then 'SIM'
           else 'NÃO' end                                                         as bateu_tempo_largada,
       dados.gols_tempo_largada,
       dados.media_tempo_rota,
       dados.total_mapas,
       dados.total_mapas_bateu_tempo_rota,
       case
           when dados.total_mapas > 0 then
               trunc(((dados.total_mapas_bateu_tempo_rota / dados.total_mapas::float) * 100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_tempo_rota,
       trunc((dados.meta_tempo_rota_mapas * 100)::numeric, 2) || '%'              as meta_tempo_rota,
       case
           when dados.total_mapas > 0 and
                ((dados.total_mapas_bateu_tempo_rota / dados.total_mapas::float) >= dados.meta_tempo_rota_mapas)
               then 'SIM'
           else 'NÃO' end                                                         as bateu_tempo_rota,
       dados.gols_tempo_ROTA,
       dados.media_tempo_interno,
       dados.total_mapas_validos_tempo_interno,
       dados.total_mapas_bateu_tempo_interno,
       case
           when dados.total_mapas_validos_tempo_interno > 0 then
               trunc(((dados.total_mapas_bateu_tempo_interno / dados.total_mapas_validos_tempo_interno::float) *
                      100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_tempo_interno,
       trunc((dados.meta_tempo_interno_mapas * 100)::numeric, 2) || '%'           as meta_tempo_interno_mapas,
       case
           when dados.total_mapas_validos_tempo_interno > 0 and
                ((dados.total_mapas_bateu_tempo_interno / dados.total_mapas_validos_tempo_interno::float) >=
                 dados.meta_tempo_interno_mapas) then 'SIM'
           else 'NÃO' end                                                         as bateu_tempo_interno,
       dados.gols_tempo_interno,
       dados.media_jornada,
       dados.total_mapas,
       dados.total_mapas_bateu_jornada,
       case
           when dados.total_mapas > 0 then
               trunc(((dados.total_mapas_bateu_jornada / dados.total_mapas::float) * 100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_jornada,
       trunc((dados.meta_jornada_liquida_mapas * 100)::numeric, 2) || '%'         as meta_jornada_liquida_mapas,
       case
           when dados.total_mapas > 0 and
                ((dados.total_mapas_bateu_jornada / dados.total_mapas::float) >= dados.meta_jornada_liquida_mapas)
               then 'SIM'
           else 'NÃO' end                                                         as bateu_jornada,
       dados.gols_jornada,
       dados.media_tempo_planejado,
       dados.total_mapas,
       dados.total_mapas_bateram_dispersao_tempo,
       case
           when dados.total_mapas > 0 then
               trunc(((dados.total_mapas_bateram_dispersao_tempo / dados.total_mapas::float) * 100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_dispersao_tempo,
       trunc((dados.meta_dispersao_tempo * 100)::numeric, 2) || '%'               as meta_dispersao_tempo,
       case
           when dados.total_mapas > 0 and
                ((dados.total_mapas_bateram_dispersao_tempo / dados.total_mapas::float) >= dados.meta_dispersao_tempo)
               then 'SIM'
           ELSE 'NÃO' END                                                         as bateu_dispersao_tempo,
       dados.gols_dispersao_tempo,
       dados.total_apontamentos,
       dados.total_apontamentos_ok,
       dados.total_apontamentos - dados.total_apontamentos_ok                     as total_apontamentos_nok,
       case
           when dados.total_apontamentos > 0 then
               trunc(((dados.total_apontamentos_ok / dados.total_apontamentos::float) * 100)::numeric, 2)
           else 0 end || '%'                                                      as resultado_tracking,
       trunc(trunc((dados.meta_tracking)::numeric, 3) * 100, 2) || '%'            as meta_tracking,
       case
           when dados.total_apontamentos > 0 and
                ((dados.total_apontamentos_ok / dados.total_apontamentos::float) >= dados.meta_tracking) then 'SIM'
           ELSE 'NÃO' END                                                         as bateu_tracking,
       dados.gols_tracking,
       (dados.gols_dev_nf +
        dados.gols_dev_pdv +
        dados.gols_dev_hl +
        dados.gols_tracking +
        dados.gols_dispersao_tempo +
        dados.gols_jornada +
        dados.gols_tempo_interno +
        dados.gols_tempo_largada +
        dados.gols_tempo_rota +
        dados.gols_dispersao_km)                                                  as total_gols
from (select m.nome,
             m.equipe,
             m.funcao,
             count(m.MAPA)                                                                           as total_mapas,
-- CaixaViagem
             sum(m.cxcarreg)                                                                         as carregadas_total,
-- Dev Hl
             sum(m.qthlcarregados)                                                                   as hl_carregados_total,
             sum(qthlcarregados - qthlentregues)                                                     as hl_devolvidos_total,
             sum(case when m.bateu_dev_hl = 'SIM' then 1 else 0 end)                                 as total_mapas_bateu_dev_hl,
-- Dev Nf
             sum(m.qtnfcarregadas)                                                                      nf_carregadas_total,
             sum(qtnfcarregadas - qtnfentregues)                                                     as nf_devolvidas_total,
             sum(case when m.bateu_dev_nf = 'SIM' then 1 else 0 end)                                 as total_mapas_bateu_dev_nf,
-- Dev Pdv
             sum(
                     m.entregascompletas + m.entregasnaorealizadas + m.entregasparciais)             as pdv_carregados_total,
             sum(m.entregasnaorealizadas + m.entregasparciais)                                       as pdv_devolvidos_total,
             sum(case when m.bateu_dev_pdv = 'SIM' then 1 else 0 end)                                as total_mapas_bateu_dev_pdv,
-- Dispersão Km
             sum(case
                     when (kmentr - m.kmsai) > 0 and (kmentr - m.kmsai) < 2000 then m.kmprevistoroad
                     else 0 end)                                                                     as km_planejado_total,
             sum(case
                     when (kmentr - m.kmsai) > 0 and (kmentr - m.kmsai) < 2000 then (m.kmentr - m.kmsai)
                     else 0 end)                                                                     as km_percorrido_total,
             sum(case when m.bateu_dispersao_km = 'SIM' then 1 else 0 end)                           as total_mapas_bateu_disp_km,
-- Dispersão de tempo
             sum(case
                     when m.bateu_dispersao_tempo = 'SIM' then 1
                     else 0 END)                                                                     as total_mapas_bateram_dispersao_tempo,
             to_char((avg(m.resultado_tempo_rota_segundos) || ' second')::interval,
                     'HH24:MI:SS')                                                                   as media_tempo_realizado,
             to_char((avg(m.tempoprevistoroad) || ' second')::INTERVAL,
                     'HH24:MI:SS')                                                                   as media_tempo_planejado,
-- Jornada --  primeiro verifica se é >00:00, depois verifica se é menor do que a meta
             to_char((AVG(m.RESULTADO_tempo_largada_SEGUNDOS + m.RESULTADO_TEMPO_ROTA_SEGUNDOS +
                          m.RESULTADO_TEMPO_INTERNO_SEGUNDOS) || ' second')::INTERVAL, 'HH24:MI:SS') as media_jornada,
             sum(case when m.bateu_jornada = 'SIM' then 1 else 0 end)                                as total_mapas_bateu_jornada,
--Tempo Interno
             sum(case when m.bateu_tempo_interno = 'SIM' then 1 else 0 end)                          as total_mapas_bateu_tempo_interno,
             sum(case
                     when to_char((m.tempo_interno || ' second')::INTERVAL, 'HH24:MI:SS')::TIME <= '05:00' and
                          m.resultado_tempo_interno_segundos > 0 then 1
                     else 0
                 end)                                                                                as total_mapas_validos_tempo_interno,
             to_char((avg(m.resultado_tempo_interno_segundos) || ' second')::interval,
                     'HH24:MI:SS')                                                                   as media_tempo_interno,
-- Tempo largada
             sum(case when m.bateu_tempo_largada = 'SIM' then 1 else 0 end)                          as total_mapas_bateu_tempo_largada,
             sum(case
                     when
                             (case
                                  when m.hr_sai::time < m.hrmatinal then to_char(
                                          (M.meta_tempo_largada_horas || ' second')::interval, 'HH24:MI:SS')::TIME
                                  else (m.hr_sai - m.hrmatinal)::time
                                 end) <= '05:00' then 1
                     else 0 end)                                                                     as total_mapas_validos_tempo_largada,
             to_char((AVG(resultado_tempo_largada_segundos) || ' second')::INTERVAL,
                     'HH24:MI:SS')                                                                      media_tempo_largada,
-- Tempo Rota
             SUM(CASE WHEN M.bateu_tempo_rota = 'SIM' THEN 1 ELSE 0 END)                             as total_mapas_bateu_tempo_rota,
             TO_CHAR((AVG(M.resultado_tempo_rota_segundos) || ' second')::interval,
                     'HH24:MI:SS')                                                                      media_tempo_rota,
-- Tracking
             sum(M.apontamentos_ok)                                                                  as total_apontamentos_ok,
             sum(M.total_tracking)                                                                   as total_apontamentos,
             m.meta_tracking,
             m.meta_tempo_rota_horas                                                                 as meta_tempo_rota_horas,
             m.meta_tempo_rota_mapas,
             m.meta_caixa_viagem,
             m.meta_dev_hl,
             m.meta_dev_pdv,
             m.meta_dispersao_km,
             m.meta_dispersao_tempo,
             m.meta_jornada_liquida_horas                                                            as meta_jornada_liquida_horas,
             m.meta_jornada_liquida_mapas,
             m.meta_raio_tracking,
             m.meta_tempo_interno_horas                                                              as meta_tempo_interno_horas,
             m.meta_tempo_interno_mapas,
             m.meta_tempo_largada_horas                                                              as meta_tempo_largada_horas,
             m.meta_tempo_largada_mapas,
             m.meta_dev_nf,
             sum(m.gol_dev_pdv)                                                                      as gols_dev_pdv,
             sum(m.gol_dev_nf)                                                                       as gols_dev_nf,
             sum(m.gol_dev_hl)                                                                       as gols_dev_hl,
             sum(m.gol_jornada)                                                                      as gols_jornada,
             sum(m.gol_tempo_interno)                                                                as gols_tempo_interno,
             sum(m.gol_tempo_rota)                                                                   as gols_tempo_rota,
             sum(m.gol_dispersao_tempo)                                                              as gols_dispersao_tempo,
             sum(m.gol_dispersao_km)                                                                 as gols_dispersao_km,
             sum(m.gol_tracking)                                                                     as gols_tracking,
             sum(m.gol_tempo_largada)                                                                as gols_tempo_largada
      from view_extrato_indicadores m
      WHERE m.cod_empresa = f_cod_empresa
        and m.cod_regional::text like f_cod_regional
        and m.cod_unidade::text like f_cod_unidade
        and m.cod_equipe::text like f_cod_equipe
        and m.cpf::text like f_cpf
        and M.DATA BETWEEN (f_data_inicial AT TIME ZONE
                            (SELECT TIMEZONE FROM func_get_time_zone_unidade(m.cod_unidade)))
          AND (f_data_final AT TIME ZONE (SELECT TIMEZONE FROM func_get_time_zone_unidade(m.cod_unidade)))
      GROUP BY m.equipe, m.cpf, m.nome, m.cod_unidade, m.meta_tracking,
               m.meta_tempo_rota_horas, m.meta_tempo_rota_mapas, m.meta_caixa_viagem, m.meta_dev_hl, m.meta_dev_pdv,
               m.meta_dispersao_km, m.meta_dispersao_tempo, m.meta_jornada_liquida_horas, m.meta_jornada_liquida_mapas,
               m.meta_raio_tracking, m.meta_tempo_interno_horas, m.meta_tempo_interno_mapas, m.meta_tempo_largada_horas,
               m.meta_tempo_largada_mapas, m.meta_dev_nf, m.funcao) as dados
order by total_gols DESC
$$;

create or replace function public.func_relatorio_extrato_mapas_indicadores(f_data_inicial date, f_data_final date,
                                                                           f_cpf text, f_cod_unidade text,
                                                                           f_cod_equipe text, f_cod_empresa bigint,
                                                                           f_cod_regional text)
    returns TABLE
            (
                "DATA"                     text,
                "EQUIPE"                   text,
                "NOME"                     text,
                "FUNÇÃO"                   text,
                "MAPA"                     integer,
                "PLACA"                    text,
                "CAIXAS CARREGADAS"        real,
                "HL CARREGADOS"            real,
                "HL ENTREGUES"             real,
                "HL DEVOLVIDOS"            numeric,
                "RESULTADO DEV HL"         text,
                "META DEV HL"              text,
                "BATEU DEV HL"             text,
                "NF CARREGADAS"            integer,
                "NF ENTREGUES"             integer,
                "NF DEVOLVIDAS"            integer,
                "RESULTADO DEV NF"         text,
                "META DEV NF"              text,
                "BATEU DEV NF"             text,
                "ENTREGAS CARREGADAS"      integer,
                "ENTREGAS REALIZADAS"      integer,
                "ENTREGAS DEVOLVIDAS"      integer,
                "RESULTADO DEV PDV"        text,
                "META DEV PDV"             text,
                "BATEU DEV PDV"            text,
                "KM PREVISTO"              real,
                "KM PERCORRIDO"            integer,
                "KM DISPERSO"              numeric,
                "RESULTADO DISP KM"        text,
                "META DISP KM"             text,
                "BATEU DISP KM"            text,
                "HORARIO MATINAL"          time without time zone,
                "HORARIO SAÍDA"            text,
                "TEMPO DE LARGADA"         time without time zone,
                "META TEMPO DE LARGADA"    text,
                "BATEU TML"                text,
                "HR SAÍDA"                 text,
                "HR ENTR"                  text,
                "TEMPO EM ROTA"            text,
                "META TEMPO EM ROTA"       text,
                "BATEU TEMPO EM ROTA"      text,
                "TEMPO INTERNO"            text,
                "META TEMPO INTERNO"       text,
                "BATEU TEMPO INTERNO"      text,
                "JORNADA"                  text,
                "META JORNADA"             text,
                "BATEU JORNADA"            text,
                "TEMPO PREVISTO"           text,
                "TEMPO REALIZADO"          text,
                "DISPERSÃO"                text,
                "META DISPERSÃO DE TEMPO"  text,
                "BATEU DISPERSÃO DE TEMPO" text,
                "TOTAL ENTREGAS"           bigint,
                "APONTAMENTOS OK"          bigint,
                "APONTAMENTOS NOK"         bigint,
                "ADERENCIA TRACKING"       text,
                "META TRACKING"            text,
                "BATEU TRACKING"           text,
                "TOTAL DE GOLS"            integer
            )
    language sql
as
$$
SELECT to_char(v.data, 'DD/MM/YYYY'),
       v.equipe,
       v.nome,
       v.funcao,
       v.mapa,
       v.placa,
       v.cxcarreg,
       --     dev HL
       v.qthlcarregados,
       v.qthlentregues,
       v.qthldevolvidos,
       trunc((v.resultado_devolucao_hectolitro * 100)::numeric, 2) || '%',
       trunc((v.meta_dev_hl * 100)::numeric, 2) || '%',
       v.BATEU_DEV_HL,
--     dev NF
       v.qtnfcarregadas,
       v.qtnfentregues,
       v.qtnfdevolvidas,
       trunc((v.resultado_devolucao_nf * 100)::numeric, 2) || '%',
       trunc((v.meta_dev_nf * 100)::numeric, 2) || '%',
       v.BATEU_DEV_NF,
--   dev PDV
       v.entregas_carregadas,
       v.entregascompletas,
       v.entregasparciais + v.entregasnaorealizadas,
       trunc((v.resultado_devolucao_pdv * 100)::numeric, 2) || '%',
       trunc((v.meta_dev_pdv * 100)::numeric, 2) || '%',
       v.BATEU_DEV_PDV,
--   dispersão KM
       v.kmprevistoroad,
       v.km_percorrido,
       trunc((v.km_percorrido - v.kmprevistoroad)::numeric, 2),
       trunc((v.resultado_dispersao_km * 100)::numeric, 2) || '%',
       trunc((v.meta_dispersao_km * 100)::numeric, 2) || '%',
       v.BATEU_DISPERSAO_KM,
--     tempo de largada
       v.hrmatinal,
       v.hrsai,
       v.TEMPO_LARGADA,
       to_char((v.meta_tempo_largada_horas || ' second')::interval, 'HH24:MI:SS'),
       v.BATEU_TEMPO_LARGADA,
--     tempo em rota
       v.hrsai,
       v.hrentr,
       v.tempo_rota,
       to_char((v.meta_tempo_rota_horas || ' second')::interval, 'HH24:MI:SS'),
       v.BATEU_TEMPO_ROTA,
--   tempo interno
       case
           when v.RESULTADO_TEMPO_INTERNO_SEGUNDOS > 0 then
               to_char((v.RESULTADO_TEMPO_INTERNO_SEGUNDOS || ' second')::interval, 'HH24:MI:SS')
           else 0::text end,
       case
           when v.meta_tempo_interno_horas > 0 then
               to_char((v.meta_tempo_interno_horas || ' second')::interval, 'HH24:MI:SS')
           else 0::text end,
       v.BATEU_TEMPO_INTERNO,
--     jornada
       case
           when (v.RESULTADO_TEMPO_INTERNO_SEGUNDOS + v.RESULTADO_tempo_largada_SEGUNDOS +
                 v.RESULTADO_TEMPO_ROTA_SEGUNDOS) > 0 then
               to_char(((v.RESULTADO_TEMPO_INTERNO_SEGUNDOS + v.RESULTADO_tempo_largada_SEGUNDOS +
                         v.RESULTADO_TEMPO_ROTA_SEGUNDOS) || ' second')::interval, 'HH24:MI:SS')
           else 0::text end,
       case
           when v.meta_jornada_liquida_horas > 0 then
               to_char((v.meta_jornada_liquida_horas || ' second')::interval, 'HH24:MI:SS')
           else 0::text end,
       v.BATEU_JORNADA,
--     dispersao de tempo
       case
           when v.tempoprevistoroad > 0 then
               to_char((v.tempoprevistoroad || ' second')::interval, 'HH24:MI:SS')
           else 0::text end,
       v.tempo_rota,
       trunc((v.RESULTADO_DISPERSAO_TEMPO * 100)::numeric, 2) || '%',
       trunc(trunc((v.meta_dispersao_tempo)::numeric, 3) * 100, 2) || '%',
       v.BATEU_DISPERSAO_TEMPO,
--     tracking
       v.TOTAL_TRACKING,
       v.APONTAMENTOS_OK,
       v.APONTAMENTOS_NOK,
       trunc((v.RESULTADO_TRACKING * 100)::numeric, 2) || '%',
       trunc(trunc((v.meta_tracking)::numeric, 3) * 100, 2) || '%',
       v.BATEU_TRACKING,
       (v.gol_dev_nf +
        v.gol_dev_pdv +
        v.gol_dev_hl +
        v.gol_tracking +
        v.gol_dispersao_tempo +
        v.gol_jornada +
        v.gol_tempo_interno +
        v.gol_tempo_largada +
        v.gol_tempo_rota +
        v.gol_dispersao_km) as total_gols
FROM VIEW_EXTRATO_INDICADORES V
WHERE case when f_cod_empresa is null then true else (v.cod_empresa = f_cod_empresa) end
  AND V.cod_regional::text like f_cod_regional
  AND v.cod_unidade::text like f_cod_unidade
  AND v.cod_equipe::text like f_cod_equipe
  AND v.cpf::text LIKE f_cpf
  AND v.data between f_data_inicial and f_data_final
$$;

create or replace function public.func_relatorio_extrato_relatos(f_data_inicial date, f_data_final date,
                                                                 f_cod_unidade bigint, f_equipe text)
    returns TABLE
            (
                "CÓDIGO"                          bigint,
                "DATA DO ENVIO"                   text,
                "INVÁLIDO"                        character,
                "ENVIADO"                         character,
                "CLASSIFICADO"                    character,
                "FECHADO"                         character,
                "ALTERNATIVA"                     text,
                "DESCRIÇÃO"                       text,
                "COD_PDV"                         integer,
                "COLABORADOR"                     text,
                "EQUIPE"                          text,
                "DATA CLASSIFICAÇÃO"              text,
                "TEMPO PARA CLASSIFICAÇÃO (DIAS)" integer,
                "CLASSIFICADO POR"                text,
                "DATA FECHAMENTO"                 text,
                "TEMPO PARA FECHAMENTO (DIAS)"    integer,
                "FECHADO POR"                     text,
                "OBS FECHAMENTO"                  text,
                "LATITUDE"                        text,
                "LONGITUDE"                       text,
                "LINK MAPS"                       text,
                "FOTO 1"                          text,
                "FOTO 2"                          text,
                "FOTO 3"                          text
            )
    language sql
as
$$
SELECT r.codigo                                                                                as cod_relato,
       to_char(r.data_hora_database, 'DD/MM/YYYY HH24:MI')                                     AS data_envio,
       case when r.status = 'INVALIDO' THEN 'X' ELSE '' END                                    AS invalido,
       'X'::CHAR                                                                               AS enviado,
       case when r.status = 'PENDENTE_FECHAMENTO' OR r.status = 'FECHADO' THEN 'X' ELSE '' END AS classificado,
       case when r.status = 'FECHADO' THEN 'X' ELSE '' END                                     AS fechado,
       ra.alternativa                                                                          as alternativa_selecionada,
       r.resposta_outros                                                                       as descricao,
       r.cod_pdv                                                                               as cod_pdv,
       relator.nome                                                                            as colaborador_envio,
       e.nome                                                                                  as equipe,
       to_char(r.data_hora_classificacao, 'DD/MM/YYYY HH24:MI')                                AS data_classificacao,
       extract(day from r.data_hora_classificacao - r.data_hora_database)::INT                 as dias_para_classificacao,
       classificador.nome                                                                      AS colaborador_classificacao,
       to_char(r.data_hora_fechamento, 'DD/MM/YYYY HH24:MI')                                   AS data_fechamento,
       extract(DAY FROM r.data_hora_fechamento - r.data_hora_database)::INT                    AS dias_para_fechamento,
       fechamento.nome                                                                         AS colaborador_fechamento,
       r.feedback_fechamento,
       r.latitude,
       r.longitude,
       'http://maps.google.com/?q=' || r.latitude || ',' || r.longitude                        as link_maps,
       r.url_foto_1,
       r.url_foto_2,
       r.url_foto_3
FROM relato r
         JOIN colaborador relator ON relator.cpf = r.cpf_colaborador
         LEFT JOIN colaborador classificador ON classificador.cpf = r.cpf_classificacao
         LEFT JOIN colaborador fechamento ON fechamento.cpf = r.cpf_fechamento
         LEFT JOIN relato_alternativa ra ON ra.cod_unidade = r.cod_unidade AND r.cod_alternativa = ra.codigo
         JOIN unidade u ON u.codigo = relator.cod_unidade
         JOIN funcao f ON f.codigo = relator.cod_funcao AND f.cod_empresa = u.cod_empresa
         JOIN equipe e ON e.codigo = relator.cod_equipe AND e.cod_unidade = relator.cod_unidade
WHERE r.cod_unidade = f_cod_unidade
  and r.data_hora_database::DATE >= f_data_inicial
  AND r.data_hora_database::DATE <= f_data_final
  AND e.codigo::text like f_equipe
$$;

create or replace function public.func_relatorio_intervalo_folha_ponto(f_cod_unidade bigint,
                                                                       f_cod_tipo_intervalo bigint,
                                                                       f_cpf_colaborador bigint, f_data_inicial date,
                                                                       f_data_final date,
                                                                       f_apenas_colaboradores_ativos boolean,
                                                                       f_time_zone_unidade text)
    returns TABLE
            (
                cpf_colaborador                bigint,
                nome_colaborador               text,
                cod_tipo_intervalo             bigint,
                cod_tipo_intervalo_por_unidade bigint,
                data_hora_inicio               timestamp without time zone,
                data_hora_fim                  timestamp without time zone,
                data_hora_inicio_utc           timestamp without time zone,
                data_hora_fim_utc              timestamp without time zone,
                foi_ajustado_inicio            boolean,
                foi_ajustado_fim               boolean,
                diferenca_marcacoes_segundos   double precision,
                trocou_dia                     boolean
            )
    language sql
as
$$
SELECT F.CPF_COLABORADOR                                                                      AS CPF_COLABORADOR,
       C.NOME                                                                                 AS NOME_COLABORADOR,
       F.COD_TIPO_INTERVALO                                                                   AS COD_TIPO_INTERVALO,
       F.COD_TIPO_INTERVALO_POR_UNIDADE                                                       AS COD_TIPO_INTERVALO_POR_UNIDADE,
       F_IF(F.STATUS_ATIVO_INICIO, F.DATA_HORA_INICIO, NULL) AT TIME ZONE F_TIME_ZONE_UNIDADE AS DATA_HORA_INICIO,
       F_IF(F.STATUS_ATIVO_FIM, F.DATA_HORA_FIM, NULL) AT TIME ZONE F_TIME_ZONE_UNIDADE       AS DATA_HORA_FIM,
       F_IF(F.STATUS_ATIVO_INICIO, F.DATA_HORA_INICIO, NULL) AT TIME ZONE 'UTC'               AS DATA_HORA_INICIO_UTC,
       F_IF(F.STATUS_ATIVO_FIM, F.DATA_HORA_FIM, NULL) AT TIME ZONE 'UTC'                     AS DATA_HORA_FIM_UTC,
       F_IF(F.STATUS_ATIVO_INICIO, F.FOI_AJUSTADO_INICIO, NULL)                               AS FOI_AJUSTADO_INICIO,
       F_IF(F.STATUS_ATIVO_FIM, F.FOI_AJUSTADO_FIM, NULL)                                     AS FOI_AJUSTADO_FIM,
       F_IF(F.STATUS_ATIVO_INICIO AND F.STATUS_ATIVO_FIM,
            EXTRACT(EPOCH FROM (F.DATA_HORA_FIM - F.DATA_HORA_INICIO)),
            NULL)                                                                             AS DIFERENCA_MARCACOES_SEGUNDOS,
       -- Só importa essa verificação se início e fim estiverem ativos.
       F.STATUS_ATIVO_INICIO AND F.STATUS_ATIVO_FIM AND
       (F.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE !=
       (F.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE                             AS TROCOU_DIA
FROM FUNC_INTERVALOS_AGRUPADOS(F_COD_UNIDADE, F_CPF_COLABORADOR, F_COD_TIPO_INTERVALO) F
         JOIN COLABORADOR C
              ON F.CPF_COLABORADOR = C.CPF
WHERE F_IF(F_APENAS_COLABORADORES_ATIVOS IS NULL, TRUE, C.STATUS_ATIVO)
  AND (F.STATUS_ATIVO_INICIO OR F.STATUS_ATIVO_FIM)
  AND
  -- FILTRA POR MARCAÇÕES QUE TENHAM SEU INÍCIO DENTRO DO PERÍODO FILTRADO, NÃO IMPORTANDO SE TENHAM FIM.
    (((F.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE >= F_DATA_INICIAL
        AND (F.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE <= F_DATA_FINAL)
        OR
        -- FILTRA POR MARCAÇÕES QUE TENHAM SEU FIM DENTRO DO PERÍODO FILTRADO, NÃO IMPORTANDO SE TENHAM INÍCIO.
     ((F.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE >= F_DATA_INICIAL
         AND (F.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE <= F_DATA_FINAL)
        OR
        -- FILTRA POR MARCAÇÕES QUE TIVERAM SEU INÍCIO ANTES DO FILTRO E FIM APÓS O FILTRO.
     ((F.DATA_HORA_INICIO AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE < F_DATA_INICIAL
         AND (F.DATA_HORA_FIM AT TIME ZONE F_TIME_ZONE_UNIDADE) :: DATE > F_DATA_FINAL))
ORDER BY F.CPF_COLABORADOR, COALESCE(F.DATA_HORA_INICIO, F.DATA_HORA_FIM) ASC;
$$;

create or replace function public.func_relatorio_intervalo_portaria_1510_tipo_3(f_cod_unidade bigint,
                                                                                f_cod_tipo_intervalo bigint,
                                                                                f_cpf_colaborador bigint,
                                                                                f_data_inicial date, f_data_final date,
                                                                                f_time_zone_datas text)
    returns TABLE
            (
                "NSR"              text,
                "TIPO DO REGISTRO" text,
                "DATA DA MARCAÇÃO" text,
                "HORA DA MARCAÇÃO" text,
                "PIS COLABORADOR"  text
            )
    language sql
as
$$
SELECT LPAD(vi.codigo_marcacao_por_unidade :: TEXT, 9, '0')             AS NSR,
       '3' :: TEXT                                                      AS TIPO_REGISTRO,
       TO_CHAR(VI.data_hora AT TIME ZONE F_TIME_ZONE_DATAS, 'DDMMYYYY') AS DATA_MARCACAO,
       TO_CHAR(VI.data_hora AT TIME ZONE F_TIME_ZONE_DATAS, 'HH24MI')   AS HORARIO_MARCACAO,
       LPAD(C.PIS :: TEXT, 12, '0')                                     AS PIS
FROM VIEW_INTERVALO VI
         JOIN COLABORADOR C ON VI.cpf_colaborador = C.cpf AND c.pis is not null
WHERE (VI.data_hora AT TIME ZONE F_TIME_ZONE_DATAS) :: DATE >= F_DATA_INICIAL
  AND (VI.data_hora AT TIME ZONE F_TIME_ZONE_DATAS) :: DATE <= F_DATA_FINAL
  AND VI.COD_UNIDADE = f_cod_unidade
  AND VI.cod_tipo_intervalo = f_cod_tipo_intervalo
  AND CASE
          WHEN F_CPF_COLABORADOR IS NULL
              THEN TRUE
          ELSE VI.cpf_colaborador = F_CPF_COLABORADOR END;
$$;

create or replace function public.func_relatorio_mapa_estratificado(f_cod_unidade bigint, f_data_inicial date, f_data_final date)
    returns TABLE
            (
                data                           character varying,
                placa                          character varying,
                mapa                           integer,
                "matric motorista"             integer,
                "nome motorista"               text,
                "matric ajudante 1"            integer,
                "nome ajudante 1"              text,
                "matric ajudante 2"            integer,
                "nome ajudante 2"              text,
                entregas                       integer,
                cxcarreg                       real,
                cxentreg                       real,
                transp                         integer,
                entrega                        character varying,
                cargaatual                     text,
                frota                          text,
                custospot                      real,
                regiao                         integer,
                veiculo                        integer,
                veiculoindisp                  real,
                placaindisp                    real,
                frotaindisp                    real,
                tipoindisp                     integer,
                ocupacao                       real,
                cxrota                         real,
                cxas                           real,
                veicbm                         real,
                rshow                          integer,
                entrvol                        character varying,
                hrsai                          timestamp without time zone,
                hrentr                         timestamp without time zone,
                kmsai                          integer,
                kmentr                         integer,
                custovariavel                  real,
                lucro                          real,
                lucrounit                      real,
                valorfrete                     real,
                tipoimposto                    character varying,
                percimposto                    real,
                valorimposto                   real,
                valorfaturado                  real,
                valorunitcxentregue            real,
                valorpgcxentregsemimp          real,
                valorpgcxentregcomimp          real,
                tempoprevistoroad              time without time zone,
                kmprevistoroad                 real,
                valorunitpontomot              real,
                valorunitpontoajd              real,
                valorequipeentrmot             real,
                valorequipeentrajd             real,
                custovariavelcedbz             real,
                lucrounitcedbz                 real,
                lucrovariavelcxentregueffcedbz real,
                tempointerno                   time without time zone,
                valordropdown                  real,
                veiccaddd                      character varying,
                kmlaco                         real,
                kmdeslocamento                 real,
                tempolaco                      time without time zone,
                tempodeslocamento              time without time zone,
                sitmulticdd                    real,
                unborigem                      integer,
                valorctedifere                 character varying,
                qtnfcarregadas                 integer,
                qtnfentregues                  integer,
                inddevcx                       real,
                inddevnf                       real,
                fator                          real,
                recarga                        character varying,
                hrmatinal                      time without time zone,
                hrjornadaliq                   time without time zone,
                hrmetajornada                  time without time zone,
                vlbateujornmot                 real,
                vlnaobateujornmot              real,
                vlrecargamot                   real,
                vlbateujornaju                 real,
                vlnaobateujornaju              real,
                vlrecargaaju                   real,
                vltotalmapa                    real,
                qthlcarregados                 real,
                qthlentregues                  real,
                indicedevhl                    real,
                regiao2                        character varying,
                qtnfcarreggeral                integer,
                qtnfentreggeral                integer,
                capacidadeveiculokg            real,
                pesocargakg                    real,
                capacveiculocx                 integer,
                entregascompletas              integer,
                entregasparciais               integer,
                entregasnaorealizadas          integer,
                codfilial                      integer,
                nomefilial                     character varying,
                codsupervtrs                   integer,
                nomesupervtrs                  character varying,
                codspot                        integer,
                nomespot                       text,
                equipcarregados                integer,
                equipdevolvidos                integer,
                equiprecolhidos                integer,
                cxentregtracking               real,
                hrcarreg                       timestamp without time zone,
                hrpcfisica                     timestamp without time zone,
                hrpcfinanceira                 timestamp without time zone,
                stmapa                         character varying,
                totalapontamentostracking      bigint,
                apontamentosok                 bigint,
                apontamentosnok                bigint,
                aderencia                      double precision
            )
    language sql
as
$$
SELECT to_char(m.data, 'DD/MM/YYYY'),
       placa,
       mapa,
       matricmotorista,
       coalesce(MOTORISTA.nome, '-')                          AS NOME_MOTORISTA,
       matricajud1,
       coalesce(AJUDANTE1.nome, '-')                          AS NOME_AJUDANTE1,
       matricajud2,
       coalesce(AJUDANTE2.nome, '-')                          AS NOME_AJUDANTE2,
       entregas,
       cxcarreg,
       cxentreg,
       transp,
       entrega,
       cargaatual,
       frota,
       custospot,
       regiao,
       veiculo,
       veiculoindisp,
       placaindisp,
       frotaindisp,
       tipoindisp,
       ocupacao,
       cxrota,
       cxas,
       veicbm,
       rshow,
       entrvol,
       hrsai,
       hrentr,
       kmsai,
       kmentr,
       custovariavel,
       lucro,
       lucrounit,
       valorfrete,
       tipoimposto,
       percimposto,
       valorimposto,
       valorfaturado,
       valorunitcxentregue,
       valorpgcxentregsemimp,
       valorpgcxentregcomimp,
       tempoprevistoroad,
       kmprevistoroad,
       valorunitpontomot,
       valorunitpontoajd,
       valorequipeentrmot,
       valorequipeentrajd,
       custovariavelcedbz,
       lucrounitcedbz,
       lucrovariavelcxentregueffcedbz,
       tempointerno,
       valordropdown,
       veiccaddd,
       kmlaco,
       kmdeslocamento,
       tempolaco,
       tempodeslocamento,
       sitmulticdd,
       unborigem,
       valorctedifere,
       qtnfcarregadas,
       qtnfentregues,
       inddevcx,
       inddevnf,
       fator,
       recarga,
       hrmatinal,
       hrjornadaliq,
       hrmetajornada,
       vlbateujornmot,
       vlnaobateujornmot,
       vlrecargamot,
       vlbateujornaju,
       vlnaobateujornaju,
       vlrecargaaju,
       vltotalmapa,
       qthlcarregados,
       qthlentregues,
       indicedevhl,
       regiao2,
       qtnfcarreggeral,
       qtnfentreggeral,
       capacidadeveiculokg,
       pesocargakg,
       capacveiculocx,
       entregascompletas,
       entregasparciais,
       entregasnaorealizadas,
       codfilial,
       nomefilial,
       codsupervtrs,
       nomesupervtrs,
       codspot,
       nomespot,
       equipcarregados,
       equipdevolvidos,
       equiprecolhidos,
       cxentregtracking,
       hrcarreg,
       hrpcfisica,
       hrpcfinanceira,
       stmapa,
       TRACKING.TOTAL_APONTAMENTOS,
       TRACKING.APONTAMENTOS_OK,
       TRACKING.TOTAL_APONTAMENTOS - TRACKING.APONTAMENTOS_OK AS apontamentos_nok,
       TRUNC((TRACKING.APONTAMENTOS_OK :: FLOAT / TRACKING.TOTAL_APONTAMENTOS) * 100)
FROM MAPA M
         JOIN unidade_funcao_produtividade UFP ON UFP.cod_unidade = M.cod_unidade
         LEFT JOIN colaborador MOTORISTA
                   ON MOTORISTA.cod_unidade = M.cod_unidade AND MOTORISTA.cod_funcao = UFP.cod_funcao_motorista
                       AND MOTORISTA.matricula_ambev = M.matricmotorista
         LEFT JOIN colaborador AJUDANTE1
                   ON AJUDANTE1.cod_unidade = M.cod_unidade AND AJUDANTE1.cod_funcao = UFP.cod_funcao_ajudante
                       AND AJUDANTE1.matricula_ambev = M.matricajud1
         LEFT JOIN colaborador AJUDANTE2
                   ON AJUDANTE2.cod_unidade = M.cod_unidade AND AJUDANTE2.cod_funcao = UFP.cod_funcao_ajudante
                       AND AJUDANTE2.matricula_ambev = M.matricajud2
         LEFT JOIN (SELECT T.MAPA                         AS TRACKING_MAPA,
                           T.código_transportadora           TRACKING_UNIDADE,
                           COUNT(T.disp_apont_cadastrado) AS TOTAL_APONTAMENTOS,
                           SUM(CASE
                                   WHEN T.disp_apont_cadastrado <= UM.meta_raio_tracking
                                       THEN 1
                                   ELSE 0 END)            AS APONTAMENTOS_OK
                    FROM TRACKING T
                             JOIN UNIDADE_METAS UM ON UM.COD_UNIDADE = T.código_transportadora
                    GROUP BY 1, 2) AS TRACKING ON TRACKING_MAPA = M.MAPA AND TRACKING_UNIDADE = M.cod_unidade
WHERE M.COD_UNIDADE = f_cod_unidade
  AND M.data BETWEEN (f_data_inicial AT TIME ZONE (SELECT TIMEZONE FROM func_get_time_zone_unidade(f_cod_unidade)))
    AND (f_data_final AT TIME ZONE (SELECT TIMEZONE FROM func_get_time_zone_unidade(f_cod_unidade)))
ORDER BY M.MAPA
$$;

create or replace function public.func_relatorio_marcacoes_diarias(f_cod_unidade bigint, f_data_inicial date,
                                                                   f_data_final date, f_cpf text)
    returns TABLE
            (
                "NOME"                                         text,
                "MATRÍCULA TRANSPORTADORA"                     text,
                "MATRÍCULA AMBEV"                              text,
                "CARGO"                                        text,
                "SETOR"                                        text,
                "INTERVALO"                                    text,
                "INICIO INTERVALO"                             text,
                "LATITUDE INÍCIO"                              text,
                "LONGITUDE INÍCIO"                             text,
                "FIM INTERVALO"                                text,
                "LATITUDE FIM"                                 text,
                "LONGITUDE FIM"                                text,
                "TEMPO DECORRIDO (MINUTOS)"                    text,
                "TEMPO RECOMENDADO (MINUTOS)"                  bigint,
                "CUMPRIU TEMPO MÍNIMO"                         text,
                "JUSTIFICATIVA NÃO CUMPRIMENTO TEMPO MÍNIMO"   text,
                "JUSTIFICATIVA ESTOURO TEMPO MÁXIMO PERMITIDO" text,
                "DISTANCIA ENTRE INÍCIO E FIM (METROS)"        text
            )
    language sql
as
$$
SELECT C.NOME                                   AS NOME_COLABORADOR,
       COALESCE(C.MATRICULA_TRANS :: TEXT, '-') AS MATRICULA_TRANS,
       COALESCE(C.MATRICULA_AMBEV :: TEXT, '-') AS MATRICULA_AMBEV,
       F.NOME                                   AS CARGO,
       S.NOME                                   AS SETOR,
       IT.NOME                                  AS INTERVALO,
       COALESCE(TO_CHAR(I.DATA_HORA_INICIO AT TIME ZONE (SELECT TIMEZONE
                                                         FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE)),
                        'DD/MM/YYYY HH24:MI:SS'),
                '')                             AS DATA_HORA_INICIO,

       I.LATITUDE_MARCACAO_INICIO :: TEXT       AS LATITUDE_INICIO,
       I.LONGITUDE_MARCACAO_INICIO :: TEXT      AS LONGITUDE_INICIO,


       COALESCE(TO_CHAR(I.DATA_HORA_FIM AT TIME ZONE (SELECT TIMEZONE
                                                      FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE)),
                        'DD/MM/YYYY HH24:MI:SS'),
                '')                             AS DATA_HORA_FIM,

       I.LATITUDE_MARCACAO_FIM :: TEXT          AS LATITUDE_FIM,
       I.LONGITUDE_MARCACAO_FIM :: TEXT         AS LONGITUDE_FIM,


       COALESCE(TRUNC(EXTRACT(EPOCH FROM I.DATA_HORA_FIM - I.DATA_HORA_INICIO) / 60) :: TEXT,
                '')                             AS TEMPO_DECORRIDO_MINUTOS,
       IT.TEMPO_RECOMENDADO_MINUTOS,
       CASE
           WHEN I.DATA_HORA_FIM IS NULL OR I.DATA_HORA_INICIO IS NULL
               THEN ''
           WHEN IT.TEMPO_RECOMENDADO_MINUTOS > (EXTRACT(EPOCH FROM I.DATA_HORA_FIM - I.DATA_HORA_INICIO) / 60)
               THEN
               'NÃO'
           ELSE 'SIM' END                       AS CUMPRIU_TEMPO_MINIMO,
       I.JUSTIFICATIVA_TEMPO_RECOMENDADO,
       I.JUSTIFICATIVA_ESTOURO,

       COALESCE(TRUNC((ST_DISTANCE(
               ST_POINT(I.LONGITUDE_MARCACAO_INICIO :: FLOAT, I.LATITUDE_MARCACAO_INICIO :: FLOAT) :: GEOGRAPHY,
               ST_POINT(I.LONGITUDE_MARCACAO_FIM :: FLOAT, I.LATITUDE_MARCACAO_FIM :: FLOAT) :: GEOGRAPHY))) :: TEXT,
                '-')                            AS DISTANCIA
FROM FUNC_INTERVALOS_AGRUPADOS(F_COD_UNIDADE, CASE
                                                  WHEN F_CPF = '%'
                                                      THEN NULL
                                                  ELSE F_CPF :: BIGINT END, NULL) I
         JOIN COLABORADOR C ON C.CPF = I.CPF_COLABORADOR
         JOIN INTERVALO_TIPO IT ON IT.COD_UNIDADE = I.COD_UNIDADE AND IT.CODIGO = I.COD_TIPO_INTERVALO
         JOIN UNIDADE U ON U.CODIGO = C.COD_UNIDADE AND C.COD_EMPRESA = U.COD_EMPRESA
         JOIN FUNCAO F ON F.COD_EMPRESA = U.COD_EMPRESA AND F.CODIGO = C.COD_FUNCAO
         JOIN SETOR S ON S.COD_UNIDADE = C.COD_UNIDADE AND S.CODIGO = C.COD_SETOR
WHERE ((I.DATA_HORA_INICIO AT TIME ZONE (SELECT TIMEZONE
                                         FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE))) :: DATE
           BETWEEN (F_DATA_INICIAL AT TIME ZONE (SELECT TIMEZONE
                                                 FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE)))
           AND (F_DATA_FINAL AT TIME ZONE (SELECT TIMEZONE
                                           FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE)))
    OR (I.DATA_HORA_FIM AT TIME ZONE (SELECT TIMEZONE
                                      FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE))) :: DATE
           BETWEEN (F_DATA_INICIAL AT TIME ZONE (SELECT TIMEZONE
                                                 FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE)))
           AND (F_DATA_FINAL AT TIME ZONE (SELECT TIMEZONE
                                           FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE))))
ORDER BY I.DATA_HORA_INICIO, C.NOME
$$;

create or replace function public.func_relatorio_pneu_aderencia_afericao(f_cod_unidade text[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE ALOCADA"                          text,
                "PLACA"                                    character varying,
                "QT AFERIÇÕES DE PRESSÃO"                  bigint,
                "MAX DIAS ENTRE AFERIÇÕES DE PRESSÃO"      text,
                "MIN DIAS ENTRE AFERIÇÕES DE PRESSÃO"      text,
                "MÉDIA DE DIAS ENTRE AFERIÇÕES DE PRESSÃO" text,
                "QTD AFERIÇÕES DE PRESSÃO DENTRO DA META"  bigint,
                "ADERÊNCIA AFERIÇÕES DE PRESSÃO"           text,
                "QT AFERIÇÕES DE SULCO"                    bigint,
                "MAX DIAS ENTRE AFERIÇÕES DE SULCO"        text,
                "MIN DIAS ENTRE AFERIÇÕES DE SULCO"        text,
                "MÉDIA DE DIAS ENTRE AFERIÇÕES DE SULCO"   text,
                "QTD AFERIÇÕES DE SULCO DENTRO DA META"    bigint,
                "ADERÊNCIA AFERIÇÕES DE SULCO"             text
            )
    language sql
as
$$
SELECT U.NOME  AS "UNIDADE ALOCADA",
       V.PLACA AS PLACA,
       COALESCE(CALCULO_PRESSAO.QTD_AFERICOES, 0),
       COALESCE(CALCULO_PRESSAO.MAX_DIAS_ENTRE_AFERICOES, '0'),
       COALESCE(CALCULO_PRESSAO.MIN_DIAS_ENTRE_AFERICOES, '0'),
       COALESCE(CALCULO_PRESSAO.MD_DIAS_ENTRE_AFERICOES, '0'),
       COALESCE(CALCULO_PRESSAO.QTD_AFERICOES_DENTRO_META, 0),
       COALESCE(CALCULO_PRESSAO.ADERENCIA, '0'),
       COALESCE(CALCULO_SULCO.QTD_AFERICOES, 0),
       COALESCE(CALCULO_SULCO.MAX_DIAS_ENTRE_AFERICOES, '0'),
       COALESCE(CALCULO_SULCO.MIN_DIAS_ENTRE_AFERICOES, '0'),
       COALESCE(CALCULO_SULCO.MD_DIAS_ENTRE_AFERICOES, '0'),
       COALESCE(CALCULO_SULCO.QTD_AFERICOES_DENTRO_META, 0),
       COALESCE(CALCULO_SULCO.ADERENCIA, '0')
FROM VEICULO V
         JOIN UNIDADE U ON V.COD_UNIDADE = U.CODIGO
         LEFT JOIN (SELECT CALCULO_AFERICAO_PRESSAO.PLACA,
                           COUNT(CALCULO_AFERICAO_PRESSAO.PLACA)                                                    AS QTD_AFERICOES,
                           CASE
                               WHEN
                                   MAX(CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                   THEN MAX(CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES)::TEXT
                               ELSE '-' END                                                                         AS MAX_DIAS_ENTRE_AFERICOES,
                           CASE
                               WHEN
                                   MIN(CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                   THEN MIN(CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES)::TEXT
                               ELSE '-' END                                                                         AS MIN_DIAS_ENTRE_AFERICOES,
                           CASE
                               WHEN
                                   MAX(CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                   THEN TRUNC(
                                       CASE
                                           WHEN SUM(CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                               THEN
                                                   SUM(CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES) /
                                                   SUM(CASE
                                                           WHEN CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES IS NOT NULL
                                                               THEN 1
                                                           ELSE 0 END)
                                           END)::TEXT
                               ELSE '-' END                                                                         AS MD_DIAS_ENTRE_AFERICOES,
                           SUM(CASE
                                   WHEN CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES <=
                                        CALCULO_AFERICAO_PRESSAO.PERIODO_AFERICAO
                                       THEN 1
                                   ELSE 0 END)                                                                      AS QTD_AFERICOES_DENTRO_META,
                           TRUNC(SUM(CASE
                                         WHEN CALCULO_AFERICAO_PRESSAO.DIAS_ENTRE_AFERICOES <=
                                              CALCULO_AFERICAO_PRESSAO.PERIODO_AFERICAO
                                             THEN 1
                                         ELSE 0 END) / COUNT(CALCULO_AFERICAO_PRESSAO.PLACA)::NUMERIC * 100) ||
                           '%'                                                                                      AS ADERENCIA
                    FROM (SELECT A.PLACA_VEICULO            AS PLACA,
                                 A.DATA_HORA,
                                 A.TIPO_MEDICAO_COLETADA,
                                 R.PERIODO_AFERICAO_PRESSAO AS PERIODO_AFERICAO,
                                 CASE
                                     WHEN A.PLACA_VEICULO = LAG(A.PLACA_VEICULO) OVER (ORDER BY PLACA_VEICULO, DATA_HORA)
                                         THEN EXTRACT(DAYS FROM A.DATA_HORA -
                                                                LAG(A.DATA_HORA) OVER (ORDER BY PLACA_VEICULO, DATA_HORA))
                                     END                    AS DIAS_ENTRE_AFERICOES
                          FROM AFERICAO A
                                   JOIN VEICULO V ON V.PLACA = A.PLACA_VEICULO
                                   JOIN PNEU_RESTRICAO_UNIDADE R ON R.COD_UNIDADE = V.COD_UNIDADE
                          WHERE V.COD_UNIDADE::TEXT LIKE ANY (f_cod_unidade)
                            AND (A.DATA_HORA AT TIME ZONE tz_unidade(A.COD_UNIDADE))::DATE >= (f_data_inicial)
                            AND (A.DATA_HORA AT TIME ZONE tz_unidade(A.COD_UNIDADE))::DATE <= (f_data_final)
                            AND (A.TIPO_MEDICAO_COLETADA = 'PRESSAO' OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO')
                            AND A.TIPO_PROCESSO_COLETA = 'PLACA'
                          ORDER BY 1, 2) AS CALCULO_AFERICAO_PRESSAO
                    GROUP BY CALCULO_AFERICAO_PRESSAO.PLACA) AS CALCULO_PRESSAO
                   ON CALCULO_PRESSAO.PLACA = V.PLACA
         LEFT JOIN (SELECT CALCULO_AFERICAO_SULCO.PLACA,
                           COUNT(CALCULO_AFERICAO_SULCO.PLACA)                                                    AS QTD_AFERICOES,
                           CASE
                               WHEN
                                   MAX(CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                   THEN MAX(CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES)::TEXT
                               ELSE '-' END                                                                       AS MAX_DIAS_ENTRE_AFERICOES,
                           CASE
                               WHEN
                                   MIN(CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                   THEN MIN(CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES)::TEXT
                               ELSE '-' END                                                                       AS MIN_DIAS_ENTRE_AFERICOES,
                           CASE
                               WHEN
                                   MAX(CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                   THEN TRUNC(
                                       CASE
                                           WHEN SUM(CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES) IS NOT NULL
                                               THEN
                                                   SUM(CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES) /
                                                   SUM(CASE
                                                           WHEN CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES IS NOT NULL
                                                               THEN 1
                                                           ELSE 0 END)
                                           END) :: TEXT
                               ELSE '-' END                                                                       AS MD_DIAS_ENTRE_AFERICOES,
                           SUM(CASE
                                   WHEN CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES <=
                                        CALCULO_AFERICAO_SULCO.PERIODO_AFERICAO
                                       THEN 1
                                   ELSE 0 END)                                                                    AS QTD_AFERICOES_DENTRO_META,
                           TRUNC(SUM(CASE
                                         WHEN CALCULO_AFERICAO_SULCO.DIAS_ENTRE_AFERICOES <=
                                              CALCULO_AFERICAO_SULCO.PERIODO_AFERICAO
                                             THEN 1
                                         ELSE 0 END) / COUNT(CALCULO_AFERICAO_SULCO.PLACA)::NUMERIC * 100) ||
                           '%'                                                                                    AS ADERENCIA
                    FROM (SELECT A.PLACA_VEICULO            AS PLACA,
                                 A.DATA_HORA,
                                 A.TIPO_MEDICAO_COLETADA,
                                 R.PERIODO_AFERICAO_PRESSAO AS PERIODO_AFERICAO,
                                 CASE
                                     WHEN A.PLACA_VEICULO = LAG(A.PLACA_VEICULO) OVER (ORDER BY PLACA_VEICULO, DATA_HORA)
                                         THEN EXTRACT(DAYS FROM A.DATA_HORA -
                                                                LAG(A.DATA_HORA) OVER (ORDER BY PLACA_VEICULO, DATA_HORA))
                                     ELSE 0
                                     END                    AS DIAS_ENTRE_AFERICOES
                          FROM AFERICAO A
                                   JOIN VEICULO V ON V.PLACA = A.PLACA_VEICULO
                                   JOIN PNEU_RESTRICAO_UNIDADE R ON R.COD_UNIDADE = V.COD_UNIDADE
                          WHERE V.COD_UNIDADE::TEXT LIKE ANY (f_cod_unidade)
                            AND (A.DATA_HORA AT TIME ZONE tz_unidade(A.COD_UNIDADE))::DATE >= (f_data_inicial)
                            AND (A.DATA_HORA AT TIME ZONE tz_unidade(A.COD_UNIDADE))::DATE <= (f_data_final)
                            AND (A.TIPO_MEDICAO_COLETADA = 'SULCO' OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO')
                            AND A.TIPO_PROCESSO_COLETA = 'PLACA'
                          ORDER BY 1, 2) AS CALCULO_AFERICAO_SULCO
                    GROUP BY CALCULO_AFERICAO_SULCO.PLACA) AS CALCULO_SULCO
                   ON CALCULO_SULCO.PLACA = V.PLACA
WHERE V.COD_UNIDADE::TEXT LIKE ANY (F_COD_UNIDADE)
  AND V.STATUS_ATIVO IS TRUE
ORDER BY U.NOME, V.PLACA;
$$;

create or replace function public.func_relatorio_pneu_afericoes_avulsas_by_colaborador(f_cod_unidade bigint,
                                                                                       f_cod_colaborador bigint,
                                                                                       f_data_inicial date,
                                                                                       f_data_final date)
    returns TABLE
            (
                "DATA/HORA AFERIÇÃO"    text,
                "QUEM AFERIU?"          character varying,
                "UNIDADE ALOCADO"       character varying,
                "PNEU"                  character varying,
                "MARCA"                 character varying,
                "MODELO"                character varying,
                "MEDIDAS"               text,
                "SULCO INTERNO"         text,
                "SULCO CENTRAL INTERNO" text,
                "SULCO CENTRAL EXTERNO" text,
                "SULCO EXTERNO"         text,
                "VIDA"                  text,
                "DOT"                   character varying
            )
    language plpgsql
as
$$
DECLARE
    DATE_FORMAT                   TEXT := 'DD/MM/YYYY HH24:MI';
    PNEU_NUNCA_AFERIDO            TEXT := 'Nunca Aferido';
    PROCESSO_AFERICAO_PNEU_AVULSO TEXT := 'PNEU_AVULSO';
BEGIN
    RETURN QUERY
        SELECT COALESCE(TO_CHAR(A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE), DATE_FORMAT),
                        PNEU_NUNCA_AFERIDO)                                                               AS ULTIMA_AFERICAO,
               C.NOME,
               U.NOME                                                                                     AS UNIDADE_ALOCADO,
               P.CODIGO_CLIENTE                                                                           AS COD_PNEU,
               MAP.NOME                                                                                   AS NOME_MARCA,
               MP.NOME                                                                                    AS NOME_MODELO,
               ((((DP.LARGURA || '/'::TEXT) || DP.ALTURA) || ' R'::TEXT) || DP.ARO)                       AS MEDIDAS,
               REPLACE(COALESCE(TRUNC(AV.ALTURA_SULCO_INTERNO::NUMERIC, 2)::TEXT, '-'), '.',
                       ',')                                                                               AS SULCO_INTERNO,
               REPLACE(COALESCE(TRUNC(AV.ALTURA_SULCO_CENTRAL_INTERNO::NUMERIC, 2)::TEXT, '-'), '.',
                       ',')                                                                               AS SULCO_CENTRAL_INTERNO,
               REPLACE(COALESCE(TRUNC(AV.ALTURA_SULCO_CENTRAL_EXTERNO::NUMERIC, 2)::TEXT, '-'), '.',
                       ',')                                                                               AS SULCO_CENTRAL_EXTERNO,
               REPLACE(COALESCE(TRUNC(AV.ALTURA_SULCO_EXTERNO::NUMERIC, 2)::TEXT, '-'), '.',
                       ',')                                                                               AS SULCO_EXTERNO,
               P.VIDA_ATUAL::TEXT                                                                         AS VIDA_ATUAL,
               COALESCE(P.DOT, '-')                                                                       AS DOT
        FROM PNEU P
                 JOIN DIMENSAO_PNEU DP ON DP.CODIGO = P.COD_DIMENSAO
                 JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
                 JOIN MODELO_PNEU MP ON MP.CODIGO = P.COD_MODELO AND MP.COD_EMPRESA = U.COD_EMPRESA
                 JOIN MARCA_PNEU MAP ON MAP.CODIGO = MP.COD_MARCA
                 JOIN AFERICAO_VALORES AV ON AV.COD_PNEU = P.CODIGO
                 JOIN AFERICAO A ON A.CODIGO = AV.COD_AFERICAO
                 JOIN COLABORADOR C
                      ON A.CPF_AFERIDOR = (SELECT CO.CPF FROM COLABORADOR CO WHERE CODIGO = F_COD_COLABORADOR)
        WHERE C.CODIGO = F_COD_COLABORADOR
          AND P.COD_UNIDADE = F_COD_UNIDADE
          AND A.TIPO_PROCESSO_COLETA = PROCESSO_AFERICAO_PNEU_AVULSO
          AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE))::DATE BETWEEN f_data_inicial AND f_data_final
        ORDER BY U.NOME ASC, ULTIMA_AFERICAO DESC NULLS LAST;
END;
$$;

create or replace function public.func_relatorio_pneu_previsao_troca_consolidado(f_cod_unidade text[],
                                                                                 f_status_pneu text,
                                                                                 f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE"    text,
                data         text,
                marca        text,
                modelo       text,
                medidas      text,
                "QUANTIDADE" bigint
            )
    language sql
as
$$
SELECT VAP."UNIDADE ALOCADO",
       TO_CHAR(VAP."PREVISÃO DE TROCA", 'DD/MM/YYYY') AS DATA,
       VAP."MARCA",
       VAP."MODELO",
       VAP."MEDIDAS",
       COUNT(VAP."MODELO")                            AS QUANTIDADE
FROM VIEW_ANALISE_PNEUS VAP
WHERE VAP.COD_UNIDADE::TEXT LIKE ANY (f_cod_unidade)
  AND VAP."PREVISÃO DE TROCA" BETWEEN f_data_inicial AND f_data_final
  AND VAP."STATUS PNEU" = f_status_pneu
GROUP BY VAP."UNIDADE ALOCADO", VAP."PREVISÃO DE TROCA", VAP."MARCA", VAP."MODELO", VAP."MEDIDAS"
ORDER BY VAP."UNIDADE ALOCADO", VAP."PREVISÃO DE TROCA" ASC, QUANTIDADE DESC;
$$;

create or replace function public.func_relatorio_pneus_by_faixa_sulco(f_cod_unidade text[], f_status_pneu text[])
    returns TABLE
            (
                altura_sulco_central real
            )
    language sql
as
$$
SELECT COALESCE(ALTURA_SULCO_CENTRAL_INTERNO, ALTURA_SULCO_CENTRAL_EXTERNO, -1) AS ALTURA_SULCO_CENTRAL
FROM PNEU
WHERE COD_UNIDADE::TEXT LIKE ANY (f_cod_unidade)
  AND STATUS LIKE ANY (f_status_pneu)
ORDER BY 1 DESC;
$$;

create or replace function public.func_relatorio_produtividade_remuneracao_acumulada_colaborador(f_cod_unidade bigint,
                                                                                                 f_cpf_colaborador bigint,
                                                                                                 f_data_inicial date,
                                                                                                 f_data_final date)
    returns TABLE
            (
                "CPF_COLABORADOR"  bigint,
                "NOME_COLABORADOR" text,
                "DATA"             date,
                "CAIXAS_ENTREGUES" numeric,
                "FATOR"            real,
                "VALOR"            double precision
            )
    language sql
as
$$
SELECT VPE.CPF,
       VPE.NOME_COLABORADOR,
       VPE.DATA,
       ROUND(VPE.CXENTREG::NUMERIC, 2),
       VPE.FATOR,
       VPE.VALOR
FROM VIEW_PRODUTIVIDADE_EXTRATO AS VPE
WHERE VPE.COD_UNIDADE = f_cod_unidade
  AND CASE WHEN f_cpf_colaborador IS NULL THEN TRUE ELSE VPE.CPF = f_cpf_colaborador END
  AND VPE.DATA >= f_data_inicial
  AND VPE.DATA <= f_data_final
ORDER BY VPE.CPF, VPE.DATA ASC;
$$;

comment on function public.func_relatorio_produtividade_remuneracao_acumulada_colaborador(bigint, bigint, date, date) is 'Busca a produtividade do colaborador para um período';

create or replace function public.func_relatorio_treinamento_visualizados_por_colaborador(f_data_inicial date,
                                                                                          f_data_final date,
                                                                                          f_time_zone_datas text,
                                                                                          f_cod_unidade bigint)
    returns TABLE
            (
                "CPF COLABORADOR"        text,
                "NOME COLABORADOR"       text,
                "TÍTULO TREINAMENTO"     text,
                "DESCRIÇÃO TREINAMENTO"  text,
                "DATA/HORA VISUALIZAÇÃO" text
            )
    language sql
as
$$
SELECT LPAD(tc.cpf_colaborador :: TEXT, 11, '0')                                          AS CPF,
       c.nome                                                                             AS COLABORADOR,
       t.titulo                                                                           AS TITULO_TREINAMENTO,
       t.descricao                                                                        AS DESCRICAO_TREINAMENTO,
       to_char(tc.data_visualizacao AT TIME ZONE f_time_zone_datas, 'DD/MM/YYYY HH24:MI') AS DATA_HORA_VISUALIZACAO
FROM treinamento_colaborador tc
         JOIN treinamento t ON tc.cod_treinamento = t.codigo
         JOIN colaborador c ON tc.cpf_colaborador = c.cpf
WHERE T.cod_unidade = f_cod_unidade
  AND (tc.data_visualizacao AT TIME ZONE f_time_zone_datas):: DATE >= f_data_inicial
  AND (tc.data_visualizacao AT TIME ZONE f_time_zone_datas):: DATE <= f_data_final
ORDER BY c.nome;
$$;

create or replace function public.func_test_1(f_cod_unidade bigint, f_data_inicial date, f_data_final date, f_cpf text)
    returns TABLE
            (
                "NOME"                                         text,
                "CARGO"                                        text,
                "SETOR"                                        text,
                "INTERVALO"                                    text,
                "INICIO INTERVALO"                             text,
                "LATITUDE INÍCIO"                              text,
                "LONGITUDE INÍCIO"                             text,
                "FIM INTERVALO"                                text,
                "LATITUDE FIM"                                 text,
                "LONGITUDE FIM"                                text,
                "TEMPO DECORRIDO (MINUTOS)"                    text,
                "TEMPO RECOMENDADO (MINUTOS)"                  bigint,
                "CUMPRIU TEMPO MÍNIMO"                         text,
                "JUSTIFICATIVA NÃO CUMPRIMENTO TEMPO MÍNIMO"   text,
                "JUSTIFICATIVA ESTOURO TEMPO MÁXIMO PERMITIDO" text,
                "DISTANCIA ENTRE INÍCIO E FIM"                 text
            )
    language sql
as
$$
SELECT C.NOME                                                                                                      AS NOME_COLABORADOR,
       F.NOME                                                                                                      AS CARGO,
       S.nome                                                                                                      AS SETOR,
       IT.NOME                                                                                                     AS INTERVALO,
       COALESCE(TO_CHAR(I.DATA_HORA_INICIO AT TIME ZONE (SELECT TIMEZONE
                                                         FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE)),
                        'DD/MM/YYYY HH24:mi:ss'),
                '')                                                                                                AS DATA_HORA_INICIO,

       I.latitude_marcacao_inicio::TEXT                                                                            as latitude_inicio,
       I.longitude_marcacao_inicio::TEXT                                                                           as longitude_inicio,


       COALESCE(TO_CHAR(I.DATA_HORA_FIM AT TIME ZONE (SELECT TIMEZONE
                                                      FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE)),
                        'DD/MM/YYYY HH24:mi:ss'),
                '')                                                                                                AS DATA_HORA_FIM,

       I.latitude_marcacao_fim::TEXT                                                                               as latitude_fim,
       I.longitude_marcacao_fim::TEXT                                                                              as longitude_fim,


       COALESCE(TRUNC(EXTRACT(EPOCH FROM I.DATA_HORA_FIM - I.DATA_HORA_INICIO) / 60) :: TEXT,
                '')                                                                                                AS TEMPO_DECORRIDO_MINUTOS,
       IT.TEMPO_RECOMENDADO_MINUTOS,
       CASE
           WHEN I.DATA_HORA_FIM IS NULL OR I.data_hora_inicio IS NULL
               THEN ''
           WHEN IT.TEMPO_RECOMENDADO_MINUTOS > (EXTRACT(EPOCH FROM I.DATA_HORA_FIM - I.DATA_HORA_INICIO) / 60)
               THEN
               'NÃO'
           ELSE 'SIM' END                                                                                          AS CUMPRIU_TEMPO_MINIMO,
       I.justificativa_tempo_recomendado,
       I.justificativa_estouro,

       coalesce(trunc((ST_Distance(
               ST_Point(i.longitude_marcacao_inicio::float, i.latitude_marcacao_inicio::float)::geography,
               ST_Point(i.longitude_marcacao_fim::float, i.latitude_marcacao_fim::float)::geography)))::TEXT,
                '-')                                                                                               as distancia
FROM FUNC_INTERVALOS_AGRUPADOS(f_cod_unidade, CASE
                                                  WHEN f_cpf = '%'
                                                      THEN NULL
                                                  ELSE f_cpf :: BIGINT END, NULL) I
         JOIN COLABORADOR C ON C.CPF = I.CPF_COLABORADOR
         JOIN INTERVALO_TIPO IT ON IT.COD_UNIDADE = I.COD_UNIDADE AND IT.CODIGO = I.COD_TIPO_INTERVALO
         JOIN UNIDADE U ON U.CODIGO = C.COD_UNIDADE AND C.cod_empresa = U.cod_empresa
         JOIN FUNCAO F ON F.cod_empresa = U.cod_empresa AND F.CODIGO = C.cod_funcao
         JOIN SETOR S ON S.cod_unidade = C.cod_unidade AND S.codigo = C.cod_setor
WHERE ((i.DATA_HORA_INICIO AT TIME ZONE (SELECT TIMEZONE
                                         FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE))) :: DATE
           BETWEEN (f_data_inicial AT TIME ZONE (SELECT TIMEZONE
                                                 FROM func_get_time_zone_unidade(f_cod_unidade)))
           AND (f_data_final AT TIME ZONE (SELECT TIMEZONE
                                           FROM func_get_time_zone_unidade(f_cod_unidade)))
    OR (i.DATA_HORA_FIM AT TIME ZONE (SELECT TIMEZONE
                                      FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE))) :: DATE
           BETWEEN (f_data_inicial AT TIME ZONE (SELECT TIMEZONE
                                                 FROM func_get_time_zone_unidade(f_cod_unidade)))
           AND (f_data_final AT TIME ZONE (SELECT TIMEZONE
                                           FROM func_get_time_zone_unidade(f_cod_unidade))))
ORDER BY I.DATA_HORA_INICIO, C.NOME
$$;

create or replace function public.func_veiculo_get_cod_pneus_aplicados(f_cod_veiculo bigint)
    returns TABLE
            (
                cod_pneu bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT VP.COD_PNEU AS COD_PNEU
        FROM VEICULO_PNEU VP
        WHERE VP.PLACA = (SELECT V.PLACA
                          FROM VEICULO V
                          WHERE V.CODIGO = F_COD_VEICULO);
END;
$$;

create or replace function public.func_veiculo_get_marcas_modelos_empresa(f_cod_empresa bigint)
    returns TABLE
            (
                cod_marca   bigint,
                nome_marca  text,
                cod_modelo  bigint,
                nome_modelo text
            )
    language sql
as
$$
SELECT MAV.CODIGO AS COD_MARCA,
       MAV.NOME   AS NOME_MARCA,
       MOV.CODIGO AS COD_MODELO,
       MOV.NOME   AS NOME_MODELO
FROM MARCA_VEICULO MAV
         LEFT JOIN MODELO_VEICULO MOV
                   ON MAV.CODIGO = MOV.COD_MARCA AND MOV.COD_EMPRESA = F_COD_EMPRESA
ORDER BY MAV.CODIGO ASC, MOV.CODIGO ASC;
$$;

comment on function public.func_veiculo_get_marcas_modelos_empresa(bigint) is 'Retorna as marcas e modelos de veículos de uma empresa. Caso a empresa não tenha modelos para uma marca qualquer, essa marca ainda será retornada.';

create or replace function public.func_veiculo_get_marcas_nivel_prolog()
    returns TABLE
            (
                cod_marca  bigint,
                nome_marca text
            )
    language sql
as
$$
SELECT MV.CODIGO AS COD_MARCA,
       MV.NOME   AS NOME_MARCA
FROM MARCA_VEICULO MV
ORDER BY MV.NOME ASC;
$$;

comment on function public.func_veiculo_get_marcas_nivel_prolog() is 'As marcas de veículo são a nível ProLog. Essa function retorna todas as marcas disponíveis no BD.';

create or replace function public.func_veiculo_get_veiculos_diagramas(f_cod_veiculos bigint[],
                                                                      f_filtro_veiculo_possui_diagrama boolean DEFAULT NULL::boolean)
    returns TABLE
            (
                cod_veiculo       bigint,
                placa_veiculo     text,
                cod_tipo_veiculo  bigint,
                nome_tipo_veiculo text,
                possui_diagama    boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH DADOS_VEICULOS AS (
            SELECT V.CODIGO                                   AS COD_VEICULO,
                   V.PLACA :: TEXT                            AS PLACA_VEICULO,
                   VT.CODIGO                                  AS COD_TIPO_VEICULO,
                   VT.NOME :: TEXT                            AS NOME_TIPO_VEICULO,
                   F_IF(VT.COD_DIAGRAMA IS NULL, FALSE, TRUE) AS POSSUI_DIAGAMA
            FROM VEICULO V
                     JOIN VEICULO_TIPO VT
                          ON V.COD_TIPO = VT.CODIGO
            WHERE V.CODIGO = ANY (F_COD_VEICULOS)
        )

        SELECT DV.COD_VEICULO       AS COD_VEICULO,
               DV.PLACA_VEICULO     AS PLACA_VEICULO,
               DV.COD_TIPO_VEICULO  AS COD_TIPO_VEICULO,
               DV.NOME_TIPO_VEICULO AS NOME_TIPO_VEICULO,
               DV.POSSUI_DIAGAMA    AS POSSUI_DIAGRAMA
        FROM DADOS_VEICULOS DV
        WHERE F_IF(F_FILTRO_VEICULO_POSSUI_DIAGRAMA IS NULL, TRUE,
                   F_FILTRO_VEICULO_POSSUI_DIAGRAMA = DV.POSSUI_DIAGAMA);
END;
$$;

create or replace function public.func_veiculo_transferencia_deleta_itens_os_veiculo(f_cod_veiculo bigint,
                                                                                     f_cod_transferencia_veiculo_informacoes bigint,
                                                                                     f_data_hora_realizacao_transferencia timestamp with time zone) returns void
    language plpgsql
as
$$
DECLARE
    QTD_INSERTS            BIGINT;
    QTD_UPDATES            BIGINT;
    F_STATUS_OS_ABERTA     TEXT := 'A';
    F_STATUS_OS_FECHADA    TEXT := 'F';
    F_STATUS_ITEM_PENDENTE TEXT := 'P';
    F_PLACA_VEICULO        TEXT := (SELECT V.PLACA
                                    FROM VEICULO V
                                    WHERE V.CODIGO = F_COD_VEICULO);
    F_OS                   CHECKLIST_ORDEM_SERVICO%ROWTYPE;
BEGIN
    FOR F_OS IN
        SELECT COS.CODIGO_PROLOG,
               COS.CODIGO,
               COS.COD_UNIDADE,
               COS.COD_CHECKLIST
               -- Utilizamos propositalmente a view e não a tabela _DATA, para não copiar OSs deletadas e não resolvidos.
        FROM CHECKLIST_ORDEM_SERVICO COS
                 JOIN CHECKLIST C ON C.CODIGO = COS.cod_checklist
        WHERE COS.STATUS = F_STATUS_OS_ABERTA
          AND C.PLACA_VEICULO = F_PLACA_VEICULO
        LOOP
            -- Copia os itens da OS.
            INSERT INTO CHECKLIST_ORDEM_SERVICO_ITEM_DELETADO_TRANSFERENCIA (
                COD_ITEM_OS_PROLOG)
            SELECT COSI.CODIGO
                   -- Utilizamos propositalmente a view e não a tabela _DATA, para não copiar itens já deletados e
                   -- não resolvidos.
            FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
            WHERE COSI.COD_OS = F_OS.CODIGO
              AND COSI.COD_UNIDADE = F_OS.COD_UNIDADE
              AND COSI.STATUS_RESOLUCAO = F_STATUS_ITEM_PENDENTE;

            GET DIAGNOSTICS QTD_INSERTS = ROW_COUNT;

            -- Deleta os itens da OS.
            UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
            SET DELETADO            = TRUE,
                PG_USERNAME_DELECAO = SESSION_USER,
                DATA_HORA_DELETADO  = F_DATA_HORA_REALIZACAO_TRANSFERENCIA
            WHERE COD_OS = F_OS.CODIGO
              AND COD_UNIDADE = F_OS.COD_UNIDADE
              AND STATUS_RESOLUCAO = F_STATUS_ITEM_PENDENTE
              AND DELETADO = FALSE;

            GET DIAGNOSTICS QTD_UPDATES = ROW_COUNT;

            IF QTD_INSERTS <> QTD_UPDATES
            THEN
                RAISE EXCEPTION
                    'Erro ao deletar os itens de O.S. de checklist na transferência de veículos. Rollback necessário!
                    __INSERTS: % UPDATES: %__', QTD_INSERTS, QTD_UPDATES;
            END IF;

            IF ((SELECT COUNT(COSI.CODIGO)
                 FROM CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSI
                 WHERE COSI.COD_OS = F_OS.CODIGO
                   AND COSI.COD_UNIDADE = F_OS.COD_UNIDADE
                   AND COSI.DELETADO = FALSE) > 0)
            THEN
                -- Se entrou aqui siginifca que a OS não tem mais itens em aberto, ela possuia alguns fechados e
                -- outros em aberto
                -- mas nós acabamos de deletar os que estavam em aberto.
                -- Por isso, precisamos fechar essa OS.
                UPDATE
                    CHECKLIST_ORDEM_SERVICO_DATA
                SET STATUS               = F_STATUS_OS_FECHADA,
                    PG_USERNAME_DELECAO  = SESSION_USER,
                    DATA_HORA_FECHAMENTO = (SELECT MAX(COSI.DATA_HORA_CONSERTO)
                                            FROM CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSI
                                            WHERE COSI.COD_OS = F_OS.CODIGO
                                              AND COSI.COD_UNIDADE = F_OS.COD_UNIDADE
                                              AND COSI.DELETADO = FALSE)
                WHERE CODIGO_PROLOG = F_OS.CODIGO_PROLOG
                  AND CODIGO = F_OS.CODIGO
                  AND COD_UNIDADE = F_OS.COD_UNIDADE
                  AND COD_CHECKLIST = F_OS.COD_CHECKLIST
                  AND DELETADO = FALSE;
            ELSE
                -- Se entrou aqui siginifica que nós deletamos todos os itens da OS.
                -- Por isso, precisamos copiar a OS para a tabela de vínculo como deletada por transferência e
                -- depois deletá-la.

                -- Copia a OS.
                INSERT INTO CHECKLIST_ORDEM_SERVICO_DELETADA_TRANSFERENCIA (COD_OS_PROLOG,
                                                                            COD_VEICULO_TRANSFERENCIA_INFORMACOES)
                SELECT F_OS.CODIGO_PROLOG,
                       F_COD_TRANSFERENCIA_VEICULO_INFORMACOES;

                GET DIAGNOSTICS QTD_INSERTS = ROW_COUNT;

                -- Deleta a OS copiada.
                UPDATE CHECKLIST_ORDEM_SERVICO_DATA
                SET DELETADO            = TRUE,
                    PG_USERNAME_DELECAO = SESSION_USER,
                    DATA_HORA_DELETADO  = F_DATA_HORA_REALIZACAO_TRANSFERENCIA
                WHERE CODIGO_PROLOG = F_OS.CODIGO_PROLOG
                  AND CODIGO = F_OS.CODIGO
                  AND COD_UNIDADE = F_OS.COD_UNIDADE
                  AND COD_CHECKLIST = F_OS.COD_CHECKLIST
                  AND DELETADO = FALSE;

                GET DIAGNOSTICS QTD_UPDATES = ROW_COUNT;

                IF QTD_INSERTS <> QTD_UPDATES
                THEN
                    RAISE EXCEPTION
                        'Erro ao deletar as OSs de checklist na transferência de veículos. Rollback necessário!
                        __INSERTS: % UPDATES: %__', QTD_INSERTS, QTD_UPDATES;
                END IF;
            END IF;
        END LOOP;
END;
$$;

create or replace function public.func_veiculo_transferencia_deleta_servicos_pneu(f_cod_veiculo bigint,
                                                                                  f_cod_pneu bigint,
                                                                                  f_cod_transferencia_veiculo_informacoes bigint,
                                                                                  f_data_hora_realizacao_transferencia timestamp with time zone) returns void
    language plpgsql
as
$$
DECLARE
    QTD_INSERTS     BIGINT;
    QTD_UPDATES     BIGINT;
    F_PLACA_VEICULO TEXT := (SELECT V.PLACA
                             FROM VEICULO V
                             WHERE V.CODIGO = F_COD_VEICULO);
BEGIN
    INSERT INTO AFERICAO_MANUTENCAO_SERVICO_DELETADO_TRANSFERENCIA (COD_SERVICO,
                                                                    COD_VEICULO_TRANSFERENCIA_INFORMACOES)
    SELECT AM.CODIGO,
           F_COD_TRANSFERENCIA_VEICULO_INFORMACOES
           -- Utilizamos propositalmente a view e não a tabela _DATA, para não copiar serviços deletados e não fechados.
    FROM AFERICAO_MANUTENCAO AM
             JOIN AFERICAO A ON A.CODIGO = AM.COD_AFERICAO
    WHERE A.PLACA_VEICULO = F_PLACA_VEICULO
      AND AM.COD_PNEU = F_COD_PNEU
      AND AM.DATA_HORA_RESOLUCAO IS NULL
      AND (AM.FECHADO_AUTOMATICAMENTE_MOVIMENTACAO = FALSE OR AM.FECHADO_AUTOMATICAMENTE_MOVIMENTACAO IS NULL);

    GET DIAGNOSTICS QTD_INSERTS = ROW_COUNT;

    UPDATE AFERICAO_MANUTENCAO_DATA
    SET DELETADO            = TRUE,
        PG_USERNAME_DELECAO = SESSION_USER,
        DATA_HORA_DELETADO  = F_DATA_HORA_REALIZACAO_TRANSFERENCIA
    WHERE COD_PNEU = F_COD_PNEU
      AND DELETADO = FALSE
      AND DATA_HORA_RESOLUCAO IS NULL
      AND (FECHADO_AUTOMATICAMENTE_MOVIMENTACAO = FALSE OR FECHADO_AUTOMATICAMENTE_MOVIMENTACAO IS NULL);

    GET DIAGNOSTICS QTD_UPDATES = ROW_COUNT;

    -- O SELECT do INSERT e o UPDATE são propositalmente diferentes nas condições do WHERE. No INSERT fazemos o JOIN
    -- com AFERICAO para buscar apenas os serviços em aberto do pneu no veículo em que ele está sendo transferido.
    -- Isso é importante, pois como fazemos o vínculo com a transferência do veículo, não podemos vincular que o veículo
    -- fechou serviços em aberto do veículo B. Ainda que seja o mesmo pneu em jogo.
    -- Em teoria, não deveriam existir serviços em aberto em outra placa que não a atual em que o pneu está aplicado.
    -- Porém, podemos ter uma inconsistência no BD.
    -- Utilizando essas condições diferentes no WHERE do INSERT e UPDATE, nós garantimos que o ROW_COUNT será diferente
    -- em ambos e vamos lançar uma exception, mapeando esse problema para termos visibilidade.
    IF QTD_INSERTS <> QTD_UPDATES
    THEN
        RAISE EXCEPTION 'Erro ao deletar os serviços de pneus na transferência de veículos. Rollback necessário!';
    END IF;
END;
$$;

create or replace function public.func_veiculo_transferencia_detalhes_placa_transferida(f_cod_processo_transferencia bigint, f_cod_veiculo bigint)
    returns TABLE
            (
                placa_veiculo                           text,
                cod_diagrama_veiculo                    bigint,
                nome_tipo_veiculo_momento_transferencia text,
                cod_pneu                                bigint,
                codigo_cliente                          text,
                altura_sulco_externo                    real,
                altura_sulco_central_externo            real,
                altura_sulco_central_interno            real,
                altura_sulco_interno                    real,
                pressao_pneu                            real,
                vida_momento_transferencia              integer,
                posicao_pneu_transferencia              integer
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT V.PLACA::TEXT                    AS PLACA_VEICULO,
               VTI.COD_DIAGRAMA_VEICULO         AS COD_DIAGRAMA_VEICULO,
               VT.NOME::TEXT                    AS NOME_TIPO_VEICULO_MOMENTO_TRANSFERENCIA,
               PTI.COD_PNEU                     AS COD_PNEU,
               P.CODIGO_CLIENTE::TEXT           AS CODIGO_CLIENTE,
               PTI.ALTURA_SULCO_EXTERNO         AS ALTURA_SULCO_EXTERNO,
               PTI.ALTURA_SULCO_CENTRAL_EXTERNO AS ALTURA_SULCO_CENTRAL_EXTERNO,
               PTI.ALTURA_SULCO_CENTRAL_INTERNO AS ALTURA_SULCO_CENTRAL_INTERNO,
               PTI.ALTURA_SULCO_INTERNO         AS ALTURA_SULCO_INTERNO,
               PTI.PSI                          AS PRESSAO_PNEU,
               PTI.VIDA_MOMENTO_TRANSFERENCIA   AS VIDA_MOMENTO_TRANSFERENCIA,
               PTI.POSICAO_PNEU_TRANSFERENCIA   AS POSICAO_PNEU_TRANSFERENCIA
        FROM VEICULO_TRANSFERENCIA_PROCESSO VTP
                 JOIN VEICULO_TRANSFERENCIA_INFORMACOES VTI ON VTP.CODIGO = VTI.COD_PROCESSO_TRANSFERENCIA
                 JOIN VEICULO V ON VTI.COD_VEICULO = V.CODIGO
                 JOIN VEICULO_TIPO VT ON V.COD_TIPO = VT.CODIGO
                 LEFT JOIN VEICULO_TRANSFERENCIA_VINCULO_PROCESSO_PNEU VTVPP
                           ON VTI.CODIGO = VTVPP.COD_VEICULO_TRANSFERENCIA_INFORMACOES
                 LEFT JOIN PNEU_TRANSFERENCIA_PROCESSO PTP ON VTVPP.COD_PROCESSO_TRANSFERENCIA_PNEU = PTP.CODIGO
                 LEFT JOIN PNEU_TRANSFERENCIA_INFORMACOES PTI ON PTP.CODIGO = PTI.COD_PROCESSO_TRANSFERENCIA
                 LEFT JOIN PNEU P ON PTI.COD_PNEU = P.CODIGO
        WHERE VTP.CODIGO = F_COD_PROCESSO_TRANSFERENCIA
          AND VTI.COD_VEICULO = F_COD_VEICULO;
END;
$$;

create or replace function public.func_veiculo_transferencia_listagem_processos(f_cod_unidades_origem bigint[],
                                                                                f_cod_unidades_destino bigint[],
                                                                                f_data_inicial date, f_data_final date)
    returns TABLE
            (
                cod_processo_tranferencia bigint,
                nome_colaborador          text,
                data_hora_realizacao      timestamp without time zone,
                nome_unidade_origem       text,
                nome_regional_origem      text,
                nome_unidade_destino      text,
                nome_regional_destino     text,
                observacao                text,
                placa_transferida         text,
                qtd_placas_transferidas   bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT VTP.CODIGO                                               AS COD_PROCESSO_TRANFERENCIA,
               C.NOME :: TEXT                                           AS NOME_COLABORADOR,
               VTP.DATA_HORA_TRANSFERENCIA_PROCESSO
                   AT TIME ZONE TZ_UNIDADE(VTP.COD_UNIDADE_COLABORADOR) AS DATA_HORA_REALIZACAO,
               UO.NOME :: TEXT                                          AS NOME_UNIDADE_ORIGEM,
               RO.REGIAO :: TEXT                                        AS NOME_REGIONAL_ORIGEM,
               UD.NOME :: TEXT                                          AS NOME_UNIDADE_DESTINO,
               RD.REGIAO :: TEXT                                        AS NOME_REGIONAL_DESTINO,
               VTP.OBSERVACAO                                           AS OBSERVACAO,
               V.PLACA :: TEXT                                          AS PLACA_TRANSFERIDA,
               COUNT(VTI.COD_VEICULO)
               OVER (
                   PARTITION BY VTP.CODIGO )                            AS QTD_PLACAS_TRANSFERIDAS
        FROM VEICULO_TRANSFERENCIA_PROCESSO VTP
                 JOIN VEICULO_TRANSFERENCIA_INFORMACOES VTI ON VTP.CODIGO = VTI.COD_PROCESSO_TRANSFERENCIA
                 JOIN VEICULO V ON VTI.COD_VEICULO = V.CODIGO
                 JOIN COLABORADOR C ON VTP.COD_COLABORADOR_REALIZACAO = C.CODIGO
                 JOIN UNIDADE UO ON VTP.COD_UNIDADE_ORIGEM = UO.CODIGO
                 JOIN REGIONAL RO ON UO.COD_REGIONAL = RO.CODIGO
                 JOIN UNIDADE UD ON VTP.COD_UNIDADE_DESTINO = UD.CODIGO
                 JOIN REGIONAL RD ON UD.COD_REGIONAL = RD.CODIGO
        WHERE VTP.COD_UNIDADE_ORIGEM = ANY (F_COD_UNIDADES_ORIGEM)
          AND VTP.COD_UNIDADE_DESTINO = ANY (F_COD_UNIDADES_DESTINO)
          AND (VTP.DATA_HORA_TRANSFERENCIA_PROCESSO
            AT TIME ZONE TZ_UNIDADE(VTP.COD_UNIDADE_COLABORADOR))::DATE >= F_DATA_INICIAL
          AND (VTP.DATA_HORA_TRANSFERENCIA_PROCESSO
            AT TIME ZONE TZ_UNIDADE(VTP.COD_UNIDADE_COLABORADOR))::DATE <= F_DATA_FINAL
        ORDER BY VTP.DATA_HORA_TRANSFERENCIA_PROCESSO DESC;
END;
$$;

create or replace function public.func_veiculo_transferencia_veiculos_selecao(f_cod_unidade_origem bigint)
    returns TABLE
            (
                cod_veiculo                 bigint,
                placa_veiculo               text,
                km_atual_veiculo            bigint,
                qtd_pneus_aplicados_veiculo bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT V.CODIGO                               AS COD_VEICULO,
               V.PLACA :: TEXT                        AS PLACA_VEICULO,
               V.KM                                   AS KM_ATUAL_VEICULO,
               COUNT(*)
                   -- Com esse filter veículos sem pneu retornam 0 na quantidade e não 1.
               FILTER (WHERE VP.COD_PNEU IS NOT NULL) AS QTD_PNEUS_APLICADOS_VEICULO
        FROM VEICULO V
                 LEFT JOIN VEICULO_PNEU VP
                           ON VP.PLACA = V.PLACA AND VP.COD_UNIDADE = V.COD_UNIDADE
        WHERE V.COD_UNIDADE = F_COD_UNIDADE_ORIGEM
        GROUP BY V.CODIGO, V.PLACA, V.KM;
END;
$$;

create or replace function public.func_veiculo_transferencia_visualizacao_processo(f_cod_processo_transferencia bigint)
    returns TABLE
            (
                cod_processo_tranferencia               bigint,
                nome_colaborador                        text,
                data_hora_realizacao                    timestamp without time zone,
                nome_unidade_origem                     text,
                nome_regional_origem                    text,
                nome_unidade_destino                    text,
                nome_regional_destino                   text,
                observacao                              text,
                cod_veiculo_transferido                 bigint,
                placa_transferida                       text,
                nome_tipo_veiculo_momento_transferencia text,
                km_veiculo_momento_transferencia        bigint,
                cod_pneu_tranferido                     bigint,
                cod_cliente_pneu_transferido            text,
                qtd_placas_transferidas                 bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH COUNT_PROCESSOS AS (
            SELECT VTI.COD_PROCESSO_TRANSFERENCIA        AS COD_PROCESSO_TRANSFERENCIA,
                   COUNT(VTI.COD_PROCESSO_TRANSFERENCIA) AS QTD_PLACAS_TRANSFERIDAS
            FROM VEICULO_TRANSFERENCIA_INFORMACOES VTI
                     JOIN VEICULO_TRANSFERENCIA_PROCESSO VTP ON VTI.COD_PROCESSO_TRANSFERENCIA = VTP.CODIGO
            WHERE VTP.CODIGO = F_COD_PROCESSO_TRANSFERENCIA
            GROUP BY VTI.COD_PROCESSO_TRANSFERENCIA
        )

        SELECT VTP.CODIGO                                               AS COD_PROCESSO_TRANFERENCIA,
               C.NOME :: TEXT                                           AS NOME_COLABORADOR,
               VTP.DATA_HORA_TRANSFERENCIA_PROCESSO
                   AT TIME ZONE TZ_UNIDADE(VTP.COD_UNIDADE_COLABORADOR) AS DATA_HORA_REALIZACAO,
               UO.NOME :: TEXT                                          AS NOME_UNIDADE_ORIGEM,
               RO.REGIAO :: TEXT                                        AS NOME_REGIONAL_ORIGEM,
               UD.NOME :: TEXT                                          AS NOME_UNIDADE_DESTINO,
               RD.REGIAO :: TEXT                                        AS NOME_REGIONAL_DESTINO,
               VTP.OBSERVACAO                                           AS OBSERVACAO,
               VTI.COD_VEICULO                                          AS COD_VEICULO_TRANSFERIDO,
               V.PLACA :: TEXT                                          AS PLACA_TRANSFERIDA,
               VT.NOME :: TEXT                                          AS NOME_TIPO_VEICULO_MOMENTO_TRANSFERENCIA,
               VTI.KM_VEICULO_MOMENTO_TRANSFERENCIA                     AS KM_VEICULO_MOMENTO_TRANSFERENCIA,
               P.CODIGO                                                 AS COD_PNEU_TRANFERIDO,
               P.CODIGO_CLIENTE :: TEXT                                 AS COD_CLIENTE_PNEU_TRANSFERIDO,
               CP.QTD_PLACAS_TRANSFERIDAS                               AS QTD_PLACAS_TRANSFERIDAS
        FROM VEICULO_TRANSFERENCIA_PROCESSO VTP
                 JOIN VEICULO_TRANSFERENCIA_INFORMACOES VTI ON VTP.CODIGO = VTI.COD_PROCESSO_TRANSFERENCIA
                 JOIN VEICULO V ON VTI.COD_VEICULO = V.CODIGO
                 JOIN VEICULO_TIPO VT ON VTI.COD_TIPO_VEICULO = VT.CODIGO
                 JOIN COLABORADOR C ON VTP.COD_COLABORADOR_REALIZACAO = C.CODIGO
                 JOIN UNIDADE UO ON VTP.COD_UNIDADE_ORIGEM = UO.CODIGO
                 JOIN REGIONAL RO ON UO.COD_REGIONAL = RO.CODIGO
                 JOIN UNIDADE UD ON VTP.COD_UNIDADE_DESTINO = UD.CODIGO
                 JOIN REGIONAL RD ON UD.COD_REGIONAL = RD.CODIGO
                 JOIN COUNT_PROCESSOS CP ON CP.COD_PROCESSO_TRANSFERENCIA = VTP.CODIGO
                 LEFT JOIN VEICULO_TRANSFERENCIA_VINCULO_PROCESSO_PNEU VTVPP
                           ON VTI.CODIGO = VTVPP.COD_VEICULO_TRANSFERENCIA_INFORMACOES
                 LEFT JOIN PNEU_TRANSFERENCIA_PROCESSO PTP ON VTVPP.COD_PROCESSO_TRANSFERENCIA_PNEU = PTP.CODIGO
                 LEFT JOIN PNEU_TRANSFERENCIA_INFORMACOES PTI ON PTP.CODIGO = PTI.COD_PROCESSO_TRANSFERENCIA
                 LEFT JOIN PNEU P ON PTI.COD_PNEU = P.CODIGO
        WHERE VTP.CODIGO = F_COD_PROCESSO_TRANSFERENCIA
        ORDER BY VTI.COD_VEICULO DESC, P.CODIGO ASC;
END;
$$;

create or replace function public.func_veiculo_update_tipo_veiculo(f_cod_tipo_veiculo bigint, f_nome_tipo_veiculo text,
                                                                   f_cod_diagrama_tipo_veiculo bigint) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_DIAGRAMA_ATUAL_ASSOCIADO BIGINT := (SELECT VT.COD_DIAGRAMA
                                            FROM VEICULO_TIPO VT
                                            WHERE VT.CODIGO = F_COD_TIPO_VEICULO);
    QTD_LINHAS_ATUALIZADAS       BIGINT;
BEGIN
    -- Se não tem diagrama associado, podemos setar o recebido no update.
    IF (COD_DIAGRAMA_ATUAL_ASSOCIADO IS NULL OR COD_DIAGRAMA_ATUAL_ASSOCIADO <= 0)
    THEN
        UPDATE VEICULO_TIPO
        SET NOME         = F_NOME_TIPO_VEICULO,
            COD_DIAGRAMA = F_COD_DIAGRAMA_TIPO_VEICULO
        WHERE CODIGO = F_COD_TIPO_VEICULO;
        -- Se tem diagrama associado, e o recebido é o mesmo do já associado, atualizamos apenas o nome do tipo de veículo.
    ELSEIF (COD_DIAGRAMA_ATUAL_ASSOCIADO IS NOT NULL
        AND COD_DIAGRAMA_ATUAL_ASSOCIADO >= 0
        AND COD_DIAGRAMA_ATUAL_ASSOCIADO = F_COD_DIAGRAMA_TIPO_VEICULO)
    THEN
        UPDATE VEICULO_TIPO
        SET NOME = F_NOME_TIPO_VEICULO
        WHERE CODIGO = F_COD_TIPO_VEICULO;
        -- Se tem diagrama associado, e o recebido é DIFERENTE do já associado, lançamos um erro, atualmente não é
        -- possível alterar o diagrama pelo front end pois isso pode impactar os pneus que estão vinculados.
    ELSEIF (COD_DIAGRAMA_ATUAL_ASSOCIADO IS NOT NULL
        AND COD_DIAGRAMA_ATUAL_ASSOCIADO >= 0
        AND COD_DIAGRAMA_ATUAL_ASSOCIADO <> F_COD_DIAGRAMA_TIPO_VEICULO)
    THEN
        RAISE EXCEPTION 'Não é permitido alterar o diagrama de um tipo de veículo'
            USING ERRCODE = (SELECT SQL_ERROR_CODE
                             FROM PROLOG_SQL_ERROR_CODE
                             WHERE PROLOG_ERROR_CODE = 'GENERIC_ERROR');
    END IF;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;
    -- Verificamos se o update funcionou.
    IF QTD_LINHAS_ATUALIZADAS <= 0
    THEN
        RAISE EXCEPTION 'Erro ao atualizar o tipo de veículo';
    END IF;

    RETURN QTD_LINHAS_ATUALIZADAS;
END;
$$;

create or replace function public.func_veiculo_verifica_possui_vinculo_modelo_checklist(f_cod_veiculo bigint) returns boolean
    language sql
as
$$
SELECT EXISTS(
               SELECT V.CODIGO
               FROM VEICULO V
                        JOIN CHECKLIST_MODELO_VEICULO_TIPO CMVT
                             ON V.COD_TIPO = CMVT.COD_TIPO_VEICULO
                                 AND V.COD_UNIDADE = CMVT.COD_UNIDADE
                        JOIN CHECKLIST_MODELO CM
                             ON CMVT.COD_MODELO = CM.CODIGO
                                 AND CM.STATUS_ATIVO = TRUE
               WHERE V.CODIGO = F_COD_VEICULO) AS ESTA_VINCULADO_MODELO_CHECKLIST
$$;

create or replace function public.millis_to_minutes(t bigint) returns bigint
    language plpgsql
as
$$
BEGIN
    RETURN T / 1000 / 60;
END;
$$;

create or replace function public.prolog_tstzrange(lower_bound timestamp with time zone,
                                                   upper_bound timestamp with time zone,
                                                   error_message text DEFAULT NULL::text) returns tstzrange
    language plpgsql
as
$$
BEGIN
    IF ERROR_MESSAGE IS NOT NULL AND LOWER_BOUND > UPPER_BOUND
    THEN
        RAISE EXCEPTION '%', ERROR_MESSAGE
            USING ERRCODE =
                    (SELECT SQL_ERROR_CODE FROM PROLOG_SQL_ERROR_CODE WHERE PROLOG_ERROR_CODE = 'GENERIC_ERROR');
    END IF;

    RETURN TSTZRANGE(LOWER_BOUND, UPPER_BOUND);
END;
$$;


create or replace function public.tg_func_bloqueio() returns trigger
    language plpgsql
as
$$
BEGIN
    RAISE EXCEPTION 'A OPERAÇÃO DE % NA TABELA % ESTÁ BLOQUEADA!', TG_OP, TG_RELNAME;
END;
$$;

create trigger tg_bloqueio_insert_update_delete_checklist_respostas_antiga
    before insert or update or delete
    on migration_checklist.checklist_respostas
    for each row
execute procedure public.tg_func_bloqueio();

create trigger tg_bloqueio_delecao_token_checklist_offline
    before delete
    on public.checklist_offline_dados_unidade
    for each row
execute procedure public.tg_func_bloqueio();

create or replace function public.tg_func_checklist_bloqueia_decremento_versao_dados_offline() returns trigger
    language plpgsql
as
$$
BEGIN
    IF (NEW.VERSAO_DADOS < OLD.VERSAO_DADOS)
    THEN
        RAISE EXCEPTION 'NÃO É PERMITIDO DECREMENTAR A VERSÃO DOS DADOS DE CHECKLIST OFFLINE!'
            USING HINT = 'A VERSÃO ATUAL É ' || OLD.VERSAO_DADOS || ' E VOCÊ ESTÁ TENTANDO ALTERAR PARA ' ||
                         NEW.VERSAO_DADOS || '.';
    END IF;
    RETURN NEW;
END;
$$;

create trigger tg_bloqueia_decremento_versao_checklist_offline
    before update
    on public.checklist_offline_dados_unidade
    for each row
execute procedure public.tg_func_checklist_bloqueia_decremento_versao_dados_offline();

create or replace function public.tg_func_checklist_insere_token_unidade_checklist_offline() returns trigger
    security definer
    language plpgsql
as
$$
BEGIN
    INSERT INTO CHECKLIST_OFFLINE_DADOS_UNIDADE (COD_UNIDADE, TOKEN_SINCRONIZACAO_CHECKLIST)
    VALUES (NEW.CODIGO, F_RANDOM_STRING(64));
    RETURN NEW;
END;
$$;

create trigger tg_unidade_insere_token_checklist_offline
    after insert
    on public.unidade
    for each row
execute procedure public.tg_func_checklist_insere_token_unidade_checklist_offline();

create or replace function public.tg_func_checklist_os_gera_codigo_os() returns trigger
    language plpgsql
as
$$
BEGIN
    -- Em integrações forçamos o código. Por isso pode ser diferente de NULL.
    IF NEW.CODIGO IS NULL
    THEN
        NEW.CODIGO := (SELECT COALESCE(MAX(COS.CODIGO) + 1, 1)
                       FROM CHECKLIST_ORDEM_SERVICO_DATA COS
                       WHERE COS.COD_UNIDADE = NEW.COD_UNIDADE);
    END IF;
    RETURN NEW;
END;
$$;

create trigger tg_gera_codigo_os
    before insert
    on public.checklist_ordem_servico_data
    for each row
execute procedure public.tg_func_checklist_os_gera_codigo_os();

create or replace function public.tg_func_checklist_update_versao_dados_offline_empresa_liberada() returns trigger
    language plpgsql
as
$$
BEGIN
    UPDATE CHECKLIST_OFFLINE_DADOS_UNIDADE
    SET VERSAO_DADOS = VERSAO_DADOS + 1
    WHERE COD_UNIDADE IN (SELECT COD_UNIDADE FROM UNIDADE WHERE COD_EMPRESA = OLD.COD_EMPRESA);
    RETURN NEW;
END;
$$;

create trigger tg_update_versao_dados_checklist_offline_empresa_liberada
    after delete
    on public.checklist_offline_empresa_bloqueada
    for each row
execute procedure public.tg_func_checklist_update_versao_dados_offline_empresa_liberada();

create or replace function public.tg_func_colaborador_seta_unidade_cadastro() returns trigger
    language plpgsql
as
$$
BEGIN
    IF NEW.COD_UNIDADE_CADASTRO IS NULL
    THEN
        NEW.COD_UNIDADE_CADASTRO := NEW.COD_UNIDADE;
    ELSEIF NEW.COD_UNIDADE <> NEW.COD_UNIDADE_CADASTRO
    THEN
        RAISE EXCEPTION
            'COD_UNIDADE (%) e COD_UNIDADE_CADASTRO (%) não podem ser diferentes!',
            NEW.COD_UNIDADE,
            NEW.COD_UNIDADE_CADASTRO;
    END IF;
    RETURN NEW;
END;
$$;

create trigger tg_seta_unidade_cadastro_colaborador
    before insert
    on public.colaborador_data
    for each row
execute procedure public.tg_func_colaborador_seta_unidade_cadastro();

create or replace function public.tg_func_empresa_bloqueia_checklist_offline() returns trigger
    security definer
    language plpgsql
as
$$
BEGIN
    INSERT INTO CHECKLIST_OFFLINE_EMPRESA_BLOQUEADA (COD_EMPRESA) VALUES (NEW.CODIGO);
    RETURN NEW;
END;
$$;

create trigger tg_bloqueia_checklist_offline_empresa_nova
    after insert
    on public.empresa
    for each row
execute procedure public.tg_func_empresa_bloqueia_checklist_offline();

create or replace function public.tg_func_marcacao_jornada_editada() returns trigger
    language plpgsql
as
$$
BEGIN
    UPDATE INTERVALO
    SET FOI_AJUSTADO = TRUE
    WHERE FOI_AJUSTADO = FALSE
      AND CODIGO = NEW.COD_MARCACAO;
    RETURN NEW;
END;
$$;

create trigger marcacao_jornada_ajustada_trigger
    after insert or update
    on public.marcacao_historico
    for each row
execute procedure public.tg_func_marcacao_jornada_editada();

create or replace function public.tg_func_pneu_incrementa_vida_uma_a_uma() returns trigger
    language plpgsql
as
$$
BEGIN
    IF ((NEW.VIDA_ATUAL > OLD.VIDA_ATUAL) AND (NEW.VIDA_ATUAL != (OLD.VIDA_ATUAL + 1)))
    THEN
        RAISE EXCEPTION 'Não é possível incrementar mais de uma vida por vez do pneu!'
            USING HINT = 'A vida atual é ' || OLD.VIDA_ATUAL || ' e você está tentando inserir a vida ' ||
                         NEW.VIDA_ATUAL || '. Tente aumentar uma vida por vez.';
    END IF;
    RETURN NEW;
END;
$$;

create trigger tg_pneu_incrementa_vida_uma_a_uma
    before update
    on public.pneu_data
    for each row
execute procedure public.tg_func_pneu_incrementa_vida_uma_a_uma();

create or replace function public.tg_marcacao_verifica_observacao_justificativa() returns trigger
    language plpgsql
as
$$
DECLARE
    OBRIGA_OBSERVACAO BOOLEAN := (SELECT OBRIGA_OBSERVACAO
                                  FROM MARCACAO_JUSTIFICATIVA_AJUSTE
                                  WHERE CODIGO = NEW.COD_JUSTIFICATIVA_AJUSTE);
BEGIN
    IF OBRIGA_OBSERVACAO AND (NEW.OBSERVACAO_AJUSTE IS NULL OR LENGTH(NEW.OBSERVACAO_AJUSTE) = 0)
    THEN
        RAISE EXCEPTION 'Justificativa de código % exige observação', NEW.COD_JUSTIFICATIVA_AJUSTE;
    END IF;
    RETURN NEW;
END;
$$;

create trigger marcacao_verifica_observacao_justificativa_trigger
    after insert or update
    on public.marcacao_ajuste
    for each row
execute procedure public.tg_marcacao_verifica_observacao_justificativa();

create or replace function public.tg_temp_update() returns trigger
    language plpgsql
as
$$
BEGIN
    REFRESH MATERIALIZED view CONCURRENTLY estratificacao_os;
    RETURN NULL;
END;
$$;

create or replace function public.throw_generic_error(f_message text) returns void
    language plpgsql
as
$$
BEGIN
    RAISE EXCEPTION '%', F_MESSAGE
        USING ERRCODE = (SELECT SQL_ERROR_CODE
                         FROM PROLOG_SQL_ERROR_CODE
                         WHERE PROLOG_ERROR_CODE = 'GENERIC_ERROR');
END;
$$;

create or replace function public.trim_and_remove_extra_spaces(f_text text) returns text
    language plpgsql
as
$$
BEGIN
    -- Além do trim, se existir mais de um espaço entre duas strings, ele será reduzido a apenas um espaço.
    RETURN TRIM(REGEXP_REPLACE(F_TEXT, '\s+', ' ', 'g'));
END;
$$;

create or replace function raizen.func_raizen_produtividade_get_item_por_codigo(f_codigo bigint)
    returns TABLE
            (
                codigo                    bigint,
                cpf_motorista             bigint,
                motorista_cadastrado      boolean,
                placa                     character varying,
                placa_cadastrada          boolean,
                data_viagem               date,
                valor                     numeric,
                usina                     character varying,
                fazenda                   character varying,
                raio_km                   numeric,
                toneladas                 numeric,
                cod_colaborador_cadastro  bigint,
                cod_colaborador_alteracao bigint,
                cod_unidade               bigint
            )
    language sql
as
$$
SELECT RP.CODIGO,
       RP.CPF_MOTORISTA,
       CASE WHEN CM.NOME IS NOT NULL THEN TRUE ELSE FALSE END AS MOTORISTA_CADASTRADO,
       RP.PLACA,
       CASE WHEN V.PLACA IS NOT NULL THEN TRUE ELSE FALSE END AS PLACA_CADASTRADA,
       RP.DATA_VIAGEM,
       RP.VALOR,
       RP.USINA,
       RP.FAZENDA,
       RP.RAIO_KM,
       RP.TONELADAS,
       RP.COD_COLABORADOR_CADASTRO,
       RP.COD_COLABORADOR_ALTERACAO,
       RP.COD_UNIDADE
FROM RAIZEN.PRODUTIVIDADE RP
         LEFT JOIN COLABORADOR AS CM ON CM.CPF = RP.CPF_MOTORISTA
         LEFT JOIN VEICULO AS V ON V.PLACA = RP.PLACA
WHERE RP.CODIGO = f_codigo
$$;

create or replace function raizen.func_raizen_produtividade_get_itens_individual(f_cod_unidade bigint,
                                                                                 f_cod_colaborador bigint,
                                                                                 f_mes integer, f_ano integer)
    returns TABLE
            (
                codigo                     bigint,
                cpf_motorista              bigint,
                nome_motorista             character varying,
                placa                      character varying,
                placa_cadastrada           boolean,
                data_viagem                date,
                valor                      numeric,
                usina                      character varying,
                fazenda                    character varying,
                raio_km                    numeric,
                toneladas                  numeric,
                cod_colaborador_cadastro   bigint,
                nome_colaborador_cadastro  character varying,
                cod_colaborador_alteracao  bigint,
                nome_colaborador_alteracao character varying,
                cod_unidade                bigint
            )
    language sql
as
$$
SELECT RP.CODIGO,
       RP.CPF_MOTORISTA,
       CM.NOME                                                AS NOME_MOTORISTA,
       RP.PLACA,
       CASE WHEN V.PLACA IS NOT NULL THEN TRUE ELSE FALSE END AS PLACA_CADASTRADA,
       RP.DATA_VIAGEM,
       RP.VALOR,
       RP.USINA,
       RP.FAZENDA,
       RP.RAIO_KM,
       RP.TONELADAS,
       RP.COD_COLABORADOR_CADASTRO,
       CC.NOME                                                AS NOME_COLABORADOR_CADASTRO,
       RP.COD_COLABORADOR_ALTERACAO,
       CA.NOME                                                AS NOME_COLABORADOR_ALTERACAO,
       RP.COD_UNIDADE
FROM RAIZEN.PRODUTIVIDADE RP
         LEFT JOIN COLABORADOR AS CM ON CM.CPF = RP.CPF_MOTORISTA
         LEFT JOIN COLABORADOR AS CC ON CC.CODIGO = RP.COD_COLABORADOR_CADASTRO
         LEFT JOIN COLABORADOR AS CA ON CA.CODIGO = RP.COD_COLABORADOR_ALTERACAO
         LEFT JOIN VEICULO AS V ON V.PLACA = RP.PLACA
WHERE RP.COD_UNIDADE = f_cod_unidade
  AND CM.CODIGO = f_cod_colaborador
  AND extract(MONTH FROM RP.DATA_VIAGEM) = f_mes
  AND extract(YEAR FROM RP.DATA_VIAGEM) = f_ano
ORDER BY RP.DATA_VIAGEM ASC, RP.PLACA ASC;
$$;

create or replace function raizen.func_raizen_produtividade_get_itens_por_colaborador(f_cod_unidade bigint, f_data_inicial date, f_data_final date)
    returns TABLE
            (
                codigo                    bigint,
                cpf_motorista             bigint,
                nome_motorista            character varying,
                placa                     character varying,
                placa_cadastrada          boolean,
                data_viagem               date,
                valor                     numeric,
                usina                     character varying,
                fazenda                   character varying,
                raio_km                   numeric,
                toneladas                 numeric,
                cod_colaborador_cadastro  bigint,
                nome_cadastro             character varying,
                cod_colaborador_alteracao bigint,
                nome_alteracao            character varying,
                cod_unidade               bigint
            )
    language sql
as
$$
SELECT RP.CODIGO,
       RP.CPF_MOTORISTA,
       CM.NOME                                                AS NOME_MOTORISTA,
       RP.PLACA,
       CASE WHEN V.PLACA IS NOT NULL THEN TRUE ELSE FALSE END AS PLACA_CADASTRADA,
       RP.DATA_VIAGEM,
       RP.VALOR,
       RP.USINA,
       RP.FAZENDA,
       RP.RAIO_KM,
       RP.TONELADAS,
       RP.COD_COLABORADOR_CADASTRO,
       CC.NOME                                                AS NOME_COLABORADOR_CADSTRO,
       RP.COD_COLABORADOR_ALTERACAO,
       CA.NOME                                                AS NOME_COLABORADOR_ALTERACAO,
       RP.COD_UNIDADE
FROM RAIZEN.PRODUTIVIDADE RP
         LEFT JOIN COLABORADOR AS CM ON CM.CPF = RP.CPF_MOTORISTA
         LEFT JOIN COLABORADOR AS CC ON CC.CODIGO = RP.COD_COLABORADOR_CADASTRO
         LEFT JOIN COLABORADOR AS CA ON CA.CODIGO = RP.COD_COLABORADOR_ALTERACAO
         LEFT JOIN VEICULO AS V ON V.PLACA = RP.PLACA
WHERE RP.COD_UNIDADE = f_cod_unidade
  AND (RP.DATA_VIAGEM >= f_data_inicial AND RP.DATA_VIAGEM <= f_data_final)
ORDER BY NOME_MOTORISTA, DATA_VIAGEM;
$$;

create or replace function raizen.func_raizen_produtividade_get_itens_por_data(f_cod_unidade bigint, f_data_inicial date, f_data_final date)
    returns TABLE
            (
                codigo                     bigint,
                cpf_motorista              bigint,
                nome_motorista             character varying,
                placa                      character varying,
                placa_cadastrada           boolean,
                data_viagem                date,
                valor                      numeric,
                usina                      character varying,
                fazenda                    character varying,
                raio_km                    numeric,
                toneladas                  numeric,
                cod_colaborador_cadastro   bigint,
                nome_colaborador_cadstro   character varying,
                cod_colaborador_alteracao  bigint,
                nome_colaborador_alteracao character varying,
                cod_unidade                bigint
            )
    language sql
as
$$
SELECT RP.CODIGO,
       RP.CPF_MOTORISTA,
       CM.NOME                                                AS NOME_MOTORISTA,
       RP.PLACA,
       CASE WHEN V.PLACA IS NOT NULL THEN TRUE ELSE FALSE END AS PLACA_CADASTRADA,
       RP.DATA_VIAGEM,
       RP.VALOR,
       RP.USINA,
       RP.FAZENDA,
       RP.RAIO_KM,
       RP.TONELADAS,
       RP.COD_COLABORADOR_CADASTRO,
       CC.NOME                                                AS NOME_COLABORADOR_CADSTRO,
       RP.COD_COLABORADOR_ALTERACAO,
       CA.NOME                                                AS NOME_COLABORADOR_ALTERACAO,
       RP.COD_UNIDADE
FROM RAIZEN.PRODUTIVIDADE RP
         LEFT JOIN COLABORADOR AS CM ON CM.CPF = RP.CPF_MOTORISTA
         LEFT JOIN COLABORADOR AS CC ON CC.CODIGO = RP.COD_COLABORADOR_CADASTRO
         LEFT JOIN COLABORADOR AS CA ON CA.CODIGO = RP.COD_COLABORADOR_ALTERACAO
         LEFT JOIN VEICULO AS V ON V.PLACA = RP.PLACA
WHERE RP.COD_UNIDADE = f_cod_unidade
  AND (RP.DATA_VIAGEM >= f_data_inicial AND RP.DATA_VIAGEM <= f_data_final)
ORDER BY RP.DATA_VIAGEM;
$$;

create or replace function raizen.func_raizen_produtividade_relatorio_dados_gerais_produtividade(f_cod_unidade bigint, f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "NOME MOTORISTA" text,
                "CPF MOTORISTA"  text,
                "PLACA"          text,
                "DATA DA VIAGEM" text,
                "VALOR"          text,
                "USINA"          text,
                "FAZENDA"        text,
                "RAIO KM"        text,
                "TONELADAS"      text
            )
    language sql
as
$$
SELECT COALESCE(CM.NOME, '-')::TEXT,
       LPAD(RP.CPF_MOTORISTA::TEXT, 11, '0'),
       RP.PLACA::TEXT,
       TO_CHAR(RP.DATA_VIAGEM, 'DD/MM/YYYY'),
       RP.VALOR::TEXT,
       RP.USINA::TEXT,
       RP.FAZENDA::TEXT,
       RP.RAIO_KM::TEXT,
       RP.TONELADAS::TEXT
FROM RAIZEN.PRODUTIVIDADE RP
         LEFT JOIN COLABORADOR AS CM ON CM.CPF = RP.CPF_MOTORISTA
WHERE RP.DATA_VIAGEM >= f_data_inicial
  AND RP.DATA_VIAGEM <= f_data_final
  AND RP.COD_UNIDADE = f_cod_unidade
ORDER BY DATA_VIAGEM;
$$;

create or replace function public.func_garante_placa_cadastrada(f_placa character varying) returns void
    language plpgsql
as
$$
BEGIN
    IF NOT EXISTS(SELECT *
                  FROM VEICULO_DATA
                  WHERE PLACA = F_PLACA)
    THEN
        RAISE EXCEPTION 'A PLACA: % NÃO ESTÁ CADASTRADA', F_PLACA;
    END IF;
END;
$$;

create or replace function public.func_garante_setor_existe(f_cod_unidade bigint, f_cod_setor bigint) returns void
    language plpgsql
as
$$
BEGIN
    -- VERIFICA SE O SETOR EXISTE
    IF NOT EXISTS(SELECT S.CODIGO FROM SETOR S WHERE S.CODIGO = F_COD_SETOR AND S.COD_UNIDADE = F_COD_UNIDADE)
    THEN
        RAISE EXCEPTION 'O setor % não existe na unidade %.', F_COD_SETOR, (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE);
    END IF;
END;
$$;

create or replace function public.func_garante_empresas_distintas(f_cod_empresa_1 bigint, f_cod_empresa_2 bigint) returns void
    language plpgsql
as
$$
BEGIN
    -- Verifica se as empresas são iguais.
    IF (F_COD_EMPRESA_1 = F_COD_EMPRESA_2)
    THEN
        RAISE EXCEPTION 'As empresas são iguais';
    END IF;
END;
$$;

create or replace function public.func_garante_equipe_existe(f_cod_unidade bigint, f_cod_equipe bigint) returns void
    language plpgsql
as
$$
BEGIN
    -- VERIFICA SE A EQUIPE EXISTE
    IF NOT EXISTS(SELECT E.CODIGO FROM EQUIPE E WHERE E.CODIGO = F_COD_EQUIPE AND E.COD_UNIDADE = F_COD_UNIDADE)
    THEN
        RAISE EXCEPTION 'A equipe de código: % não existe na unidade: %.', F_COD_EQUIPE,
                (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE);
    END IF;
END;
$$;

create or replace function public.func_garante_colaborador_existe(f_cpf_colaborador bigint) returns void
    language plpgsql
as
$$
BEGIN
    -- VERIFICA SE O COLABORADOR EXISTE
    IF NOT EXISTS(SELECT C.CPF
                  FROM COLABORADOR C
                  WHERE C.CPF = F_CPF_COLABORADOR)
    THEN
        RAISE EXCEPTION 'O colaborador com CPF: % não está cadastrado.', F_CPF_COLABORADOR;
    END IF;
END;
$$;

create or replace function public.func_garante_integridade_unidade_colaborador(f_cod_unidade bigint, f_cpf_colaborador bigint) returns void
    language plpgsql
as
$$
BEGIN
    --VERIFICA SE COLABORADOR EXISTE
    PERFORM FUNC_GARANTE_COLABORADOR_EXISTE(F_CPF_COLABORADOR);

    --VERIFICA SE UNIDADE EXISTE
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    -- VERIFICA SE O COLABORADOR PERTENCE A UNIDADE.
    IF NOT EXISTS(SELECT C.CPF
                  FROM COLABORADOR C
                  WHERE C.CPF = F_CPF_COLABORADOR
                    AND C.COD_UNIDADE = F_COD_UNIDADE)
    THEN
        RAISE EXCEPTION 'O colaborador com CPF: %, nome: %, não pertence a unidade: % - %!',
            F_CPF_COLABORADOR,
                (SELECT C.NOME FROM COLABORADOR C WHERE C.CPF = F_CPF_COLABORADOR),
            F_COD_UNIDADE,
                (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE);
    END IF;
END;
$$;


create or replace function public.func_relato_copia_alternativas_relato(f_cod_unidade_origem bigint,
                                                                        f_cod_setor_origem bigint,
                                                                        f_cod_unidade_destino bigint,
                                                                        f_cod_setor_destino bigint,
                                                                        OUT aviso_alternativa_inserida text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_INSERTS BIGINT;
BEGIN
    -- VERIFICA SE O SETOR EXISTE NA UNIDADE DESTINO.
    PERFORM FUNC_GARANTE_SETOR_EXISTE(F_COD_UNIDADE_DESTINO, F_COD_SETOR_DESTINO);

    -- VERIFICA SE O SETOR EXISTE NA UNIDADE ORIGEM.
    PERFORM FUNC_GARANTE_SETOR_EXISTE(F_COD_UNIDADE_ORIGEM, F_COD_SETOR_ORIGEM);

    -- VERIFICA SE EXISTEM ALTERNATIVAS DE RELATO PARA SER COPIADO COM BASE NA UNIDADE E SETOR INFORMADOS.
    IF NOT EXISTS(SELECT RA.CODIGO
                  FROM RELATO_ALTERNATIVA RA
                  WHERE RA.COD_UNIDADE = F_COD_UNIDADE_ORIGEM
                    AND RA.COD_SETOR = F_COD_SETOR_ORIGEM)
    THEN
        RAISE EXCEPTION 'Não existem alternativas de relato para a unidade; %, setor: %!', F_COD_UNIDADE_ORIGEM,
            F_COD_SETOR_ORIGEM;
    END IF;

    -- COPIA ALTERNATIVAS DE RELATO QUE NÃO ESTÃO NA UNIDADE DESTINO.
    INSERT INTO RELATO_ALTERNATIVA (COD_UNIDADE, COD_SETOR, ALTERNATIVA, STATUS_ATIVO)
    SELECT F_COD_UNIDADE_DESTINO,
           F_COD_SETOR_DESTINO,
           TRIM_AND_REMOVE_EXTRA_SPACES(RA.ALTERNATIVA),
           RA.STATUS_ATIVO
    FROM RELATO_ALTERNATIVA RA
    WHERE RA.COD_UNIDADE = F_COD_UNIDADE_ORIGEM
      AND RA.COD_SETOR = F_COD_SETOR_ORIGEM
      AND NOT EXISTS(SELECT *
                     FROM RELATO_ALTERNATIVA R
                     WHERE R.COD_UNIDADE = F_COD_UNIDADE_DESTINO
                       AND R.COD_SETOR = F_COD_SETOR_DESTINO
                       AND (TRIM_AND_REMOVE_EXTRA_SPACES(UNACCENT(RA.ALTERNATIVA)) ILIKE
                            TRIM_AND_REMOVE_EXTRA_SPACES(UNACCENT(R.ALTERNATIVA))));
    GET DIAGNOSTICS QTD_INSERTS = ROW_COUNT;

    IF (QTD_INSERTS > 0)
    THEN
        SELECT ('ALTERNATIVAS DE RELATO COPIADOS COM SUCESSO PARA A UNIDADE: '
                    || (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_DESTINO)
                    || ' DE CÓDIGO: '
                    || F_COD_UNIDADE_DESTINO
                    || ' , SETOR: '
                    || F_COD_SETOR_DESTINO
                    || ' , QUANTIDADE DE ALTERNATIVAS INSERIDAS: '
            || QTD_INSERTS)
        INTO AVISO_ALTERNATIVA_INSERIDA;
    ELSE
        SELECT ('NENHUMA ALTERNATIVA INSERIDA - A UNIDADE: '
                    || (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_DESTINO)
                    || ' DE CÓDIGO: '
                    || F_COD_UNIDADE_DESTINO
                    || ' - , SETOR: '
                    || F_COD_SETOR_DESTINO
            || ', JÁ POSSUI AS ALTERNATIVAS')
        INTO AVISO_ALTERNATIVA_INSERIDA;
    END IF;
END;
$$;

create or replace function public.func_veiculo_relatorio_listagem_veiculos_by_unidade(f_cod_unidades bigint[])
    returns TABLE
            (
                unidade                  text,
                placa                    text,
                marca                    text,
                modelo                   text,
                tipo                     text,
                "DIAGRAMA VINCULADO?"    text,
                "KM ATUAL"               text,
                status                   text,
                "DATA/HORA CADASTRO"     text,
                "VEÍCULO COMPLETO"       text,
                "QTD PNEUS VINCULADOS"   text,
                "QTD POSIÇÕES DIAGRAMA"  text,
                "QTD POSIÇÕES SEM PNEUS" text,
                "QTD ESTEPES"            text
            )
    language plpgsql
as
$$
DECLARE
    ESTEPES            INTEGER := 900;
    POSICOES_SEM_PNEUS INTEGER = 0;
    SIM                TEXT    := 'SIM';
    NAO                TEXT    := 'NÃO';
BEGIN
    RETURN QUERY
        -- Calcula a quantidade de pneus e estepes que estão vinculados na placa.
        WITH QTD_PNEUS_VINCULADOS_PLACA AS (
            SELECT V.PLACA,
                   COUNT(VP.PLACA)
                   FILTER (WHERE VP.POSICAO < ESTEPES)  AS QTD_PNEUS_VINCULADOS,
                   COUNT(VP.PLACA)
                   FILTER (WHERE VP.POSICAO >= ESTEPES) AS QTD_ESTEPES_VINCULADOS,
                   VT.COD_DIAGRAMA
            FROM VEICULO V
                     JOIN VEICULO_TIPO VT ON V.COD_TIPO = VT.CODIGO
                     LEFT JOIN VEICULO_PNEU VP ON V.PLACA = VP.PLACA AND V.COD_UNIDADE = VP.COD_UNIDADE
            WHERE V.COD_UNIDADE = ANY (F_COD_UNIDADES)
            GROUP BY V.PLACA,
                     VT.COD_DIAGRAMA
        ),

             -- Calcula a quantidade de posições nos diagramas que existem no prolog.
             QTD_POSICOES_DIAGRAMA AS (
                 SELECT VDE.COD_DIAGRAMA,
                        SUM(VDE.QT_PNEUS) AS QTD_POSICOES_DIAGRAMA
                 FROM VEICULO_DIAGRAMA_EIXOS VDE
                 GROUP BY COD_DIAGRAMA
             )

        SELECT U.NOME :: TEXT                                                     AS UNIDADE,
               V.PLACA :: TEXT                                                    AS PLACA,
               MA.NOME :: TEXT                                                    AS MARCA,
               MO.NOME :: TEXT                                                    AS MODELO,
               VT.NOME :: TEXT                                                    AS TIPO,
               CASE
                   WHEN QPVP.COD_DIAGRAMA IS NULL
                       THEN 'NÃO'
                   ELSE 'SIM' END                                                 AS POSSUI_DIAGRAMA,
               V.KM :: TEXT                                                       AS KM_ATUAL,
               F_IF(V.STATUS_ATIVO, 'ATIVO' :: TEXT, 'INATIVO' :: TEXT)           AS STATUS,
               COALESCE(TO_CHAR(V.DATA_HORA_CADASTRO, 'DD/MM/YYYY HH24:MI'), '-') AS DATA_HORA_CADASTRO,
               -- Caso a quantidade de posições sem pneus seja 0 é porque o veículo está com todos os pneus - veículo completo.
               CASE
                   WHEN (QSD.QTD_POSICOES_DIAGRAMA - QPVP.QTD_PNEUS_VINCULADOS) = POSICOES_SEM_PNEUS
                       THEN SIM
                   ELSE NAO END                                                   AS VEICULO_COMPLETO,
               QPVP.QTD_PNEUS_VINCULADOS :: TEXT                                  AS QTD_PNEUS_VINCULADOS,
               QSD.QTD_POSICOES_DIAGRAMA :: TEXT                                  AS QTD_POSICOES_DIAGRAMA,
               -- Calcula a quantidade de posições sem pneus.
               (QSD.QTD_POSICOES_DIAGRAMA - QPVP.QTD_PNEUS_VINCULADOS) :: TEXT    AS QTD_POSICOES_SEM_PNEUS,
               QPVP.QTD_ESTEPES_VINCULADOS :: TEXT                                AS QTD_ESTEPES_VINCULADOS
        FROM VEICULO V
                 JOIN UNIDADE U ON V.COD_UNIDADE = U.CODIGO
                 JOIN MODELO_VEICULO MO ON V.COD_MODELO = MO.CODIGO
                 JOIN MARCA_VEICULO MA ON MO.COD_MARCA = MA.CODIGO
                 JOIN VEICULO_TIPO VT ON V.COD_TIPO = VT.CODIGO
                 RIGHT JOIN QTD_PNEUS_VINCULADOS_PLACA QPVP ON QPVP.PLACA = V.PLACA
                 LEFT JOIN QTD_POSICOES_DIAGRAMA QSD ON QSD.COD_DIAGRAMA = QPVP.COD_DIAGRAMA
        ORDER BY U.NOME ASC,
                 STATUS ASC,
                 V.PLACA ASC,
                 MA.NOME ASC,
                 MO.NOME ASC,
                 VT.NOME ASC,
                 QTD_POSICOES_SEM_PNEUS DESC;
END;
$$;

create or replace function public.func_checklist_relatorio_ambev_realizados_dia(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE"            text,
                "DATA"               text,
                "QTD CHECKS SAÍDA"   bigint,
                "ADERÊNCIA SAÍDA"    text,
                "QTD CHECKS RETORNO" bigint,
                "ADERÊNCIA RETORNO"  text,
                "TOTAL DE CHECKS"    bigint,
                "TOTAL DE VIAGENS"   bigint,
                "ADERÊNCIA DIA"      text
            )
    language sql
as
$$
SELECT DADOS.NOME_UNIDADE                AS NOME_UNIDADE,
       TO_CHAR(DADOS.DATA, 'DD/MM/YYYY') AS DATA,
       DADOS.CHECKS_SAIDA                AS QTD_CHECKS_SAIDA,
       TRUNC((DADOS.CHECKS_SAIDA :: FLOAT / DADOS.TOTAL_VIAGENS) * 100) ||
       '%'                               AS ADERENCIA_SAIDA,
       DADOS.CHECKS_RETORNO              AS QTD_CHECKS_RETORNO,
       TRUNC((DADOS.CHECKS_RETORNO :: FLOAT / DADOS.TOTAL_VIAGENS) * 100) ||
       '%'                               AS ADERENCIA_RETORNO,
       DADOS.TOTAL_CHECKS                AS TOTAL_CHECKS,
       DADOS.TOTAL_VIAGENS               AS TOTAL_MAPAS,
       TRUNC(((DADOS.CHECKS_SAIDA + DADOS.CHECKS_RETORNO) :: FLOAT / (DADOS.TOTAL_VIAGENS * 2)) * 100) ||
       '%'                               AS ADERENCIA_DIA
FROM (SELECT U.NOME                                                       AS NOME_UNIDADE,
             (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE AS DATA,
             SUM(CASE
                     WHEN C.TIPO = 'S'
                         THEN 1
                     ELSE 0 END)                                          AS CHECKS_SAIDA,
             SUM(CASE
                     WHEN C.TIPO = 'R'
                         THEN 1
                     ELSE 0 END)                                          AS CHECKS_RETORNO,
             COUNT(C.DATA_HORA :: DATE)                                   AS TOTAL_CHECKS,
             DIA_ESCALA.TOTAL_VIAGENS                                     AS TOTAL_VIAGENS
      FROM CHECKLIST C
               JOIN UNIDADE U ON C.COD_UNIDADE = U.CODIGO
               LEFT JOIN (SELECT ED.DATA         AS DATA_ESCALA,
                                 COUNT(ED.PLACA) AS TOTAL_VIAGENS
                          FROM ESCALA_DIARIA ED
                                   JOIN VEICULO V ON V.PLACA = ED.PLACA
                          WHERE ED.COD_UNIDADE = ANY (ARRAY [F_COD_UNIDADES])
                            AND ED.DATA >= F_DATA_INICIAL
                            AND ED.DATA <= F_DATA_FINAL
                          GROUP BY ED.DATA
                          ORDER BY ED.DATA ASC) AS DIA_ESCALA
                         ON DIA_ESCALA.DATA_ESCALA = (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE
      WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
        AND (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
        AND (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
      GROUP BY U.CODIGO, DATA, DIA_ESCALA.TOTAL_VIAGENS
      ORDER BY U.NOME, (C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)) :: DATE) AS DADOS
$$;

create or replace function public.func_checklist_insert_checklist_infos(f_cod_unidade_checklist bigint,
                                                                        f_cod_modelo_checklist bigint,
                                                                        f_data_hora_realizacao timestamp with time zone,
                                                                        f_cod_colaborador bigint, f_cod_veiculo bigint,
                                                                        f_placa_veiculo text,
                                                                        f_tipo_checklist character,
                                                                        f_km_coletado bigint, f_tempo_realizacao bigint,
                                                                        f_data_hora_sincronizacao timestamp with time zone,
                                                                        f_fonte_data_hora_realizacao text,
                                                                        f_versao_app_momento_realizacao integer,
                                                                        f_versao_app_momento_sincronizacao integer,
                                                                        f_device_id text, f_device_imei text,
                                                                        f_device_uptime_realizacao_millis bigint,
                                                                        f_device_uptime_sincronizacao_millis bigint,
                                                                        f_total_perguntas_ok integer,
                                                                        f_total_perguntas_nok integer,
                                                                        f_total_alternativas_ok integer,
                                                                        f_total_alternativas_nok integer) returns bigint
    language plpgsql
as
$$
DECLARE
    -- Iremos atualizar o KM do Veículo somente para o caso em que o KM atual do veículo for menor que o KM coletado.
    DEVE_ATUALIZAR_KM_VEICULO BOOLEAN := (CASE
                                              WHEN (F_KM_COLETADO > (SELECT V.KM
                                                                     FROM VEICULO V
                                                                     WHERE V.CODIGO = F_COD_VEICULO))
                                                  THEN
                                                  TRUE
                                              ELSE FALSE END);
    COD_CHECKLIST_INSERIDO    BIGINT;
    QTD_LINHAS_ATUALIZADAS    BIGINT;
BEGIN

    INSERT INTO CHECKLIST(COD_UNIDADE,
                          COD_CHECKLIST_MODELO,
                          DATA_HORA,
                          CPF_COLABORADOR,
                          PLACA_VEICULO,
                          TIPO,
                          TEMPO_REALIZACAO,
                          KM_VEICULO,
                          DATA_HORA_SINCRONIZACAO,
                          FONTE_DATA_HORA_REALIZACAO,
                          VERSAO_APP_MOMENTO_REALIZACAO,
                          VERSAO_APP_MOMENTO_SINCRONIZACAO,
                          DEVICE_ID,
                          DEVICE_IMEI,
                          DEVICE_UPTIME_REALIZACAO_MILLIS,
                          DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
                          FOI_OFFLINE,
                          TOTAL_PERGUNTAS_OK,
                          TOTAL_PERGUNTAS_NOK,
                          TOTAL_ALTERNATIVAS_OK,
                          TOTAL_ALTERNATIVAS_NOK)
    VALUES (F_COD_UNIDADE_CHECKLIST,
            F_COD_MODELO_CHECKLIST,
            F_DATA_HORA_REALIZACAO,
            (SELECT C.CPF FROM COLABORADOR C WHERE C.CODIGO = F_COD_COLABORADOR),
            F_PLACA_VEICULO,
            F_TIPO_CHECKLIST,
            F_TEMPO_REALIZACAO,
            F_KM_COLETADO,
            F_DATA_HORA_SINCRONIZACAO,
            F_FONTE_DATA_HORA_REALIZACAO,
            F_VERSAO_APP_MOMENTO_REALIZACAO,
            F_VERSAO_APP_MOMENTO_SINCRONIZACAO,
            F_DEVICE_ID,
            F_DEVICE_IMEI,
            F_DEVICE_UPTIME_REALIZACAO_MILLIS,
            F_DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
            TRUE,
            F_TOTAL_PERGUNTAS_OK,
            F_TOTAL_PERGUNTAS_NOK,
            F_TOTAL_ALTERNATIVAS_OK,
            F_TOTAL_ALTERNATIVAS_NOK) RETURNING CODIGO INTO COD_CHECKLIST_INSERIDO;

    -- Verificamos se o insert funcionou.
    IF COD_CHECKLIST_INSERIDO <= 0
    THEN
        RAISE EXCEPTION 'Não foi possível inserir o checklist';
    END IF;

    IF DEVE_ATUALIZAR_KM_VEICULO
    THEN
        UPDATE VEICULO SET KM = F_KM_COLETADO WHERE CODIGO = F_COD_VEICULO;
    END IF;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    -- Se devemos atualizar o KM mas nenhuma linha foi alterada, então temos um erro.
    IF (DEVE_ATUALIZAR_KM_VEICULO AND QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Não foi possível atualizar o km do veículo';
    END IF;

    RETURN COD_CHECKLIST_INSERIDO;
END;
$$;

create or replace function public.func_dispositivo_get_marcas_dispositivo_movel()
    returns TABLE
            (
                cod_marca  integer,
                nome_marca text
            )
    language sql
as
$$
SELECT MDP.CODIGO AS COD_MARCA, MDP.NOME :: TEXT AS NOME_MARCA
FROM DISPOSITIVO_MOVEL_MARCA_PROLOG MDP
ORDER BY MDP.NOME ASC;
$$;

create or replace function public.func_dispositivo_get_dispositivos_moveis(f_cod_empresa bigint)
    returns TABLE
            (
                cod_empresa     bigint,
                cod_marca       bigint,
                marca           text,
                cod_dispositivo bigint,
                modelo          text,
                descricao       text,
                cod_imei        bigint,
                imei            text
            )
    language sql
as
$$
SELECT DM.COD_EMPRESA    AS COD_EMPRESA,
       DM.COD_MARCA      AS COD_MARCA,
       MD.NOME :: TEXT   AS MARCA,
       DM.CODIGO         AS COD_DISPOSITIVO,
       DM.MODELO :: TEXT AS MODELO,
       DM.DESCRICAO      AS DESCRICAO,
       DI.CODIGO         AS COD_IMEI,
       DI.IMEI :: TEXT   AS IMEI
FROM DISPOSITIVO_MOVEL_IMEI DI
         LEFT JOIN DISPOSITIVO_MOVEL DM ON DM.CODIGO = DI.COD_DISPOSITIVO
         LEFT JOIN DISPOSITIVO_MOVEL_MARCA_PROLOG MD ON MD.CODIGO = DM.COD_MARCA
WHERE DI.COD_EMPRESA = F_COD_EMPRESA
ORDER BY DM.CODIGO, DI.CODIGO;
$$;

create or replace function public.func_dispositivo_get_dispositivo_movel(f_cod_empresa bigint, f_cod_dispositivo bigint)
    returns TABLE
            (
                cod_empresa     bigint,
                cod_marca       bigint,
                marca           text,
                cod_dispositivo bigint,
                modelo          text,
                descricao       text,
                cod_imei        bigint,
                imei            text
            )
    language sql
as
$$
SELECT DM.COD_EMPRESA    AS COD_EMPRESA,
       DM.COD_MARCA      AS COD_MARCA,
       MD.NOME :: TEXT   AS MARCA,
       DM.CODIGO         AS COD_DISPOSITIVO,
       DM.MODELO :: TEXT AS MODELO,
       DM.DESCRICAO      AS DESCRICAO,
       DI.CODIGO         AS COD_IMEI,
       DI.IMEI :: TEXT   AS IMEI
FROM DISPOSITIVO_MOVEL_IMEI DI
         LEFT JOIN DISPOSITIVO_MOVEL DM ON DM.CODIGO = DI.COD_DISPOSITIVO
         LEFT JOIN DISPOSITIVO_MOVEL_MARCA_PROLOG MD ON MD.CODIGO = DM.COD_MARCA
WHERE DI.COD_EMPRESA = F_COD_EMPRESA
  AND DM.CODIGO = F_COD_DISPOSITIVO
ORDER BY DM.CODIGO, DI.CODIGO;
$$;

create or replace function public.func_dispositivo_insere_dispositivo_movel(f_cod_empresa bigint, f_cod_marca bigint,
                                                                            f_modelo text,
                                                                            f_descricao text) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_DISPOSITIVO_INSERIDO BIGINT;
BEGIN
    -- Verifica se a empresa existe
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

    -- Verifica se a marca do dispositivo móvel existe no banco.
    IF ((F_COD_MARCA IS NOT NULL) AND (SELECT NOT EXISTS(
            SELECT MDP.CODIGO AS COD_MARCA, MDP.NOME :: TEXT AS NOME_MARCA
            FROM DISPOSITIVO_MOVEL_MARCA_PROLOG MDP
            WHERE MDP.CODIGO = F_COD_MARCA)))
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível encontrar esta marca do dispositivo móvel, confira a marca e tente novamente');
    END IF;

    -- Insere o registro de IMEI.
    INSERT INTO DISPOSITIVO_MOVEL (COD_EMPRESA, COD_MARCA, MODELO, DESCRICAO)
    VALUES (F_COD_EMPRESA, F_COD_MARCA, TRIM_AND_REMOVE_EXTRA_SPACES(F_MODELO),
            TRIM_AND_REMOVE_EXTRA_SPACES(F_DESCRICAO)) RETURNING CODIGO
               INTO COD_DISPOSITIVO_INSERIDO;

    -- Verificamos se o insert funcionou.
    IF COD_DISPOSITIVO_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível inserir o dispositivo móvel, tente novamente');
    END IF;

    RETURN COD_DISPOSITIVO_INSERIDO;
END;
$$;

create or replace function public.func_dispositivo_insere_imei(f_cod_empresa bigint, f_cod_dispositivo bigint, f_imei text) returns void
    language plpgsql
as
$$
DECLARE
    COD_IMEI_INSERIDO BIGINT;
BEGIN
    -- Verifica se o dispositivo móvel existe no banco.
    IF (SELECT NOT EXISTS(
            SELECT CODIGO
            FROM DISPOSITIVO_MOVEL
            WHERE CODIGO = F_COD_DISPOSITIVO
              AND COD_EMPRESA = F_COD_EMPRESA))
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível encontrar este dispositivo móvel, confira o código e tente novamente');
    END IF;

    -- Verifica se o IMEI já existe no banco.
    IF (SELECT EXISTS(SELECT IMEI FROM DISPOSITIVO_MOVEL_IMEI WHERE IMEI = F_IMEI AND COD_EMPRESA = F_COD_EMPRESA))
    THEN
        PERFORM THROW_GENERIC_ERROR(FORMAT('O IMEI %s já está vinculado a outro dispositivo', F_IMEI));
    END IF;

    -- Insere o registro de IMEI
    INSERT INTO DISPOSITIVO_MOVEL_IMEI (COD_EMPRESA, COD_DISPOSITIVO, IMEI)
    VALUES (F_COD_EMPRESA, F_COD_DISPOSITIVO, F_IMEI) RETURNING CODIGO
        INTO COD_IMEI_INSERIDO;

    -- Verificamos se o insert funcionou.
    IF COD_IMEI_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível inserir o número IMEI, tente novamente');
    END IF;
END;
$$;

create or replace function public.func_dispositivo_insere_dispositivo_movel_com_imei(f_cod_empresa bigint,
                                                                                     f_cod_marca bigint, f_modelo text,
                                                                                     f_descricao text,
                                                                                     f_imei text[]) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_DISPOSITIVO_INSERIDO BIGINT;
    IMEI                     TEXT;
BEGIN
    -- Verifica se a empresa existe
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

    -- Insere o dispositivo móvel
    COD_DISPOSITIVO_INSERIDO := FUNC_DISPOSITIVO_INSERE_DISPOSITIVO_MOVEL(F_COD_EMPRESA,
                                                                          F_COD_MARCA,
                                                                          F_MODELO,
                                                                          F_DESCRICAO);

    -- Verificamos se o insert funcionou.
    IF COD_DISPOSITIVO_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível inserir o dispositivo móvel, tente novamente');
    END IF;

    -- Insere os números de IMEI
    FOREACH IMEI IN ARRAY F_IMEI
        LOOP
            PERFORM FUNC_DISPOSITIVO_INSERE_IMEI(F_COD_EMPRESA, COD_DISPOSITIVO_INSERIDO, IMEI);
        END LOOP;

    RETURN COD_DISPOSITIVO_INSERIDO;
END;
$$;

create or replace function public.func_dispositivo_edita_dispositivo_movel(f_cod_empresa bigint,
                                                                           f_cod_dispositivo bigint, f_cod_marca bigint,
                                                                           f_modelo text, f_descricao text,
                                                                           f_imei text[]) returns bigint
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
    IMEI                   TEXT;
BEGIN
    -- Verifica se a empresa existe.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

    IF (SELECT NOT EXISTS(
            SELECT DM.CODIGO
            FROM DISPOSITIVO_MOVEL DM
            WHERE DM.CODIGO = F_COD_DISPOSITIVO
              AND DM.COD_EMPRESA = F_COD_EMPRESA))
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível encontrar este dispositivo móvel, confira se ele está na listagem e tente novamente');
    END IF;

    -- Verifica se a marca do dispositivo móvel existe no banco.
    IF ((F_COD_MARCA IS NOT NULL) AND (SELECT NOT EXISTS(
            SELECT MDP.CODIGO AS COD_MARCA, MDP.NOME :: TEXT AS NOME_MARCA
            FROM DISPOSITIVO_MOVEL_MARCA_PROLOG MDP
            WHERE MDP.CODIGO = F_COD_MARCA)))
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível encontrar esta marca do dispositivo móvel, confira a marca e tente novamente');
    END IF;

    -- Edita o registro do dispositivo móvel.
    UPDATE DISPOSITIVO_MOVEL
    SET COD_MARCA = F_COD_MARCA,
        MODELO    = TRIM_AND_REMOVE_EXTRA_SPACES(F_MODELO),
        DESCRICAO = TRIM_AND_REMOVE_EXTRA_SPACES(F_DESCRICAO)
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND CODIGO = F_COD_DISPOSITIVO;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF (QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Erro ao editar o dispositivo móvel, tente novamente');
    END IF;

    -- Deleta todos os números de IMEI anteriores
    DELETE
    FROM DISPOSITIVO_MOVEL_IMEI
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND COD_DISPOSITIVO = F_COD_DISPOSITIVO;

    -- Insere os números de IMEI
    FOREACH IMEI IN ARRAY F_IMEI
        LOOP
            PERFORM FUNC_DISPOSITIVO_INSERE_IMEI(F_COD_EMPRESA, F_COD_DISPOSITIVO, IMEI);
        END LOOP;

    RETURN QTD_LINHAS_ATUALIZADAS;
END;
$$;

create or replace function public.func_dispositivo_deleta_dispositivo_movel(f_cod_empresa bigint, f_cod_dispositivo bigint) returns bigint
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_DELETADAS BIGINT;
BEGIN
    IF (SELECT NOT EXISTS(SELECT CODIGO
                          FROM DISPOSITIVO_MOVEL
                          WHERE COD_EMPRESA = F_COD_EMPRESA
                            AND CODIGO = F_COD_DISPOSITIVO))
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Erro ao deletar, dispositivo móvel não encontrado');
    END IF;

    -- Deleta todos os números de IMEI anteriores
    DELETE
    FROM DISPOSITIVO_MOVEL_IMEI
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND COD_DISPOSITIVO = F_COD_DISPOSITIVO;

    -- Deleta o dispositivo móvel.
    DELETE
    FROM DISPOSITIVO_MOVEL
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND CODIGO = F_COD_DISPOSITIVO;

    GET DIAGNOSTICS QTD_LINHAS_DELETADAS = ROW_COUNT;

    IF (QTD_LINHAS_DELETADAS <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR('Erro ao deletar o dispositivo móvel, tente novamente');
    END IF;
    --
    --
    RETURN QTD_LINHAS_DELETADAS;
END;
$$;

create or replace function public.func_marcacao_insert_marcacao_jornada(f_cod_unidade bigint,
                                                                        f_cod_tipo_intervalo bigint,
                                                                        f_cpf_colaborador bigint,
                                                                        f_data_hora timestamp with time zone,
                                                                        f_tipo_marcacao text, f_fonte_data_hora text,
                                                                        f_justificativa_tempo_recomendado text,
                                                                        f_justificativa_estouro text,
                                                                        f_latitude_marcacao text,
                                                                        f_longitude_marcacao text,
                                                                        f_data_hora_sincronizacao timestamp with time zone,
                                                                        f_versao_app_momento_marcacao integer,
                                                                        f_versao_app_momento_sincronizacao integer,
                                                                        f_device_id text, f_device_imei text,
                                                                        f_device_uptime_realizacao_millis bigint,
                                                                        f_device_uptime_sincronizacao_millis bigint,
                                                                        f_android_api_version bigint,
                                                                        f_marca_device text,
                                                                        f_modelo_device text) returns bigint
    language sql
as
$$
INSERT INTO INTERVALO (COD_UNIDADE,
                       COD_TIPO_INTERVALO,
                       CPF_COLABORADOR,
                       DATA_HORA,
                       TIPO_MARCACAO,
                       FONTE_DATA_HORA,
                       JUSTIFICATIVA_TEMPO_RECOMENDADO,
                       JUSTIFICATIVA_ESTOURO,
                       LATITUDE_MARCACAO,
                       LONGITUDE_MARCACAO,
                       DATA_HORA_SINCRONIZACAO,
                       VERSAO_APP_MOMENTO_MARCACAO,
                       VERSAO_APP_MOMENTO_SINCRONIZACAO,
                       DEVICE_ID,
                       DEVICE_IMEI,
                       DEVICE_UPTIME_REALIZACAO_MILLIS,
                       DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
                       ANDROID_API_VERSION,
                       MARCA_DEVICE,
                       MODELO_DEVICE)
VALUES (F_COD_UNIDADE,
        F_COD_TIPO_INTERVALO,
        F_CPF_COLABORADOR,
        F_DATA_HORA,
        F_TIPO_MARCACAO,
        F_FONTE_DATA_HORA,
        F_JUSTIFICATIVA_TEMPO_RECOMENDADO,
        F_JUSTIFICATIVA_ESTOURO,
        F_LATITUDE_MARCACAO,
        F_LONGITUDE_MARCACAO,
        F_DATA_HORA_SINCRONIZACAO,
        F_VERSAO_APP_MOMENTO_MARCACAO,
        F_VERSAO_APP_MOMENTO_SINCRONIZACAO,
        F_DEVICE_ID,
        F_DEVICE_IMEI,
        F_DEVICE_UPTIME_REALIZACAO_MILLIS,
        F_DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
        F_ANDROID_API_VERSION,
        F_MARCA_DEVICE,
        F_MODELO_DEVICE) RETURNING CODIGO;
$$;


create or replace function public.func_marcacao_get_marcacoes_colaborador_ajuste(f_cod_tipo_marcacao bigint, f_cod_colaborador bigint, f_dia date)
    returns TABLE
            (
                cod_marcacao_inicio            bigint,
                cod_marcacao_fim               bigint,
                data_hora_inicio               timestamp without time zone,
                data_hora_fim                  timestamp without time zone,
                status_ativo_inicio            boolean,
                status_ativo_fim               boolean,
                foi_ajustado_inicio            boolean,
                foi_ajustado_fim               boolean,
                cod_tipo_marcacao              bigint,
                nome_tipo_marcacao             text,
                device_imei_inicio             text,
                device_imei_inicio_reconhecido boolean,
                device_marca_inicio            text,
                device_modelo_inicio           text,
                device_imei_fim                text,
                device_imei_fim_reconhecido    boolean,
                device_marca_fim               text,
                device_modelo_fim              text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT F.COD_MARCACAO_INICIO                                       AS COD_MARCACAO_INICIO,
               F.COD_MARCACAO_FIM                                          AS COD_MARCACAO_FIM,
               (F.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE)) AS DATA_HORA_INICIO,
               (F.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE))    AS DATA_HORA_FIM,
               F.STATUS_ATIVO_INICIO                                       AS STATUS_ATIVO_INICIO,
               F.STATUS_ATIVO_FIM                                          AS STATUS_ATIVO_FIM,
               F.FOI_AJUSTADO_INICIO                                       AS FOI_AJUSTADO_INICIO,
               F.FOI_AJUSTADO_FIM                                          AS FOI_AJUSTADO_FIM,
               F.COD_TIPO_INTERVALO                                        AS COD_TIPO_MARCACAO,
               IT.NOME :: TEXT                                             AS NOME_TIPO_MARCACAO,
               F.DEVICE_IMEI_INICIO :: TEXT                                AS DEVICE_IMEI_INICIO,
               F.DEVICE_IMEI_INICIO_RECONHECIDO :: BOOLEAN                 AS DEVICE_IMEI_INICIO_RECONHECIDO,
               F.DEVICE_MARCA_INICIO :: TEXT                               AS DEVICE_MARCA_INICIO,
               F.DEVICE_MODELO_INICIO :: TEXT                              AS DEVICE_MODELO_INICIO,
               F.DEVICE_IMEI_FIM :: TEXT                                   AS DEVICE_IMEI_FIM,
               F.DEVICE_IMEI_FIM_RECONHECIDO :: BOOLEAN                    AS DEVICE_IMEI_FIM_RECONHECIDO,
               F.DEVICE_MARCA_FIM :: TEXT                                  AS DEVICE_MARCA_FIM,
               F.DEVICE_MODELO_FIM :: TEXT                                 AS DEVICE_MODELO_FIM
        FROM FUNC_INTERVALOS_AGRUPADOS(NULL,
                                       (SELECT C.CPF FROM COLABORADOR C WHERE C.CODIGO = F_COD_COLABORADOR),
                                       F_COD_TIPO_MARCACAO) F
                 JOIN INTERVALO_TIPO IT ON F.COD_TIPO_INTERVALO = IT.CODIGO
        WHERE ((F.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE)) :: DATE = F_DIA
            OR (F.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE)) :: DATE = F_DIA)
        ORDER BY COALESCE(F.DATA_HORA_INICIO, F.DATA_HORA_FIM);
END;
$$;

create or replace function public.func_marcacao_get_marcacoes_acompanhamento(f_cod_inicio bigint, f_cod_fim bigint, f_tz_unidade text)
    returns TABLE
            (
                fonte_data_hora_inicio                    text,
                fonte_data_hora_fim                       text,
                justificativa_estouro                     text,
                justificativa_tempo_recomendado           text,
                latitude_marcacao_inicio                  text,
                longitude_marcacao_inicio                 text,
                latitude_marcacao_fim                     text,
                longitude_marcacao_fim                    text,
                cod_unidade                               bigint,
                cpf_colaborador                           text,
                nome_colaborador                          text,
                nome_tipo_marcacao                        text,
                data_hora_inicio                          timestamp without time zone,
                data_hora_fim                             timestamp without time zone,
                tempo_decorrido_entre_inicio_fim_segundos bigint,
                tempo_recomendado_tipo_marcacao_segundos  bigint,
                cod_marcacao_inicio                       bigint,
                cod_marcacao_fim                          bigint,
                status_ativo_inicio                       boolean,
                status_ativo_fim                          boolean,
                foi_ajustado_inicio                       boolean,
                foi_ajustado_fim                          boolean,
                data_hora_sincronizacao_inicio            timestamp without time zone,
                data_hora_sincronizacao_fim               timestamp without time zone,
                versao_app_momento_marcacao_inicio        integer,
                versao_app_momento_marcacao_fim           integer,
                versao_app_momento_sincronizacao_inicio   integer,
                versao_app_momento_sincronizacao_fim      integer,
                tipo_jornada                              boolean,
                device_imei_inicio                        text,
                device_imei_inicio_reconhecido            boolean,
                device_marca_inicio                       text,
                device_modelo_inicio                      text,
                device_imei_fim                           text,
                device_imei_fim_reconhecido               boolean,
                device_marca_fim                          text,
                device_modelo_fim                         text
            )
    language plpgsql
as
$$
BEGIN
    -- Se os dois códigos foram fornecidos, garantimos que eles são do mesmo colaborador e também que são marcações
    -- vinculadas.
    IF F_COD_INICIO IS NOT NULL AND F_COD_FIM IS NOT NULL
    THEN
        IF (SELECT I.CPF_COLABORADOR
            FROM INTERVALO I
            WHERE I.CODIGO = F_COD_INICIO) <> (SELECT I.CPF_COLABORADOR
                                               FROM INTERVALO I
                                               WHERE I.CODIGO = F_COD_FIM)
        THEN
            RAISE EXCEPTION 'As marcações de início e fim buscadas não pertencem ao mesmo colaborador';
        END IF;
        IF (SELECT NOT EXISTS(SELECT MV.CODIGO
                              FROM MARCACAO_VINCULO_INICIO_FIM MV
                              WHERE MV.COD_MARCACAO_INICIO = F_COD_INICIO
                                AND MV.COD_MARCACAO_FIM = F_COD_FIM))
        THEN
            RAISE EXCEPTION 'As marcações de início e fim buscadas não estão vinculadas';
        END IF;
    END IF;

    RETURN QUERY
        WITH INICIOS AS (
            SELECT MI.COD_MARCACAO_INICIO             AS COD_MARCACAO_INICIO,
                   MV.COD_MARCACAO_FIM                AS COD_MARCACAO_VINCULO,
                   I.FONTE_DATA_HORA                  AS FONTE_DATA_HORA_INICIO,
                   I.LATITUDE_MARCACAO                AS LATITUDE_MARCACAO_INICIO,
                   I.LONGITUDE_MARCACAO               AS LONGITUDE_MARCACAO_INICIO,
                   I.COD_UNIDADE                      AS COD_UNIDADE,
                   I.CPF_COLABORADOR                  AS CPF_COLABORADOR,
                   I.DATA_HORA                        AS DATA_HORA_INICIO,
                   I.CODIGO                           AS CODIGO_INICIO,
                   I.STATUS_ATIVO                     AS STATUS_ATIVO_INICIO,
                   I.FOI_AJUSTADO                     AS FOI_AJUSTADO_INICIO,
                   I.DATA_HORA_SINCRONIZACAO          AS DATA_HORA_SINCRONIZACAO_INICIO,
                   I.VERSAO_APP_MOMENTO_MARCACAO      AS VERSAO_APP_MOMENTO_MARCACAO_INICIO,
                   I.VERSAO_APP_MOMENTO_SINCRONIZACAO AS VERSAO_APP_MOMENTO_SINCRONIZACAO_INICIO,
                   I.DEVICE_IMEI                      AS DEVICE_IMEI,
                   DMI.IMEI IS NOT NULL               AS DEVICE_RECONHECIDO,
                   I.MARCA_DEVICE                     AS DEVICE_MARCA,
                   I.MODELO_DEVICE                    AS DEVICE_MODELO,
                   VIT.NOME                           AS NOME_TIPO_MARCACAO,
                   VIT.TEMPO_RECOMENDADO_MINUTOS      AS TEMPO_RECOMENDADO_MINUTOS,
                   VIT.TIPO_JORNADA                   AS TIPO_JORNADA
            FROM MARCACAO_INICIO MI
                     LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV
                               ON MI.COD_MARCACAO_INICIO = MV.COD_MARCACAO_INICIO
                     JOIN INTERVALO I
                          ON MI.COD_MARCACAO_INICIO = I.CODIGO
                     JOIN UNIDADE UNI
                          ON UNI.CODIGO = I.COD_UNIDADE
                     LEFT JOIN DISPOSITIVO_MOVEL_IMEI DMI
                               ON DMI.COD_EMPRESA = UNI.COD_EMPRESA AND DMI.IMEI = I.DEVICE_IMEI
                     JOIN VIEW_INTERVALO_TIPO VIT
                          ON I.COD_TIPO_INTERVALO = VIT.CODIGO
            WHERE F_IF(F_COD_INICIO IS NULL, I.CODIGO IS NULL, I.CODIGO = F_COD_INICIO)
        ),

             FINS AS (
                 SELECT MF.COD_MARCACAO_FIM                AS COD_MARCACAO_FIM,
                        MV.COD_MARCACAO_INICIO             AS COD_MARCACAO_VINCULO,
                        F.FONTE_DATA_HORA                  AS FONTE_DATA_HORA_FIM,
                        F.JUSTIFICATIVA_ESTOURO            AS JUSTIFICATIVA_ESTOURO,
                        F.JUSTIFICATIVA_TEMPO_RECOMENDADO  AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
                        F.LATITUDE_MARCACAO                AS LATITUDE_MARCACAO_FIM,
                        F.LONGITUDE_MARCACAO               AS LONGITUDE_MARCACAO_FIM,
                        F.COD_UNIDADE                      AS COD_UNIDADE,
                        F.CPF_COLABORADOR                  AS CPF_COLABORADOR,
                        F.DATA_HORA                        AS DATA_HORA_FIM,
                        F.CODIGO                           AS CODIGO_FIM,
                        F.STATUS_ATIVO                     AS STATUS_ATIVO_FIM,
                        F.FOI_AJUSTADO                     AS FOI_AJUSTADO_FIM,
                        F.DATA_HORA_SINCRONIZACAO          AS DATA_HORA_SINCRONIZACAO_FIM,
                        F.VERSAO_APP_MOMENTO_MARCACAO      AS VERSAO_APP_MOMENTO_MARCACAO_FIM,
                        F.VERSAO_APP_MOMENTO_SINCRONIZACAO AS VERSAO_APP_MOMENTO_SINCRONIZACAO_FIM,
                        F.DEVICE_IMEI                      AS DEVICE_IMEI,
                        DMI.IMEI IS NOT NULL               AS DEVICE_RECONHECIDO,
                        F.MARCA_DEVICE                     AS DEVICE_MARCA,
                        F.MODELO_DEVICE                    AS DEVICE_MODELO,
                        VIT.NOME                           AS NOME_TIPO_MARCACAO,
                        VIT.TEMPO_RECOMENDADO_MINUTOS      AS TEMPO_RECOMENDADO_MINUTOS,
                        VIT.TIPO_JORNADA                   AS TIPO_JORNADA
                 FROM MARCACAO_FIM MF
                          LEFT JOIN MARCACAO_VINCULO_INICIO_FIM MV
                                    ON MF.COD_MARCACAO_FIM = MV.COD_MARCACAO_FIM
                          JOIN INTERVALO F
                               ON MF.COD_MARCACAO_FIM = F.CODIGO
                          JOIN UNIDADE UNI
                               ON UNI.CODIGO = F.COD_UNIDADE
                          LEFT JOIN DISPOSITIVO_MOVEL_IMEI DMI
                                    ON DMI.COD_EMPRESA = UNI.COD_EMPRESA AND DMI.IMEI = F.DEVICE_IMEI
                          JOIN VIEW_INTERVALO_TIPO VIT
                               ON F.COD_TIPO_INTERVALO = VIT.CODIGO
                 WHERE F_IF(F_COD_FIM IS NULL, F.CODIGO IS NULL, F.CODIGO = F_COD_FIM)
             )

             -- Por algum outro erro que não seja códigos de início e fim de colaboradores diferentes e marcações não vinculadas,
             -- a function poderia também acabar retornando mais de uma linha, preferimos não utilizar limit aqui e deixar esse
             -- erro subir para o servidor tratar.
        SELECT I.FONTE_DATA_HORA_INICIO :: TEXT                                      AS FONTE_DATA_HORA_INICIO,
               F.FONTE_DATA_HORA_FIM :: TEXT                                         AS FONTE_DATA_HORA_FIM,
               F.JUSTIFICATIVA_ESTOURO :: TEXT                                       AS JUSTIFICATIVA_ESTOURO,
               F.JUSTIFICATIVA_TEMPO_RECOMENDADO :: TEXT                             AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
               I.LATITUDE_MARCACAO_INICIO :: TEXT                                    AS LATITUDE_MARCACAO_INICIO,
               I.LONGITUDE_MARCACAO_INICIO :: TEXT                                   AS LONGITUDE_MARCACAO_INICIO,
               F.LATITUDE_MARCACAO_FIM :: TEXT                                       AS LATITUDE_MARCACAO_FIM,
               F.LONGITUDE_MARCACAO_FIM :: TEXT                                      AS LONGITUDE_MARCACAO_FIM,
               COALESCE(I.COD_UNIDADE, F.COD_UNIDADE)                                AS COD_UNIDADE,
               LPAD(COALESCE(I.CPF_COLABORADOR, F.CPF_COLABORADOR) :: TEXT, 11, '0') AS CPF_COLABORADOR,
               INITCAP(C.NOME) :: TEXT                                               AS NOME_COLABORADOR,
               COALESCE(I.NOME_TIPO_MARCACAO, F.NOME_TIPO_MARCACAO) :: TEXT          AS NOME_TIPO_MARCACAO,
               I.DATA_HORA_INICIO AT TIME ZONE F_TZ_UNIDADE                          AS DATA_HORA_INICIO,
               F.DATA_HORA_FIM AT TIME ZONE F_TZ_UNIDADE                             AS DATA_HORA_FIM,
               TO_SECONDS(F.DATA_HORA_FIM - I.DATA_HORA_INICIO)                      AS TEMPO_DECORRIDO_ENTRE_INICIO_FIM_SEGUNDOS,
               COALESCE(I.TEMPO_RECOMENDADO_MINUTOS,
                        F.TEMPO_RECOMENDADO_MINUTOS) *
               60                                                                    AS TEMPO_RECOMENDADO_TIPO_MARCACAO_SEGUNDOS,
               I.CODIGO_INICIO                                                       AS CODIGO_INICIO,
               F.CODIGO_FIM                                                          AS CODIGO_FIM,
               I.STATUS_ATIVO_INICIO                                                 AS STATUS_ATIVO_INICIO,
               F.STATUS_ATIVO_FIM                                                    AS STATUS_ATIVO_FIM,
               I.FOI_AJUSTADO_INICIO                                                 AS FOI_AJUSTADO_INICIO,
               F.FOI_AJUSTADO_FIM                                                    AS FOI_AJUSTADO_FIM,
               I.DATA_HORA_SINCRONIZACAO_INICIO AT TIME ZONE F_TZ_UNIDADE            AS DATA_HORA_SINCRONIZACAO_INICIO,
               F.DATA_HORA_SINCRONIZACAO_FIM AT TIME ZONE F_TZ_UNIDADE               AS DATA_HORA_SINCRONIZACAO_FIM,
               I.VERSAO_APP_MOMENTO_MARCACAO_INICIO                                  AS VERSAO_APP_MOMENTO_MARCACAO_INICIO,
               F.VERSAO_APP_MOMENTO_MARCACAO_FIM                                     AS VERSAO_APP_MOMENTO_MARCACAO_FIM,
               I.VERSAO_APP_MOMENTO_SINCRONIZACAO_INICIO                             AS VERSAO_APP_MOMENTO_SINCRONIZACAO_INICIO,
               F.VERSAO_APP_MOMENTO_SINCRONIZACAO_FIM                                AS VERSAO_APP_MOMENTO_SINCRONIZACAO_FIM,
               (F.TIPO_JORNADA OR I.TIPO_JORNADA)                                    AS TIPO_JORNADA,
               I.DEVICE_IMEI :: TEXT                                                 AS DEVICE_IMEI_INICIO,
               I.DEVICE_RECONHECIDO :: BOOLEAN                                       AS DEVICE_IMEI_INICIO_RECONHECIDO,
               I.DEVICE_MARCA :: TEXT                                                AS DEVICE_MARCA_INICIO,
               I.DEVICE_MODELO :: TEXT                                               AS DEVICE_MODELO_INICIO,
               F.DEVICE_IMEI :: TEXT                                                 AS DEVICE_IMEI_FIM,
               F.DEVICE_RECONHECIDO :: BOOLEAN                                       AS DEVICE_IMEI_FIM_RECONHECIDO,
               F.DEVICE_MARCA :: TEXT                                                AS DEVICE_MARCA_FIM,
               F.DEVICE_MODELO :: TEXT                                               AS DEVICE_MODELO_FIM
        FROM INICIOS I
                 FULL OUTER JOIN FINS F
                                 ON I.COD_MARCACAO_VINCULO = F.COD_MARCACAO_FIM
                 JOIN COLABORADOR C
                      ON C.CPF = COALESCE(I.CPF_COLABORADOR, F.CPF_COLABORADOR);
END;
$$;

create or replace function public.func_relatorio_intervalos_mapas(f_cod_unidade bigint, f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "DATA"                                 character varying,
                "MAPA"                                 integer,
                "MOTORISTA"                            character varying,
                "INICIO INTERVALO MOTORISTA"           character varying,
                "FIM INTERVALO MOTORISTA"              character varying,
                "MARCAÇÕES RECONHECIDAS MOT"           character varying,
                "TEMPO DECORRIDO EM MINUTOS MOTORISTA" character varying,
                "MOTORISTA CUMPRIU TEMPO MÍNIMO"       character varying,
                "AJUDANTE 1"                           character varying,
                "INICIO INTERVALO AJ 1"                character varying,
                "FIM INTERVALO AJ 1"                   character varying,
                "MARCAÇÕES RECONHECIDAS AJ 1"          character varying,
                "TEMPO DECORRIDO EM MINUTOS AJ 1"      character varying,
                "AJ 1 CUMPRIU TEMPO MÍNIMO"            character varying,
                "AJ 2"                                 character varying,
                "INICIO INTERVALO AJ 2"                character varying,
                "FIM INTERVALO AJ 2"                   character varying,
                "MARCAÇÕES RECONHECIDAS AJ 2"          character varying,
                "TEMPO DECORRIDO EM MINUTOS AJ 2"      character varying,
                "AJ 2 CUMPRIU TEMPO MÍNIMO"            character varying
            )
    language sql
as
$$
SELECT to_char(dados.data, 'DD/MM/YYYY'),
       dados.mapa,
       dados.NOME_MOTORISTA,
       dados.INICIO_INTERVALO_MOT,
       dados.FIM_INTERVALO_MOT,
       F_IF(dados.MARCACOES_RECONHECIDAS_MOT, 'SIM', 'NÃO' :: TEXT),
       dados.TEMPO_DECORRIDO_MINUTOS_MOT,
       dados.MOT_CUMPRIU_TEMPO_MINIMO,
       dados.NOME_aj1,
       dados.INICIO_INTERVALO_aj1,
       dados.FIM_INTERVALO_aj1,
       F_IF(dados.MARCACOES_RECONHECIDAS_AJ1, 'SIM', 'NÃO' :: TEXT),
       dados.TEMPO_DECORRIDO_MINUTOS_aj1,
       dados.aj1_CUMPRIU_TEMPO_MINIMO,
       dados.NOME_aj2,
       dados.INICIO_INTERVALO_aj2,
       dados.FIM_INTERVALO_aj2,
       F_IF(dados.MARCACOES_RECONHECIDAS_AJ2, 'SIM', 'NÃO' :: TEXT),
       dados.TEMPO_DECORRIDO_MINUTOS_aj2,
       dados.aj2_CUMPRIU_TEMPO_MINIMO
FROM view_extrato_mapas_versus_intervalos dados
WHERE dados.cod_unidade = f_cod_unidade
  AND dados.data :: date between f_data_inicial and f_data_final
ORDER BY dados.MAPA desc
$$;

create or replace function public.func_relatorio_intervalo_escala_diaria(f_cod_unidade bigint,
                                                                         f_cod_tipo_intervalo bigint,
                                                                         f_data_inicial date, f_data_final date,
                                                                         f_time_zone_unidade text)
    returns TABLE
            (
                "UNIDADE"                     text,
                "PLACA VEÍCULO"               text,
                "CÓDIGO ROTA (MAPA)"          bigint,
                "DATA"                        text,
                "TIPO DE INTERVALO"           text,
                "MOTORISTA"                   text,
                "INÍCIO INTERVALO MOTORISTA"  text,
                "FIM INTERVALO MOTORISTA"     text,
                "MARCAÇÕES RECONHECIDAS MOT"  text,
                "AJUDANTE 1"                  text,
                "INÍCIO INTERVALO AJUDANTE 1" text,
                "FIM INTERVALO AJUDANTE 1"    text,
                "MARCAÇÕES RECONHECIDAS AJ 1" text,
                "AJUDANTE 2"                  text,
                "INÍCIO INTERVALO AJUDANTE 2" text,
                "FIM INTERVALO AJUDANTE 2"    text,
                "MARCAÇÕES RECONHECIDAS AJ 2" text
            )
    language sql
as
$$
WITH TABLE_INTERVALOS AS (SELECT *
                          FROM FUNC_INTERVALOS_AGRUPADOS(f_cod_unidade, NULL, f_cod_tipo_intervalo) F
                          WHERE (COALESCE(F.data_hora_inicio, F.data_hora_fim) AT TIME ZONE
                                 f_time_zone_unidade) :: DATE >= f_data_inicial
                            AND (COALESCE(F.data_hora_inicio, F.data_hora_fim) AT TIME ZONE
                                 f_time_zone_unidade) :: DATE <= f_data_final)

SELECT (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = f_cod_unidade),
       ED.PLACA,
       ED.MAPA,
       TO_CHAR(ED.DATA, 'DD/MM/YYYY'),
       (SELECT IT.NOME FROM INTERVALO_TIPO IT WHERE IT.CODIGO = f_cod_tipo_intervalo),
       -- MOTORISTA
       F_IF(CM.CPF IS NULL, 'MOTORISTA NÃO CADASTRADO', CM.NOME)    AS NOME_MOTORISTA,
       F_IF(INT_MOT.DATA_HORA_INICIO IS NOT NULL,
            TO_CHAR(INT_MOT.DATA_HORA_INICIO AT TIME ZONE f_time_zone_unidade, 'DD/MM/YYYY HH24:mi:ss'),
            'NÃO MARCADO'),
       F_IF(INT_MOT.DATA_HORA_FIM IS NOT NULL,
            TO_CHAR(INT_MOT.DATA_HORA_FIM AT TIME ZONE f_time_zone_unidade, 'DD/MM/YYYY HH24:mi:ss'),
            'NÃO MARCADO'),
       F_IF(
               F_IF(INT_MOT.DEVICE_IMEI_INICIO_RECONHECIDO AND INT_MOT.DEVICE_IMEI_FIM_RECONHECIDO, TRUE, FALSE),
               'SIM',
               'NÃO' :: TEXT)                                       AS MARCACOES_RECONHECIDAS_MOT,
       -- AJUDANTE 1
       F_IF(CA1.CPF IS NULL, 'AJUDANTE 1 NÃO CADASTRADO', CA1.NOME) AS NOME_AJUDANTE_1,
       F_IF(INT_AJ1.DATA_HORA_INICIO IS NOT NULL,
            TO_CHAR(INT_AJ1.DATA_HORA_INICIO AT TIME ZONE f_time_zone_unidade, 'DD/MM/YYYY HH24:mi:ss'),
            'NÃO MARCADO'),
       F_IF(INT_AJ1.DATA_HORA_FIM IS NOT NULL,
            TO_CHAR(INT_AJ1.DATA_HORA_FIM AT TIME ZONE f_time_zone_unidade, 'DD/MM/YYYY HH24:mi:ss'),
            'NÃO MARCADO'),
       F_IF(
               F_IF(INT_AJ1.DEVICE_IMEI_INICIO_RECONHECIDO AND INT_AJ1.DEVICE_IMEI_FIM_RECONHECIDO, TRUE, FALSE),
               'SIM',
               'NÃO' :: TEXT)                                       AS MARCACOES_RECONHECIDAS_AJ1,
       -- AJUDANTE 2
       F_IF(CA2.CPF IS NULL, 'AJUDANTE 1 NÃO CADASTRADO', CA2.NOME) AS NOME_AJUDANTE_2,
       F_IF(INT_AJ2.DATA_HORA_INICIO IS NOT NULL,
            TO_CHAR(INT_AJ2.DATA_HORA_INICIO AT TIME ZONE f_time_zone_unidade, 'DD/MM/YYYY HH24:mi:ss'),
            'NÃO MARCADO'),
       F_IF(INT_AJ2.DATA_HORA_FIM IS NOT NULL,
            TO_CHAR(INT_AJ2.DATA_HORA_FIM AT TIME ZONE f_time_zone_unidade, 'DD/MM/YYYY HH24:mi:ss'),
            'NÃO MARCADO'),
       F_IF(
               F_IF(INT_AJ2.DEVICE_IMEI_INICIO_RECONHECIDO AND INT_AJ2.DEVICE_IMEI_FIM_RECONHECIDO, TRUE, FALSE),
               'SIM',
               'NÃO' :: TEXT)                                       AS MARCACOES_RECONHECIDAS_AJ2
FROM ESCALA_DIARIA AS ED
         LEFT JOIN COLABORADOR AS CM ON CM.CPF = ED.CPF_MOTORISTA
         LEFT JOIN COLABORADOR AS CA1 ON CA1.CPF = ED.CPF_AJUDANTE_1
         LEFT JOIN COLABORADOR AS CA2 ON CA2.CPF = ED.CPF_AJUDANTE_2
         LEFT JOIN TABLE_INTERVALOS INT_MOT
                   ON (COALESCE(INT_MOT.data_hora_inicio, INT_MOT.data_hora_fim) AT TIME ZONE
                       f_time_zone_unidade) :: DATE =
                      ED.data
                       AND INT_MOT.cpf_colaborador = ED.cpf_motorista
         LEFT JOIN TABLE_INTERVALOS INT_AJ1
                   ON (COALESCE(INT_AJ1.data_hora_inicio, INT_AJ1.data_hora_fim) AT TIME ZONE
                       f_time_zone_unidade) :: DATE =
                      ED.data
                       AND INT_AJ1.cpf_colaborador = ED.cpf_ajudante_1
         LEFT JOIN TABLE_INTERVALOS INT_AJ2
                   ON (COALESCE(INT_AJ2.data_hora_inicio, INT_AJ2.data_hora_fim) AT TIME ZONE
                       f_time_zone_unidade) :: DATE =
                      ED.data
                       AND INT_AJ2.cpf_colaborador = ED.cpf_ajudante_2

WHERE (ED.DATA >= f_data_inicial AND ED.DATA <= f_data_final)
  AND ED.COD_UNIDADE = F_COD_UNIDADE;
$$;

create or replace function public.func_garante_regional_existe(f_cod_regional bigint) returns void
    language plpgsql
as
$$
BEGIN
    IF NOT EXISTS(SELECT R.CODIGO
                  FROM REGIONAL R
                  WHERE R.CODIGO = F_COD_REGIONAL)
    THEN
        RAISE EXCEPTION 'Regional de código % não existe!', F_COD_REGIONAL;
    END IF;
END;
$$;

create or replace function public.func_garante_not_null(f_value anyelement, f_field_name text) returns void
    language plpgsql
as
$$
BEGIN
    IF (F_VALUE IS NULL)
    THEN
        RAISE EXCEPTION '% não pode ser nulo', F_FIELD_NAME;
    END IF;
END;
$$;

create or replace function public.func_garante_pilares_validos(f_pilares_verificacao integer[]) returns void
    language plpgsql
as
$$
DECLARE
    PILARES_VALIDOS INTEGER[] := ARRAY [1, 2, 3, 4, 5];
BEGIN
    IF NOT (F_PILARES_VERIFICACAO <@ PILARES_VALIDOS)
    THEN
        RAISE EXCEPTION 'Apenas os pilares % são válidos', ARRAY_TO_STRING(PILARES_VALIDOS, ', ');
    END IF;
END;
$$;

create or replace function public.is_timezone(tz text) returns boolean
    stable
    language plpgsql
as
$$
DECLARE
    DATE TIMESTAMPTZ;
BEGIN
    DATE := NOW() AT TIME ZONE TZ;
    RETURN TRUE;
EXCEPTION
    WHEN OTHERS THEN
        RETURN FALSE;
END;
$$;

create or replace function suporte.func_unidade_cadastra_unidade(f_cod_empresa bigint, f_cod_regional bigint,
                                                                 f_nome_unidade text, f_timezone text,
                                                                 f_pilares_liberados integer[],
                                                                 OUT aviso_unidade_cadastrada text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_CADASTRADAS BIGINT;
    COD_UNIDADE_CADASTRADA BIGINT;
    MAX_LENGTH_COLUMN      INTEGER := 40;
    COD_PILAR_GENTE        INTEGER := 3;
BEGIN
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);
    PERFORM FUNC_GARANTE_REGIONAL_EXISTE(F_COD_REGIONAL);
    PERFORM FUNC_GARANTE_NOT_NULL(F_NOME_UNIDADE, 'Nome Unidade');
    PERFORM FUNC_GARANTE_NOT_NULL(F_TIMEZONE, 'Timezone');
    PERFORM FUNC_GARANTE_NOT_NULL(F_PILARES_LIBERADOS, 'Pilares Liberados');
    PERFORM FUNC_GARANTE_PILARES_VALIDOS(F_PILARES_LIBERADOS);

    -- Todas as unidades devem ter o pilar GENTE.
    SELECT ARRAY_APPEND(F_PILARES_LIBERADOS, COD_PILAR_GENTE) INTO F_PILARES_LIBERADOS;
    -- Após adicionar o pilar GENTE, removemos do array qualquer valor duplicado.
    SELECT ARRAY_DISTINCT(F_PILARES_LIBERADOS) INTO F_PILARES_LIBERADOS;

    -- Garante que nome unidade não tenha mais do que 40 caracteres.
    IF (LENGTH(TRIM_AND_REMOVE_EXTRA_SPACES(F_NOME_UNIDADE)) > MAX_LENGTH_COLUMN)
    THEN
        RAISE EXCEPTION 'O nome da unidade não pode ter mais do que % caracteres', MAX_LENGTH_COLUMN;
    END IF;

    -- Garante que unidade com mesmo nome não exista para a mesma empresa.
    IF (LOWER(UNACCENT(TRIM_AND_REMOVE_EXTRA_SPACES(F_NOME_UNIDADE))) IN
        (SELECT LOWER(UNACCENT(TRIM_AND_REMOVE_EXTRA_SPACES(U.NOME)))
         FROM UNIDADE U
         WHERE U.COD_EMPRESA = F_COD_EMPRESA))
    THEN
        RAISE EXCEPTION 'Já existe uma unidade com nome % cadastrada para a empresa %',
            TRIM_AND_REMOVE_EXTRA_SPACES(F_NOME_UNIDADE),
            F_COD_EMPRESA;
    END IF;

    -- Garante que o timezone informado exista.
    IF (NOT IS_TIMEZONE(F_TIMEZONE))
    THEN
        RAISE EXCEPTION '% não é um timezone válido', F_TIMEZONE;
    END IF;

    -- Insere a unidade.
    INSERT INTO UNIDADE (NOME, TIMEZONE, COD_REGIONAL, COD_EMPRESA)
    VALUES (F_NOME_UNIDADE, F_TIMEZONE, F_COD_REGIONAL, F_COD_EMPRESA) RETURNING CODIGO INTO COD_UNIDADE_CADASTRADA;

    -- Verifica se insert de unidade funcionou.
    IF (COD_UNIDADE_CADASTRADA <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao cadastrar unidade de nome: %', F_NOME_UNIDADE;
    END IF;

    -- Insere os pilares.
    INSERT INTO UNIDADE_PILAR_PROLOG (COD_UNIDADE, COD_PILAR)
    SELECT COD_UNIDADE_CADASTRADA,
           UNNEST(F_PILARES_LIBERADOS);

    GET DIAGNOSTICS QTD_LINHAS_CADASTRADAS = ROW_COUNT;

    -- Verifica se insert de pilares funcionou.
    IF (QTD_LINHAS_CADASTRADAS <= 0)
    THEN
        RAISE EXCEPTION 'Erro ao liberar pilares para a unidade de nome: %', F_NOME_UNIDADE;
    END IF;

    SELECT 'UNIDADE CADASTRADA: '
               || F_NOME_UNIDADE
               || ', CÓDIGO UNIDADE: '
               || COD_UNIDADE_CADASTRADA
               || ', E PILARES: '
               || ARRAY_TO_STRING(F_PILARES_LIBERADOS, ', ')
    INTO AVISO_UNIDADE_CADASTRADA;
END ;
$$;

create or replace function public.coalesce_percentage(f_dividendo double precision, f_divisor double precision) returns text
    language plpgsql
as
$$
BEGIN
    RETURN COALESCE(TRUNC(F_DIVIDENDO / NULLIF(F_DIVISOR, 0) * 100) || '%', '0%');
END;
$$;

create or replace function public.func_relatorio_aderencia_intervalo_dias(f_cod_unidade bigint, f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "DATA"                     character varying,
                "QT MAPAS"                 bigint,
                "QT MOTORISTAS"            bigint,
                "QT INTERVALOS MOTORISTAS" bigint,
                "ADERÊNCIA MOTORISTAS"     text,
                "QT AJUDANTES"             bigint,
                "QT INTERVALOS AJUDANTES"  bigint,
                "ADERÊNCIA AJUDANTES"      text,
                "QT INTERVALOS PREVISTOS"  bigint,
                "QT INTERVALOS REALIZADOS" bigint,
                "ADERÊNCIA DIA"            text
            )
    language sql
as
$$
SELECT to_char(V.DATA, 'DD/MM/YYYY'),
       COUNT(V.MAPA)                                                              as mapas,
       SUM(f_if(v.cpf_motorista is not null, 1, 0))                               as qt_motoristas,
       SUM(f_if(v.tempo_decorrido_minutos_mot <> '-', 1, 0))                      as qt_intervalos_mot,
       COALESCE_PERCENTAGE(SUM(f_if(v.tempo_decorrido_minutos_mot <> '-', 1, 0)) :: FLOAT,
                           SUM(f_if(v.cpf_motorista is not null, 1, 0)) :: FLOAT) as aderencia_motoristas,
       SUM(f_if(v.cpf_aj1 is not null, 1, 0)) +
       SUM(f_if(v.cpf_aj2 is not null, 1, 0))                                     as numero_ajudantes,
       SUM(f_if(v.tempo_decorrido_minutos_aj1 <> '-', 1, 0)) +
       SUM(f_if(v.tempo_decorrido_minutos_aj2 <> '-', 1, 0))                      as qt_intervalos_aj,
       COALESCE_PERCENTAGE(
                   SUM(f_if(v.tempo_decorrido_minutos_aj1 <> '-', 1, 0)) +
                   SUM(f_if(v.tempo_decorrido_minutos_aj2 <> '-', 1, 0)) :: FLOAT,
                   SUM(f_if(v.cpf_aj1 is not null, 1, 0)) +
                   SUM(f_if(v.cpf_aj2 is not null, 1, 0)) :: FLOAT)               as aderencia_ajudantes,
       SUM(f_if(v.tempo_decorrido_minutos_aj1 <> '-', 1, 0)) +
       SUM(V.intervalos_previstos)                                                as qt_intervalos_previstos,
       SUM(V.INTERVALOS_realizados)                                               as qt_intervalos_realizados,
       COALESCE_PERCENTAGE(SUM(V.intervalos_realizados) :: FLOAT,
                           SUM(V.intervalos_previstos) :: FLOAT)                  as aderencia_dia
FROM view_extrato_mapas_versus_intervalos V
         JOIN unidade u on u.codigo = v.cod_unidade
         JOIN empresa e on e.codigo = u.cod_empresa
WHERE V.cod_unidade = f_cod_unidade
  AND V.data BETWEEN f_data_inicial AND f_data_final
GROUP BY V.DATA
ORDER BY V.DATA
$$;

create or replace function suporte.func_movimentacao_altera_km_movimentacao(f_cod_movimentacao bigint,
                                                                            f_placa character varying,
                                                                            f_km_atualizado integer,
                                                                            OUT aviso_km_atualizado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS  BIGINT;
    TIPO                    TEXT    := 'EM_USO';
    MOVIMENTACAO_ATUALIZADA TEXT;
    EXISTE_DESTINO          BOOLEAN := TRUE;
    EXISTE_ORIGEM           BOOLEAN := TRUE;
BEGIN
    PERFORM FUNC_GARANTE_PLACA_CADASTRADA(F_PLACA);
    PERFORM FUNC_GARANTE_NOVO_KM_MENOR_QUE_ATUAL_VEICULO(
                        (SELECT V.COD_UNIDADE FROM VEICULO V WHERE V.PLACA = F_PLACA),
                        F_PLACA,
                        F_KM_ATUALIZADO);

    --VERIFICA SE A PLACA AINDA ESTÁ NA EMPRESA QUE FOI REALIZADA A MOVIMENTACAO.
    IF ((SELECT U.COD_EMPRESA
         FROM UNIDADE U
         WHERE U.CODIGO = (SELECT V.COD_UNIDADE FROM VEICULO V WHERE V.PLACA = F_PLACA)) !=
        (SELECT U.COD_EMPRESA
         FROM UNIDADE U
         WHERE U.CODIGO = (SELECT M.COD_UNIDADE FROM MOVIMENTACAO M WHERE M.CODIGO = F_COD_MOVIMENTACAO)))
    THEN
        RAISE EXCEPTION 'A PLACA % NÃO ESTÁ MAIS NA EMPRESA %.',
            F_PLACA,
            (SELECT E.NOME
             FROM EMPRESA E
             WHERE E.CODIGO = (SELECT U.COD_EMPRESA
                               FROM UNIDADE U
                               WHERE U.CODIGO =
                                     (SELECT M.COD_UNIDADE FROM MOVIMENTACAO M WHERE M.CODIGO = F_COD_MOVIMENTACAO)));
    END IF;

    --VERIFICA SE KM É NULL OU IGUAL A 0
    IF (F_KM_ATUALIZADO IS NULL OR F_KM_ATUALIZADO <= 0)
    THEN
        RAISE EXCEPTION 'O VALOR ATRIBUÍDO PARA QUILOMETRAGEM NÃO PODE SER VAZIO OU MENOR OU IGUAL A ZERO(0).';
    END IF;

    --VERIFICA SE COD_MOVIMENTACAO É NULL
    IF (F_COD_MOVIMENTACAO IS NULL)
    THEN
        RAISE EXCEPTION 'O VALOR ATRIBUÍDO PARA CÓDIGO MOVIMENTAÇÃO NÃO PODE SER VAZIO.';
    END IF;

    --VERIFICA SE OS DADOS EXISTEM NA TABELA MOVIMENTACAO_DESTINO E, CASO NÃO ENCONTRE, SETA A FLAG.
    IF NOT EXISTS(
            SELECT MD.COD_MOVIMENTACAO
            FROM MOVIMENTACAO_DESTINO MD
            WHERE MD.COD_MOVIMENTACAO = F_COD_MOVIMENTACAO
              AND MD.PLACA = F_PLACA
              AND MD.TIPO_DESTINO = TIPO
        )
    THEN
        EXISTE_DESTINO = FALSE;
    END IF;

    --VERIFICA SE OS DADOS EXISTEM NA TABELA MOVIMENTACAO_ORIGEM E, CASO NÃO ENCONTRE, SETA A FLAG.
    IF NOT EXISTS(
            SELECT MO.COD_MOVIMENTACAO
            FROM MOVIMENTACAO_ORIGEM MO
            WHERE MO.COD_MOVIMENTACAO = F_COD_MOVIMENTACAO
              AND MO.PLACA = F_PLACA
              AND MO.TIPO_ORIGEM = TIPO
        )
    THEN
        EXISTE_ORIGEM = FALSE;
    END IF;

    --VERIFICA SE HÁ INCONSISTÊNCIA NO BANCO.
    IF (EXISTE_DESTINO AND EXISTE_ORIGEM)
    THEN
        RAISE EXCEPTION 'HÁ UMA INCONSISTÊNCIA NO BANCO, A MOVIMENTACAO COM CÓDIGO % TEM O TIPO "EM USO" TANTO NA
             MOVIMENTAÇÃO ORIGEM QUANTO NA MOVIMENTAÇÃO DESTINO.', F_COD_MOVIMENTACAO;
    END IF;

    --VERIFICA SE A MOVIMENTAÇÃO EXISTE NAS TABELAS MOVIMENTACAO_DESTINO E MOVIMENTACAO_ORIGEM.
    IF (EXISTE_DESTINO IS FALSE AND EXISTE_ORIGEM IS FALSE)
    THEN
        RAISE EXCEPTION 'NÃO FOI POSSÍVEL ATUALIZAR A QUILOMETRAGEM! FAVOR VERIFICAR OS SEGUINTES DADOS:
                          CODIGO MOVIMENTAÇÃO: %, PLACA: %',
            F_COD_MOVIMENTACAO, F_PLACA;
    END IF;

    --VERIFICA SE A MOVIMENTAÇÃO EXISTE NAS TABELAS MOVIMENTACAO_DESTINO E MOVIMENTACAO_ORIGEM.
    IF (EXISTE_DESTINO IS FALSE AND EXISTE_ORIGEM IS FALSE)
    THEN
        RAISE EXCEPTION 'NÃO FOI POSSÍVEL ATUALIZAR A QUILOMETRAGEM! FAVOR VERIFICAR OS SEGUINTES DADOS:
                          CODIGO MOVIMENTAÇÃO: %, PLACA: %',
            F_COD_MOVIMENTACAO, F_PLACA;
    END IF;

    -- REALIZA UPDATE NA TABELA CORRESPONDENTE
    IF (EXISTE_DESTINO AND EXISTE_ORIGEM IS FALSE)
    THEN
        UPDATE MOVIMENTACAO_DESTINO
        SET KM_VEICULO = F_KM_ATUALIZADO
        WHERE COD_MOVIMENTACAO = F_COD_MOVIMENTACAO
          AND PLACA = F_PLACA
          AND TIPO_DESTINO = TIPO;
        MOVIMENTACAO_ATUALIZADA = 'DESTINO';
        GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;
    ELSE
        IF (EXISTE_DESTINO IS FALSE AND EXISTE_ORIGEM)
        THEN
            UPDATE MOVIMENTACAO_ORIGEM
            SET KM_VEICULO = F_KM_ATUALIZADO
            WHERE COD_MOVIMENTACAO = F_COD_MOVIMENTACAO
              AND PLACA = F_PLACA
              AND TIPO_ORIGEM = TIPO;
            MOVIMENTACAO_ATUALIZADA = 'ORIGEM';
            GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;
        END IF;
    END IF;

    IF (QTD_LINHAS_ATUALIZADAS > 0)
    THEN
        SELECT 'ATUALIZAÇÃO REALIZADA COM SUCESSO EM MOVIMENTAÇÃO '
                   || MOVIMENTACAO_ATUALIZADA
                   || '! CÓDIGO MOVIMENTAÇÃO: '
                   || F_COD_MOVIMENTACAO
                   || ', PLACA: '
                   || F_PLACA
                   || ', KM_VEICULO: '
                   || F_KM_ATUALIZADO
        INTO AVISO_KM_ATUALIZADO;
    ELSE
        RAISE EXCEPTION 'NÃO FOI POSSÍVEL ATUALIZAR A QUILOMETRAGEM! FAVOR, VERIFICAR OS SEGUINTES DADOS:
                          CODIGO MOVIMENTAÇÃO: %, PLACA: % ' ,
            F_COD_MOVIMENTACAO, F_PLACA;

    END IF;
END
$$;

create or replace function public.tg_func_os_fechamento_massivo_os() returns trigger
    language plpgsql
as
$$
DECLARE
    TEM_VALOR_NULL                  BOOLEAN := (NEW.CPF_MECANICO IS NULL OR
                                                NEW.DATA_HORA_FIM_RESOLUCAO IS NULL OR
                                                NEW.DATA_HORA_INICIO_RESOLUCAO IS NULL OR
                                                NEW.TEMPO_REALIZACAO IS NULL OR
                                                NEW.PLACA_VEICULO IS NULL OR
                                                NEW.DATA_HORA_CONSERTO IS NULL OR
                                                NEW.FEEDBACK_CONSERTO IS NULL OR
                                                NEW.COD_UNIDADE IS NULL OR
                                                NEW.COD_OS IS NULL OR
                                                NEW.COD_PERGUNTA IS NULL OR
                                                NEW.COD_ALTERNATIVA IS NULL);
    KM_VEICULO                      BIGINT  := (CASE
                                                    WHEN NEW.KM IS NULL THEN (SELECT V.KM
                                                                              FROM VEICULO V
                                                                              WHERE V.PLACA = NEW.PLACA_VEICULO) END);
    STATUS_RESOLUCAO_COSI_REALIZADO TEXT    := 'R';
    STATUS_RESOLUCAO_COSI_PENDENTE  TEXT    := 'P';
    STATUS_COS_FECHADO              TEXT    := 'F';
    STATUS_COS_ABERTO               TEXT    := 'A';
    QTD_ERROS                       BIGINT  := 0;
    SOMA_ERRO                       BIGINT  := 1;
    NENHUM_ERRO                     BIGINT  := 0;
    MSGS_ERROS                      TEXT;
    CODIGO_EMPRESA                  BIGINT  := (SELECT U.COD_EMPRESA
                                                FROM UNIDADE U
                                                WHERE U.CODIGO = NEW.COD_UNIDADE);
BEGIN
    NEW.USUARIO := SESSION_USER;
    NEW.DATA_HORA_SOLICITACAO := NOW()::TIMESTAMP WITH TIME ZONE;

    --VERIFICA INFORMAÇÕES
    IF (TEM_VALOR_NULL)
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - EXISTEM CAMPOS SEM PREENCHIMENTO');
    END IF;

    ---VERIFICA SE UNIDADE ESTÁ CADASTRADA
    IF ((NEW.COD_UNIDADE IS NOT NULL)
        AND NOT EXISTS(SELECT U.CODIGO FROM UNIDADE U WHERE U.CODIGO = NEW.COD_UNIDADE))
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - UNIDADE NÃO CADASTRADA');
    END IF;

    ---VERIFICA SE O COLABORADOR (MECÂNICO) EXISTE
    IF ((NEW.CPF_MECANICO IS NOT NULL) AND
        NOT EXISTS(SELECT C.CPF FROM COLABORADOR C WHERE C.CPF = NEW.CPF_MECANICO))
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - MECÂNICO NÃO CADASTRADO');
    END IF;

    ---VERIFICA SE O COLABORADOR (MECÂNICO) É DA EMPRESA
    IF ((NEW.CPF_MECANICO IS NOT NULL) AND
        NOT EXISTS(SELECT C.CPF FROM COLABORADOR C WHERE C.CPF = NEW.CPF_MECANICO AND C.COD_EMPRESA = CODIGO_EMPRESA))
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - MECÂNICO NÃO É DA EMPRESA');
    END IF;

    ---VERIFICA SE PLACA ESTÁ CADASTRADA
    IF ((NEW.PLACA_VEICULO IS NOT NULL) AND
        NOT EXISTS(SELECT V.PLACA FROM VEICULO V WHERE V.PLACA = NEW.PLACA_VEICULO))
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - PLACA NÃO ESTÁ CADASTRADA');
    END IF;

    ---VERIFICA SE COD_OS EXISTE
    IF ((NEW.COD_OS IS NOT NULL AND NEW.COD_UNIDADE IS NOT NULL) AND
        NOT EXISTS(SELECT COS.CODIGO FROM CHECKLIST_ORDEM_SERVICO COS WHERE COS.CODIGO = NEW.COD_OS))
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - CODIGO DA ORDEM DE SERVIÇO NÃO EXISTE');
        --VERIFICAÇÕES SE A OS EXISTIR
    ELSEIF ((NEW.COD_OS IS NOT NULL) AND EXISTS(SELECT COSI.COD_OS
                                                FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                                WHERE COSI.COD_OS = NEW.COD_OS))
    THEN
        ---VERIFICA SE OS PERTENCE À UNIDADE
        IF ((NEW.COD_UNIDADE IS NOT NULL) AND
            NOT EXISTS(SELECT COS.CODIGO
                       FROM CHECKLIST_ORDEM_SERVICO COS
                       WHERE COS.CODIGO = NEW.COD_OS
                         AND COS.COD_UNIDADE = NEW.COD_UNIDADE
                         AND COS.STATUS = STATUS_COS_ABERTO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS,
                                ' - NÃO EXISTE ORDEM DE SERVIÇO ABERTA PARA A UNIDADE INFORMADA');
        END IF;

        ---VERIFICA SE O ITEM ESTÁ COM STATUS PENDENTE
        IF ((NEW.COD_OS IS NOT NULL AND NEW.COD_PERGUNTA IS NOT NULL AND NEW.COD_ALTERNATIVA IS NOT NULL) AND
            NOT EXISTS(SELECT COSI.CODIGO
                       FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                       WHERE COSI.COD_OS = NEW.COD_OS
                         AND COSI.COD_PERGUNTA = NEW.COD_PERGUNTA
                         AND COSI.COD_ALTERNATIVA = NEW.COD_ALTERNATIVA
                         AND COSI.STATUS_RESOLUCAO = STATUS_RESOLUCAO_COSI_PENDENTE))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - O ITEM JÁ ESTAVA FECHADO');
        END IF;

        ---VERIFICA SE OS ESTÁ ABERTA
        IF NOT EXISTS(SELECT COS.CODIGO
                      FROM CHECKLIST_ORDEM_SERVICO COS
                      WHERE COS.CODIGO = NEW.COD_OS
                        AND COS.STATUS = STATUS_COS_ABERTO)
        THEN
            IF EXISTS(SELECT COSI.STATUS_RESOLUCAO
                      FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                      WHERE COSI.STATUS_RESOLUCAO = STATUS_RESOLUCAO_COSI_PENDENTE
                        AND COSI.COD_OS = NEW.COD_OS
                        AND COSI.COD_UNIDADE = NEW.COD_UNIDADE)
            THEN
                UPDATE CHECKLIST_ORDEM_SERVICO
                SET STATUS = STATUS_COS_ABERTO
                WHERE CODIGO = NEW.COD_OS
                  AND COD_UNIDADE = NEW.COD_UNIDADE;
                QTD_ERROS = QTD_ERROS + SOMA_ERRO;
                MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS,
                                    ' - ORDEM DE SERVIÇO ESTAVA FECHADA MAS POSSUÍA ITENS PENDENTES');
            END IF;
        ELSE
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - ORDEM DE SERVIÇO JÁ ESTAVA FECHADA');
        END IF;
    END IF;

    ---VERIFICA SE A PERGUNTA ESTÁ CONTIDA NA ORDEM DE SERVIÇO ITENS
    IF ((NEW.COD_PERGUNTA IS NOT NULL) AND
        NOT EXISTS(SELECT COSI.COD_PERGUNTA
                   FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                   WHERE COSI.COD_OS = NEW.COD_OS
                     AND COSI.COD_PERGUNTA = NEW.COD_PERGUNTA))
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS, ' - NÃO EXISTE PERGUNTA PARA A ORDEM DE SERVIÇO INFORMADA');
    END IF;

    ---VERIFICA SE A ALTERNATIVA ESTÁ CONTIDA NA ORDEM DE SERCIÇO ITENS
    IF ((NEW.COD_PERGUNTA IS NOT NULL AND NEW.COD_ALTERNATIVA IS NOT NULL) AND
        NOT EXISTS(SELECT COSI.COD_ALTERNATIVA
                   FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                   WHERE COSI.COD_OS = NEW.COD_OS
                     AND COSI.COD_PERGUNTA = NEW.COD_PERGUNTA
                     AND COSI.COD_ALTERNATIVA = NEW.COD_ALTERNATIVA))
    THEN
        QTD_ERROS = QTD_ERROS + SOMA_ERRO;
        MSGS_ERROS = CONCAT(MSGS_ERROS, CHR(10), QTD_ERROS,
                            ' - NÃO EXISTE ALTERNATIVA PARA A ORDEM DE SERVIÇO E PERGUNTA INFORMADOS');
    END IF;


    IF (QTD_ERROS > NENHUM_ERRO)
    THEN
        NEW.STATUS_FECHADO := FALSE;
        NEW.MENSAGEM_STATUS := CONCAT('QUANTIDADE DE ERROS: ', QTD_ERROS, chr(10), MSGS_ERROS);
    ELSEIF (NOT TEM_VALOR_NULL OR QTD_ERROS = NENHUM_ERRO)
    THEN
        UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
        SET CPF_MECANICO               = NEW.CPF_MECANICO,
            DATA_HORA_FIM_RESOLUCAO    = NEW.DATA_HORA_FIM_RESOLUCAO,
            DATA_HORA_INICIO_RESOLUCAO = NEW.DATA_HORA_INICIO_RESOLUCAO,
            TEMPO_REALIZACAO           = NEW.TEMPO_REALIZACAO,
            KM                         = KM_VEICULO,
            DATA_HORA_CONSERTO         = NEW.DATA_HORA_CONSERTO,
            FEEDBACK_CONSERTO          = NEW.FEEDBACK_CONSERTO,
            STATUS_RESOLUCAO           = STATUS_RESOLUCAO_COSI_REALIZADO
        WHERE COD_UNIDADE = NEW.COD_UNIDADE
          AND COD_OS = NEW.COD_OS
          AND COD_PERGUNTA = NEW.COD_PERGUNTA
          AND COD_ALTERNATIVA = NEW.COD_ALTERNATIVA;

        UPDATE CHECKLIST_ORDEM_SERVICO_DATA
        SET STATUS               = STATUS_COS_FECHADO,
            DATA_HORA_FECHAMENTO = NOW()
        WHERE COD_UNIDADE = NEW.COD_UNIDADE
          AND CODIGO NOT IN
              (SELECT COD_OS
               FROM CHECKLIST_ORDEM_SERVICO_ITENS
               WHERE COD_UNIDADE = NEW.COD_UNIDADE
                 AND CPF_MECANICO IS NULL);
        NEW.STATUS_FECHADO := TRUE;
        NEW.MENSAGEM_STATUS := 'FECHADA';
    ELSE
        RAISE EXCEPTION 'ERRO AO FECHAR ORDEM DE SERVIÇO';
    END IF;
    RETURN NEW;
END
$$;

create or replace function public.func_checklist_os_relatorio_itens_maior_quantidade_nok(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                unidade               text,
                "MODELO CHECKLIST"    text,
                pergunta              text,
                alternativa           text,
                prioridade            text,
                "TOTAL MARCAÇÕES NOK" bigint,
                "TOTAL REALIZAÇÕES"   bigint,
                "PROPORÇÃO"           text
            )
    language sql
as
$$
SELECT Q.NOME_UNIDADE          AS NOME_UNIDADE,
       Q.NOME_MODELO_CHECKLIST AS NOME_MODELO_CHECKLIST,
       Q.PERGUNTA              AS PERGUNTA,
       Q.ALTERNATIVA           AS ALTERNATIVA,
       Q.PRIORIDADE            AS PRIORIDADE,
       Q.TOTAL_MARCACOES_NOK   AS TOTAL_MARCACOES_NOK,
       Q.TOTAL_REALIZACOES     AS TOTAL_REALIZACOES,
       Q.PROPORCAO_NUM || '%'  AS PROPORCAO
FROM (SELECT U.NOME                                                         AS NOME_UNIDADE,
             CM.NOME                                                        AS NOME_MODELO_CHECKLIST,
             CP.PERGUNTA                                                    AS PERGUNTA,
             CAP.ALTERNATIVA                                                AS ALTERNATIVA,
             CAP.PRIORIDADE                                                 AS PRIORIDADE,
             COUNT(CRN.CODIGO)                                              AS TOTAL_MARCACOES_NOK,
             COUNT(DISTINCT C.CODIGO)                                       AS TOTAL_REALIZACOES,
             TRUNC(((COUNT(CRN.CODIGO)
                 / COUNT(DISTINCT C.CODIGO) :: FLOAT) * 100) :: NUMERIC, 2) AS PROPORCAO_NUM
      FROM CHECKLIST C
               -- O JOIN é feito pelo código do modelo e não da versão pois queremos saber as proporções de
               -- respostas NOK em todas as versões de cada modelo.
               JOIN CHECKLIST_PERGUNTAS CP
                    ON CP.COD_CHECKLIST_MODELO = C.COD_CHECKLIST_MODELO
               JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                    ON CP.CODIGO = CAP.COD_PERGUNTA
               LEFT JOIN CHECKLIST_RESPOSTAS_NOK CRN
                         ON C.CODIGO = CRN.COD_CHECKLIST AND CAP.CODIGO = CRN.COD_ALTERNATIVA
               JOIN CHECKLIST_MODELO CM
                    ON CM.CODIGO = C.COD_CHECKLIST_MODELO
               JOIN UNIDADE U ON C.COD_UNIDADE = U.CODIGO
      WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
        AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
        AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
      GROUP BY U.NOME, CAP.PRIORIDADE, CP.PERGUNTA, CAP.ALTERNATIVA, CM.NOME, C.COD_CHECKLIST_MODELO) Q
ORDER BY Q.NOME_UNIDADE, Q.PROPORCAO_NUM DESC, Q.TOTAL_MARCACOES_NOK DESC, Q.PERGUNTA;
$$;

create or replace function public.func_pneu_altera_status_pneu(f_cod_empresa bigint, f_cod_unidade bigint,
                                                               f_quantidade_pneus bigint,
                                                               OUT aviso_status_atualizado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    F_STATUS_ATUALIZADO    TEXT    := 'EM_USO';
    F_STATUS_ATUAL         TEXT    := 'ESTOQUE';
    QTD_LINHAS_ATUALIZADAS BIGINT;
    F_VALIDA_CONDICOES     BOOLEAN := FALSE;
BEGIN

    --EXECUTA VALIDAÇÕES
    IF (F_VALIDA_CONDICOES IS FALSE)
    THEN
        --VERIFICA SE EMPRESA EXISTE.
        PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

        --VERIFICA SE UNIDADE EXISTE.
        PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

        --VERIFICA SE EMPRESA POSSUI UNIDADE.
        PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE);

        --VERIFICA SE A QUANTIDADE DE PNEUS É MAIOR QUE 0(ZERO).
        IF (F_QUANTIDADE_PNEUS < 0)
        THEN
            RAISE EXCEPTION 'A QUANTIDADE DE PNEUS INFORMADA: % DEVE SER MAIOR/DIFERENTE DE 0(ZERO)!'
                , F_QUANTIDADE_PNEUS;
        END IF;

        F_VALIDA_CONDICOES = TRUE;
    END IF;

    --EXECUTA UPDATE NA TABELA.
    IF (F_VALIDA_CONDICOES)
    THEN
        UPDATE PNEU_DATA
        SET STATUS = F_STATUS_ATUALIZADO
        WHERE COD_EMPRESA = F_COD_EMPRESA
          AND COD_UNIDADE = F_COD_UNIDADE
          AND STATUS = F_STATUS_ATUAL
          AND CODIGO IN (SELECT COD_PNEU FROM VEICULO_PNEU);

        GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

        --VERIFICA SE A QUANTIDADE DE LINHAS ATUALIZADAS É IGUAL A DE PNEUS A SEREM ATUALIZADOS.
        IF (QTD_LINHAS_ATUALIZADAS != F_QUANTIDADE_PNEUS)
        THEN
            RAISE EXCEPTION 'ERRO AO ATUALIZAR! A QUANTIDADE DE PNEUS: % NÃO É A MESMA DE LINHAS AFETADAS: % '
                'NA ATUALIZAÇÃO!', F_QUANTIDADE_PNEUS, QTD_LINHAS_ATUALIZADAS;
        END IF;
    END IF;

    --MENSAGEM DE SUCESSO.
    SELECT 'ATUALIZADO COM SUCESSO! NÚMERO TOTAL DE: ' || F_QUANTIDADE_PNEUS || ' PNEUS.'
    INTO AVISO_STATUS_ATUALIZADO;
END
$$;

create or replace function public.func_garante_integridade_empresa_colaborador(f_cod_empresa bigint, f_cpf_colaborador bigint) returns void
    language plpgsql
as
$$
BEGIN
    --VERIFICA SE COLABORADOR EXISTE
    PERFORM FUNC_GARANTE_COLABORADOR_EXISTE(F_CPF_COLABORADOR);

    --VERIFICA SE EMPRESA EXISTE
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

    -- VERIFICA SE O COLABORADOR PERTENCE À EMPRESA.
    IF NOT EXISTS(SELECT C.CPF
                  FROM COLABORADOR C
                  WHERE C.CPF = F_CPF_COLABORADOR
                    AND C.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'O colaborador com CPF: %, nome: %, não pertence a empresa: % - %!',
            F_CPF_COLABORADOR,
                (SELECT C.NOME FROM COLABORADOR C WHERE C.CPF = F_CPF_COLABORADOR),
            F_COD_EMPRESA,
                (SELECT E.NOME FROM EMPRESA E WHERE E.CODIGO = F_COD_EMPRESA);
    END IF;
END;
$$;

create or replace function public.func_garante_cargo_existe(f_cod_empresa bigint, f_cod_funcao bigint) returns void
    language plpgsql
as
$$
BEGIN
    -- VERIFICA SE A FUNCAO EXISTE
    IF NOT EXISTS(SELECT F.CODIGO FROM FUNCAO F WHERE F.CODIGO = F_COD_FUNCAO AND F.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'A funcao de codigo: % não existe na empresa: %.', F_COD_FUNCAO,
                (SELECT E.NOME FROM EMPRESA E WHERE E.CODIGO = F_COD_EMPRESA);
    END IF;
END;
$$;

create or replace function suporte.func_colaborador_transfere_entre_empresas(f_cod_unidade_origem bigint,
                                                                             f_cpf_colaborador bigint,
                                                                             f_cod_unidade_destino integer,
                                                                             f_cod_empresa_destino bigint,
                                                                             f_cod_setor_destino bigint,
                                                                             f_cod_equipe_destino bigint,
                                                                             f_cod_funcao_destino integer,
                                                                             f_matricula_trans integer DEFAULT NULL::integer,
                                                                             f_matricula_ambev integer DEFAULT NULL::integer,
                                                                             f_nivel_permissao integer DEFAULT 0,
                                                                             OUT aviso_colaborador_transferido text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    EMPRESA_ORIGEM BIGINT := (SELECT U.COD_EMPRESA AS EMPRESA_ORIGEM
                              FROM UNIDADE U
                              WHERE U.CODIGO = F_COD_UNIDADE_ORIGEM);
BEGIN
    -- VERIFICA SE EMPRESA ORIGEM/DESTINO SÃO DISTINTAS
    PERFORM FUNC_GARANTE_EMPRESAS_DISTINTAS(EMPRESA_ORIGEM, F_COD_EMPRESA_DESTINO);

    -- VERIFICA SE UNIDADE DESTINO EXISTE E SE PERTENCE A EMPRESA.
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_UNIDADE(F_COD_EMPRESA_DESTINO, F_COD_UNIDADE_DESTINO);

    --VERIFICA SE O COLABORADOR ESTÁ CADASTRADO E SE PERTENCE A UNIDADE ORIGEM.
    PERFORM FUNC_GARANTE_INTEGRIDADE_UNIDADE_COLABORADOR(F_COD_UNIDADE_ORIGEM, F_CPF_COLABORADOR);

    -- VERIFICA SE O SETOR EXISTE NA UNIDADE DESTINO.
    PERFORM FUNC_GARANTE_SETOR_EXISTE(F_COD_UNIDADE_DESTINO, F_COD_SETOR_DESTINO);

    -- VERIFICA SE A EQUIPE EXISTE NA UNIDADE DESTINO.
    PERFORM FUNC_GARANTE_EQUIPE_EXISTE(F_COD_UNIDADE_DESTINO, F_COD_EQUIPE_DESTINO);

    -- VERIFICA SE A FUNÇÃO EXISTE NA EMPRESA DESTINO.
    PERFORM FUNC_GARANTE_CARGO_EXISTE(F_COD_EMPRESA_DESTINO, F_COD_FUNCAO_DESTINO);

    -- VERIFICA SE PERMISSÃO EXISTE
    IF NOT EXISTS(SELECT P.CODIGO FROM PERMISSAO P WHERE P.CODIGO = F_NIVEL_PERMISSAO)
    THEN
        RAISE EXCEPTION 'Não existe permissão com o código: %', F_NIVEL_PERMISSAO;
    END IF;

    -- TRANSFERE COLABORADOR
    UPDATE COLABORADOR
    SET COD_UNIDADE     = F_COD_UNIDADE_DESTINO,
        COD_EMPRESA     = F_COD_EMPRESA_DESTINO,
        COD_SETOR       = F_COD_SETOR_DESTINO,
        COD_EQUIPE      = F_COD_EQUIPE_DESTINO,
        COD_FUNCAO      = F_COD_FUNCAO_DESTINO,
        MATRICULA_TRANS = F_MATRICULA_TRANS,
        MATRICULA_AMBEV = F_MATRICULA_AMBEV,
        COD_PERMISSAO   = F_NIVEL_PERMISSAO
    WHERE CPF = F_CPF_COLABORADOR
      AND COD_UNIDADE = F_COD_UNIDADE_ORIGEM;

    SELECT ('COLABORADOR: '
                || (SELECT C.NOME FROM COLABORADOR C WHERE C.CPF = F_CPF_COLABORADOR)
                || ' , TRANSFERIDO PARA A UNIDADE: '
        || (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_DESTINO))
    INTO AVISO_COLABORADOR_TRANSFERIDO;
END;
$$;

create or replace function public.func_pneu_altera_status_pneu_vinculado(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                         f_quantidade_pneus bigint,
                                                                         OUT aviso_status_atualizado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    F_STATUS_PNEU_VINCULADO TEXT := 'EM_USO';
    F_STATUS_ATUAL          TEXT := 'ESTOQUE';
    QTD_LINHAS_ATUALIZADAS  BIGINT;
BEGIN
    --VERIFICA SE EMPRESA EXISTE.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

    --VERIFICA SE UNIDADE EXISTE.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    --VERIFICA SE EMPRESA POSSUI UNIDADE.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE);

    --EXECUTA UPDATE NA TABELA.
    UPDATE PNEU_DATA
    SET STATUS = F_STATUS_PNEU_VINCULADO
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND COD_UNIDADE = F_COD_UNIDADE
      AND STATUS = F_STATUS_ATUAL
      AND CODIGO IN (SELECT COD_PNEU FROM VEICULO_PNEU);

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    --VERIFICA SE A QUANTIDADE DE LINHAS ATUALIZADAS É IGUAL A DE PNEUS A SEREM ATUALIZADOS.
    IF (QTD_LINHAS_ATUALIZADAS != F_QUANTIDADE_PNEUS)
    THEN
        RAISE EXCEPTION 'ERRO AO ATUALIZAR! A QUANTIDADE DE PNEUS: % NÃO É A MESMA DE LINHAS AFETADAS: % '
            'NA ATUALIZAÇÃO!', F_QUANTIDADE_PNEUS, QTD_LINHAS_ATUALIZADAS;
    ELSE
        --MENSAGEM DE SUCESSO.
        SELECT 'ATUALIZADO COM SUCESSO! NÚMERO TOTAL DE: ' || F_QUANTIDADE_PNEUS || ' PNEUS.'
        INTO AVISO_STATUS_ATUALIZADO;
    END IF;
END
$$;

CREATE OR REPLACE FUNCTION FUNC_COLABORADOR_VERIFICA_PERMISSOES(F_PERMISSOES_COLABORADOR INTEGER[],
                                                                F_PERMISSSOES_NECESSARIAS INTEGER[],
                                                                F_PRECISA_TER_TODAS_AS_PERMISSOES BOOLEAN)
    RETURNS TABLE
            (
                TOKEN_VALIDO      BOOLEAN,
                POSSUI_PERMISSSAO BOOLEAN
            )
    LANGUAGE PLPGSQL
AS
$$
BEGIN
    -- Se permissões colaborador for null, então o token não existe.
    IF F_PERMISSOES_COLABORADOR IS NULL
    THEN
        RETURN QUERY
            SELECT FALSE AS TOKEN_VALIDO,
                   FALSE AS POSSUI_PERMISSAO;
        -- Sem esse RETURN para barrar a execução a query pode acabar retornando duas linhas.
        RETURN;
    END IF;

    -- PERMISSOES_COLABORADOR contains F_PERMISSSOES_NECESSARIAS
    IF (F_PRECISA_TER_TODAS_AS_PERMISSOES AND F_PERMISSOES_COLABORADOR @> F_PERMISSSOES_NECESSARIAS)
        OR
        -- PERMISSOES_COLABORADOR overlap (have elements in common) F_PERMISSSOES_NECESSARIAS
       (NOT F_PRECISA_TER_TODAS_AS_PERMISSOES AND F_PERMISSOES_COLABORADOR && F_PERMISSSOES_NECESSARIAS)
    THEN
        RETURN QUERY
            SELECT TRUE AS TOKEN_VALIDO,
                   TRUE AS POSSUI_PERMISSAO;
    ELSE
        RETURN QUERY
            SELECT TRUE  AS TOKEN_VALIDO,
                   FALSE AS POSSUI_PERMISSAO;
    END IF;
END;
$$;

create or replace function func_colaborador_verifica_permissoes_token(f_token text,
                                                                      f_permisssoes_necessarias integer[],
                                                                      f_precisa_ter_todas_as_permissoes boolean,
                                                                      f_apenas_usuarios_ativos boolean)
    returns table
            (
                token_valido      boolean,
                possui_permisssao boolean,
                cpf_colaborador   bigint,
                cod_colaborador   bigint
            )
    language plpgsql
as
$$
declare
    v_permissoes_colaborador integer[];
    v_cpf_colaborador        bigint;
    v_cod_colaborador        bigint;
begin
    select array_agg(cfp.cod_funcao_prolog),
           c.cpf,
           c.codigo
    from token_autenticacao ta
             join colaborador c on c.cpf = ta.cpf_colaborador
        -- Usando um LEFT JOIN aqui, caso o token não exista nada será retornado, porém, se o
        -- token existir mas o usuário não tiver nenhuma permissão, será retornando um array
        -- contendo null.
             left join cargo_funcao_prolog_v11 cfp
                       on cfp.cod_unidade = c.cod_unidade
                           and cfp.cod_funcao_colaborador = c.cod_funcao
    where ta.token = f_token
      and f_if(f_apenas_usuarios_ativos, c.status_ativo = true, true)
    group by c.cpf, c.codigo
    into v_permissoes_colaborador, v_cpf_colaborador, v_cod_colaborador;

    return query
        select f.token_valido      as token_valido,
               f.possui_permisssao as possui_permissao,
               v_cpf_colaborador   as cpf_colaborador,
               v_cod_colaborador   as cod_colaborador
        from func_colaborador_verifica_permissoes(
                     v_permissoes_colaborador,
                     f_permisssoes_necessarias,
                     f_precisa_ter_todas_as_permissoes) f;
end;
$$;

create or replace function
    func_colaborador_verifica_permissoes_cpf_data_nascimento(f_cpf bigint,
                                                             f_data_nascimento date,
                                                             f_permisssoes_necessarias integer[],
                                                             f_precisa_ter_todas_as_permissoes boolean,
                                                             f_apenas_usuarios_ativos boolean)
    returns table
            (
                token_valido      boolean,
                possui_permisssao boolean,
                cpf_colaborador   bigint,
                cod_colaborador   bigint
            )
    language plpgsql
as
$$
declare
    v_permissoes_colaborador integer[];
    v_cpf_colaborador        bigint;
    v_cod_colaborador        bigint;
begin
    select array_agg(cfp.cod_funcao_prolog),
           c.cpf,
           c.codigo
    from colaborador c
             -- Usando um LEFT JOIN aqui, caso o token não exista nada será retornado, porém, se o
             -- token existir mas o usuário não tiver nenhuma permissão, será retornando um array
             -- contendo null.
             left join cargo_funcao_prolog_v11 cfp
                       on cfp.cod_unidade = c.cod_unidade
                           and cfp.cod_funcao_colaborador = c.cod_funcao
    where c.cpf = f_cpf
      and c.data_nascimento = f_data_nascimento
      and f_if(f_apenas_usuarios_ativos, c.status_ativo = true, true)
    group by c.cpf, c.codigo
    into v_permissoes_colaborador, v_cpf_colaborador, v_cod_colaborador;

    return query
        select f.token_valido      as token_valido,
               f.possui_permisssao as possui_permissao,
               v_cpf_colaborador   as cpf_colaborador,
               v_cod_colaborador   as cod_colaborador
        from func_colaborador_verifica_permissoes(
                     v_permissoes_colaborador,
                     f_permisssoes_necessarias,
                     f_precisa_ter_todas_as_permissoes) f;
end;
$$;

create or replace function public.func_relatorio_pneus_descartados(f_cod_unidade text[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE DO DESCARTE"          text,
                "RESPONSÁVEL PELO DESCARTE"    text,
                "DATA/HORA DO DESCARTE"        text,
                "CÓDIGO DO PNEU"               text,
                "MARCA DO PNEU"                text,
                "MODELO DO PNEU"               text,
                "MARCA DA BANDA"               text,
                "MODELO DA BANDA"              text,
                "DIMENSÃO DO PNEU"             text,
                "ÚLTIMA PRESSÃO"               text,
                "TOTAL DE VIDAS"               text,
                "ALTURA SULCO INTERNO"         text,
                "ALTURA SULCO CENTRAL INTERNO" text,
                "ALTURA SULCO CENTRAL EXTERNO" text,
                "ALTURA SULCO EXTERNO"         text,
                "MENOR SULCO"                  text,
                "DOT"                          text,
                "MOTIVO DO DESCARTE"           text,
                "FOTO 1"                       text,
                "FOTO 2"                       text,
                "FOTO 3"                       text
            )
    language sql
as
$$
SELECT U.NOME                                                                          AS UNIDADE_DO_DESCARTE,
       C.NOME                                                                          AS RESPONSAVEL_PELO_DESCARTE,
       TO_CHAR(MP.DATA_HORA AT TIME ZONE tz_unidade(P.COD_UNIDADE),
               'DD/MM/YYYY HH24:MI')                                                   AS DATA_HORA_DESCARTE,
       P.CODIGO_CLIENTE                                                                AS CODIGO_PNEU,
       MAP.NOME                                                                        AS MARCA_PNEU,
       MOP.NOME                                                                        AS MODELO_PNEU,
       MAB.NOME                                                                        AS MARCA_BANDA,
       MOB.NOME                                                                        AS MODELO_BANDA,
       'Altura: ' || DP.ALTURA || ' - Largura: ' || DP.LARGURA || ' - Aro: ' || DP.ARO AS DIMENSAO_PNEU,
       REPLACE(COALESCE(TRUNC(P.PRESSAO_ATUAL) :: TEXT, '-'), '.', ',')                AS ULTIMA_PRESSAO,
       P.VIDA_ATUAL :: TEXT                                                            AS TOTAL_VIDAS,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_INTERNO)                                  AS SULCO_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_INTERNO)                          AS SULCO_CENTRAL_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_EXTERNO)                          AS SULCO_CENTRAL_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_EXTERNO)                                  AS SULCO_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(LEAST(P.ALTURA_SULCO_EXTERNO, P.ALTURA_SULCO_CENTRAL_EXTERNO,
                                    P.ALTURA_SULCO_CENTRAL_INTERNO,
                                    P.ALTURA_SULCO_INTERNO))                           AS MENOR_SULCO,
       P.DOT                                                                           AS DOT,
       MMDE.MOTIVO                                                                     AS MOTIVO_DESCARTE,
       MD.URL_IMAGEM_DESCARTE_1                                                        AS FOTO_1,
       MD.URL_IMAGEM_DESCARTE_2                                                        AS FOTO_2,
       MD.URL_IMAGEM_DESCARTE_3                                                        AS FOTO_3
FROM PNEU P
         JOIN MODELO_PNEU MOP ON P.COD_MODELO = MOP.CODIGO
         JOIN MARCA_PNEU MAP ON MOP.COD_MARCA = MAP.CODIGO
         JOIN DIMENSAO_PNEU DP ON P.COD_DIMENSAO = DP.CODIGO
         JOIN UNIDADE U ON P.COD_UNIDADE = U.CODIGO
         LEFT JOIN MODELO_BANDA MOB ON P.COD_MODELO_BANDA = MOB.CODIGO
         LEFT JOIN MARCA_BANDA MAB ON MOB.COD_MARCA = MAB.CODIGO
         LEFT JOIN MOVIMENTACAO_PROCESSO MP ON P.COD_UNIDADE = MP.COD_UNIDADE
         LEFT JOIN MOVIMENTACAO M ON MP.CODIGO = M.COD_MOVIMENTACAO_PROCESSO
         LEFT JOIN MOVIMENTACAO_DESTINO MD ON M.CODIGO = MD.COD_MOVIMENTACAO
         LEFT JOIN COLABORADOR C ON MP.CPF_RESPONSAVEL = C.CPF
         LEFT JOIN MOVIMENTACAO_MOTIVO_DESCARTE_EMPRESA MMDE
                   ON MD.COD_MOTIVO_DESCARTE = MMDE.CODIGO AND C.COD_EMPRESA = MMDE.COD_EMPRESA
WHERE P.COD_UNIDADE :: TEXT LIKE ANY (F_COD_UNIDADE)
  AND P.STATUS = 'DESCARTE'
  AND M.COD_PNEU = P.CODIGO
  AND MD.TIPO_DESTINO = 'DESCARTE'
  AND (MP.DATA_HORA AT TIME ZONE tz_unidade(MP.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
  AND (MP.DATA_HORA AT TIME ZONE tz_unidade(MP.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
ORDER BY U.NOME;
$$;

create or replace function public.func_marcacao_get_tipo_marcacao(f_cod_tipo_marcacao bigint)
    returns TABLE
            (
                codigo_tipo_intervalo             bigint,
                codigo_tipo_intervalo_por_unidade bigint,
                nome_tipo_intervalo               character varying,
                cod_unidade                       bigint,
                ativo                             boolean,
                horario_sugerido                  time without time zone,
                icone                             character varying,
                tempo_estouro_minutos             bigint,
                tempo_recomendado_minutos         bigint,
                tipo_jornada                      boolean,
                cod_auxiliar                      text
            )
    language sql
as
$$
SELECT IT.CODIGO                            AS CODIGO_TIPO_INTERVALO,
       IT.CODIGO_TIPO_INTERVALO_POR_UNIDADE AS CODIGO_TIPO_INTERVALO_POR_UNIDADE,
       IT.NOME                              AS NOME_TIPO_INTERVALO,
       IT.COD_UNIDADE                       AS COD_UNIDADE,
       IT.ATIVO                             AS ATIVO,
       IT.HORARIO_SUGERIDO                  AS HORARIO_SUGERIDO,
       IT.ICONE                             AS ICONE,
       IT.TEMPO_ESTOURO_MINUTOS             AS TEMPO_ESTOURO_MINUTOS,
       IT.TEMPO_RECOMENDADO_MINUTOS         AS TEMPO_RECOMENDADO_MINUTOS,
       IT.TIPO_JORNADA                      AS TIPO_JORNADA,
       IT.COD_AUXILIAR                      AS COD_AUXILIAR
FROM VIEW_INTERVALO_TIPO IT
WHERE IT.CODIGO = F_COD_TIPO_MARCACAO;
$$;

create or replace function public.func_marcacao_get_tipos_marcacoes(f_cod_unidade bigint, f_apenas_ativos boolean)
    returns TABLE
            (
                codigo_tipo_intervalo             bigint,
                codigo_tipo_intervalo_por_unidade bigint,
                nome_tipo_intervalo               character varying,
                cod_unidade                       bigint,
                ativo                             boolean,
                horario_sugerido                  time without time zone,
                icone                             character varying,
                tempo_estouro_minutos             bigint,
                tempo_recomendado_minutos         bigint,
                tipo_jornada                      boolean,
                cod_auxiliar                      text
            )
    language sql
as
$$
SELECT DISTINCT IT.CODIGO                            AS CODIGO_TIPO_INTERVALO,
                IT.CODIGO_TIPO_INTERVALO_POR_UNIDADE AS CODIGO_TIPO_INTERVALO_POR_UNIDADE,
                IT.NOME                              AS NOME_TIPO_INTERVALO,
                IT.COD_UNIDADE,
                IT.ATIVO,
                IT.HORARIO_SUGERIDO,
                IT.ICONE,
                IT.TEMPO_ESTOURO_MINUTOS,
                IT.TEMPO_RECOMENDADO_MINUTOS,
                IT.TIPO_JORNADA,
                IT.COD_AUXILIAR
FROM VIEW_INTERVALO_TIPO IT
WHERE IT.COD_UNIDADE = F_COD_UNIDADE
  AND CASE
          WHEN F_APENAS_ATIVOS IS TRUE
              THEN IT.ATIVO = TRUE
          ELSE TRUE END
ORDER BY IT.ATIVO DESC, IT.NOME ASC;
$$;

create or replace function public.func_marcacao_relatorio_exportacao_generica(f_cod_unidade bigint,
                                                                              f_cod_tipo_intervalo bigint,
                                                                              f_cod_colaborador bigint,
                                                                              f_apenas_marcacoes_ativas boolean,
                                                                              f_data_inicial date, f_data_final date)
    returns TABLE
            (
                pis           text,
                evento        text,
                data          text,
                hora          text,
                numerorelogio text
            )
    language plpgsql
as
$$
DECLARE
    TZ_UNIDADE TEXT := TZ_UNIDADE(F_COD_UNIDADE);
BEGIN
    RETURN QUERY
        SELECT LPAD(C.PIS :: TEXT, 11, '0')                             AS PIS,
               COALESCE(IT.COD_AUXILIAR, '00')                          AS EVENTO,
               TO_CHAR(I.DATA_HORA AT TIME ZONE TZ_UNIDADE, 'DDMMYYYY') AS DATA,
               TO_CHAR(I.DATA_HORA AT TIME ZONE TZ_UNIDADE, 'HH24mi')   AS HORA,
               COALESCE(U.COD_AUXILIAR, '00')                           AS NUMERORELOGIO
        FROM INTERVALO I
                 JOIN COLABORADOR C ON I.CPF_COLABORADOR = C.CPF
                 JOIN INTERVALO_TIPO IT ON I.COD_UNIDADE = IT.COD_UNIDADE AND I.COD_TIPO_INTERVALO = IT.CODIGO
                 JOIN UNIDADE U ON I.COD_UNIDADE = U.CODIGO
        WHERE I.COD_UNIDADE = F_COD_UNIDADE
          AND (I.DATA_HORA AT TIME ZONE TZ_UNIDADE) :: DATE >= F_DATA_INICIAL
          AND (I.DATA_HORA AT TIME ZONE TZ_UNIDADE) :: DATE <= F_DATA_FINAL
          AND C.PIS IS NOT NULL
          AND C.PIS <> ''
          AND F_IF(F_COD_COLABORADOR IS NULL, TRUE, C.CODIGO = F_COD_COLABORADOR)
          AND F_IF(F_COD_TIPO_INTERVALO IS NULL, TRUE, IT.CODIGO = F_COD_TIPO_INTERVALO)
          AND F_IF(F_APENAS_MARCACOES_ATIVAS IS NULL, TRUE, I.STATUS_ATIVO);
END;
$$;

create or replace function piccolotur.func_check_os_resolve_item_pendente(f_cod_unidade_item_os bigint,
                                                                          f_cod_os_globus bigint,
                                                                          f_cod_item_resolvido_globus bigint,
                                                                          f_cpf_colaborador_resolucao bigint,
                                                                          f_placa_veiculo_item_os text,
                                                                          f_km_coletado_resolucao bigint,
                                                                          f_duracao_resolucao_ms bigint,
                                                                          f_feedback_resolucao text,
                                                                          f_data_hora_resolvido_prolog timestamp with time zone,
                                                                          f_data_hora_inicio_resolucao timestamp with time zone,
                                                                          f_data_hora_fim_resolucao timestamp with time zone,
                                                                          f_token_integracao text,
                                                                          f_data_hora_sincronia_resolucao timestamp with time zone) returns bigint
    language plpgsql
as
$$
DECLARE
    STATUS_ITEM_OS_PENDENTE       TEXT   := 'P';
    COD_ITEM_RESOLVIDO_PROLOG     BIGINT;
    COD_RETORNO_SUCESSO           BIGINT := 1;
    F_QTD_ROWS_ITENS_OS           BIGINT;
    F_QTD_ROWS_VINCULOS_ALTERADOS BIGINT;
BEGIN
    -- Antes de processarmos a resolução de Itens de O.S., validamos todos os códigos de vínculo possíveis.
    -- Por segurança, verificamos se a integração está fechando os itens de o.s. que pertencem a empresa correta.
    IF (F_COD_UNIDADE_ITEM_OS NOT IN (SELECT CODIGO
                                      FROM PUBLIC.UNIDADE
                                      WHERE COD_EMPRESA = (SELECT TI.COD_EMPRESA
                                                           FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                           WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE VÍNCULO] O token "%s" não está autorizado a inserir dados da unidade "%s"',
                               F_TOKEN_INTEGRACAO,
                               F_COD_UNIDADE_ITEM_OS));
    END IF;

    -- Validamos se o código do item fechado no Globus, está mapeado no ProLog.
    IF (SELECT EXISTS(SELECT COD_ITEM_OS_PROLOG
                      FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
                      WHERE COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS
                        AND COD_OS_GLOBUS = F_COD_OS_GLOBUS
                        AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS))
    THEN
        SELECT COD_ITEM_OS_PROLOG
        FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
        WHERE COD_OS_GLOBUS = F_COD_OS_GLOBUS
          AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS
          AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
        INTO COD_ITEM_RESOLVIDO_PROLOG;
    ELSE
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE VÍNCULO] O item "%s" da O.S. "%s" não possuí vínculo no ProLog',
                               F_COD_ITEM_RESOLVIDO_GLOBUS,
                               F_COD_OS_GLOBUS));
    END IF;

    -- Validamos se o item mapeado está pendente no ProLog. Caso já está resolvido, apenas retorna sucesso.
    IF (SELECT COSID.STATUS_RESOLUCAO
        FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO COSIV
                 JOIN CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSID
                      ON COSIV.COD_ITEM_OS_PROLOG = COSID.CODIGO
        WHERE COD_OS_GLOBUS = F_COD_OS_GLOBUS
          AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS) != STATUS_ITEM_OS_PENDENTE
    THEN
        RETURN COD_RETORNO_SUCESSO;
    END IF;

    -- Validamos se o usuário está na base de dados do ProLog, podendo estar em qualquer unidade da empresa integrada.
    IF (SELECT NOT EXISTS(SELECT C.CODIGO
                          FROM PUBLIC.COLABORADOR C
                          WHERE C.CPF = F_CPF_COLABORADOR_RESOLUCAO
                            AND C.COD_EMPRESA = (SELECT U.COD_EMPRESA
                                                 FROM PUBLIC.UNIDADE U
                                                 WHERE U.CODIGO = F_COD_UNIDADE_ITEM_OS)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O CPF "%s" não encontra-se cadastrado no ProLog',
                                                  PUBLIC.FORMAT_CPF(F_CPF_COLABORADOR_RESOLUCAO)));
    END IF;

    -- Validamos se a placa é a mesma do item pendente mapeado no ProLog.
    IF ((SELECT PLACA_VEICULO_OS
         FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
         WHERE COD_OS_GLOBUS = F_COD_OS_GLOBUS
           AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
           AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS) != F_PLACA_VEICULO_ITEM_OS)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('A placa "%s" não bate com a placa do item pendente "%s" do ProLog',
                               F_PLACA_VEICULO_ITEM_OS,
                               COD_ITEM_RESOLVIDO_PROLOG));
    END IF;

    -- Depois de validar podemos resolver o item.
    UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
    SET CPF_MECANICO               = F_CPF_COLABORADOR_RESOLUCAO,
        KM                         = F_KM_COLETADO_RESOLUCAO,
        STATUS_RESOLUCAO           = 'R',
        TEMPO_REALIZACAO           = F_DURACAO_RESOLUCAO_MS,
        DATA_HORA_CONSERTO         = F_DATA_HORA_RESOLVIDO_PROLOG,
        FEEDBACK_CONSERTO          = F_FEEDBACK_RESOLUCAO,
        DATA_HORA_INICIO_RESOLUCAO = F_DATA_HORA_INICIO_RESOLUCAO,
        DATA_HORA_FIM_RESOLUCAO    = F_DATA_HORA_FIM_RESOLUCAO
    WHERE CODIGO = COD_ITEM_RESOLVIDO_PROLOG;

    -- O ATRIBUTO 'ROW_COUNT' CONTERÁ A QUANTIDADE DE LINHAS QUE FORAM ATUALIZADAS PELO UPDATE ACIMA. A FUNCITON
    -- IRÁ RETORNAR ESSE ATRIBUTO PARA QUE POSSAMOS VALIDAR SE TODOS OS UPDATES ACONTECERAM COMO DEVERIAM.
    GET DIAGNOSTICS F_QTD_ROWS_ITENS_OS = ROW_COUNT;

    -- SE APÓS O UPDATE NENHUMA LINHA FOR ALTERADA, SIGNIFICA QUE O UPDATE NÃO EXECUTOU CORRETAMENTE.
    -- LANÇAMOS AQUI UMA EXCEÇÃO PARA RASTREAR ESSE ERRO.
    IF F_QTD_ROWS_ITENS_OS <= 0
    THEN
        RAISE EXCEPTION 'Não foi possível resolver o item do ProLog "%s"', COD_ITEM_RESOLVIDO_PROLOG;
    END IF;

    -- Vamos fechar a O.S. caso todos os itens dela já estejam resolvidos.
    UPDATE CHECKLIST_ORDEM_SERVICO_DATA
    SET STATUS               = 'F',
        DATA_HORA_FECHAMENTO = F_DATA_HORA_RESOLVIDO_PROLOG
    WHERE CODIGO = F_COD_OS_GLOBUS
      AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
      AND (SELECT COUNT(*)
           FROM PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS COSI
           WHERE COSI.COD_OS = F_COD_OS_GLOBUS
             AND COSI.COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
             AND COSI.STATUS_RESOLUCAO = 'P') = 0;

    -- Para finalizar, atualizamos a tabela de vínculo marcando o item como resolvido.
    UPDATE PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
    SET DATA_HORA_SINCRONIA_RESOLUCAO = F_DATA_HORA_SINCRONIA_RESOLUCAO
    WHERE COD_ITEM_OS_PROLOG = COD_ITEM_RESOLVIDO_PROLOG
      AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS;

    GET DIAGNOSTICS F_QTD_ROWS_VINCULOS_ALTERADOS = ROW_COUNT;

    -- VERIFICAMOS SE O INSERT NA TABELA DE MAPEAMENTO DE ITENS RESOLVIDOS NA INTEGRAÇÃO OCORREU COM ÊXITO.
    IF F_QTD_ROWS_VINCULOS_ALTERADOS <= 0
    THEN
        RAISE EXCEPTION
            'Não foi possível inserir o item do ProLog resolvido na tabela de mapeamento, item "%s"',
            COD_ITEM_RESOLVIDO_PROLOG;
    END IF;

    RETURN F_QTD_ROWS_ITENS_OS;
END;
$$;

create or replace function agendador.tg_notify_configuracao_agendamento() returns trigger
    language plpgsql
as
$$
DECLARE
    JSON_ROW JSON := CASE
                         WHEN TG_OP::TEXT = 'DELETE'
                             THEN ROW_TO_JSON(OLD)
                         ELSE ROW_TO_JSON(NEW)
        END;
BEGIN
    PERFORM PG_NOTIFY('configuracao_agendamento_event', JSON_BUILD_OBJECT('tableName', TG_TABLE_NAME,
                                                                          'operation', TG_OP,
                                                                          'configuracaoAgendamento', JSON_ROW) :: TEXT);

    RETURN NULL;
END;
$$;

create trigger tg_notify_configuracao_agendamento
    after insert or update or delete
    on agendador.configuracao_agendamento
    for each row
execute procedure agendador.tg_notify_configuracao_agendamento();

create or replace function integracao.func_veiculo_insere_veiculo_prolog(f_cod_unidade_veiculo_alocado bigint,
                                                                         f_placa_veiculo_cadastrado text,
                                                                         f_km_atual_veiculo_cadastrado bigint,
                                                                         f_cod_modelo_veiculo_cadastrado bigint,
                                                                         f_cod_tipo_veiculo_cadastrado bigint,
                                                                         f_data_hora_veiculo_cadastro timestamp with time zone,
                                                                         f_token_integracao text) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_VEICULO CONSTANT       BIGINT  := (SELECT TI.COD_EMPRESA
                                                   FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                   WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    DEVE_SOBRESCREVER_VEICULO CONSTANT BOOLEAN := (SELECT *
                                                   FROM INTEGRACAO.FUNC_EMPRESA_GET_CONFIG_SOBRESCREVE_VEICULOS(
                                                                COD_EMPRESA_VEICULO));
    VEICULO_ESTA_NO_PROLOG CONSTANT    BOOLEAN := (SELECT EXISTS(SELECT V.CODIGO
                                                                 FROM PUBLIC.VEICULO_DATA V
                                                                 WHERE V.PLACA::TEXT = F_PLACA_VEICULO_CADASTRADO));
    STATUS_ATIVO_VEICULO CONSTANT      BOOLEAN := TRUE;
    COD_VEICULO_PROLOG                 BIGINT;
    F_QTD_ROWS_ALTERADAS               BIGINT;
BEGIN
    -- Validamos se a Unidade pertence a mesma empresa do token.
    IF ((SELECT U.COD_EMPRESA FROM PUBLIC.UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_VEICULO_ALOCADO)
        <>
        (SELECT TI.COD_EMPRESA
         FROM INTEGRACAO.TOKEN_INTEGRACAO TI
         WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT(
                                '[ERRO DE VÍNCULO] O token "%s" não está autorizado a inserir dados da unidade "%s",
                                 confira se está usando o token correto',
                                F_TOKEN_INTEGRACAO,
                                F_COD_UNIDADE_VEICULO_ALOCADO));
    END IF;

    -- Validamos se o KM foi inputado corretamente.
    IF (F_KM_ATUAL_VEICULO_CADASTRADO < 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE DADOS] A quilometragem do veículo não pode ser um número negativo');
    END IF;

    -- Validamos se o modelo do veículo está mapeado.
    IF (SELECT NOT EXISTS(SELECT CODIGO
                          FROM PUBLIC.MODELO_VEICULO MV
                          WHERE MV.COD_EMPRESA = COD_EMPRESA_VEICULO
                            AND MV.CODIGO = F_COD_MODELO_VEICULO_CADASTRADO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE VINCULO] O modelo do veículo não está mapeado corretamente, verificar vinculos');
    END IF;

    -- Validamos se o tipo do veículo está mapeado.
    IF (SELECT NOT EXISTS(SELECT CODIGO
                          FROM PUBLIC.VEICULO_TIPO VT
                          WHERE VT.CODIGO = F_COD_TIPO_VEICULO_CADASTRADO
                            AND VT.COD_EMPRESA = COD_EMPRESA_VEICULO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE VINCULO] O tipo do veículo não está mapeado corretamente, verificar vinculos');
    END IF;

    -- Validamos se a placa já existe no ProLog.
    IF (VEICULO_ESTA_NO_PROLOG AND NOT DEVE_SOBRESCREVER_VEICULO)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE DADOS] A placa "%s" já está cadastrada no Sistema ProLog',
                               F_PLACA_VEICULO_CADASTRADO));
    END IF;

    IF (VEICULO_ESTA_NO_PROLOG AND DEVE_SOBRESCREVER_VEICULO)
    THEN
        -- Buscamos o código do veículo que será sobrescrito.
        SELECT V.CODIGO
        FROM VEICULO V
        WHERE V.PLACA = F_PLACA_VEICULO_CADASTRADO
          AND V.COD_EMPRESA = COD_EMPRESA_VEICULO
        INTO COD_VEICULO_PROLOG;

        -- Removemos os pneus aplicados na placa, para que ela possa receber novos pneus.
        PERFORM INTEGRACAO.FUNC_PNEU_REMOVE_VINCULO_PNEU_PLACA_POSICAO_BY_PLACA(F_PLACA_VEICULO_CADASTRADO);

        -- Sebrescrevemos os dados do veículo.
        PERFORM INTEGRACAO.FUNC_VEICULO_SOBRESCREVE_VEICULO_CADASTRADO(
                        F_PLACA_VEICULO_CADASTRADO,
                        F_COD_UNIDADE_VEICULO_ALOCADO,
                        F_KM_ATUAL_VEICULO_CADASTRADO,
                        F_COD_TIPO_VEICULO_CADASTRADO,
                        F_COD_MODELO_VEICULO_CADASTRADO);

    ELSE
        -- Aqui devemos apenas inserir o veículo no ProLog.
        INSERT INTO PUBLIC.VEICULO(COD_EMPRESA,
                                   COD_UNIDADE,
                                   PLACA,
                                   KM,
                                   STATUS_ATIVO,
                                   COD_TIPO,
                                   COD_MODELO,
                                   COD_UNIDADE_CADASTRO)
        VALUES (COD_EMPRESA_VEICULO,
                F_COD_UNIDADE_VEICULO_ALOCADO,
                F_PLACA_VEICULO_CADASTRADO,
                F_KM_ATUAL_VEICULO_CADASTRADO,
                STATUS_ATIVO_VEICULO,
                F_COD_TIPO_VEICULO_CADASTRADO,
                F_COD_MODELO_VEICULO_CADASTRADO,
                F_COD_UNIDADE_VEICULO_ALOCADO) RETURNING CODIGO INTO COD_VEICULO_PROLOG;
    END IF;

    IF (DEVE_SOBRESCREVER_VEICULO)
    THEN
        -- Se permite sobrescrita de dados, então tentamos inserir, caso a constraint estourar,
        -- apenas atualizamos os dados. Tentamos inserir antes, pois, em cenários onde o veículo já encontra-se no
        -- ProLog, não temos nenhuma entrada para ele na tabela de mapeamento.
        INSERT INTO INTEGRACAO.VEICULO_CADASTRADO(COD_EMPRESA_CADASTRO,
                                                  COD_UNIDADE_CADASTRO,
                                                  COD_VEICULO_CADASTRO_PROLOG,
                                                  PLACA_VEICULO_CADASTRO,
                                                  DATA_HORA_CADASTRO_PROLOG)
        VALUES (COD_EMPRESA_VEICULO,
                F_COD_UNIDADE_VEICULO_ALOCADO,
                COD_VEICULO_PROLOG,
                F_PLACA_VEICULO_CADASTRADO,
                F_DATA_HORA_VEICULO_CADASTRO)
        ON CONFLICT ON CONSTRAINT UNIQUE_PLACA_CADASTRADA_EMPRESA_INTEGRACAO
            DO UPDATE SET COD_VEICULO_CADASTRO_PROLOG = COD_VEICULO_PROLOG,
                          COD_UNIDADE_CADASTRO        = F_COD_UNIDADE_VEICULO_ALOCADO,
                          DATA_HORA_ULTIMA_EDICAO     = F_DATA_HORA_VEICULO_CADASTRO;
    ELSE
        -- Se não houve sobrescrita de dados, significa que devemos apenas inserir os dados na tabela de mapeamento.
        INSERT INTO INTEGRACAO.VEICULO_CADASTRADO(COD_EMPRESA_CADASTRO,
                                                  COD_UNIDADE_CADASTRO,
                                                  COD_VEICULO_CADASTRO_PROLOG,
                                                  PLACA_VEICULO_CADASTRO,
                                                  DATA_HORA_CADASTRO_PROLOG)
        VALUES (COD_EMPRESA_VEICULO,
                F_COD_UNIDADE_VEICULO_ALOCADO,
                COD_VEICULO_PROLOG,
                F_PLACA_VEICULO_CADASTRADO,
                F_DATA_HORA_VEICULO_CADASTRO);
    END IF;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- VERIFICAMOS SE O INSERT NA TABELA DE MAPEAMENTO DE VEÍCULOS CADASTRADOS NA INTEGRAÇÃO OCORREU COM ÊXITO.
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        RAISE EXCEPTION
            'Não foi possível inserir a placa "%" na tabela de mapeamento', F_PLACA_VEICULO_CADASTRADO;
    END IF;

    RETURN COD_VEICULO_PROLOG;
END;
$$;

create or replace function integracao.func_veiculo_atualiza_veiculo_prolog(f_cod_unidade_original_alocado bigint,
                                                                           f_placa_original_veiculo text,
                                                                           f_novo_cod_unidade_alocado bigint,
                                                                           f_nova_placa_veiculo text,
                                                                           f_novo_km_veiculo bigint,
                                                                           f_novo_cod_modelo_veiculo bigint,
                                                                           f_novo_cod_tipo_veiculo bigint,
                                                                           f_data_hora_edicao_veiculo timestamp with time zone,
                                                                           f_token_integracao text) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_VEICULO     BIGINT := (SELECT TI.COD_EMPRESA
                                       FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                       WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_TIPO_VEICULO_ANTIGO BIGINT := (SELECT VD.COD_TIPO
                                       FROM PUBLIC.VEICULO_DATA VD
                                       WHERE VD.PLACA = F_PLACA_ORIGINAL_VEICULO);
    COD_VEICULO_PROLOG      BIGINT;
    F_QTD_ROWS_ALTERADAS    BIGINT;
BEGIN
    -- Validamos se o usuário trocou a unidade alocada do veículo.
    IF (F_COD_UNIDADE_ORIGINAL_ALOCADO <> F_NOVO_COD_UNIDADE_ALOCADO)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE OPERAÇÃO] Para mudar a Unidade do veículo, utilize a transferência de veículo');
    END IF;

    -- Validamos se o usuário trocou a placa do veículo.
    IF (F_PLACA_ORIGINAL_VEICULO <> F_NOVA_PLACA_VEICULO)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE OPERAÇÃO] O ProLog não permite a edição da placa do veículo');
    END IF;

    -- Validamos se a Unidade do veículo trocou
    IF ((SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO_DATA V WHERE V.PLACA = F_PLACA_ORIGINAL_VEICULO)
        <> F_COD_UNIDADE_ORIGINAL_ALOCADO)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE OPERAÇÃO] Para mudar a Unidade do veículo, utilize a transferência de veículo');
    END IF;

    -- Validamos se a Unidade pertence a mesma empresa do token.
    IF ((SELECT U.COD_EMPRESA FROM PUBLIC.UNIDADE U WHERE U.CODIGO = F_NOVO_COD_UNIDADE_ALOCADO)
        <>
        (SELECT TI.COD_EMPRESA
         FROM INTEGRACAO.TOKEN_INTEGRACAO TI
         WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT(
                                '[ERRO DE VÍNCULO] O token "%s" não está autorizado a atualizar dados da unidade "%s", verificar vínculos',
                                F_TOKEN_INTEGRACAO,
                                F_NOVO_COD_UNIDADE_ALOCADO));
    END IF;

    -- Validamos se a placa já existe no ProLog.
    IF (SELECT NOT EXISTS(SELECT V.CODIGO FROM PUBLIC.VEICULO_DATA V WHERE V.PLACA::TEXT = F_NOVA_PLACA_VEICULO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE DADOS] A placa "%s" não existe no Sistema ProLog', F_NOVA_PLACA_VEICULO));
    END IF;

    -- Validamos se o KM foi inputado corretamente.
    IF (F_NOVO_KM_VEICULO < 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE DADOS] A quilometragem do veículo não pode ser um número negativo');
    END IF;

    -- Validamos se o modelo do veículo está mapeado.
    IF (SELECT NOT EXISTS(SELECT CODIGO
                          FROM PUBLIC.MODELO_VEICULO MV
                          WHERE MV.COD_EMPRESA = COD_EMPRESA_VEICULO
                            AND MV.CODIGO = F_NOVO_COD_MODELO_VEICULO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE VINCULO] O modelo do veículo não está mapeado corretamente, verificar vínculos');
    END IF;

    -- Validamos se o tipo do veículo está mapeado.
    IF (SELECT NOT EXISTS(SELECT CODIGO
                          FROM PUBLIC.VEICULO_TIPO VT
                          WHERE VT.CODIGO = F_NOVO_COD_TIPO_VEICULO
                            AND VT.COD_EMPRESA = COD_EMPRESA_VEICULO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE VINCULO] O tipo do veículo não está mapeado corretamente, verificar vínculos');
    END IF;

    -- Validamos se o tipo foi alterado mesmo com o veículo contendo pneus aplicados.
    IF ((COD_TIPO_VEICULO_ANTIGO <> F_NOVO_COD_TIPO_VEICULO)
        AND (SELECT COUNT(VP.*) FROM PUBLIC.VEICULO_PNEU VP WHERE VP.PLACA = F_PLACA_ORIGINAL_VEICULO) > 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        '[ERRO DE OPERAÇÃO] O tipo do veículo não pode ser alterado se a placa contém pneus aplicados');
    END IF;

    UPDATE PUBLIC.VEICULO_DATA
    SET KM         = F_NOVO_KM_VEICULO,
        COD_MODELO = F_NOVO_COD_MODELO_VEICULO,
        COD_TIPO   = F_NOVO_COD_TIPO_VEICULO
    WHERE PLACA = F_PLACA_ORIGINAL_VEICULO
      AND COD_UNIDADE = F_COD_UNIDADE_ORIGINAL_ALOCADO RETURNING CODIGO INTO COD_VEICULO_PROLOG;

    UPDATE INTEGRACAO.VEICULO_CADASTRADO
    SET DATA_HORA_ULTIMA_EDICAO = F_DATA_HORA_EDICAO_VEICULO
    WHERE COD_EMPRESA_CADASTRO = COD_EMPRESA_VEICULO
      AND PLACA_VEICULO_CADASTRO = F_PLACA_ORIGINAL_VEICULO;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- VERIFICAMOS SE O UPDATE NA TABELA DE MAPEAMENTO DE VEÍCULOS CADASTRADOS NA INTEGRAÇÃO OCORREU COM ÊXITO.
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        RAISE EXCEPTION
            'Não foi possível atualizar a placa "%" na tabela de mapeamento', F_PLACA_ORIGINAL_VEICULO;
    END IF;

    RETURN COD_VEICULO_PROLOG;
END;
$$;

create or replace function integracao.func_veiculo_ativa_desativa_veiculo_prolog(f_placa_veiculo text,
                                                                                 f_ativar_desativar_veiculo boolean,
                                                                                 f_data_hora_edicao_veiculo timestamp with time zone,
                                                                                 f_token_integracao text) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_VEICULO  BIGINT := (SELECT TI.COD_EMPRESA
                                    FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                    WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_UNIDADE_VEICULO  BIGINT := (SELECT V.COD_UNIDADE
                                    FROM PUBLIC.VEICULO V
                                    WHERE V.PLACA = F_PLACA_VEICULO);
    COD_VEICULO_PROLOG   BIGINT;
    F_QTD_ROWS_ALTERADAS BIGINT;
BEGIN
    -- Validamos se a Unidade pertence a mesma empresa do token.
    IF ((SELECT U.COD_EMPRESA
         FROM PUBLIC.VEICULO V
                  JOIN PUBLIC.UNIDADE U ON V.COD_UNIDADE = U.CODIGO
         WHERE V.PLACA = F_PLACA_VEICULO) <> COD_EMPRESA_VEICULO)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT(
                                '[ERRO DE VÍNCULO] O token "%s" não está autorizado a atualizar dados da placa "%s", verificar vínculos',
                                F_TOKEN_INTEGRACAO,
                                F_PLACA_VEICULO));
    END IF;

    -- Validamos se a placa já existe no ProLog.
    IF (SELECT NOT EXISTS(SELECT V.CODIGO FROM PUBLIC.VEICULO_DATA V WHERE V.PLACA::TEXT = F_PLACA_VEICULO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE DADOS] A placa "%s" não existe no Sistema ProLog', F_PLACA_VEICULO));
    END IF;

    UPDATE PUBLIC.VEICULO_DATA
    SET STATUS_ATIVO = F_ATIVAR_DESATIVAR_VEICULO
    WHERE PLACA = F_PLACA_VEICULO
      AND COD_UNIDADE = COD_UNIDADE_VEICULO RETURNING CODIGO INTO COD_VEICULO_PROLOG;

    UPDATE INTEGRACAO.VEICULO_CADASTRADO
    SET DATA_HORA_ULTIMA_EDICAO = F_DATA_HORA_EDICAO_VEICULO
    WHERE COD_EMPRESA_CADASTRO = COD_EMPRESA_VEICULO
      AND PLACA_VEICULO_CADASTRO = F_PLACA_VEICULO;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- VERIFICAMOS SE O UPDATE NA TABELA DE MAPEAMENTO DE VEÍCULOS CADASTRADOS NA INTEGRAÇÃO OCORREU COM ÊXITO.
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        RAISE EXCEPTION
            'Não foi possível ativar/desativar a placa "%" na tabela de mapeamento', F_PLACA_VEICULO;
    END IF;

    RETURN COD_VEICULO_PROLOG;
END;
$$;

create or replace function public.func_veiculo_transferencia_busca_aviso_bloqueio(f_cod_empresa bigint)
    returns TABLE
            (
                cod_empresa                       bigint,
                bloquear_delecao_os_checklist     boolean,
                bloquear_delecao_servicos_pneu    boolean,
                aviso_bloqueio_tela_transferencia text
            )
    language plpgsql
as
$$
DECLARE
    F_BLOQUEAR_DELECAO_OS_CHECKLIST     BOOLEAN;
    F_BLOQUEAR_DELECAO_SERVICOS_PNEU    BOOLEAN;
    F_AVISO_BLOQUEIO_TELA_TRANSFERENCIA TEXT;
    F_AVISO_DEFAULT                     TEXT := '<b>Atenção!</b> Ao transferir um veículo, todas as OSs de ' ||
                                                'checklist e serviços de pneus em aberto serão automaticamente ' ||
                                                'removidos. Isso garante que eles não ficarão em um estado de ' ||
                                                'inconsistência e que não levarão histórico de problemas para uma ' ||
                                                'nova unidade, assim prevenimos que relatórios e dashboards sejam ' ||
                                                'comprometidos.';
BEGIN
    SELECT VTBD.BLOQUEAR_DELECAO_OS_CHECKLIST,
           VTBD.BLOQUEAR_DELECAO_SERVICOS_PNEU,
           VTBD.AVISO_BLOQUEIO_TELA_TRANSFERENCIA
    FROM VEICULO_TRANSFERENCIA_BLOQUEIO_DELECAO_OS VTBD
    WHERE VTBD.COD_EMPRESA = F_COD_EMPRESA
    INTO
        F_BLOQUEAR_DELECAO_OS_CHECKLIST,
        F_BLOQUEAR_DELECAO_SERVICOS_PNEU,
        F_AVISO_BLOQUEIO_TELA_TRANSFERENCIA;

    IF (F_BLOQUEAR_DELECAO_OS_CHECKLIST,
        F_BLOQUEAR_DELECAO_SERVICOS_PNEU,
        F_AVISO_BLOQUEIO_TELA_TRANSFERENCIA) IS NULL
    THEN
        RETURN QUERY
            SELECT F_COD_EMPRESA,
                   FALSE,
                   FALSE,
                   F_AVISO_DEFAULT;
    ELSE
        RETURN QUERY
            SELECT F_COD_EMPRESA,
                   F_BLOQUEAR_DELECAO_OS_CHECKLIST,
                   F_BLOQUEAR_DELECAO_SERVICOS_PNEU,
                   F_AVISO_BLOQUEIO_TELA_TRANSFERENCIA;
    END IF;

END;
$$;

create or replace function public.func_garante_empresa_existe(f_cod_empresa bigint, f_error_message text DEFAULT NULL::text) returns void
    language plpgsql
as
$$
DECLARE
    ERROR_MESSAGE TEXT :=
        F_IF(F_ERROR_MESSAGE IS NULL, FORMAT('Empresa de código %s não existe!', F_COD_EMPRESA), F_ERROR_MESSAGE);
BEGIN
    IF NOT EXISTS(SELECT E.CODIGO
                  FROM EMPRESA E
                  WHERE E.CODIGO = F_COD_EMPRESA)
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;
END;
$$;

create or replace function public.func_garante_unidade_existe(f_cod_unidade bigint, f_error_message text DEFAULT NULL::text) returns void
    language plpgsql
as
$$
DECLARE
    ERROR_MESSAGE TEXT :=
        F_IF(F_ERROR_MESSAGE IS NULL, FORMAT('Unidade de código %s não existe!', F_COD_UNIDADE), F_ERROR_MESSAGE);
BEGIN
    IF NOT EXISTS(SELECT U.CODIGO
                  FROM UNIDADE U
                  WHERE U.CODIGO = F_COD_UNIDADE)
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;
END;
$$;

create or replace function public.func_garante_empresa_possui_unidade(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                      f_error_message text DEFAULT NULL::text) returns void
    language plpgsql
as
$$
DECLARE
    ERROR_MESSAGE TEXT :=
        F_IF(F_ERROR_MESSAGE IS NULL,
             FORMAT('A unidade %s não pertence a empresa %s!', F_COD_UNIDADE, F_COD_EMPRESA),
             F_ERROR_MESSAGE);
BEGIN
    -- Verifica se a unidade é da empresa informada.
    IF NOT EXISTS(SELECT U.CODIGO
                  FROM UNIDADE U
                  WHERE U.CODIGO = F_COD_UNIDADE
                    AND U.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;
END;
$$;

create or replace function public.func_garante_integridade_empresa_unidade(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                           f_error_message text DEFAULT NULL::text) returns void
    language plpgsql
as
$$
BEGIN
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA, F_ERROR_MESSAGE);
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE, F_ERROR_MESSAGE);
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE, F_ERROR_MESSAGE);
END;
$$;

create or replace function integracao.func_pneu_realiza_incremento_vida_cadastro(f_cod_unidade_pneu bigint,
                                                                                 f_cod_pneu_prolog bigint,
                                                                                 f_cod_modelo_banda_pneu bigint,
                                                                                 f_valor_banda_pneu real,
                                                                                 f_vida_nova_pneu integer) returns boolean
    language plpgsql
as
$$
DECLARE
    COD_TIPO_SERVICO_INCREMENTA_VIDA_CADASTRO BIGINT  := (SELECT PTS.CODIGO
                                                          FROM PNEU_TIPO_SERVICO AS PTS
                                                          WHERE PTS.COD_EMPRESA IS NULL
                                                            AND PTS.STATUS_ATIVO = TRUE
                                                            AND PTS.INCREMENTA_VIDA = TRUE
                                                            AND PTS.UTILIZADO_CADASTRO_PNEU = TRUE);
    FONTE_SERVICO_REALIZADO_CADASTRO          TEXT    := 'FONTE_CADASTRO';
    VIDA_MOMENTO_SERVICO_REALIZADO            INTEGER := F_VIDA_NOVA_PNEU - 1;
    IS_PRIMEIRA_VIDA                          BOOLEAN := F_VIDA_NOVA_PNEU < 2;
    F_COD_SERVICO_REALIZADO                   BIGINT;
    F_QTD_ROWS_ALTERADAS                      BIGINT;
BEGIN
    -- Validamos que o pneu pode receber o serviço de incremento de vida.
    IF (IS_PRIMEIRA_VIDA)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        'Não é possível aplicar um serviço de troca de banda em um pneu na primeira vida');
    END IF;

    --  Inserimos o serviço realizado, retornando o código.
    INSERT INTO PUBLIC.PNEU_SERVICO_REALIZADO(COD_TIPO_SERVICO,
                                              COD_UNIDADE,
                                              COD_PNEU,
                                              CUSTO,
                                              VIDA,
                                              FONTE_SERVICO_REALIZADO)
    VALUES (COD_TIPO_SERVICO_INCREMENTA_VIDA_CADASTRO,
            F_COD_UNIDADE_PNEU,
            F_COD_PNEU_PROLOG,
            F_VALOR_BANDA_PNEU,
            VIDA_MOMENTO_SERVICO_REALIZADO,
            FONTE_SERVICO_REALIZADO_CADASTRO) RETURNING CODIGO INTO F_COD_SERVICO_REALIZADO;

    -- Mapeamos o incremento de vida do serviço realizado acima.
    INSERT INTO PUBLIC.PNEU_SERVICO_REALIZADO_INCREMENTA_VIDA(COD_SERVICO_REALIZADO,
                                                              COD_MODELO_BANDA,
                                                              VIDA_NOVA_PNEU,
                                                              FONTE_SERVICO_REALIZADO)
    VALUES (F_COD_SERVICO_REALIZADO,
            F_COD_MODELO_BANDA_PNEU,
            F_VIDA_NOVA_PNEU,
            FONTE_SERVICO_REALIZADO_CADASTRO);

    INSERT INTO PUBLIC.PNEU_SERVICO_CADASTRO(COD_PNEU,
                                             COD_SERVICO_REALIZADO)
    VALUES (F_COD_PNEU_PROLOG,
            F_COD_SERVICO_REALIZADO);

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Verificamos se a criação do serviço de incremento de vida ocorreu com sucesso.
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Não foi possível incrementar a vida do pneu %s', F_COD_PNEU_PROLOG));
    END IF;

    RETURN TRUE;
END;
$$;

create or replace function integracao.func_pneu_atualiza_pneu_prolog(f_cod_pneu_sistema_integrado bigint,
                                                                     f_novo_codigo_pneu_cliente text,
                                                                     f_novo_cod_modelo_pneu bigint,
                                                                     f_novo_cod_dimensao_pneu bigint,
                                                                     f_novo_dot_pneu text, f_novo_valor_pneu real,
                                                                     f_novo_cod_modelo_banda_pneu bigint,
                                                                     f_novo_valor_banda_pneu real,
                                                                     f_data_hora_edicao_pneu timestamp with time zone,
                                                                     f_token_integracao text) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_PNEU     BIGINT  := (SELECT TI.COD_EMPRESA
                                     FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                     WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_PNEU_PROLOG      BIGINT  := (SELECT PC.COD_PNEU_CADASTRO_PROLOG
                                     FROM INTEGRACAO.PNEU_CADASTRADO PC
                                     WHERE PC.COD_PNEU_SISTEMA_INTEGRADO = F_COD_PNEU_SISTEMA_INTEGRADO
                                       AND PC.COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU);
    PNEU_POSSUI_BANDA    BOOLEAN := F_IF(((SELECT P.COD_MODELO_BANDA
                                           FROM PUBLIC.PNEU P
                                           WHERE P.CODIGO = COD_PNEU_PROLOG) IS NULL), FALSE, TRUE);
    TROCOU_BANDA_PNEU    BOOLEAN := F_IF(F_NOVO_COD_MODELO_BANDA_PNEU IS NULL, FALSE, TRUE);
    F_QTD_ROWS_ALTERADAS BIGINT;
BEGIN

    -- Validamos se a Empresa é válida.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_PNEU,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    -- Validamos se o código do pneu no sistema integrado está mapeado na tabela interna do ProLog.
    IF (COD_PNEU_PROLOG IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O pneu de código interno %s não está mapeado no Sistema ProLog',
                                                  F_COD_PNEU_SISTEMA_INTEGRADO));
    END IF;

    -- Validamos se o novo_codigo_cliente é um código válido ou já possui um igual na base dados.
    IF (SELECT EXISTS(SELECT PC.COD_PNEU_CADASTRO_PROLOG
                      FROM INTEGRACAO.PNEU_CADASTRADO PC
                      WHERE PC.COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU
                        AND PC.COD_CLIENTE_PNEU_CADASTRO = F_NOVO_CODIGO_PNEU_CLIENTE
                        AND PC.COD_PNEU_SISTEMA_INTEGRADO != F_COD_PNEU_SISTEMA_INTEGRADO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Já existe um pneu com o código %s cadastrado no Sistema ProLog',
                                                  F_NOVO_CODIGO_PNEU_CLIENTE));
    END IF;

    -- Validamos se o modelo do pneu está mapeado.
    IF (SELECT NOT EXISTS(SELECT MP.CODIGO
                          FROM PUBLIC.MODELO_PNEU MP
                          WHERE MP.COD_EMPRESA = COD_EMPRESA_PNEU
                            AND MP.CODIGO = F_NOVO_COD_MODELO_PNEU))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O modelo do pneu %s não está mapeado', F_NOVO_COD_MODELO_PNEU));
    END IF;

    -- Validamos se a dimensão do pneu está mapeada.
    IF (SELECT NOT EXISTS(SELECT DP.CODIGO
                          FROM PUBLIC.DIMENSAO_PNEU DP
                          WHERE DP.CODIGO = F_NOVO_COD_DIMENSAO_PNEU))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('A dimensão de código %s do pneu não está mapeada',
                                                  F_NOVO_COD_DIMENSAO_PNEU));
    END IF;

    -- Validamos se o valor do pneu é um valor válido.
    IF (F_NOVO_VALOR_PNEU < 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor do pneu não pode ser um número negativo');
    END IF;

    -- Validamos se o pneu possui banda e se ela não foi removida na atualização.
    IF (PNEU_POSSUI_BANDA AND F_NOVO_COD_MODELO_BANDA_PNEU IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('O modelo da banda do pneu deve ser informado');
    END IF;

    -- Validamos se o código do modelo da banda é válido. Apenas validamos se o pneu possuir banda.
    IF (PNEU_POSSUI_BANDA AND (SELECT NOT EXISTS(SELECT MB.CODIGO
                                                 FROM PUBLIC.MODELO_BANDA MB
                                                 WHERE MB.COD_EMPRESA = COD_EMPRESA_PNEU
                                                   AND MB.CODIGO = F_NOVO_COD_MODELO_BANDA_PNEU)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O modelo da banda do pneu %s não está mapeado',
                                                  F_NOVO_COD_MODELO_BANDA_PNEU));
    END IF;

    -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda e a mesma tiver sido
    -- atualizada.
    IF (PNEU_POSSUI_BANDA AND TROCOU_BANDA_PNEU AND F_NOVO_VALOR_BANDA_PNEU IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        'Você está trocando a banda, deve ser informado o valor da nova banda aplicada');
    END IF;

    -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
    IF (PNEU_POSSUI_BANDA AND TROCOU_BANDA_PNEU AND F_NOVO_VALOR_BANDA_PNEU IS NULL AND F_NOVO_VALOR_BANDA_PNEU < 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da nova banda do pneu não pode ser um número negativo');
    END IF;

    UPDATE PUBLIC.PNEU
    SET CODIGO_CLIENTE   = F_NOVO_CODIGO_PNEU_CLIENTE,
        COD_MODELO       = F_NOVO_COD_MODELO_PNEU,
        COD_DIMENSAO     = F_NOVO_COD_DIMENSAO_PNEU,
        DOT              = F_NOVO_DOT_PNEU,
        VALOR            = F_NOVO_VALOR_PNEU,
        COD_MODELO_BANDA = F_IF(PNEU_POSSUI_BANDA AND TROCOU_BANDA_PNEU, F_NOVO_COD_MODELO_BANDA_PNEU, NULL)
    WHERE CODIGO = COD_PNEU_PROLOG;

    UPDATE INTEGRACAO.PNEU_CADASTRADO
    SET DATA_HORA_ULTIMA_EDICAO = F_DATA_HORA_EDICAO_PNEU
    WHERE COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU
      AND COD_PNEU_SISTEMA_INTEGRADO = F_COD_PNEU_SISTEMA_INTEGRADO;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Verificamos se a atualização na tabela de mapeamento ocorreu com sucesso.
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        RAISE EXCEPTION
            'Não foi possível atualizar o pneu % na tabela de mapeamento', COD_PNEU_PROLOG;
    END IF;

    IF (PNEU_POSSUI_BANDA
        AND NOT (SELECT *
                 FROM PUBLIC.FUNC_PNEUS_UPDATE_BANDA_PNEU(COD_PNEU_PROLOG,
                                                          F_NOVO_COD_MODELO_BANDA_PNEU,
                                                          F_NOVO_VALOR_BANDA_PNEU)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('Não foi possível atualizar a banda do pneu');
    END IF;

    RETURN COD_PNEU_PROLOG;
END;
$$;

create or replace function integracao.func_pneu_vincula_pneu_posicao_placa(f_cod_veiculo_prolog bigint,
                                                                           f_placa_veiculo_pneu_aplicado text,
                                                                           f_cod_pneu_prolog bigint,
                                                                           f_codigo_pneu_cliente text,
                                                                           f_cod_unidade_pneu bigint,
                                                                           f_posicao_veiculo_pneu_aplicado integer,
                                                                           f_is_posicao_estepe boolean) returns boolean
    language plpgsql
as
$$
DECLARE
    F_QTD_ROWS_ALTERADAS BIGINT;
BEGIN
    -- Validamos se a placa existe no ProLog.
    IF (F_COD_VEICULO_PROLOG IS NULL OR F_COD_VEICULO_PROLOG <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('A placa informada %s não está presente no Sistema ProLog',
                                                  F_PLACA_VEICULO_PNEU_APLICADO));
    END IF;

    -- Validamos se o placa e o pneu pertencem a mesma unidade.
    IF ((SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = F_COD_VEICULO_PROLOG) <> F_COD_UNIDADE_PNEU)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('A placa informada %s está em uma Unidade diferente do pneu informado %s,
               unidade da placa %s, unidade do pneu %s',
                               F_PLACA_VEICULO_PNEU_APLICADO,
                               F_CODIGO_PNEU_CLIENTE,
                               (SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = F_COD_VEICULO_PROLOG),
                               F_COD_UNIDADE_PNEU));
    END IF;

    -- Validamos se a posição repassada é uma posição válida no ProLog.
    IF (NOT IS_PLACA_POSICAO_PNEU_VALIDA(F_COD_VEICULO_PROLOG, F_POSICAO_VEICULO_PNEU_APLICADO, F_IS_POSICAO_ESTEPE))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('A posição informada %s para o pneu, não é uma posição válida para a placa %s',
                               F_POSICAO_VEICULO_PNEU_APLICADO,
                               F_PLACA_VEICULO_PNEU_APLICADO));
    END IF;

    -- Validamos se a placa possui algum outro pneu aplicado na posição.
    IF (SELECT EXISTS(SELECT *
                      FROM PUBLIC.VEICULO_PNEU VP
                      WHERE VP.PLACA = F_PLACA_VEICULO_PNEU_APLICADO
                        AND VP.COD_UNIDADE = F_COD_UNIDADE_PNEU
                        AND VP.POSICAO = F_POSICAO_VEICULO_PNEU_APLICADO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Já existe um pneu na placa %s, posição %s',
                                                  F_PLACA_VEICULO_PNEU_APLICADO,
                                                  F_POSICAO_VEICULO_PNEU_APLICADO));
    END IF;

    -- Vincula pneu a placa.
    INSERT INTO PUBLIC.VEICULO_PNEU(PLACA,
                                    COD_PNEU,
                                    COD_UNIDADE,
                                    POSICAO)
    VALUES (F_PLACA_VEICULO_PNEU_APLICADO,
            F_COD_PNEU_PROLOG,
            F_COD_UNIDADE_PNEU,
            F_POSICAO_VEICULO_PNEU_APLICADO);

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Verificamos se o update ocorreu como deveria
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Não foi possível aplicar o pneu %s na placa %s',
                                                  F_CODIGO_PNEU_CLIENTE,
                                                  F_PLACA_VEICULO_PNEU_APLICADO));
    END IF;

    -- Retornamos sucesso se o pneu estiver aplicado na placa e posição que deveria estar.
    IF (SELECT EXISTS(SELECT VP.POSICAO
                      FROM PUBLIC.VEICULO_PNEU VP
                      WHERE VP.PLACA = F_PLACA_VEICULO_PNEU_APLICADO
                        AND VP.COD_PNEU = F_COD_PNEU_PROLOG
                        AND VP.POSICAO = F_POSICAO_VEICULO_PNEU_APLICADO
                        AND VP.COD_UNIDADE = F_COD_UNIDADE_PNEU))
    THEN
        RETURN TRUE;
    ELSE
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Não foi possível aplicar o pneu %s na placa %s',
                                                  F_CODIGO_PNEU_CLIENTE,
                                                  F_PLACA_VEICULO_PNEU_APLICADO));
    END IF;
END ;
$$;

create or replace function integracao.func_pneu_lista_modelos_pneus_empresa(f_token_integracao text,
                                                                            f_cod_marca_pneu bigint DEFAULT NULL::bigint,
                                                                            f_apenas_modelos_pneu_ativos boolean DEFAULT true)
    returns TABLE
            (
                cod_empresa_modelo_pneu   bigint,
                cod_marca_pneu            bigint,
                cod_modelo_pneu           bigint,
                nome_modelo_pneu          text,
                qtd_sulcos_modelo_pneu    integer,
                altura_sulcos_nodelo_pneu real,
                status_ativo_modelo_pneu  boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT MP.COD_EMPRESA        AS COD_EMPRESA_MODELO_PNEU,
               MP.COD_MARCA          AS COD_MARCA_PNEU,
               MP.CODIGO             AS COD_MODELO_PNEU,
               MP.NOME::TEXT         AS NOME_MODELO_PNEU,
               MP.QT_SULCOS::INTEGER AS QTD_SULCOS_MODELO_PNEU,
               MP.ALTURA_SULCOS      AS ALTURA_SULCOS_NODELO_PNEU,
               TRUE                  AS STATUS_ATIVO_MODELO_PNEU
        FROM PUBLIC.MODELO_PNEU MP
        WHERE MP.COD_EMPRESA IN (SELECT TI.COD_EMPRESA
                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)
          AND F_IF(F_COD_MARCA_PNEU IS NULL, TRUE, MP.COD_MARCA = F_COD_MARCA_PNEU)
        ORDER BY MP.COD_MARCA, MP.CODIGO;
END;
$$;

create or replace function integracao.func_pneu_lista_marcas_modelos_pneus_empresa(f_token_integracao text, apenas_marcas_pneu_ativas boolean)
    returns TABLE
            (
                cod_marca_pneu            bigint,
                nome_marca_pneu           text,
                status_ativo_marca_pneu   boolean,
                cod_modelo_pneu           bigint,
                nome_modelo_pneu          text,
                cod_empresa_marca_modelo  bigint,
                qtd_sulcos_modelo_pneu    integer,
                altura_sulcos_nodelo_pneu real,
                status_ativo_modelo_pneu  boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT MP.CODIGO                     AS COD_MARCA_PNEU,
               MP.NOME::TEXT                 AS NOME_MARCA_PNEU,
               TRUE                          AS STATUS_ATIVO_MARCA_PNEU,
               MPE.COD_MODELO_PNEU           AS COD_MODELO_PNEU,
               MPE.NOME_MODELO_PNEU          AS NOME_MODELO_PNEU,
               MPE.COD_EMPRESA_MODELO_PNEU   AS COD_EMPRESA_MARCA_MODELO,
               MPE.QTD_SULCOS_MODELO_PNEU    AS QTD_SULCOS_MODELO_PNEU,
               MPE.ALTURA_SULCOS_NODELO_PNEU AS ALTURA_SULCOS_NODELO_PNEU,
               MPE.STATUS_ATIVO_MODELO_PNEU  AS STATUS_ATIVO_MODELO_PNEU
        FROM PUBLIC.MARCA_PNEU MP
                 LEFT JOIN (SELECT * FROM INTEGRACAO.FUNC_PNEU_LISTA_MODELOS_PNEUS_EMPRESA(F_TOKEN_INTEGRACAO)) MPE
                           ON MPE.COD_MARCA_PNEU = MP.CODIGO
        ORDER BY MP.CODIGO, MPE.COD_MODELO_PNEU;
END;
$$;

create or replace function integracao.func_unidade_lista_unidades_empresa(f_token_integracao text,
                                                                          f_apenas_unidades_ativas boolean DEFAULT false)
    returns TABLE
            (
                cod_empresa  bigint,
                codigo       bigint,
                nome         text,
                status_ativo boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT U.COD_EMPRESA,
               U.CODIGO,
               U.NOME::TEXT,
               U.STATUS_ATIVO
        FROM PUBLIC.UNIDADE U
        WHERE U.COD_EMPRESA = (SELECT TI.COD_EMPRESA
                               FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                               WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)
          AND F_IF(F_APENAS_UNIDADES_ATIVAS, U.STATUS_ATIVO = TRUE, TRUE)
        ORDER BY U.CODIGO;
END;
$$;

create or replace function integracao.func_pneu_realiza_incremento_vida_movimentacao(f_cod_unidade_pneu bigint,
                                                                                     f_cod_pneu_prolog bigint,
                                                                                     f_cod_modelo_banda_pneu bigint,
                                                                                     f_valor_banda_pneu real,
                                                                                     f_vida_nova_pneu integer,
                                                                                     f_cod_tipo_servico_incrementa_vida bigint) returns boolean
    language plpgsql
as
$$
DECLARE
    FONTE_SERVICO_REALIZADO_MOVIMENTACAO TEXT    := 'FONTE_MOVIMENTACAO';
    VIDA_MOMENTO_SERVICO_REALIZADO       INTEGER := F_VIDA_NOVA_PNEU - 1;
    F_COD_SERVICO_REALIZADO              BIGINT;
    F_QTD_ROWS_ALTERADAS                 BIGINT;
BEGIN
    --  Inserimos o serviço realizado, retornando o código.
    INSERT INTO PUBLIC.PNEU_SERVICO_REALIZADO(COD_TIPO_SERVICO,
                                              COD_UNIDADE,
                                              COD_PNEU,
                                              CUSTO,
                                              VIDA,
                                              FONTE_SERVICO_REALIZADO)
    VALUES (F_COD_TIPO_SERVICO_INCREMENTA_VIDA,
            F_COD_UNIDADE_PNEU,
            F_COD_PNEU_PROLOG,
            F_VALOR_BANDA_PNEU,
            VIDA_MOMENTO_SERVICO_REALIZADO,
            FONTE_SERVICO_REALIZADO_MOVIMENTACAO) RETURNING CODIGO INTO F_COD_SERVICO_REALIZADO;

    -- Mapeamos o incremento de vida do serviço realizado acima.
    INSERT INTO PUBLIC.PNEU_SERVICO_REALIZADO_INCREMENTA_VIDA(COD_SERVICO_REALIZADO,
                                                              COD_MODELO_BANDA,
                                                              VIDA_NOVA_PNEU,
                                                              FONTE_SERVICO_REALIZADO)
    VALUES (F_COD_SERVICO_REALIZADO,
            F_COD_MODELO_BANDA_PNEU,
            F_VIDA_NOVA_PNEU,
            FONTE_SERVICO_REALIZADO_MOVIMENTACAO);

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Verificamos se a criação do serviço de incremento de vida ocorreu com sucesso.
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Não foi possível incrementar a vida do pneu %s', F_COD_PNEU_PROLOG));
    END IF;

    RETURN TRUE;
END;
$$;

create or replace function public.func_pneu_get_servico_incrementa_vida_pneu_empresa(f_cod_empresa bigint) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_SERVICO_INCREMENTA_VIDA BIGINT := (SELECT PTS.CODIGO
                                           FROM PUBLIC.PNEU_TIPO_SERVICO PTS
                                           WHERE PTS.COD_EMPRESA = F_COD_EMPRESA
                                             AND PTS.INCREMENTA_VIDA IS TRUE
                                             AND PTS.UTILIZADO_CADASTRO_PNEU IS FALSE
                                             AND PTS.STATUS_ATIVO IS TRUE
                                           ORDER BY PTS.CODIGO
                                           LIMIT 1);
    TIPO_SERVICO_RECAPAGEM      TEXT   := 'RECAPAGEM';
BEGIN
    IF (COD_SERVICO_INCREMENTA_VIDA IS NULL)
    THEN
        INSERT INTO PUBLIC.PNEU_TIPO_SERVICO(COD_EMPRESA,
                                             NOME,
                                             INCREMENTA_VIDA,
                                             DATA_HORA_CRIACAO)
        VALUES (F_COD_EMPRESA,
                TIPO_SERVICO_RECAPAGEM,
                TRUE,
                NOW()) RETURNING CODIGO INTO COD_SERVICO_INCREMENTA_VIDA;
    END IF;
    RETURN COD_SERVICO_INCREMENTA_VIDA;
END;
$$;

create or replace function integracao.func_pneu_atualiza_status_pneu_prolog(f_cod_pneu_sistema_integrado bigint,
                                                                            f_codigo_pneu_cliente character varying,
                                                                            f_cod_unidade_pneu bigint,
                                                                            f_cpf_colaborador_alteracao_status character varying,
                                                                            f_data_hora_alteracao_status timestamp without time zone,
                                                                            f_status_pneu character varying,
                                                                            f_trocou_de_banda boolean,
                                                                            f_cod_novo_modelo_banda_pneu bigint,
                                                                            f_valor_nova_banda_pneu numeric,
                                                                            f_placa_veiculo_pneu_aplicado character varying,
                                                                            f_posicao_veiculo_pneu_aplicado integer,
                                                                            f_token_integracao character varying) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_PNEU            BIGINT  := (SELECT TI.COD_EMPRESA
                                            FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                            WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_VEICULO_PROLOG          BIGINT  := (SELECT V.CODIGO
                                            FROM PUBLIC.VEICULO V
                                            WHERE V.PLACA = F_PLACA_VEICULO_PNEU_APLICADO
                                              AND V.COD_UNIDADE IN (SELECT U.CODIGO
                                                                    FROM PUBLIC.UNIDADE U
                                                                    WHERE U.COD_EMPRESA = COD_EMPRESA_PNEU));
    IS_POSICAO_ESTEPE           BOOLEAN := F_IF(F_POSICAO_VEICULO_PNEU_APLICADO >= 900
                                                    AND F_POSICAO_VEICULO_PNEU_APLICADO <= 908, TRUE, FALSE);
    COD_PNEU_PROLOG             BIGINT  := (SELECT PC.COD_PNEU_CADASTRO_PROLOG
                                            FROM INTEGRACAO.PNEU_CADASTRADO PC
                                            WHERE PC.COD_PNEU_SISTEMA_INTEGRADO = F_COD_PNEU_SISTEMA_INTEGRADO
                                              AND PC.COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU);
    VIDA_ATUAL_PNEU             INTEGER := (SELECT P.VIDA_ATUAL
                                            FROM PUBLIC.PNEU P
                                            WHERE P.CODIGO = COD_PNEU_PROLOG);
    PROXIMA_VIDA_PNEU           INTEGER := VIDA_ATUAL_PNEU + 1;
    STATUS_APLICADO_VEICULO     TEXT    := 'EM_USO';
    COD_SERVICO_INCREMENTA_VIDA BIGINT;
    F_QTD_ROWS_ALTERADAS        BIGINT;
BEGIN
    -- Validamos se a Empresa é válida.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_PNEU,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    -- Validamos se a Unidade repassada existe.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE_PNEU,
                                        FORMAT('A Unidade %s repassada não existe no Sistema ProLog',
                                               F_COD_UNIDADE_PNEU));

    -- Validamos se a Unidade pertence a Empresa do token repassado.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(COD_EMPRESA_PNEU,
                                                F_COD_UNIDADE_PNEU,
                                                FORMAT('A Unidade %s não está configurada para esta empresa',
                                                       F_COD_UNIDADE_PNEU));

    -- Validamos se o código do pneu no sistema integrado está mapeado na tabela interna do ProLog.
    IF (COD_PNEU_PROLOG IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O pneu de código interno %s não está mapeado no Sistema ProLog',
                                                  F_COD_PNEU_SISTEMA_INTEGRADO));
    END IF;

    -- Deletamos o vinculo do pneu com a placa. Caso o pneu não estava vinculado, nada irá acontecer.
    DELETE FROM VEICULO_PNEU VP WHERE VP.COD_PNEU = COD_PNEU_PROLOG;

    -- Atualiza o pneu para o status em que ele deve estar.
    UPDATE PUBLIC.PNEU
    SET STATUS      = F_STATUS_PNEU,
        COD_UNIDADE = F_COD_UNIDADE_PNEU
    WHERE CODIGO = COD_PNEU_PROLOG;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Validamos se o status do pneu foi atualizado com sucesso
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('Não foi possível atualizar as informações do pneu %s para o status %s',
                               F_CODIGO_PNEU_CLIENTE,
                               F_STATUS_PNEU));
    END IF;

    -- Precisamos vincular o pneu ao veículo apenas se o status for aplicado.
    IF (F_STATUS_PNEU = STATUS_APLICADO_VEICULO)
    THEN
        -- Transferimos o pneu para a unidade do veículo, caso ele já não esteja.
        IF ((SELECT P.COD_UNIDADE FROM PUBLIC.PNEU P WHERE P.CODIGO = COD_PNEU_PROLOG) <> F_COD_UNIDADE_PNEU)
        THEN
            UPDATE PUBLIC.PNEU
            SET COD_UNIDADE = (SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG)
            WHERE CODIGO = COD_PNEU_PROLOG;

            SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG INTO F_COD_UNIDADE_PNEU;
        END IF;

        PERFORM INTEGRACAO.FUNC_PNEU_VINCULA_PNEU_POSICAO_PLACA(COD_VEICULO_PROLOG,
                                                                F_PLACA_VEICULO_PNEU_APLICADO,
                                                                COD_PNEU_PROLOG,
                                                                F_CODIGO_PNEU_CLIENTE,
                                                                F_COD_UNIDADE_PNEU,
                                                                F_POSICAO_VEICULO_PNEU_APLICADO,
                                                                IS_POSICAO_ESTEPE);
    END IF;

    IF (F_TROCOU_DE_BANDA)
    THEN
        -- Validamos se o código do modelo de banda é válido. Apenas validamos se o pneu possuir banda.
        IF (F_COD_NOVO_MODELO_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O código do modelo da banda deve ser informado');
        END IF;

        -- Validamos se o código do modelo da banda é válido. Apenas validamos se o pneu possuir banda.
        IF ((SELECT NOT EXISTS(SELECT MB.CODIGO
                               FROM PUBLIC.MODELO_BANDA MB
                               WHERE MB.COD_EMPRESA = COD_EMPRESA_PNEU
                                 AND MB.CODIGO = F_COD_NOVO_MODELO_BANDA_PNEU)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O modelo da banda do pneu %s não está mapeado no Sistema ProLog',
                                                      F_COD_NOVO_MODELO_BANDA_PNEU));
        END IF;

        -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
        IF (F_VALOR_NOVA_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da banda do pneu deve ser informado');
        END IF;

        -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
        IF (F_VALOR_NOVA_BANDA_PNEU < 0)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da banda do pneu não pode ser um número negativo');
        END IF;

        -- Busca serviço que incrementa a vida do pneu dentro da empresa em questão.
        SELECT *
        FROM PUBLIC.FUNC_PNEU_GET_SERVICO_INCREMENTA_VIDA_PNEU_EMPRESA(COD_EMPRESA_PNEU)
        INTO COD_SERVICO_INCREMENTA_VIDA;

        IF (COD_SERVICO_INCREMENTA_VIDA IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('Erro ao vincular banda ao pneu');
        END IF;

        -- Incrementa a vida do pneu simulando um processo de movimentação.
        PERFORM INTEGRACAO.FUNC_PNEU_REALIZA_INCREMENTO_VIDA_MOVIMENTACAO(F_COD_UNIDADE_PNEU,
                                                                          COD_PNEU_PROLOG,
                                                                          F_COD_NOVO_MODELO_BANDA_PNEU,
                                                                          F_VALOR_NOVA_BANDA_PNEU,
                                                                          PROXIMA_VIDA_PNEU,
                                                                          COD_SERVICO_INCREMENTA_VIDA);

        -- Após incrementar a vida e criar o serviço, atualizamos o pneu para ficar com a banda e a vida correta.
        PERFORM PUBLIC.FUNC_PNEUS_INCREMENTA_VIDA_PNEU(COD_PNEU_PROLOG, F_COD_NOVO_MODELO_BANDA_PNEU);
    END IF;

    -- Qualquer alteração de status do pneu deve verificar se o pneu tem serviços aberto e fechá-los.
    PERFORM INTEGRACAO.FUNC_PNEU_FECHA_SERVICO_PNEU_AUTOMATICAMENTE(COD_PNEU_PROLOG,
                                                                    F_DATA_HORA_ALTERACAO_STATUS);

    RETURN COD_PNEU_PROLOG;
END;
$$;

create or replace function public.remove_extra_spaces(f_text text, f_remove_char_like_space boolean DEFAULT false) returns text
    language plpgsql
as
$$
BEGIN
    IF F_REMOVE_CHAR_LIKE_SPACE
    THEN
        RETURN REGEXP_REPLACE(TRIM(REGEXP_REPLACE((F_TEXT), '[\u0080-\u00ff]', '', 'g')), '\s+', ' ', 'g');
    ELSE
        RETURN TRIM(REGEXP_REPLACE(F_TEXT, '\s+', ' ', 'g'));
    END IF;
END;
$$;

create or replace function public.tg_func_pneu_nomenclatura_formata_nomenclatura() returns trigger
    language plpgsql
as
$$
DECLARE
    NOVA_NOMENCLATURA TEXT := REMOVE_EXTRA_SPACES(NEW.NOMENCLATURA, TRUE);
BEGIN
    IF NOVA_NOMENCLATURA IS NULL OR NOVA_NOMENCLATURA = ''
    THEN
        PERFORM THROW_GENERIC_ERROR('A nomenclatura não pode estar vazia!');
    END IF;
    RETURN NEW;
END
$$;

create trigger tg_formata_nomenclatura
    before insert or update
    on public.pneu_posicao_nomenclatura_empresa
    for each row
execute procedure public.tg_func_pneu_nomenclatura_formata_nomenclatura();

create or replace function public.array_sort(anyarray) returns anyarray
    language sql
as
$$
SELECT ARRAY(SELECT UNNEST($1) ORDER BY 1)
$$;

create or replace function public.func_garante_pneu_nomenclatura_completa(f_cod_diagrama bigint,
                                                                          f_posicoes_prolog integer[],
                                                                          f_error_message text DEFAULT NULL::text) returns void
    language plpgsql
as
$$
DECLARE
    POSICAO_ESTEPE BIGINT := 900;
    ERROR_MESSAGE  TEXT   :=
        F_IF(F_ERROR_MESSAGE IS NULL, 'Erro! Nomenclatura incompleta.', F_ERROR_MESSAGE);
BEGIN
    IF (ARRAY_SORT(F_POSICOES_PROLOG) <> (SELECT ARRAY_AGG(VDP.POSICAO_PROLOG ORDER BY VDP.POSICAO_PROLOG) :: INTEGER[]
                                          FROM VEICULO_DIAGRAMA_POSICAO_PROLOG VDP
                                          WHERE VDP.COD_DIAGRAMA = F_COD_DIAGRAMA
                                            AND VDP.POSICAO_PROLOG < POSICAO_ESTEPE))
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;
END;
$$;

create or replace function public.func_pneu_nomenclatura_deleta_estepes(f_cod_empresa bigint, f_cod_diagrama bigint) returns void
    language plpgsql
as
$$
DECLARE
    ESTEPES BIGINT := 900;
BEGIN
    DELETE
    FROM PNEU_POSICAO_NOMENCLATURA_EMPRESA
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND COD_DIAGRAMA = F_COD_DIAGRAMA
      AND POSICAO_PROLOG >= ESTEPES;
END;
$$;

create or replace function public.func_pneu_nomenclatura_insere_edita_nomenclatura(f_cod_empresa bigint,
                                                                                   f_cod_diagrama bigint,
                                                                                   f_posicao_prolog bigint,
                                                                                   f_nomenclatura character varying,
                                                                                   f_token_responsavel_insercao text,
                                                                                   f_data_hora_cadastro timestamp with time zone) returns void
    language plpgsql
as
$$
DECLARE
    COD_COLABORADOR_INSERCAO BIGINT := (SELECT CODIGO
                                        FROM COLABORADOR
                                        WHERE CPF = (SELECT CPF_COLABORADOR
                                                     FROM TOKEN_AUTENTICACAO
                                                     WHERE TOKEN = F_TOKEN_RESPONSAVEL_INSERCAO));
BEGIN
    INSERT INTO PNEU_POSICAO_NOMENCLATURA_EMPRESA (COD_DIAGRAMA,
                                                   COD_EMPRESA,
                                                   POSICAO_PROLOG,
                                                   NOMENCLATURA,
                                                   COD_COLABORADOR_CADASTRO,
                                                   DATA_HORA_CADASTRO)
    VALUES (F_COD_DIAGRAMA,
            F_COD_EMPRESA,
            F_POSICAO_PROLOG,
            F_NOMENCLATURA,
            COD_COLABORADOR_INSERCAO,
            F_DATA_HORA_CADASTRO)
    ON CONFLICT ON CONSTRAINT UNIQUE_DIAGRAMA_EMPRESA_POSICAO_PROLOG
        DO UPDATE SET NOMENCLATURA             = F_NOMENCLATURA,
                      COD_COLABORADOR_CADASTRO = COD_COLABORADOR_INSERCAO,
                      DATA_HORA_CADASTRO       = F_DATA_HORA_CADASTRO;
END;
$$;

create or replace function public.func_pneu_nomenclatura_get_nomenclatura(f_cod_empresa bigint, f_cod_diagrama bigint)
    returns TABLE
            (
                nomenclatura   character varying,
                posicao_prolog integer
            )
    language sql
as
$$
SELECT PPNE.NOMENCLATURA, PPNE.POSICAO_PROLOG
FROM PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE
WHERE PPNE.COD_EMPRESA = F_COD_EMPRESA
  AND PPNE.COD_DIAGRAMA = F_COD_DIAGRAMA
$$;

create or replace function public.func_relatorio_pneu_extrato_servicos_fechados(f_cod_unidade text[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE DO SERVIÇO"               text,
                "DATA AFERIÇÃO"                    text,
                "DATA RESOLUÇÃO"                   text,
                "HORAS PARA RESOLVER"              double precision,
                "MINUTOS PARA RESOLVER"            double precision,
                "PLACA"                            text,
                "KM AFERIÇÃO"                      bigint,
                "KM CONSERTO"                      bigint,
                "KM PERCORRIDO"                    bigint,
                "COD PNEU"                         character varying,
                "PRESSÃO RECOMENDADA"              real,
                "PRESSÃO AFERIÇÃO"                 text,
                "DISPERSÃO RECOMENDADA X AFERIÇÃO" text,
                "PRESSÃO INSERIDA"                 text,
                "DISPERSÃO RECOMENDADA X INSERIDA" text,
                "POSIÇÃO PNEU ABERTURA SERVIÇO"    text,
                "SERVIÇO"                          text,
                "MECÂNICO"                         text,
                "PROBLEMA APONTADO (INSPEÇÃO)"     text,
                "FECHADO AUTOMATICAMENTE"          text
            )
    language sql
as
$$
SELECT U.NOME                                                                                                       AS UNIDADE_SERVICO,
       TO_CHAR((A.DATA_HORA AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)),
               'DD/MM/YYYY HH24:MI:SS')                                                                             AS DATA_HORA_AFERICAO,
       TO_CHAR((AM.DATA_HORA_RESOLUCAO AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)),
               'DD/MM/YYYY HH24:MI:SS')                                                                             AS DATA_HORA_RESOLUCAO,
       TRUNC(EXTRACT(EPOCH FROM ((AM.DATA_HORA_RESOLUCAO) - (A.DATA_HORA))) /
             3600)                                                                                                  AS HORAS_RESOLUCAO,
       TRUNC(
               EXTRACT(EPOCH FROM ((AM.DATA_HORA_RESOLUCAO) - (A.DATA_HORA))) / 60)                                 AS MINUTOS_RESOLUCAO,
       A.PLACA_VEICULO                                                                                              AS PLACA_VEICULO,
       A.KM_VEICULO                                                                                                 AS KM_AFERICAO,
       AM.KM_MOMENTO_CONSERTO                                                                                       AS KM_MOMENTO_CONSERTO,
       AM.KM_MOMENTO_CONSERTO - A.KM_VEICULO                                                                        AS KM_PERCORRIDO,
       P.CODIGO_CLIENTE                                                                                             AS CODIGO_CLIENTE_PNEU,
       P.PRESSAO_RECOMENDADA                                                                                        AS PRESSAO_RECOMENDADA_PNEU,
       COALESCE(REPLACE(ROUND(AV.PSI :: NUMERIC, 2) :: TEXT, '.', ','),
                '-')                                                                                                AS PSI_AFERICAO,
       COALESCE(REPLACE(ROUND((((AV.PSI / P.PRESSAO_RECOMENDADA) - 1) * 100) :: NUMERIC, 2) || '%', '.', ','),
                '-')                                                                                                AS DISPERSAO_PRESSAO_ANTES,
       COALESCE(REPLACE(ROUND(AM.PSI_APOS_CONSERTO :: NUMERIC, 2) :: TEXT, '.', ','),
                '-')                                                                                                AS PSI_POS_CONSERTO,
       COALESCE(REPLACE(ROUND((((AM.PSI_APOS_CONSERTO / P.PRESSAO_RECOMENDADA) - 1) * 100) :: NUMERIC, 2) || '%', '.',
                        ','),
                '-')                                                                                                AS DISPERSAO_PRESSAO_DEPOIS,
       COALESCE(PPNE.NOMENCLATURA, '-')                                                                             AS POSICAO,
       AM.TIPO_SERVICO                                                                                              AS TIPO_SERVICO,
       COALESCE(INITCAP(C.NOME), '-')                                                                               AS NOME_MECANICO,
       COALESCE(AA.ALTERNATIVA, '-')                                                                                AS PROBLEMA_APONTADO,
       F_IF(AM.FECHADO_AUTOMATICAMENTE_MOVIMENTACAO OR AM.FECHADO_AUTOMATICAMENTE_INTEGRACAO, 'Sim' :: TEXT,
            'Não')                                                                                                  AS TIPO_FECHAMENTO
FROM AFERICAO_MANUTENCAO AM
         JOIN UNIDADE U
              ON AM.COD_UNIDADE = U.CODIGO
         JOIN AFERICAO_VALORES AV
              ON AM.COD_UNIDADE = AV.COD_UNIDADE
                  AND AM.COD_AFERICAO = AV.COD_AFERICAO
                  AND AM.COD_PNEU = AV.COD_PNEU
         JOIN AFERICAO A
              ON A.CODIGO = AV.COD_AFERICAO
         LEFT JOIN COLABORADOR C
                   ON AM.CPF_MECANICO = C.CPF
         JOIN PNEU P
              ON P.CODIGO = AV.COD_PNEU
         LEFT JOIN VEICULO_PNEU VP
                   ON VP.COD_PNEU = P.CODIGO
                       AND VP.COD_UNIDADE = P.COD_UNIDADE
         LEFT JOIN AFERICAO_ALTERNATIVA_MANUTENCAO_INSPECAO AA
                   ON AA.CODIGO = AM.COD_ALTERNATIVA
         LEFT JOIN VEICULO V
                   ON V.PLACA = VP.PLACA
         LEFT JOIN EMPRESA E
                   ON U.COD_EMPRESA = E.CODIGO
         LEFT JOIN VEICULO_TIPO VT
                   ON E.CODIGO = VT.COD_EMPRESA
                       AND VT.CODIGO = V.COD_TIPO
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE
                   ON PPNE.COD_EMPRESA = P.COD_EMPRESA
                       AND PPNE.COD_DIAGRAMA = VT.COD_DIAGRAMA
                       AND PPNE.POSICAO_PROLOG = AV.POSICAO
WHERE AV.COD_UNIDADE :: TEXT LIKE ANY (F_COD_UNIDADE)
  AND AM.DATA_HORA_RESOLUCAO IS NOT NULL
  AND (AM.DATA_HORA_RESOLUCAO AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
  AND (AM.DATA_HORA_RESOLUCAO AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
ORDER BY U.NOME, A.DATA_HORA DESC
$$;

create or replace function public.func_afericao_relatorio_dados_gerais(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "CÓDIGO AFERIÇÃO"           text,
                "UNIDADE"                   text,
                "DATA E HORA"               text,
                "CPF DO RESPONSÁVEL"        text,
                "NOME COLABORADOR"          text,
                "PNEU"                      text,
                "STATUS ATUAL"              text,
                "VALOR COMPRA"              text,
                "MARCA DO PNEU"             text,
                "MODELO DO PNEU"            text,
                "QTD SULCOS MODELO"         text,
                "VIDA ATUAL"                text,
                "VALOR VIDA ATUAL"          text,
                "BANDA APLICADA"            text,
                "QTD SULCOS BANDA"          text,
                "DIMENSÃO"                  text,
                "DOT"                       text,
                "DATA E HORA CADASTRO"      text,
                "POSIÇÃO PNEU"              text,
                "PLACA"                     text,
                "VIDA MOMENTO AFERIÇÃO"     text,
                "KM NO MOMENTO DA AFERIÇÃO" text,
                "KM ATUAL"                  text,
                "MARCA DO VEÍCULO"          text,
                "MODELO DO VEÍCULO"         text,
                "TIPO DE MEDIÇÃO COLETADA"  text,
                "TIPO DA AFERIÇÃO"          text,
                "TEMPO REALIZAÇÃO (MM:SS)"  text,
                "SULCO INTERNO"             text,
                "SULCO CENTRAL INTERNO"     text,
                "SULCO CENTRAL EXTERNO"     text,
                "SULCO EXTERNO"             text,
                "MENOR SULCO"               text,
                "PRESSÃO"                   text
            )
    language sql
as
$$
SELECT A.CODIGO :: TEXT                                                                 AS COD_AFERICAO,
       U.NOME                                                                           AS UNIDADE,
       TO_CHAR((A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)),
               'DD/MM/YYYY HH24:MI')                                                    AS DATA_HORA_AFERICAO,
       LPAD(C.CPF :: TEXT, 11, '0')                                                     AS CPF_COLABORADOR,
       C.NOME                                                                           AS NOME_COLABORADOR,
       P.CODIGO_CLIENTE                                                                 AS CODIGO_CLIENTE_PNEU,
       P.STATUS                                                                         AS STATUS_ATUAL_PNEU,
       ROUND(P.VALOR :: NUMERIC, 2) :: TEXT                                             AS VALOR_COMPRA,
       MAP.NOME                                                                         AS MARCA_PNEU,
       MP.NOME                                                                          AS MODELO_PNEU,
       MP.QT_SULCOS :: TEXT                                                             AS QTD_SULCOS_MODELO,
       (SELECT PVN.NOME
        FROM PNEU_VIDA_NOMENCLATURA PVN
        WHERE PVN.COD_VIDA = P.VIDA_ATUAL)                                              AS VIDA_ATUAL,
       COALESCE(ROUND(PVV.VALOR :: NUMERIC, 2) :: TEXT, '-')                            AS VALOR_VIDA_ATUAL,
       F_IF(MARB.CODIGO IS NOT NULL, MARB.NOME || ' - ' || MODB.NOME, 'Nunca Recapado') AS BANDA_APLICADA,
       COALESCE(MODB.QT_SULCOS :: TEXT, '-')                                            AS QTD_SULCOS_BANDA,
       DP.LARGURA || '-' || DP.ALTURA || '/' || DP.ARO                                  AS DIMENSAO,
       P.DOT                                                                            AS DOT,
       COALESCE(TO_CHAR(P.DATA_HORA_CADASTRO AT TIME ZONE TZ_UNIDADE(P.COD_UNIDADE_CADASTRO),
                        'DD/MM/YYYY HH24:MI'),
                '-')                                                                    AS DATA_HORA_CADASTRO,
       COALESCE(PPNE.NOMENCLATURA, '-')                                                 AS POSICAO,
       COALESCE(A.PLACA_VEICULO, '-')                                                   AS PLACA,
       (SELECT PVN.NOME
        FROM PNEU_VIDA_NOMENCLATURA PVN
        WHERE PVN.COD_VIDA = AV.VIDA_MOMENTO_AFERICAO)                                  AS VIDA_MOMENTO_AFERICAO,
       COALESCE(A.KM_VEICULO :: TEXT, '-')                                              AS KM_MOMENTO_AFERICAO,
       COALESCE(V.KM :: TEXT, '-')                                                      AS KM_ATUAL,
       COALESCE(M2.NOME, '-')                                                           AS MARCA_VEICULO,
       COALESCE(MV.NOME, '-')                                                           AS MODELO_VEICULO,
       A.TIPO_MEDICAO_COLETADA,
       A.TIPO_PROCESSO_COLETA,
       TO_CHAR((A.TEMPO_REALIZACAO || ' milliseconds') :: INTERVAL, 'MI:SS')            AS TEMPO_REALIZACAO_MINUTOS,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_INTERNO)                                  AS SULCO_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_CENTRAL_INTERNO)                          AS SULCO_CENTRAL_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_CENTRAL_EXTERNO)                          AS SULCO_CENTRAL_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_EXTERNO)                                  AS SULCO_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(LEAST(AV.ALTURA_SULCO_EXTERNO, AV.ALTURA_SULCO_CENTRAL_EXTERNO,
                                    AV.ALTURA_SULCO_CENTRAL_INTERNO,
                                    AV.ALTURA_SULCO_INTERNO))                           AS MENOR_SULCO,
       REPLACE(COALESCE(TRUNC(AV.PSI :: NUMERIC, 1) :: TEXT, '-'), '.', ',')            AS PRESSAO
FROM AFERICAO A
         JOIN AFERICAO_VALORES AV ON A.CODIGO = AV.COD_AFERICAO AND A.COD_UNIDADE = AV.COD_UNIDADE
         JOIN UNIDADE U ON U.CODIGO = A.COD_UNIDADE
         JOIN COLABORADOR C ON C.CPF = A.CPF_AFERIDOR
         JOIN PNEU P ON P.CODIGO = AV.COD_PNEU AND P.COD_UNIDADE = AV.COD_UNIDADE
         JOIN MODELO_PNEU MP ON P.COD_MODELO = MP.CODIGO AND MP.COD_EMPRESA = P.COD_EMPRESA
         JOIN MARCA_PNEU MAP ON MAP.CODIGO = MP.COD_MARCA
         JOIN DIMENSAO_PNEU DP ON P.COD_DIMENSAO = DP.CODIGO
         LEFT JOIN PNEU_VALOR_VIDA PVV ON P.CODIGO = PVV.COD_PNEU AND P.VIDA_ATUAL = PVV.VIDA

    -- Pode não possuir banda.
         LEFT JOIN MODELO_BANDA MODB ON MODB.CODIGO = P.COD_MODELO_BANDA
         LEFT JOIN MARCA_BANDA MARB ON MARB.CODIGO = MODB.COD_MARCA

    -- Se foi aferição de pneu avulso, pode não possuir placa.
         LEFT JOIN VEICULO V ON V.PLACA = A.PLACA_VEICULO

         LEFT JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
         LEFT JOIN VEICULO_TIPO VT ON E.CODIGO = VT.COD_EMPRESA AND VT.CODIGO = V.COD_TIPO
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE
                   ON PPNE.COD_EMPRESA = P.COD_EMPRESA
                       AND PPNE.COD_DIAGRAMA = VT.COD_DIAGRAMA
                       AND PPNE.POSICAO_PROLOG = AV.POSICAO
         LEFT JOIN MODELO_VEICULO MV
                   ON MV.CODIGO = V.COD_MODELO
         LEFT JOIN MARCA_VEICULO M2
                   ON MV.COD_MARCA = M2.CODIGO
WHERE A.COD_UNIDADE = ANY (F_COD_UNIDADES)
  AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE)) :: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
ORDER BY U.CODIGO, A.DATA_HORA DESC;
$$;

create or replace function public.func_movimentacao_relatorio_dados_gerais(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE"               text,
                "DATA E HORA"           text,
                "CPF DO RESPONSÁVEL"    text,
                "NOME"                  text,
                "PNEU"                  text,
                "MARCA"                 text,
                "MODELO"                text,
                "BANDA APLICADA"        text,
                "MEDIDAS"               text,
                "SULCO INTERNO"         text,
                "SULCO CENTRAL INTERNO" text,
                "SULCO CENTRAL EXTERNO" text,
                "SULCO EXTERNO"         text,
                "MENOR SULCO"           text,
                "PRESSÃO ATUAL (PSI)"   text,
                "VIDA ATUAL"            text,
                "ORIGEM"                text,
                "PLACA DE ORIGEM"       text,
                "POSIÇÃO DE ORIGEM"     text,
                "DESTINO"               text,
                "PLACA DE DESTINO"      text,
                "POSIÇÃO DE DESTINO"    text,
                "KM MOVIMENTAÇÃO"       text,
                "RECAPADORA DESTINO"    text,
                "CÓDIGO COLETA"         text,
                "OBS. MOVIMENTAÇÃO"     text,
                "OBS. GERAL"            text
            )
    language sql
as
$$
SELECT U.NOME,
       TO_CHAR((MOVP.DATA_HORA AT TIME ZONE TZ_UNIDADE(MOVP.COD_UNIDADE)), 'DD/MM/YYYY HH24:MI') :: TEXT AS DATA_HORA,
       LPAD(MOVP.CPF_RESPONSAVEL :: TEXT, 11, '0'),
       C.NOME,
       P.CODIGO_CLIENTE                                                                                  AS PNEU,
       MAP.NOME                                                                                          AS NOME_MARCA_PNEU,
       MP.NOME                                                                                           AS NOME_MODELO_PNEU,
       F_IF(MARB.CODIGO IS NULL, 'Nunca Recapado',
            MARB.NOME || ' - ' || MODB.NOME)                                                             AS BANDA_APLICADA,
       ((((DP.LARGURA || '/' :: TEXT) || DP.ALTURA) || ' R' :: TEXT) || DP.ARO)                          AS MEDIDAS,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_INTERNO)                                                    AS SULCO_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_INTERNO)                                            AS SULCO_CENTRAL_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_EXTERNO)                                            AS SULCO_CENTRAL_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_EXTERNO)                                                    AS SULCO_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(LEAST(P.ALTURA_SULCO_EXTERNO, P.ALTURA_SULCO_CENTRAL_EXTERNO,
                                    P.ALTURA_SULCO_CENTRAL_INTERNO,
                                    P.ALTURA_SULCO_INTERNO))                                             AS MENOR_SULCO,
       COALESCE(TRUNC(P.PRESSAO_ATUAL) :: TEXT, '-')                                                     AS PRESSAO_ATUAL,
       PVN.NOME :: TEXT                                                                                  AS VIDA_ATUAL,
       O.TIPO_ORIGEM                                                                                     AS ORIGEM,
       COALESCE(O.PLACA, '-')                                                                            AS PLACA_ORIGEM,
       COALESCE(NOMENCLATURA_ORIGEM.NOMENCLATURA, '-')                                                   AS POSICAO_ORIGEM,
       D.TIPO_DESTINO                                                                                    AS DESTINO,
       COALESCE(D.PLACA, '-')                                                                            AS PLACA_DESTINO,
       COALESCE(NOMENCLATURA_DESTINO.NOMENCLATURA, '-')                                                  AS POSICAO_DESTINO,
       COALESCE(VORIGEM.KM, VDESTINO.KM) :: TEXT                                                         AS KM_COLETADO_MOVIMENTACAO,
       COALESCE(R.NOME, '-')                                                                             AS RECAPADORA_DESTINO,
       COALESCE(NULLIF(TRIM(D.COD_COLETA), ''), '-')                                                     AS COD_COLETA_RECAPADORA,
       COALESCE(NULLIF(TRIM(M.OBSERVACAO), ''), '-')                                                     AS OBSERVACAO_MOVIMENTACAO,
       COALESCE(NULLIF(TRIM(MOVP.OBSERVACAO), ''), '-')                                                  AS OBSERVACAO_GERAL
FROM MOVIMENTACAO_PROCESSO MOVP
         JOIN MOVIMENTACAO M ON MOVP.CODIGO = M.COD_MOVIMENTACAO_PROCESSO AND MOVP.COD_UNIDADE = M.COD_UNIDADE
         JOIN MOVIMENTACAO_DESTINO D ON M.CODIGO = D.COD_MOVIMENTACAO
         JOIN PNEU P ON P.CODIGO = M.COD_PNEU
         JOIN MOVIMENTACAO_ORIGEM O ON M.CODIGO = O.COD_MOVIMENTACAO
         JOIN UNIDADE U ON U.CODIGO = MOVP.COD_UNIDADE
         JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
         JOIN COLABORADOR C ON MOVP.CPF_RESPONSAVEL = C.CPF
         JOIN DIMENSAO_PNEU DP ON DP.CODIGO = P.COD_DIMENSAO
         JOIN MODELO_PNEU MP ON MP.CODIGO = P.COD_MODELO AND MP.COD_EMPRESA = U.COD_EMPRESA
         JOIN MARCA_PNEU MAP ON MAP.CODIGO = MP.COD_MARCA
         JOIN PNEU_VIDA_NOMENCLATURA PVN ON PVN.COD_VIDA = P.VIDA_ATUAL

    -- Terá recapadora apenas se foi movido para análise.
         LEFT JOIN RECAPADORA R ON R.CODIGO = D.COD_RECAPADORA_DESTINO

    -- Pode não possuir banda.
         LEFT JOIN MODELO_BANDA MODB ON MODB.CODIGO = P.COD_MODELO_BANDA
         LEFT JOIN MARCA_BANDA MARB ON MARB.CODIGO = MODB.COD_MARCA

    -- Joins para buscar a nomenclatura da posição do pneu na placa de ORIGEM, que a unidade pode não possuir.
         LEFT JOIN VEICULO VORIGEM
                   ON O.PLACA = VORIGEM.PLACA
         LEFT JOIN VEICULO_TIPO VTORIGEM ON E.CODIGO = VTORIGEM.COD_EMPRESA AND VTORIGEM.CODIGO = VORIGEM.COD_TIPO
         LEFT JOIN VEICULO_DIAGRAMA VDORIGEM ON VTORIGEM.COD_DIAGRAMA = VDORIGEM.CODIGO
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA NOMENCLATURA_ORIGEM
                   ON NOMENCLATURA_ORIGEM.COD_EMPRESA = P.COD_EMPRESA
                       AND NOMENCLATURA_ORIGEM.COD_DIAGRAMA = VDORIGEM.CODIGO
                       AND NOMENCLATURA_ORIGEM.POSICAO_PROLOG = O.POSICAO_PNEU_ORIGEM

    -- Joins para buscar a nomenclatura da posição do pneu na placa de DESTINO, que a unidade pode não possuir.
         LEFT JOIN VEICULO VDESTINO
                   ON D.PLACA = VDESTINO.PLACA
         LEFT JOIN VEICULO_TIPO VTDESTINO ON E.CODIGO = VTDESTINO.COD_EMPRESA AND VTDESTINO.CODIGO = VDESTINO.COD_TIPO
         LEFT JOIN VEICULO_DIAGRAMA VDDESTINO ON VTDESTINO.COD_DIAGRAMA = VDDESTINO.CODIGO
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA NOMENCLATURA_DESTINO
                   ON NOMENCLATURA_DESTINO.COD_EMPRESA = P.COD_EMPRESA
                       AND NOMENCLATURA_DESTINO.COD_DIAGRAMA = VDDESTINO.CODIGO
                       AND NOMENCLATURA_DESTINO.POSICAO_PROLOG = D.POSICAO_PNEU_DESTINO

WHERE MOVP.COD_UNIDADE = ANY (F_COD_UNIDADES)
  AND (MOVP.DATA_HORA AT TIME ZONE TZ_UNIDADE(MOVP.COD_UNIDADE)) :: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
ORDER BY U.CODIGO, MOVP.DATA_HORA DESC;
$$;

create or replace function public.func_pneu_relatorio_desgaste_irregular(f_cod_unidades bigint[],
                                                                         f_status_pneu pneu_status_type DEFAULT NULL::pneu_status_type)
    returns TABLE
            (
                "UNIDADE ALOCADO"       text,
                "PNEU"                  text,
                "STATUS"                text,
                "VALOR DE AQUISIÇÃO"    text,
                "DATA/HORA CADASTRO"    text,
                "MARCA"                 text,
                "MODELO"                text,
                "BANDA APLICADA"        text,
                "VALOR DA BANDA"        text,
                "MEDIDAS"               text,
                "PLACA"                 text,
                "TIPO"                  text,
                "POSIÇÃO"               text,
                "QUANTIDADE DE SULCOS"  text,
                "SULCO INTERNO"         text,
                "SULCO CENTRAL INTERNO" text,
                "SULCO CENTRAL EXTERNO" text,
                "SULCO EXTERNO"         text,
                "MENOR SULCO"           text,
                "PRESSÃO ATUAL (PSI)"   text,
                "PRESSÃO IDEAL (PSI)"   text,
                "VIDA ATUAL"            text,
                "DOT"                   text,
                "ÚLTIMA AFERIÇÃO"       text,
                "DESCRIÇÃO DESGASTE"    text,
                "NÍVEL DE DESGASTE"     text,
                "APARÊNCIA PNEU"        text,
                "CAUSAS PROVÁVEIS"      text,
                "AÇÃO"                  text,
                "PRECAUÇÃO"             text
            )
    language plpgsql
as
$$
DECLARE
    F_TIMESTAMP_FORMAT TEXT := 'DD/MM/YYYY HH24:MI';
BEGIN
    RETURN QUERY
        -- Essa CTE busca o código da última aferição de cada pneu.
        -- Com o código nós conseguimos buscar depois a data/hora da aferição e o código da unidade em que ocorreu,
        -- para aplicar o TZ correto.
        WITH ULTIMAS_AFERICOES AS (
            SELECT AV.COD_PNEU   AS COD_PNEU_AFERIDO,
                   MAX(A.CODIGO) AS COD_AFERICAO
            FROM AFERICAO A
                     JOIN AFERICAO_VALORES AV
                          ON AV.COD_AFERICAO = A.CODIGO
                     JOIN PNEU P ON P.CODIGO = AV.COD_PNEU
            WHERE P.COD_UNIDADE = ANY (F_COD_UNIDADES)
            GROUP BY AV.COD_PNEU
        )

        SELECT U.NOME :: TEXT                                                               AS UNIDADE_ALOCADO,
               P.CODIGO_CLIENTE :: TEXT                                                     AS COD_PNEU,
               P.STATUS :: TEXT                                                             AS STATUS,
               COALESCE(TRUNC(P.VALOR :: NUMERIC, 2) :: TEXT, '-')                          AS VALOR_AQUISICAO,
               FORMAT_WITH_TZ(P.DATA_HORA_CADASTRO,
                              TZ_UNIDADE(P.COD_UNIDADE_CADASTRO),
                              F_TIMESTAMP_FORMAT,
                              '-')                                                          AS DATA_HORA_CADASTRO,
               MAP.NOME :: TEXT                                                             AS NOME_MARCA_PNEU,
               MP.NOME :: TEXT                                                              AS NOME_MODELO_PNEU,
               F_IF(MARB.CODIGO IS NULL, 'Nunca Recapado', MARB.NOME || ' - ' || MODB.NOME) AS BANDA_APLICADA,
               COALESCE(TRUNC(PVV.VALOR :: NUMERIC, 2) :: TEXT, '-')                        AS VALOR_BANDA,
               FUNC_PNEU_FORMAT_DIMENSAO(DP.LARGURA, DP.ALTURA, DP.ARO)                     AS MEDIDAS,
               COALESCE(VP.PLACA, '-') :: TEXT                                              AS PLACA,
               COALESCE(VT.NOME, '-') :: TEXT                                               AS TIPO_VEICULO,
               COALESCE(PPNE.NOMENCLATURA :: TEXT, '-')                                     AS POSICAO_PNEU,
               COALESCE(MODB.QT_SULCOS, MP.QT_SULCOS) :: TEXT                               AS QTD_SULCOS,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_INTERNO)                               AS SULCO_INTERNO,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_INTERNO)                       AS SULCO_CENTRAL_INTERNO,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_EXTERNO)                       AS SULCO_CENTRAL_EXTERNO,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_EXTERNO)                               AS SULCO_EXTERNO,
               FUNC_PNEU_FORMAT_SULCO(LEAST(P.ALTURA_SULCO_EXTERNO, P.ALTURA_SULCO_CENTRAL_EXTERNO,
                                            P.ALTURA_SULCO_CENTRAL_INTERNO,
                                            P.ALTURA_SULCO_INTERNO))                        AS MENOR_SULCO,
               COALESCE(TRUNC(P.PRESSAO_ATUAL) :: TEXT, '-')                                AS PRESSAO_ATUAL,
               P.PRESSAO_RECOMENDADA :: TEXT                                                AS PRESSAO_RECOMENDADA,
               PVN.NOME :: TEXT                                                             AS VIDA_ATUAL,
               COALESCE(P.DOT, '-') :: TEXT                                                 AS DOT,
               -- Usamos um CASE ao invés do coalesce da func FORMAT_WITH_TZ, pois desse modo evitamos o evaluate
               -- dos dois selects internos de consulta na tabela AFERICAO caso o pneu nunca tenha sido aferido.
               CASE
                   WHEN UA.COD_AFERICAO IS NULL
                       THEN 'Nunca Aferido'
                   ELSE
                       FORMAT_WITH_TZ((SELECT A.DATA_HORA
                                       FROM AFERICAO A
                                       WHERE A.CODIGO = UA.COD_AFERICAO),
                                      TZ_UNIDADE((SELECT A.COD_UNIDADE
                                                  FROM AFERICAO A
                                                  WHERE A.CODIGO = UA.COD_AFERICAO)),
                                      F_TIMESTAMP_FORMAT)
                   END                                                                      AS ULTIMA_AFERICAO,
               PTDI.DESCRICAO                                                               AS DESCRICAO_DESGASTE,
               -- Por enquanto, deixamos hardcoded os ranges de cada nível de desgaste.
               CASE
                   WHEN VERIF_DESGASTE.NIVEL_DESGASTE_IRREGULAR = 'BAIXO'
                       THEN 'BAIXO (0.1 mm até 0.9 mm)'
                   WHEN VERIF_DESGASTE.NIVEL_DESGASTE_IRREGULAR = 'MODERADO'
                       THEN 'MODERADO (1.0 mm até 2.0 mm)'
                   WHEN VERIF_DESGASTE.NIVEL_DESGASTE_IRREGULAR = 'ACENTUADO'
                       THEN 'ACENTUADO (2.1 mm e acima)'
                   END                                                                      AS NIVEL_DESGASTE,
               PTDI.APARENCIA_PNEU                                                          AS APARENCIA_PNEU,
               PTDI.CAUSAS_PROVAVEIS                                                        AS CAUSAS_PROVAVEIS,
               PTDI.ACAO                                                                    AS ACAO,
               PTDI.PRECAUCAO                                                               AS PRECAUCAO
        FROM PNEU P
                 JOIN DIMENSAO_PNEU DP ON DP.CODIGO = P.COD_DIMENSAO
                 JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
                 JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
                 JOIN MODELO_PNEU MP ON MP.CODIGO = P.COD_MODELO AND MP.COD_EMPRESA = U.COD_EMPRESA
                 JOIN MARCA_PNEU MAP ON MAP.CODIGO = MP.COD_MARCA
                 JOIN PNEU_VIDA_NOMENCLATURA PVN ON PVN.COD_VIDA = P.VIDA_ATUAL
                 JOIN FUNC_PNEU_VERIFICA_DESGASTE_IRREGULAR(P.CODIGO,
                                                            P.ALTURA_SULCO_EXTERNO,
                                                            P.ALTURA_SULCO_CENTRAL_EXTERNO,
                                                            P.ALTURA_SULCO_CENTRAL_INTERNO,
                                                            P.ALTURA_SULCO_INTERNO) VERIF_DESGASTE
                      ON VERIF_DESGASTE.COD_PNEU = P.CODIGO
                 LEFT JOIN PNEU_TIPO_DESGASTE_IRREGULAR PTDI
                           ON PTDI.TIPO_DESGASTE_IRREGULAR = VERIF_DESGASTE.TIPO_DESGASTE_IRREGULAR
                 LEFT JOIN MODELO_BANDA MODB ON MODB.CODIGO = P.COD_MODELO_BANDA
                 LEFT JOIN MARCA_BANDA MARB ON MARB.CODIGO = MODB.COD_MARCA
                 LEFT JOIN PNEU_VALOR_VIDA PVV ON P.CODIGO = PVV.COD_PNEU AND PVV.VIDA = P.VIDA_ATUAL
                 LEFT JOIN VEICULO_PNEU VP
                           ON P.CODIGO = VP.COD_PNEU
                               AND P.COD_UNIDADE = VP.COD_UNIDADE
                 LEFT JOIN VEICULO V
                           ON VP.PLACA = V.PLACA
                               AND VP.COD_UNIDADE = V.COD_UNIDADE
                 LEFT JOIN VEICULO_TIPO VT
                           ON V.COD_TIPO = VT.CODIGO
                 LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
                 LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
            AND PPNE.COD_DIAGRAMA = VD.CODIGO
            AND PPNE.POSICAO_PROLOG = VP.POSICAO
                 LEFT JOIN ULTIMAS_AFERICOES UA
                           ON UA.COD_PNEU_AFERIDO = P.CODIGO
        WHERE P.COD_UNIDADE = ANY (F_COD_UNIDADES)
          AND F_IF(F_STATUS_PNEU IS NULL, TRUE, F_STATUS_PNEU = P.STATUS :: PNEU_STATUS_TYPE)
          AND VERIF_DESGASTE.TEM_DESGASTE_IRREGULAR
        ORDER BY VERIF_DESGASTE.NIVEL_DESGASTE_IRREGULAR DESC, U.NOME, P.CODIGO_CLIENTE;
END;
$$;

create or replace function public.func_pneu_relatorio_status_atual_pneus(f_cod_unidades bigint[])
    returns TABLE
            (
                "UNIDADE ALOCADO"    text,
                "PNEU"               text,
                "STATUS ATUAL"       text,
                "PLACA APLICADO"     text,
                "POSIÇÃO APLICADO"   text,
                "RECAPADORA ALOCADO" text
            )
    language plpgsql
as
$$
DECLARE
    F_STATUS_ANALISE TEXT := 'ANALISE';
BEGIN
    RETURN QUERY
        SELECT U.NOME :: TEXT                           AS UNIDADE_ALOCADO,
               P.CODIGO_CLIENTE :: TEXT                 AS COD_PNEU,
               P.STATUS :: TEXT                         AS STATUS_ATUAL,
               COALESCE(VP.PLACA :: TEXT, '-')          AS PLACA_APLICADO,
               COALESCE(PPNE.NOMENCLATURA :: TEXT, '-') AS POSICAO_APLICADO,
               COALESCE(
                       CASE
                           WHEN P.STATUS = F_STATUS_ANALISE
                               THEN (SELECT R.NOME AS NOME_RECAPADORA
                                     FROM MOVIMENTACAO M
                                              JOIN MOVIMENTACAO_DESTINO MD
                                                   ON M.CODIGO = MD.COD_MOVIMENTACAO
                                              JOIN RECAPADORA R ON MD.COD_RECAPADORA_DESTINO = R.CODIGO
                                     WHERE M.COD_PNEU = P.CODIGO
                                     ORDER BY M.CODIGO DESC
                                     LIMIT 1)
                           END,
                       '-')                             AS RECAPADORA_ALOCADO
        FROM PNEU P
                 JOIN UNIDADE U
                      ON P.COD_UNIDADE = U.CODIGO
                 JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
                 LEFT JOIN VEICULO_PNEU VP
                           ON P.CODIGO = VP.COD_PNEU
                               AND P.COD_UNIDADE = VP.COD_UNIDADE
                 LEFT JOIN VEICULO V
                           ON VP.PLACA = V.PLACA
                               AND VP.COD_UNIDADE = V.COD_UNIDADE
                 LEFT JOIN VEICULO_TIPO VT
                           ON V.COD_TIPO = VT.CODIGO
                 LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
                 LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
            AND PPNE.COD_DIAGRAMA = VD.CODIGO
            AND PPNE.POSICAO_PROLOG = VP.POSICAO
        WHERE P.COD_UNIDADE = ANY (F_COD_UNIDADES)
        ORDER BY U.CODIGO ASC, P.CODIGO_CLIENTE ASC;
END;
$$;

create or replace function public.func_relatorio_dados_ultima_afericao_pneu(f_cod_unidades text[])
    returns TABLE
            (
                "UNIDADE ALOCADO"               text,
                "PNEU"                          text,
                "STATUS ATUAL"                  text,
                "MARCA PNEU"                    text,
                "MODELO PNEU"                   text,
                "MEDIDAS"                       text,
                "PLACA APLICADO"                text,
                "MARCA VEÍCULO"                 text,
                "MODELO VEÍCULO"                text,
                "TIPO VEÍCULO"                  text,
                "POSIÇÃO APLICADO"              text,
                "SULCO INTERNO"                 text,
                "SULCO CENTRAL INTERNO"         text,
                "SULCO CENTRAL EXTERNO"         text,
                "SULCO EXTERNO"                 text,
                "MENOR SULCO"                   text,
                "PRESSÃO (PSI)"                 text,
                "VIDA ATUAL"                    text,
                "DOT"                           text,
                "ÚLTIMA AFERIÇÃO"               text,
                "TIPO PROCESSO ÚLTIMA AFERIÇÃO" text
            )
    language plpgsql
as
$$
BEGIN
    -- Essa CTE busca o código da última aferição de cada pneu.
    -- Com o código nós conseguimos buscar depois qualquer outra informação da aferição.
    RETURN QUERY
        WITH CODS_AFERICOES AS (
            SELECT AV.COD_PNEU   AS COD_PNEU_AFERIDO,
                   MAX(A.CODIGO) AS COD_AFERICAO
            FROM AFERICAO A
                     JOIN AFERICAO_VALORES AV
                          ON AV.COD_AFERICAO = A.CODIGO
                     JOIN PNEU P ON P.CODIGO = AV.COD_PNEU
            WHERE P.COD_UNIDADE :: TEXT = ANY (F_COD_UNIDADES)
            GROUP BY AV.COD_PNEU
        ),

             ULTIMAS_AFERICOES AS (
                 SELECT CA.COD_PNEU_AFERIDO    AS COD_PNEU_AFERIDO,
                        A.DATA_HORA            AS DATA_HORA_AFERICAO,
                        A.COD_UNIDADE          AS COD_UNIDADE_AFERICAO,
                        A.TIPO_PROCESSO_COLETA AS TIPO_PROCESSO_COLETA
                 FROM CODS_AFERICOES CA
                          JOIN AFERICAO A ON A.CODIGO = CA.COD_AFERICAO)

        SELECT U.NOME :: TEXT                                                   AS UNIDADE_ALOCADO,
               P.CODIGO_CLIENTE :: TEXT                                         AS COD_PNEU,
               P.STATUS :: TEXT                                                 AS STATUS_ATUAL,
               MAP.NOME :: TEXT                                                 AS NOME_MARCA,
               MP.NOME :: TEXT                                                  AS NOME_MODELO,
               ((((DP.LARGURA || '/' :: TEXT) || DP.ALTURA) || ' R' :: TEXT) ||
                DP.ARO)                                                         AS MEDIDAS,
               COALESCE(VP.PLACA, '-') :: TEXT                                  AS PLACA,
               COALESCE(MARV.NOME, '-') :: TEXT                                 AS MARCA_VEICULO,
               COALESCE(MODV.NOME, '-') :: TEXT                                 AS MODELO_VEICULO,
               COALESCE(VT.NOME, '-') :: TEXT                                   AS TIPO_VEICULO,
               COALESCE(PPNE.NOMENCLATURA:: TEXT, '-')                          AS POSICAO_PNEU,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_INTERNO)                   AS SULCO_INTERNO,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_INTERNO)           AS SULCO_CENTRAL_INTERNO,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_EXTERNO)           AS SULCO_CENTRAL_EXTERNO,
               FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_EXTERNO)                   AS SULCO_EXTERNO,
               FUNC_PNEU_FORMAT_SULCO(LEAST(P.ALTURA_SULCO_EXTERNO, P.ALTURA_SULCO_CENTRAL_EXTERNO,
                                            P.ALTURA_SULCO_CENTRAL_INTERNO,
                                            P.ALTURA_SULCO_INTERNO))            AS MENOR_SULCO,
               REPLACE(COALESCE(TRUNC(P.PRESSAO_ATUAL) :: TEXT, '-'), '.', ',') AS PRESSAO_ATUAL,
               P.VIDA_ATUAL :: TEXT                                             AS VIDA_ATUAL,
               COALESCE(P.DOT, '-') :: TEXT                                     AS DOT,
               COALESCE(TO_CHAR(UA.DATA_HORA_AFERICAO AT TIME ZONE
                                tz_unidade(UA.COD_UNIDADE_AFERICAO),
                                'DD/MM/YYYY HH24:MI'),
                        'Nunca Aferido')                                        AS ULTIMA_AFERICAO,
               CASE
                   WHEN UA.TIPO_PROCESSO_COLETA IS NULL
                       THEN 'Nunca Aferido'
                   WHEN UA.TIPO_PROCESSO_COLETA = 'PLACA'
                       THEN 'Aferido em uma placa'
                   ELSE 'Aferido Avulso (em estoque)' END                       AS TIPO_PROCESSO_ULTIMA_AFERICAO
        FROM PNEU P
                 JOIN DIMENSAO_PNEU DP ON DP.CODIGO = P.COD_DIMENSAO
                 JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
                 JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
                 JOIN MODELO_PNEU MP ON MP.CODIGO = P.COD_MODELO AND MP.COD_EMPRESA = U.COD_EMPRESA
                 JOIN MARCA_PNEU MAP ON MAP.CODIGO = MP.COD_MARCA
                 LEFT JOIN VEICULO_PNEU VP
                           ON P.CODIGO = VP.COD_PNEU
                               AND P.COD_UNIDADE = VP.COD_UNIDADE
                 LEFT JOIN VEICULO V
                           ON VP.PLACA = V.PLACA
                               AND VP.COD_UNIDADE = V.COD_UNIDADE
                 LEFT JOIN VEICULO_TIPO VT
                           ON V.COD_TIPO = VT.CODIGO
                 LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
                 LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
            AND PPNE.COD_DIAGRAMA = VD.CODIGO
            AND PPNE.POSICAO_PROLOG = VP.POSICAO
                 LEFT JOIN MODELO_VEICULO MODV
                           ON MODV.CODIGO = V.COD_MODELO
                 LEFT JOIN MARCA_VEICULO MARV
                           ON MARV.CODIGO = MODV.COD_MARCA
                 LEFT JOIN ULTIMAS_AFERICOES UA
                           ON UA.COD_PNEU_AFERIDO = P.CODIGO
        WHERE P.COD_UNIDADE :: TEXT = ANY (F_COD_UNIDADES)
        ORDER BY U.NOME, P.CODIGO_CLIENTE;
END;
$$;

create or replace function public.func_relatorio_pneu_extrato_servicos_abertos(f_cod_unidade text[],
                                                                               f_data_inicial date, f_data_final date,
                                                                               f_data_atual date)
    returns TABLE
            (
                "UNIDADE DO SERVIÇO"            text,
                "CÓDIGO DO SERVIÇO"             text,
                "TIPO DO SERVIÇO"               text,
                "QTD APONTAMENTOS"              text,
                "DATA HORA ABERTURA"            text,
                "QTD DIAS EM ABERTO"            text,
                "NOME DO COLABORADOR"           text,
                "PLACA"                         text,
                "PNEU"                          text,
                "POSIÇÃO PNEU ABERTURA SERVIÇO" text,
                "MEDIDAS"                       text,
                "COD AFERIÇÃO"                  text,
                "SULCO INTERNO"                 text,
                "SULCO CENTRAL INTERNO"         text,
                "SULCO CENTRAL EXTERNO"         text,
                "SULCO EXTERNO"                 text,
                "MENOR SULCO"                   text,
                "PRESSÃO (PSI)"                 text,
                "PRESSÃO RECOMENDADA (PSI)"     text,
                "ESTADO ATUAL"                  text,
                "MÁXIMO DE RECAPAGENS"          text
            )
    language sql
as
$$
SELECT U.NOME                                                                                       AS UNIDADE_SERVICO,
       AM.CODIGO :: TEXT                                                                            AS CODIGO_SERVICO,
       AM.TIPO_SERVICO                                                                              AS TIPO_SERVICO,
       AM.QT_APONTAMENTOS :: TEXT                                                                   AS QT_APONTAMENTOS,
       TO_CHAR((A.DATA_HORA AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)),
               'DD/MM/YYYY HH24:MI') :: TEXT                                                        AS DATA_HORA_ABERTURA,
       (F_DATA_ATUAL - ((A.DATA_HORA AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)) :: DATE)) :: TEXT     AS DIAS_EM_ABERTO,
       C.NOME                                                                                       AS NOME_COLABORADOR,
       A.PLACA_VEICULO                                                                              AS PLACA_VEICULO,
       P.CODIGO_CLIENTE                                                                             AS COD_PNEU_PROBLEMA,
       COALESCE(PPNE.NOMENCLATURA :: TEXT, '-')                                                     AS POSICAO_PNEU_PROBLEMA,
       DP.LARGURA || '/' :: TEXT || DP.ALTURA || ' R' :: TEXT || DP.ARO                             AS MEDIDAS,
       A.CODIGO :: TEXT                                                                             AS COD_AFERICAO,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_INTERNO)                                              AS SULCO_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_CENTRAL_INTERNO)                                      AS SULCO_CENTRAL_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_CENTRAL_EXTERNO)                                      AS SULCO_CENTRAL_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_EXTERNO)                                              AS SULCO_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(LEAST(AV.ALTURA_SULCO_EXTERNO, AV.ALTURA_SULCO_CENTRAL_EXTERNO,
                                    AV.ALTURA_SULCO_CENTRAL_INTERNO,
                                    AV.ALTURA_SULCO_INTERNO))                                       AS MENOR_SULCO,
       REPLACE(COALESCE(TRUNC(AV.PSI) :: TEXT, '-'), '.', ',')                                      AS PRESSAO_PNEU_PROBLEMA,
       REPLACE(COALESCE(TRUNC(P.PRESSAO_RECOMENDADA) :: TEXT, '-'), '.',
               ',')                                                                                 AS PRESSAO_RECOMENDADA,
       PVN.NOME                                                                                     AS VIDA_PNEU_PROBLEMA,
       PRN.NOME                                                                                     AS TOTAL_RECAPAGENS
FROM AFERICAO_MANUTENCAO AM
         JOIN PNEU P
              ON AM.COD_PNEU = P.CODIGO
         JOIN DIMENSAO_PNEU DP
              ON DP.CODIGO = P.COD_DIMENSAO
         JOIN AFERICAO A
              ON A.CODIGO = AM.COD_AFERICAO
         JOIN COLABORADOR C
              ON A.CPF_AFERIDOR = C.CPF
         JOIN AFERICAO_VALORES AV
              ON AV.COD_AFERICAO = AM.COD_AFERICAO
                  AND AV.COD_PNEU = AM.COD_PNEU
         JOIN UNIDADE U
              ON U.CODIGO = AM.COD_UNIDADE
         JOIN EMPRESA E
              ON U.COD_EMPRESA = E.CODIGO
         JOIN PNEU_VIDA_NOMENCLATURA PVN
              ON PVN.COD_VIDA = AV.VIDA_MOMENTO_AFERICAO
         JOIN PNEU_RECAPAGEM_NOMENCLATURA PRN
              ON PRN.COD_TOTAL_VIDA = P.VIDA_TOTAL
         JOIN VEICULO V
              ON A.PLACA_VEICULO = V.PLACA
                  AND V.COD_UNIDADE = A.COD_UNIDADE
         LEFT JOIN VEICULO_TIPO VT
                   ON V.COD_TIPO = VT.CODIGO
         LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
    AND PPNE.COD_DIAGRAMA = VD.CODIGO
    AND AV.POSICAO = PPNE.POSICAO_PROLOG
WHERE AM.COD_UNIDADE :: TEXT LIKE ANY (F_COD_UNIDADE)
  AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)) :: DATE >= F_DATA_INICIAL
  AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(AM.COD_UNIDADE)) :: DATE <= F_DATA_FINAL
  AND AM.DATA_HORA_RESOLUCAO IS NULL
  AND (AM.FECHADO_AUTOMATICAMENTE_MOVIMENTACAO = FALSE OR AM.FECHADO_AUTOMATICAMENTE_MOVIMENTACAO IS NULL)
  AND (AM.FECHADO_AUTOMATICAMENTE_INTEGRACAO = FALSE OR AM.FECHADO_AUTOMATICAMENTE_INTEGRACAO IS NULL)
ORDER BY U.NOME, A.DATA_HORA;
$$;

create or replace function public.func_relatorio_previsao_troca(f_data_inicial date, f_data_final date,
                                                                f_cod_unidade text[], f_status_pneu character varying)
    returns TABLE
            (
                "UNIDADE ALOCADO"         text,
                "COD PNEU"                text,
                "STATUS"                  text,
                "VIDA ATUAL"              integer,
                "MARCA"                   text,
                "MODELO"                  text,
                "MEDIDAS"                 text,
                "PLACA APLICADO"          text,
                "POSIÇÃO APLICADO"        text,
                "QTD DE AFERIÇÕES"        bigint,
                "DATA 1ª AFERIÇÃO"        text,
                "DATA ÚLTIMA AFERIÇÃO"    text,
                "DIAS ATIVO"              integer,
                "MÉDIA KM POR DIA"        numeric,
                "MAIOR MEDIÇÃO VIDA"      numeric,
                "MENOR SULCO ATUAL"       numeric,
                "MILÍMETROS GASTOS"       numeric,
                "KMS POR MILÍMETRO"       numeric,
                "VALOR VIDA"              real,
                "VALOR ACUMULADO"         real,
                "VALOR POR KM VIDA ATUAL" numeric,
                "VALOR POR KM ACUMULADO"  numeric,
                "KMS A PERCORRER"         numeric,
                "DIAS RESTANTES"          double precision,
                "PREVISÃO DE TROCA"       text,
                "DESTINO"                 text
            )
    language sql
as
$$
SELECT VAP."UNIDADE ALOCADO",
       VAP."COD PNEU CLIENTE",
       VAP."STATUS PNEU",
       VAP."VIDA ATUAL",
       VAP."MARCA",
       VAP."MODELO",
       VAP."MEDIDAS",
       VP.PLACA                                 AS PLACA_APLICADO,
       COALESCE(PPNE.NOMENCLATURA, '-') :: TEXT AS POSICAO_APLICADO,
       VAP."QTD DE AFERIÇÕES",
       VAP."DTA 1a AFERIÇÃO",
       VAP."DTA ÚLTIMA AFERIÇÃO",
       VAP."DIAS ATIVO",
       VAP."MÉDIA KM POR DIA",
       VAP."MAIOR MEDIÇÃO VIDA",
       VAP."MENOR SULCO ATUAL",
       VAP."MILIMETROS GASTOS",
       VAP."KMS POR MILIMETRO",
       VAP.VALOR_VIDA_ATUAL,
       VAP.VALOR_ACUMULADO,
       VAP."VALOR POR KM",
       VAP."VALOR POR KM ACUMULADO",
       VAP."KMS A PERCORRER",
       VAP."DIAS RESTANTES",
       TO_CHAR(VAP."PREVISÃO DE TROCA", 'DD/MM/YYYY'),
       VAP."DESTINO"
FROM VIEW_PNEU_ANALISE_VIDA_ATUAL AS VAP
         JOIN VEICULO_PNEU VP
              ON VAP."COD PNEU" = VP.COD_PNEU
         JOIN VEICULO V
              ON VP.PLACA = V.PLACA
         LEFT JOIN VEICULO_TIPO VT
                   ON V.COD_TIPO = VT.CODIGO
         JOIN EMPRESA E ON VT.COD_EMPRESA = E.CODIGO
         LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON PPNE.COD_EMPRESA = E.CODIGO
    AND PPNE.COD_DIAGRAMA = VD.CODIGO
    AND VP.POSICAO = PPNE.POSICAO_PROLOG
WHERE VAP.COD_UNIDADE :: TEXT LIKE ANY (F_COD_UNIDADE)
  AND VAP."PREVISÃO DE TROCA" <= F_DATA_FINAL
  AND VAP."STATUS PNEU" LIKE F_STATUS_PNEU
ORDER BY VAP."UNIDADE ALOCADO";
$$;

create or replace function public.is_placa_posicao_pneu_valida(f_cod_veiculo bigint, f_posicao_pneu integer,
                                                               f_is_pneu_estepe boolean) returns boolean
    language plpgsql
as
$$
DECLARE
    IS_POSICAO_VALIDA BOOLEAN;
BEGIN
    IF (F_IS_PNEU_ESTEPE)
    THEN
        SELECT (F_POSICAO_PNEU >= 900 AND F_POSICAO_PNEU <= 908) INTO IS_POSICAO_VALIDA;
    ELSE
        SELECT EXISTS(SELECT VDPP.POSICAO_PROLOG
                      FROM VEICULO_DIAGRAMA_POSICAO_PROLOG VDPP
                      WHERE VDPP.POSICAO_PROLOG = F_POSICAO_PNEU
                        AND VDPP.COD_DIAGRAMA = (SELECT VT.COD_DIAGRAMA
                                                 FROM VEICULO_TIPO VT
                                                 WHERE VT.CODIGO = (SELECT V.COD_TIPO
                                                                    FROM VEICULO V
                                                                    WHERE V.CODIGO = F_COD_VEICULO)))
        INTO IS_POSICAO_VALIDA;
    END IF;
    RETURN IS_POSICAO_VALIDA;
END;
$$;

create or replace function public.func_gera_similaridade(f_texto1 text, f_texto2 text) returns real
    language plpgsql
as
$$
BEGIN
    RETURN SIMILARITY(REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(F_TEXTO1),
                      REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(F_TEXTO2));
END;
$$;

create or replace function public.remove_espacos_e_caracteres_especiais(f_texto text) returns text
    language plpgsql
as
$$
BEGIN
    RETURN REGEXP_REPLACE(UNACCENT(F_TEXTO), '[^a-zA-Z0-9]+', '', 'g');
END;
$$;



create or replace function implantacao.func_veiculo_confere_planilha_importacao(f_cod_unidade bigint, f_json_veiculos jsonb)
    returns TABLE
            (
                "PLACA NA PLANILHA"           text,
                "PLACA DUPLICADA NA PLANILHA" text,
                "PLACA PLANILHA FORMATADA"    text,
                "POSSUI 7 DIGITOS?"           text,
                "PLACA_NA_UNIDADE/EMPRESA"    text,
                "STATUS_ATIVO_BANCO"          boolean,
                "KM VEICULO"                  bigint,
                "MARCA PLANILHA"              text,
                "MARCA BANCO"                 text,
                "COD_MARCA"                   text,
                "MODELO PLANILHA"             text,
                "MODELO BANCO"                text,
                "COD_MODELO"                  text,
                "DIAGRAMA PLANILHA"           text,
                "DIAGRAMA BANCO"              text,
                "COD_DIAGRAMA"                text,
                "TIPO PLANILHA"               text,
                "TIPO BANCO"                  text,
                "COD_TIPO"                    text
            )
    language plpgsql
as
$$
DECLARE
    F_COD_EMPRESA CONSTANT            BIGINT := (SELECT U.COD_EMPRESA
                                                 FROM UNIDADE U
                                                 WHERE U.CODIGO = F_COD_UNIDADE);
    F_SIMILARIDADE CONSTANT           REAL   = 0.4;
    F_SIMILIARIDADE_DIAGRAMA CONSTANT REAL   = 0.5;
    F_SEM_SIMILARIDADE CONSTANT       REAL   = 0.0;
    NAO_ENCONTRADO CONSTANT           TEXT   := '-';
BEGIN
    CREATE TEMP TABLE IF NOT EXISTS TABLE_JSON
    (
        CODIGO             BIGSERIAL,
        PLACA              TEXT,
        PLACA_FORMATADA    TEXT,
        KM                 BIGINT,
        MARCA              TEXT,
        MARCA_FORMATADA    TEXT,
        MODELO             TEXT,
        MODELO_FORMATADO   TEXT,
        TIPO               TEXT,
        TIPO_FORMATADO     TEXT,
        DIAGRAMA           TEXT,
        DIAGRAMA_FORMATADO TEXT
    ) ON COMMIT DELETE ROWS;
    INSERT
    INTO TABLE_JSON (PLACA,
                     PLACA_FORMATADA,
                     KM,
                     MARCA,
                     MARCA_FORMATADA,
                     MODELO,
                     MODELO_FORMATADO,
                     TIPO,
                     TIPO_FORMATADO,
                     DIAGRAMA,
                     DIAGRAMA_FORMATADO)
    SELECT (SRC ->> 'placa') :: TEXT,
           REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS((SRC ->> 'placa')) :: TEXT,
           (SRC ->> 'km') :: BIGINT,
           (SRC ->> 'marca') :: TEXT,
           REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(SRC ->> ('marca')) :: TEXT,
           (SRC ->> 'modelo') :: TEXT,
           REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(SRC ->> ('modelo')) :: TEXT,
           (SRC ->> 'tipo') :: TEXT,
           REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(SRC ->> ('tipo')) :: TEXT,
           (SRC ->> 'diagrama') :: TEXT,
           REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(SRC ->> ('diagrama')) :: TEXT
    FROM JSONB_ARRAY_ELEMENTS(F_JSON_VEICULOS) SRC;

    RETURN QUERY
        -- PROCURA PLACAS DUPLICADAS.
        WITH PROCURA_PLACAS_DUPLICADAS AS (
            SELECT TJ.PLACA_FORMATADA,
                   COUNT(TJ.PLACA_FORMATADA) AS PLACAS_DUPLICADAS
            FROM TABLE_JSON TJ
            GROUP BY TJ.PLACA_FORMATADA
        ),

             -- VERIFICAÇÕES PLACA.
             VERIFICACOES_PLACA AS (
                 SELECT TJ.CODIGO,
                        TJ.PLACA AS PLACA_PLANILHA,
                        CASE
                            WHEN (PPD.PLACAS_DUPLICADAS > 1)
                                THEN 'SIM'
                            ELSE NAO_ENCONTRADO
                            END  AS PLACAS_DUPLICADAS,
                        TJ.PLACA_FORMATADA,
                        V.PLACA  AS PLACA_VEICULO,
                        V.STATUS_ATIVO,
                        CASE
                            WHEN (V.PLACA IS NULL)
                                THEN NAO_ENCONTRADO
                            -- Vai retornar assim: ("Unidade Teste", "Zalf Sistemas").
                            ELSE (U.NOME, E.NOME) :: TEXT
                            END  AS PLACA_NA_UNIDADE_EMPRESA,
                        CASE
                            WHEN LENGTH(TJ.PLACA_FORMATADA) <> 7
                                THEN 'NÃO POSSUI'
                            ELSE 'SIM'
                            END  AS PLACA_7_DIGITOS,
                        TJ.KM
                 FROM TABLE_JSON TJ
                          JOIN PROCURA_PLACAS_DUPLICADAS PPD
                               ON PPD.PLACA_FORMATADA = TJ.PLACA_FORMATADA
                          LEFT JOIN VEICULO V ON TJ.PLACA_FORMATADA ILIKE V.PLACA
                          LEFT JOIN UNIDADE U ON V.COD_UNIDADE = U.CODIGO
                          LEFT JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
             ),

             -- PROCURA SIMILARIDADE DE MARCA DE VEÍCULO NO BANCO.
             SIMILARIDADE_MARCAS_VEICULOS AS (
                 SELECT DISTINCT ON (TJ.MARCA_FORMATADA) TJ.MARCA                                                  AS MARCA_PLANILHA,
                                                         TJ.MARCA_FORMATADA                                        AS MARCA_PLANILHA_FORMATADA,
                                                         MAV.NOME                                                  AS MARCA_VEICULO_BANCO,
                                                         MAV.CODIGO                                                AS COD_MARCA_BANCO,
                                                         MAX(FUNC_GERA_SIMILARIDADE(TJ.MARCA_FORMATADA, MAV.NOME)) AS SIMILARIEDADE_MARCA
                 FROM TABLE_JSON TJ
                          FULL JOIN MARCA_VEICULO MAV ON TRUE
                 GROUP BY TJ.MARCA_FORMATADA, TJ.MARCA, MAV.NOME, MAV.CODIGO
                 ORDER BY TJ.MARCA_FORMATADA, SIMILARIEDADE_MARCA DESC
             ),

             -- REMOVE MARCAS_MODELOS IGUAIS.
             DISTINCT_MARCAS_MODELOS_VEICULOS AS (
                 SELECT DISTINCT ON (CONCAT(SMV.COD_MARCA_BANCO, TJ.MODELO_FORMATADO)) SMV.COD_MARCA_BANCO,
                                                                                       TJ.MARCA                                         AS MARCA_PLANILHA,
                                                                                       TJ.MODELO                                        AS MODELO_PLANILHA,
                                                                                       CONCAT(SMV.COD_MARCA_BANCO, TJ.MODELO)           AS MARCA_MODELO_PLANILHA,
                                                                                       CONCAT(SMV.COD_MARCA_BANCO, TJ.MODELO_FORMATADO) AS MARCA_MODELO_PLANILHA_FORMATADA
                 FROM TABLE_JSON TJ
                          JOIN SIMILARIDADE_MARCAS_VEICULOS SMV ON TJ.MARCA = SMV.MARCA_PLANILHA
             ),

             -- PROCURA SIMILARIEDADE DE MARCA_MODELO DE VEÍCULO NO BANCO.
             SIMILARIEDADE_MARCAS_MODELOS_VEICULOS AS (
                 SELECT DISTINCT ON (DMMV.MARCA_MODELO_PLANILHA_FORMATADA) DMMV.MARCA_PLANILHA                  AS MARCA_PLANILHA,
                                                                           DMMV.MODELO_PLANILHA                 AS MODELO_PLANILHA,
                                                                           DMMV.MARCA_MODELO_PLANILHA           AS MARCA_MODELO_PLANILHA,
                                                                           DMMV.MARCA_MODELO_PLANILHA_FORMATADA AS MARCA_MODELO_PLANILHA_FORMATADA,
                                                                           MAV.NOME                             AS MARCA_VEICULO_BANCO,
                                                                           MAV.CODIGO                           AS COD_MARCA_VEICULO,
                                                                           MOV.NOME                             AS MODELO_VEICULO_BANCO,
                                                                           MOV.CODIGO                           AS COD_MODELO_VEICULO,
                                                                           CASE
                                                                               WHEN DMMV.COD_MARCA_BANCO = MAV.CODIGO
                                                                                   THEN
                                                                                   MAX(FUNC_GERA_SIMILARIDADE(DMMV.MODELO_PLANILHA, MOV.NOME))
                                                                               ELSE F_SEM_SIMILARIDADE
                                                                               END                              AS SIMILARIEDADE_MARCA_MODELO
                 FROM DISTINCT_MARCAS_MODELOS_VEICULOS DMMV
                          FULL JOIN MARCA_VEICULO MAV ON TRUE
                          JOIN MODELO_VEICULO MOV ON MAV.CODIGO = MOV.COD_MARCA
                 WHERE MOV.COD_EMPRESA = F_COD_EMPRESA
                 GROUP BY DMMV.MARCA_MODELO_PLANILHA_FORMATADA, DMMV.MARCA_MODELO_PLANILHA, DMMV.MARCA_PLANILHA,
                          DMMV.COD_MARCA_BANCO,
                          DMMV.MODELO_PLANILHA, MAV.NOME,
                          MAV.CODIGO, MOV.NOME,
                          MOV.CODIGO
                 ORDER BY DMMV.MARCA_MODELO_PLANILHA_FORMATADA, SIMILARIEDADE_MARCA_MODELO DESC
             ),

             -- PROCURA DIAGRAMA NO BANCO.
             SIMILARIEDADE_DIAGRAMA AS (
                 SELECT DISTINCT ON (TJ.DIAGRAMA_FORMATADO ) TJ.DIAGRAMA                                                 AS DIAGRAMA_PLANILHA,
                                                             TJ.DIAGRAMA_FORMATADO                                       AS DIAGRAMA_PLANILHA_FORMATADO,
                                                             VD.NOME                                                     AS DIAGRAMA_BANCO,
                                                             VD.CODIGO                                                   AS COD_DIAGRAMA_BANCO,
                                                             MAX(FUNC_GERA_SIMILARIDADE(TJ.DIAGRAMA_FORMATADO, VD.NOME)) AS SIMILARIEDADE_DIAGRAMA
                 FROM TABLE_JSON TJ
                          FULL JOIN VEICULO_DIAGRAMA VD ON TRUE
                 GROUP BY TJ.DIAGRAMA_FORMATADO, TJ.DIAGRAMA, VD.NOME, VD.CODIGO
                 ORDER BY TJ.DIAGRAMA_FORMATADO, SIMILARIEDADE_DIAGRAMA DESC
             ),

             -- REMOVE TIPOS IGUAIS.
             DISTINCT_TIPOS_DIAGRAMA_VEICULOS AS (
                 SELECT DISTINCT ON (CONCAT(SD.COD_DIAGRAMA_BANCO, TJ.TIPO_FORMATADO)) SD.COD_DIAGRAMA_BANCO,
                                                                                       TJ.DIAGRAMA                                      AS DIAGRAMA_PLANILHA,
                                                                                       TJ.TIPO                                          AS TIPO_PLANILHA,
                                                                                       CONCAT(TJ.TIPO, TJ.DIAGRAMA)                     AS TIPO_DIAGRAMA_PLANILHA,
                                                                                       CONCAT(TJ.TIPO_FORMATADO, TJ.DIAGRAMA_FORMATADO) AS TIPO_DIAGRAMA_PLANILHA_FORMATADO
                 FROM TABLE_JSON TJ
                          JOIN SIMILARIEDADE_DIAGRAMA SD ON TJ.DIAGRAMA = SD.DIAGRAMA_PLANILHA
             ),

             -- PROCURA SIMILARIDADE DE TIPO_DIAGRAMA DE VEÍCULO NO BANCO.
             SIMILARIDADE_TIPOS_DIAGRAMA_VEICULOS AS (
                 SELECT DISTINCT ON (DTDV.TIPO_DIAGRAMA_PLANILHA_FORMATADO) DTDV.DIAGRAMA_PLANILHA                AS DIAGRAMA_PLANILHA,
                                                                            DTDV.TIPO_PLANILHA                    AS TIPO_PLANILHA,
                                                                            DTDV.TIPO_DIAGRAMA_PLANILHA           AS TIPO_DIAGRAMA_PLANILHA,
                                                                            DTDV.TIPO_DIAGRAMA_PLANILHA_FORMATADO AS TIPO_DIAGRAMA_PLANILHA_FORMATADO,
                                                                            VD.NOME                               AS DIAGRAMA_VEICULO_BANCO,
                                                                            VD.CODIGO                             AS COD_DIAGRAMA_VEICULO,
                                                                            VT.NOME                               AS TIPO_BANCO,
                                                                            VT.CODIGO                             AS COD_TIPO_VEICULO,
                                                                            CASE
                                                                                WHEN DTDV.COD_DIAGRAMA_BANCO = VD.CODIGO
                                                                                    THEN MAX(FUNC_GERA_SIMILARIDADE(DTDV.TIPO_PLANILHA, VT.NOME))
                                                                                ELSE F_SEM_SIMILARIDADE
                                                                                END                               AS SIMILARIEDADE_TIPO_DIAGRAMA
                 FROM DISTINCT_TIPOS_DIAGRAMA_VEICULOS DTDV
                          FULL JOIN VEICULO_TIPO VT ON TRUE
                          LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
                 WHERE VT.COD_EMPRESA = F_COD_EMPRESA
                 GROUP BY DTDV.TIPO_DIAGRAMA_PLANILHA_FORMATADO,
                          DTDV.TIPO_DIAGRAMA_PLANILHA,
                          DTDV.DIAGRAMA_PLANILHA,
                          DTDV.COD_DIAGRAMA_BANCO,
                          DTDV.TIPO_PLANILHA,
                          VT.NOME,
                          VT.CODIGO,
                          VD.NOME,
                          VD.CODIGO
                 ORDER BY DTDV.TIPO_DIAGRAMA_PLANILHA_FORMATADO, SIMILARIEDADE_TIPO_DIAGRAMA DESC
             )

        SELECT VP.PLACA_PLANILHA,
               VP.PLACAS_DUPLICADAS,
               VP.PLACA_FORMATADA,
               VP.PLACA_7_DIGITOS,
               VP.PLACA_NA_UNIDADE_EMPRESA :: TEXT,
               F_IF(VP.PLACA_NA_UNIDADE_EMPRESA != NAO_ENCONTRADO, VP.STATUS_ATIVO, NULL),
               VP.KM,
               SMV.MARCA_PLANILHA,
               F_IF(SMV.SIMILARIEDADE_MARCA >= F_SIMILARIDADE, SMV.MARCA_VEICULO_BANCO :: TEXT, NAO_ENCONTRADO),
               F_IF(SMV.SIMILARIEDADE_MARCA >= F_SIMILARIDADE, SMV.COD_MARCA_BANCO :: TEXT, NAO_ENCONTRADO),
               SMMV.MODELO_PLANILHA,
               F_IF(SMMV.SIMILARIEDADE_MARCA_MODELO >= F_SIMILARIDADE, SMMV.MODELO_VEICULO_BANCO :: TEXT,
                    NAO_ENCONTRADO),
               F_IF(SMMV.SIMILARIEDADE_MARCA_MODELO >= F_SIMILARIDADE, SMMV.COD_MODELO_VEICULO :: TEXT, NAO_ENCONTRADO),
               SD.DIAGRAMA_PLANILHA,
               F_IF(SD.SIMILARIEDADE_DIAGRAMA >= F_SIMILIARIDADE_DIAGRAMA, SD.DIAGRAMA_BANCO :: TEXT, NAO_ENCONTRADO),
               F_IF(SD.SIMILARIEDADE_DIAGRAMA >= F_SIMILIARIDADE_DIAGRAMA, SD.COD_DIAGRAMA_BANCO :: TEXT,
                    NAO_ENCONTRADO) AS COD_DIAGRAMA,
               STDV.TIPO_PLANILHA,
               F_IF(STDV.SIMILARIEDADE_TIPO_DIAGRAMA >= F_SIMILARIDADE, STDV.TIPO_BANCO :: TEXT, NAO_ENCONTRADO),
               F_IF(STDV.SIMILARIEDADE_TIPO_DIAGRAMA >= F_SIMILARIDADE, STDV.COD_TIPO_VEICULO :: TEXT,
                    NAO_ENCONTRADO) AS COD_TIPO
        FROM VERIFICACOES_PLACA VP
                 JOIN TABLE_JSON TJ ON TJ.CODIGO = VP.CODIGO
                 JOIN SIMILARIDADE_MARCAS_VEICULOS SMV ON TJ.MARCA = SMV.MARCA_PLANILHA
                 JOIN SIMILARIEDADE_MARCAS_MODELOS_VEICULOS SMMV ON SMV.MARCA_PLANILHA = SMMV.MARCA_PLANILHA
                 JOIN SIMILARIEDADE_DIAGRAMA SD ON TJ.DIAGRAMA = SD.DIAGRAMA_PLANILHA
                 JOIN SIMILARIDADE_TIPOS_DIAGRAMA_VEICULOS STDV ON SD.DIAGRAMA_PLANILHA = STDV.DIAGRAMA_PLANILHA;
    DROP TABLE TABLE_JSON;
END;
$$;

create or replace function suporte.tg_func_checklist_os_fechamento_massivo_os() returns trigger
    language plpgsql
as
$$
DECLARE
    TEM_VALOR_NULL                  BOOLEAN                  := (NEW.CPF_MECANICO IS NULL OR
                                                                 NEW.DATA_HORA_FIM_RESOLUCAO IS NULL OR
                                                                 NEW.DATA_HORA_INICIO_RESOLUCAO IS NULL OR
                                                                 NEW.TEMPO_REALIZACAO IS NULL OR
                                                                 NEW.PLACA_VEICULO IS NULL OR
                                                                 NEW.DATA_HORA_CONSERTO IS NULL OR
                                                                 NEW.FEEDBACK_CONSERTO IS NULL OR
                                                                 NEW.COD_UNIDADE IS NULL OR
                                                                 NEW.COD_OS IS NULL OR
                                                                 NEW.COD_PERGUNTA IS NULL OR
                                                                 NEW.COD_ALTERNATIVA IS NULL);
    KM_ATUAL_VEICULO                BIGINT                   := (SELECT V.KM
                                                                 FROM VEICULO V
                                                                 WHERE V.PLACA = NEW.PLACA_VEICULO);
    KM_VEICULO                      BIGINT                   := (CASE
                                                                     WHEN NEW.KM IS NULL THEN KM_ATUAL_VEICULO
                                                                     ELSE NEW.KM END);
    STATUS_RESOLUCAO_COSI_REALIZADO TEXT                     := 'R';
    STATUS_RESOLUCAO_COSI_PENDENTE  TEXT                     := 'P';
    STATUS_COS_FECHADO              TEXT                     := 'F';
    STATUS_COS_ABERTO               TEXT                     := 'A';
    QTD_ERROS                       BIGINT                   := 0;
    SOMA_ERRO                       BIGINT                   := 1;
    MSGS_ERROS                      TEXT;
    CODIGO_EMPRESA                  BIGINT                   := (SELECT U.COD_EMPRESA
                                                                 FROM UNIDADE U
                                                                 WHERE U.CODIGO = NEW.COD_UNIDADE);
    CODIGO_CHECKLIST                BIGINT                   := (SELECT COS.COD_CHECKLIST
                                                                 FROM CHECKLIST_ORDEM_SERVICO COS
                                                                 WHERE COS.CODIGO = NEW.COD_OS
                                                                   AND COS.COD_UNIDADE = NEW.COD_UNIDADE);
    DATA_HORA_CHECKLIST             TIMESTAMP WITH TIME ZONE := (SELECT C.DATA_HORA
                                                                 FROM CHECKLIST C
                                                                 WHERE C.CODIGO = CODIGO_CHECKLIST);
    PLACA_CADASTRADA                BOOLEAN                  := TRUE;
    QUEBRA_LINHA                    TEXT                     := CHR(10);
    VERIFICAR_OS                    BOOLEAN                  := FALSE;
BEGIN
    IF (TG_OP = 'UPDATE' AND OLD.STATUS_ITEM_FECHADO IS TRUE)
    THEN
        NEW.MENSAGEM_STATUS_ITEM = CONCAT(OLD.MENSAGEM_STATUS_ITEM, QUEBRA_LINHA, 'O ITEM JÁ ESTAVA FECHADO');
        NEW.MENSAGEM_STATUS_OS = OLD.MENSAGEM_STATUS_OS;
        NEW.CPF_MECANICO = OLD.CPF_MECANICO;
        NEW.DATA_HORA_FIM_RESOLUCAO = OLD.DATA_HORA_FIM_RESOLUCAO;
        NEW.DATA_HORA_INICIO_RESOLUCAO = OLD.DATA_HORA_INICIO_RESOLUCAO;
        NEW.TEMPO_REALIZACAO = OLD.TEMPO_REALIZACAO;
        NEW.PLACA_VEICULO = OLD.PLACA_VEICULO;
        NEW.KM = OLD.KM;
        NEW.DATA_HORA_CONSERTO = OLD.DATA_HORA_CONSERTO;
        NEW.FEEDBACK_CONSERTO = OLD.FEEDBACK_CONSERTO;
        NEW.COD_UNIDADE = OLD.COD_UNIDADE;
        NEW.COD_OS = OLD.COD_OS;
        NEW.COD_PERGUNTA = OLD.COD_PERGUNTA;
        NEW.COD_ALTERNATIVA = OLD.COD_ALTERNATIVA;
        NEW.STATUS_ITEM_FECHADO = OLD.STATUS_ITEM_FECHADO;
        NEW.STATUS_OS_FECHADA = OLD.STATUS_OS_FECHADA;
        NEW.USUARIO := CONCAT(OLD.USUARIO, QUEBRA_LINHA, NEW.USUARIO);
        NEW.DATA_SOLICITACAO := OLD.DATA_SOLICITACAO;
        NEW.HORA_SOLICITACAO := OLD.HORA_SOLICITACAO;
    ELSE
        NEW.USUARIO := SESSION_USER;
        NEW.DATA_SOLICITACAO := CURRENT_DATE;
        NEW.HORA_SOLICITACAO := CURRENT_TIME;

        --VERIFICA INFORMAÇÕES
        IF (TEM_VALOR_NULL)
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS, ' - EXISTEM CAMPOS SEM PREENCHIMENTO');
        END IF;

        --VERIFICA SE UNIDADE ESTÁ CADASTRADA
        IF ((NEW.COD_UNIDADE IS NOT NULL) AND
            NOT EXISTS(SELECT U.CODIGO FROM UNIDADE U WHERE U.CODIGO = NEW.COD_UNIDADE))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS, ' - UNIDADE NÃO CADASTRADA');
        END IF;

        --VERIFICA SE O COLABORADOR (MECÂNICO) EXISTE
        IF ((NEW.CPF_MECANICO IS NOT NULL) AND
            NOT EXISTS(SELECT C.CPF FROM COLABORADOR C WHERE C.CPF = NEW.CPF_MECANICO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS, ' - MECÂNICO NÃO CADASTRADO');
            --VERIFICA SE O COLABORADOR (MECÂNICO) É DA EMPRESA
        ELSEIF ((NEW.CPF_MECANICO IS NOT NULL) AND
                NOT EXISTS(
                        SELECT C.CPF
                        FROM COLABORADOR C
                        WHERE C.CPF = NEW.CPF_MECANICO
                          AND C.COD_EMPRESA = CODIGO_EMPRESA))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS =
                    CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                           ' - MECÂNICO NÃO PERTENCE À EMPRESA DA ORDEM DE SERVIÇO');
        END IF;

        --VERIFICA SE PLACA ESTÁ CADASTRADA
        IF ((NEW.PLACA_VEICULO IS NOT NULL) AND
            NOT EXISTS(SELECT V.PLACA FROM VEICULO V WHERE V.PLACA = NEW.PLACA_VEICULO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS, ' - PLACA NÃO ESTÁ CADASTRADA');
            PLACA_CADASTRADA = FALSE;
        END IF;

        --VERIFICAÇÕES REFERENTE ÀS DATAS E HORAS
        ---DATA/H INICIO DA RESOLUÇÃO:
        ----Verifica e adiciona msg de erro se a data/h atual for menor que a data/h do início da resolução
        IF ((NEW.DATA_HORA_INICIO_RESOLUCAO IS NOT NULL) AND
            ((NEW.DATA_SOLICITACAO + NEW.HORA_SOLICITACAO) < NEW.DATA_HORA_INICIO_RESOLUCAO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                ' - A DATA/HORA DE INICIO DA RESOLUÇÃO NÃO PODE SER MAIOR QUE A ATUAL ');
            ----Verifica e adiciona msg de erro se a  data do inicio da resolução for menor que a data/h do checklist realizado
        ELSEIF ((NEW.DATA_HORA_INICIO_RESOLUCAO IS NOT NULL)
            AND (NEW.DATA_HORA_INICIO_RESOLUCAO < DATA_HORA_CHECKLIST))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                ' - A DATA/HORA DE INICIO DA RESOLUÇÃO NÃO PODE SER MENOR QUE A DATA/HORA DA REALIZAÇÃO DO CHECKLIST');
        END IF;

        ---DATA/HR FIM DA RESOLUÇÃO
        ----Verifica e adiciona msg de erro se a data/h atual for menor que a data/h do fim da resolução
        IF ((NEW.DATA_HORA_FIM_RESOLUCAO IS NOT NULL) AND
            ((NEW.DATA_SOLICITACAO + NEW.HORA_SOLICITACAO) < NEW.DATA_HORA_FIM_RESOLUCAO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                ' - A DATA/HORA DE FIM DA RESOLUÇÃO NÃO PODE SER MAIOR QUE A ATUAL');
            ----Verifica e adiciona msg de erro se a data/h do fim da resolução for menor que a data/h do inicio da resolucao
        ELSEIF ((NEW.DATA_HORA_FIM_RESOLUCAO IS NOT NULL)
            AND (NEW.DATA_HORA_FIM_RESOLUCAO < NEW.DATA_HORA_INICIO_RESOLUCAO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                ' - A DATA/HORA DE FIM DA RESOLUÇÃO NÃO PODE SER MENOR QUE A DATA/HORA DE INICIO DA RESOLUCAO');
            ----Verifica e adiciona msg de erro se a data/h do fim da resolução for menor que a data/h do checklist realizado
        ELSEIF ((NEW.DATA_HORA_FIM_RESOLUCAO IS NOT NULL)
            AND (NEW.DATA_HORA_FIM_RESOLUCAO < DATA_HORA_CHECKLIST))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                ' - A DATA/HORA DE FIM DA RESOLUÇÃO NÃO PODE SER MENOR QUE A DATA/HORA DA REALIZAÇÃO DO CHECKLIST');
        END IF;

        ---DATA/H CONSERTO
        ----Verifica e adiciona msg de erro se a data/h atual for menor que a data/h do conserto
        IF ((NEW.DATA_HORA_CONSERTO IS NOT NULL) AND
            ((NEW.DATA_SOLICITACAO + NEW.HORA_SOLICITACAO) < NEW.DATA_HORA_CONSERTO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                ' - A DATA/HORA DO CONSERTO NÃO PODE SER MAIOR QUE A ATUAL');
            ----Verifica e adiciona msg de erro se a data/h do conserto for menor que a data/h da realização do checklist
        ELSEIF ((NEW.DATA_HORA_CONSERTO IS NOT NULL)
            AND (NEW.DATA_HORA_CONSERTO < DATA_HORA_CHECKLIST))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                ' - A DATA/HORA DO CONSERTO NÃO PODE SER MENOR QUE A DATA/HORA DA REALIZAÇÃO DO CHECKLIST');
            ----Verifica e adiciona msg de erro se a data/h do conserto for menor que a data/h do fim da resolucao
        ELSEIF ((NEW.DATA_HORA_CONSERTO IS NOT NULL) AND (NEW.DATA_HORA_CONSERTO < NEW.DATA_HORA_FIM_RESOLUCAO))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS =
                    CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                           ' - A DATA/HORA DE CONSERTO NÃO PODE SER MENOR QUE A DATA/HORA DO FIM DA RESOLUCAO');
        END IF;

        ---VERIFICA SE COD_OS EXISTE
        IF ((NEW.COD_OS IS NOT NULL AND NEW.COD_UNIDADE IS NOT NULL) AND
            NOT EXISTS(SELECT COS.CODIGO FROM CHECKLIST_ORDEM_SERVICO COS WHERE COS.CODIGO = NEW.COD_OS))
        THEN
            QTD_ERROS = QTD_ERROS + SOMA_ERRO;
            MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS, ' - CODIGO DA ORDEM DE SERVIÇO NÃO EXISTE');

            --VERIFICAÇÕES SE A OS EXISTIR
        ELSEIF ((NEW.COD_OS IS NOT NULL) AND
                EXISTS(SELECT COSI.COD_OS
                       FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                       WHERE COSI.COD_OS = NEW.COD_OS))
        THEN
            ---VERIFICA SE A PLACA É DO CHECKLIST QUE GEROU A OS
            IF ((NEW.PLACA_VEICULO IS NOT NULL) AND (PLACA_CADASTRADA) AND NOT EXISTS(SELECT C.PLACA_VEICULO
                                                                                      FROM CHECKLIST C
                                                                                      WHERE C.CODIGO = CODIGO_CHECKLIST
                                                                                        AND C.PLACA_VEICULO = NEW.PLACA_VEICULO))
            THEN
                QTD_ERROS = QTD_ERROS + SOMA_ERRO;
                MSGS_ERROS =
                        CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                               ' - A PLACA NÃO PERTENCE AO CHECKLIST DA ORDEM DE SERVIÇO');
                ---VERIFICA SE OS PERTENCE À UNIDADE
            END IF;
            IF ((NEW.COD_UNIDADE IS NOT NULL) AND
                NOT EXISTS(SELECT COS.CODIGO
                           FROM CHECKLIST_ORDEM_SERVICO COS
                           WHERE COS.CODIGO = NEW.COD_OS
                             AND COS.COD_UNIDADE = NEW.COD_UNIDADE))
            THEN
                QTD_ERROS = QTD_ERROS + SOMA_ERRO;
                MSGS_ERROS =
                        CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                               ' - A ORDEM DE SERVIÇO ABERTA NÃO É DA UNIDADE INFORMADA');
            END IF;

            ---VERIFICA SE A PERGUNTA ESTÁ CONTIDA NA ORDEM DE SERVIÇO ITENS
            IF ((NEW.COD_PERGUNTA IS NOT NULL) AND
                NOT EXISTS(SELECT COSI.COD_PERGUNTA
                           FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                           WHERE COSI.COD_OS = NEW.COD_OS
                             AND COSI.COD_PERGUNTA = NEW.COD_PERGUNTA))
            THEN
                QTD_ERROS = QTD_ERROS + SOMA_ERRO;
                MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                    ' - A PERGUNTA NÃO EXISTE PARA A ORDEM DE SERVIÇO INFORMADA');
                ---VERIFICA SE A ALTERNATIVA ESTÁ CONTIDA NA PERGUNTA
            ELSEIF ((NEW.COD_PERGUNTA IS NOT NULL AND NEW.COD_ALTERNATIVA IS NOT NULL) AND
                    NOT EXISTS(SELECT COSI.COD_ALTERNATIVA
                               FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                               WHERE COSI.COD_PERGUNTA = NEW.COD_PERGUNTA
                                 AND COSI.COD_ALTERNATIVA = NEW.COD_ALTERNATIVA))
            THEN
                QTD_ERROS = QTD_ERROS + SOMA_ERRO;
                MSGS_ERROS = CONCAT(MSGS_ERROS, QUEBRA_LINHA, QTD_ERROS,
                                    ' - A ALTERNATIVA NÃO EXISTE PARA PERGUNTA INFORMADA');
            END IF;
        END IF;

        --REALIZA O FECHAMENTO DOS ITENS SE NÃO HOUVER ERROS
        IF (QTD_ERROS > 0)
        THEN
            NEW.STATUS_ITEM_FECHADO := FALSE;
            NEW.MENSAGEM_STATUS_ITEM :=
                    CONCAT('ITEM NÃO FECHADO', QUEBRA_LINHA, 'QUANTIDADE DE ERROS: ', QTD_ERROS, QUEBRA_LINHA,
                           MSGS_ERROS);
            NEW.STATUS_OS_FECHADA := FALSE;
            NEW.MENSAGEM_STATUS_OS := 'FECHAMENTO NÃO REALIZADO';
        ELSEIF (NOT TEM_VALOR_NULL OR QTD_ERROS = 0)
        THEN
            ---VERIFICA SE O ITEM JÁ ESTAVA FECHADO (STATUS REALIZADO)
            IF ((NEW.COD_OS IS NOT NULL AND NEW.COD_PERGUNTA IS NOT NULL AND NEW.COD_ALTERNATIVA IS NOT NULL) AND
                EXISTS(SELECT COSI.CODIGO
                       FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                       WHERE COSI.COD_OS = NEW.COD_OS
                         AND COSI.COD_PERGUNTA = NEW.COD_PERGUNTA
                         AND COSI.COD_ALTERNATIVA = NEW.COD_ALTERNATIVA
                         AND COSI.STATUS_RESOLUCAO = STATUS_RESOLUCAO_COSI_REALIZADO))
            THEN
                -- O ITEM JÁ ESTAVA FECHADO
                NEW.STATUS_ITEM_FECHADO = TRUE;
                NEW.MENSAGEM_STATUS_ITEM = 'O ITEM JÁ ESTAVA FECHADO';
                VERIFICAR_OS := TRUE;
            ELSE
                -- REALIZADO O FECHAMENTO DO ITEM
                UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
                SET CPF_MECANICO               = NEW.CPF_MECANICO,
                    DATA_HORA_FIM_RESOLUCAO    = NEW.DATA_HORA_FIM_RESOLUCAO,
                    DATA_HORA_INICIO_RESOLUCAO = NEW.DATA_HORA_INICIO_RESOLUCAO,
                    TEMPO_REALIZACAO           = NEW.TEMPO_REALIZACAO,
                    KM                         = KM_VEICULO,
                    DATA_HORA_CONSERTO         = NEW.DATA_HORA_CONSERTO,
                    FEEDBACK_CONSERTO          = NEW.FEEDBACK_CONSERTO,
                    STATUS_RESOLUCAO           = STATUS_RESOLUCAO_COSI_REALIZADO
                WHERE COD_UNIDADE = NEW.COD_UNIDADE
                  AND COD_OS = NEW.COD_OS
                  AND COD_PERGUNTA = NEW.COD_PERGUNTA
                  AND COD_ALTERNATIVA = NEW.COD_ALTERNATIVA;
                NEW.STATUS_ITEM_FECHADO = TRUE;
                NEW.MENSAGEM_STATUS_ITEM :=
                        CONCAT('ITEM FECHADO ATRAVÉS DO SUPORTE', QUEBRA_LINHA, 'KM DO VEÍCULO NA HORA DO FECHAMENTO: ',
                               KM_ATUAL_VEICULO);
                VERIFICAR_OS := TRUE;
            END IF;
        ELSE
            RAISE EXCEPTION 'ERRO AO FECHAR O ITEM DA ORDEM DE SERVIÇO';
        END IF;

        IF (VERIFICAR_OS)
        THEN
            -- VERIFICA SE EXISTEM ITENS PENDENTES NA OS
            IF EXISTS(SELECT COSI.CODIGO
                      FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                      WHERE COSI.COD_OS = NEW.COD_OS
                        AND COSI.COD_UNIDADE = NEW.COD_UNIDADE
                        AND COSI.STATUS_RESOLUCAO = STATUS_RESOLUCAO_COSI_PENDENTE)
            THEN
                NEW.STATUS_OS_FECHADA := FALSE;
                NEW.MENSAGEM_STATUS_OS := 'OS ABERTA';
                -- VERIFICA SE A OS ESTÁ FECHADA MESMO COM ITENS PENDENTES
                IF EXISTS(SELECT COS.STATUS
                          FROM CHECKLIST_ORDEM_SERVICO COS
                          WHERE COS.STATUS = STATUS_COS_FECHADO
                            AND COS.CODIGO = NEW.COD_OS
                            AND COS.COD_UNIDADE = NEW.COD_UNIDADE)
                THEN
                    -- SE ESTIVER, É UM ERRO. ENTÃO REABRE A OS E EXIBE MSG ESPECÍFICA.
                    UPDATE CHECKLIST_ORDEM_SERVICO
                    SET STATUS = STATUS_COS_ABERTO
                    WHERE CODIGO = NEW.COD_OS
                      AND COD_UNIDADE = NEW.COD_UNIDADE;
                    NEW.STATUS_OS_FECHADA := FALSE;
                    NEW.MENSAGEM_STATUS_OS :=
                            'ORDEM DE SERVIÇO ESTAVA FECHADA MAS POSSUÍA ITENS PENDENTES - OS FOI REABERTA';
                END IF;
            ELSE
                -- SE NÃO EXISTIR ITENS PENDENTES, A OS PODE SER FECHADA.
                UPDATE CHECKLIST_ORDEM_SERVICO_DATA
                SET STATUS               = STATUS_COS_FECHADO,
                    DATA_HORA_FECHAMENTO = (SELECT COSI.DATA_HORA_FIM_RESOLUCAO
                                            FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                            WHERE COSI.COD_UNIDADE = NEW.COD_UNIDADE
                                              AND COSI.COD_OS = NEW.COD_OS
                                              AND COSI.COD_PERGUNTA = NEW.COD_PERGUNTA
                                              AND COSI.COD_ALTERNATIVA = NEW.COD_ALTERNATIVA)
                WHERE COD_UNIDADE = NEW.COD_UNIDADE
                  AND CODIGO NOT IN
                      (SELECT COD_OS
                       FROM CHECKLIST_ORDEM_SERVICO_ITENS
                       WHERE COD_UNIDADE = NEW.COD_UNIDADE
                         AND CPF_MECANICO IS NULL);
                NEW.STATUS_OS_FECHADA := TRUE;
                NEW.MENSAGEM_STATUS_OS := 'OS FECHADA';
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END
$$;

create trigger tg_verifica_fechamento_os
    before insert or update
    on suporte.fechamento_os
    for each row
execute procedure suporte.tg_func_checklist_os_fechamento_massivo_os();

create or replace function suporte.func_afericao_deleta_afericao_valores(f_cod_unidade bigint, f_placa text,
                                                                         f_codigo_pneu bigint, f_codigo_afericao bigint,
                                                                         OUT aviso_afericao_valor_deletada text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS   BIGINT;
    -- Busca a quantidade de valores aferidos estão ativos nesta aferição
    QTD_VALORES_AFERICAO     BIGINT := (SELECT COUNT(*)
                                        FROM AFERICAO_VALORES
                                        WHERE COD_AFERICAO = F_CODIGO_AFERICAO
                                          AND COD_UNIDADE = F_COD_UNIDADE);

    -- Variável utilizada para melhorar o feedback da function de acordo com o fluxo
    PREFIXO_MENSAGEM_RETORNO TEXT;
BEGIN
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    IF NOT EXISTS(SELECT *
                  FROM AFERICAO_VALORES
                  WHERE COD_AFERICAO = F_CODIGO_AFERICAO
                    AND COD_UNIDADE = F_COD_UNIDADE
                    AND COD_PNEU = F_CODIGO_PNEU)
    THEN
        RAISE EXCEPTION 'Nenhum valor de aferição encontrado com estes parâmetros: Unidade %, Placa %, Pneu %
            e Código %', F_COD_UNIDADE, F_PLACA, F_CODIGO_PNEU, F_CODIGO_AFERICAO;
    END IF;

    -- Define qual fluxo executar de acordo com a quantidade de valores de aferição encontrados
    CASE QTD_VALORES_AFERICAO
        WHEN 1
            THEN
                -- Somente um valor de aferição foi encontrado, deletar toda a aferição, manutenção e valores
                PERFORM SUPORTE.FUNC_AFERICAO_DELETA_AFERICAO(F_COD_UNIDADE, F_PLACA, F_CODIGO_AFERICAO);
                PREFIXO_MENSAGEM_RETORNO := 'AFERIÇÃO, MANUTENÇÃO E VALOR DE AFERIÇÃO DELETADO ';
        ELSE
            -- Existe mais de um valor de aferição, deletar exclusivamente por COD_PNEU
            -- DELETA AFERIÇÃO.
            UPDATE AFERICAO_VALORES_DATA
            SET DELETADO            = TRUE,
                DATA_HORA_DELETADO  = NOW(),
                PG_USERNAME_DELECAO = SESSION_USER
            WHERE COD_UNIDADE = F_COD_UNIDADE
              AND COD_PNEU = F_CODIGO_PNEU
              AND COD_AFERICAO = F_CODIGO_AFERICAO;

            GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

            IF (QTD_LINHAS_ATUALIZADAS <= 0)
            THEN
                RAISE EXCEPTION 'Erro ao deletar os valores de aferição com estes parâmetros Unidade %, Placa %,
                    Pneu % e Código %', F_COD_UNIDADE, F_PLACA, F_CODIGO_PNEU, F_CODIGO_AFERICAO;
            END IF;

            -- DELETA AFERIÇÃO MANUTENÇÃO.
            -- Não verificamos quantas linhas atualizadas pois aferição pode não ter manutenções.
            UPDATE AFERICAO_MANUTENCAO_DATA
            SET DELETADO            = TRUE,
                DATA_HORA_DELETADO  = NOW(),
                PG_USERNAME_DELECAO = SESSION_USER
            WHERE COD_UNIDADE = F_COD_UNIDADE
              AND COD_PNEU = F_CODIGO_PNEU
              AND COD_AFERICAO = F_CODIGO_AFERICAO;

            PREFIXO_MENSAGEM_RETORNO := 'VALOR DE AFERIÇÃO DELETADO ';
        END CASE;

    SELECT PREFIXO_MENSAGEM_RETORNO
               || ', CÓDIGO DA UNIDADE: '
               || F_COD_UNIDADE
               || ', PLACA: '
               || F_PLACA
               || ', CÓDIGO DO PNEU: '
               || F_CODIGO_PNEU
               || ', CÓDIGO DA AFERIÇÃO: '
               || F_CODIGO_AFERICAO
    INTO AVISO_AFERICAO_VALOR_DELETADA;
END
$$;

create or replace function public.func_checklist_update_status_modelo(f_cod_unidade bigint, f_cod_modelo bigint, f_status_ativo boolean) returns void
    security definer
    language plpgsql
as
$$
DECLARE
    F_NOME_MODELO_CHECKLIST TEXT := (SELECT NOME
                                     FROM CHECKLIST_MODELO_DATA
                                     WHERE COD_UNIDADE = F_COD_UNIDADE
                                       AND CODIGO = F_COD_MODELO);
BEGIN
    -- VERIFICA SE UNIDADE EXISTE.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    -- Se estamos ativando o modelo e existe outro na mesma unidade, de mesmo nome e já ativo, lançamos um erro.
    IF F_STATUS_ATIVO AND (SELECT EXISTS(SELECT CM.CODIGO
                                         FROM CHECKLIST_MODELO CM
                                         WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                                           AND LOWER(CM.NOME) = LOWER(F_NOME_MODELO_CHECKLIST)
                                           AND CM.STATUS_ATIVO = TRUE))
    THEN
        PERFORM THROW_GENERIC_ERROR('Erro! Já existe um modelo de checklist ativo com esse nome.');
    END IF;

    UPDATE CHECKLIST_MODELO_DATA
    SET STATUS_ATIVO = F_STATUS_ATIVO
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND CODIGO = F_COD_MODELO;

    IF NOT FOUND
    THEN
        RAISE EXCEPTION 'Erro ao atualizar o status do modelo de checklist % para %', F_COD_MODELO, F_STATUS_ATIVO;
    END IF;
END
$$;

create or replace function public.func_relatorio_pneu_resumo_geral_pneus(f_cod_unidade text[], f_status_pneu text)
    returns TABLE
            (
                "UNIDADE ALOCADO"       text,
                "PNEU"                  text,
                "STATUS"                text,
                "VALOR DE AQUISIÇÃO"    text,
                "DATA/HORA CADASTRO"    text,
                "MARCA"                 text,
                "MODELO"                text,
                "BANDA APLICADA"        text,
                "VALOR DA BANDA"        text,
                "MEDIDAS"               text,
                "PLACA"                 text,
                "TIPO"                  text,
                "POSIÇÃO"               text,
                "QUANTIDADE DE SULCOS"  text,
                "SULCO INTERNO"         text,
                "SULCO CENTRAL INTERNO" text,
                "SULCO CENTRAL EXTERNO" text,
                "SULCO EXTERNO"         text,
                "MENOR SULCO"           text,
                "PRESSÃO ATUAL (PSI)"   text,
                "PRESSÃO IDEAL (PSI)"   text,
                "VIDA ATUAL"            text,
                "DOT"                   text,
                "ÚLTIMA AFERIÇÃO"       text
            )
    language sql
as
$$
SELECT U.NOME                                                                   AS UNIDADE_ALOCADO,
       P.CODIGO_CLIENTE                                                         AS COD_PNEU,
       P.STATUS                                                                 AS STATUS,
       COALESCE(TRUNC(P.VALOR :: NUMERIC, 2) :: TEXT, '-')                      AS VALOR_AQUISICAO,
       COALESCE(TO_CHAR(P.DATA_HORA_CADASTRO AT TIME ZONE TZ_UNIDADE(P.COD_UNIDADE_CADASTRO),
                        'DD/MM/YYYY HH24:MI'),
                '-')                                                            AS DATA_HORA_CADASTRO,
       MAP.NOME                                                                 AS NOME_MARCA_PNEU,
       MP.NOME                                                                  AS NOME_MODELO_PNEU,
       CASE
           WHEN MARB.CODIGO IS NULL
               THEN 'Nunca Recapado'
           ELSE MARB.NOME || ' - ' || MODB.NOME
           END                                                                  AS BANDA_APLICADA,
       COALESCE(TRUNC(PVV.VALOR :: NUMERIC, 2) :: TEXT, '-')                    AS VALOR_BANDA,
       ((((DP.LARGURA || '/' :: TEXT) || DP.ALTURA) || ' R' :: TEXT) || DP.ARO) AS MEDIDAS,
       COALESCE(POSICAO_PNEU_VEICULO.PLACA_VEICULO_PNEU, '-')                   AS PLACA,
       COALESCE(POSICAO_PNEU_VEICULO.VEICULO_TIPO, '-')                         AS TIPO_VEICULO,
       COALESCE(POSICAO_PNEU_VEICULO.POSICAO_PNEU, '-') :: TEXT                 AS POSICAO_PNEU,
       COALESCE(MODB.QT_SULCOS, MP.QT_SULCOS) :: TEXT                           AS QTD_SULCOS,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_INTERNO)                           AS SULCO_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_INTERNO)                   AS SULCO_CENTRAL_INTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_CENTRAL_EXTERNO)                   AS SULCO_CENTRAL_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(P.ALTURA_SULCO_EXTERNO)                           AS SULCO_EXTERNO,
       FUNC_PNEU_FORMAT_SULCO(LEAST(P.ALTURA_SULCO_EXTERNO, P.ALTURA_SULCO_CENTRAL_EXTERNO,
                                    P.ALTURA_SULCO_CENTRAL_INTERNO,
                                    P.ALTURA_SULCO_INTERNO))                    AS MENOR_SULCO,
       COALESCE(TRUNC(P.PRESSAO_ATUAL) :: TEXT, '-')                            AS PRESSAO_ATUAL,
       P.PRESSAO_RECOMENDADA :: TEXT                                            AS PRESSAO_RECOMENDADA,
       PVN.NOME :: TEXT                                                         AS VIDA_ATUAL,
       COALESCE(P.DOT, '-')                                                     AS DOT,
       COALESCE(
               TO_CHAR(F.DATA_HORA_ULTIMA_AFERICAO AT TIME ZONE TZ_UNIDADE(F.COD_UNIDADE_ULTIMA_AFERICAO),
                       'DD/MM/YYYY HH24:MI'), 'Nunca Aferido')                  AS ULTIMA_AFERICAO
FROM PNEU P
         JOIN DIMENSAO_PNEU DP ON DP.CODIGO = P.COD_DIMENSAO
         JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
         JOIN MODELO_PNEU MP ON MP.CODIGO = P.COD_MODELO AND MP.COD_EMPRESA = U.COD_EMPRESA
         JOIN MARCA_PNEU MAP ON MAP.CODIGO = MP.COD_MARCA
         JOIN PNEU_VIDA_NOMENCLATURA PVN ON PVN.COD_VIDA = P.VIDA_ATUAL
         LEFT JOIN MODELO_BANDA MODB ON MODB.CODIGO = P.COD_MODELO_BANDA
         LEFT JOIN MARCA_BANDA MARB ON MARB.CODIGO = MODB.COD_MARCA
         LEFT JOIN PNEU_VALOR_VIDA PVV ON P.CODIGO = PVV.COD_PNEU AND PVV.VIDA = P.VIDA_ATUAL
         LEFT JOIN (SELECT PPNE.NOMENCLATURA AS POSICAO_PNEU,
                           VP.COD_PNEU       AS CODIGO_PNEU,
                           VP.PLACA          AS PLACA_VEICULO_PNEU,
                           VP.COD_UNIDADE    AS COD_UNIDADE_PNEU,
                           VT.NOME           AS VEICULO_TIPO
                    FROM VEICULO V
                             JOIN VEICULO_PNEU VP
                                  ON VP.PLACA = V.PLACA AND VP.COD_UNIDADE = V.COD_UNIDADE
                             JOIN VEICULO_TIPO VT
                                  ON V.COD_TIPO = VT.CODIGO
                             JOIN EMPRESA E ON VT.COD_EMPRESA = E.CODIGO
                        -- LEFT JOIN porque unidade pode não ter nomenclatura.
                             LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
                             LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE
                                       ON PPNE.COD_EMPRESA = E.CODIGO
                                           AND PPNE.COD_DIAGRAMA = VD.CODIGO
                                           AND VP.POSICAO = PPNE.POSICAO_PROLOG
                    WHERE V.COD_UNIDADE :: TEXT LIKE ANY (F_COD_UNIDADE)
                    ORDER BY VP.COD_PNEU) AS POSICAO_PNEU_VEICULO
                   ON P.CODIGO = POSICAO_PNEU_VEICULO.CODIGO_PNEU
         LEFT JOIN FUNC_PNEU_GET_PRIMEIRA_ULTIMA_AFERICAO(P.CODIGO) F
                   ON F.COD_PNEU = P.CODIGO
WHERE P.COD_UNIDADE :: TEXT LIKE ANY (F_COD_UNIDADE)
  AND CASE
          WHEN F_STATUS_PNEU IS NULL
              THEN TRUE
          ELSE P.STATUS = F_STATUS_PNEU
    END
ORDER BY U.NOME, P.CODIGO_CLIENTE;
$$;

create or replace function integracao.func_pneu_remove_vinculo_pneu_placa_posicao(f_cod_sistema_integrado_pneus bigint[]) returns void
    language plpgsql
as
$$
BEGIN
    DELETE
    FROM PUBLIC.VEICULO_PNEU
    WHERE COD_PNEU IN (SELECT PC.COD_PNEU_CADASTRO_PROLOG
                       FROM INTEGRACAO.PNEU_CADASTRADO PC
                       WHERE PC.COD_PNEU_SISTEMA_INTEGRADO = ANY (F_COD_SISTEMA_INTEGRADO_PNEUS));
END;
$$;

create or replace function public.func_afericao_servico_is_tipo_servico(f_cod_servico bigint, f_tipo_servico_pneu text) returns boolean
    language plpgsql
as
$$
BEGIN
    RETURN
            (SELECT AM.TIPO_SERVICO
             FROM AFERICAO_MANUTENCAO AM
             WHERE AM.CODIGO = F_COD_SERVICO) = F_TIPO_SERVICO_PNEU;
END;
$$;

create or replace function public.func_pneu_get_pneu_by_placa(f_placa character varying)
    returns TABLE
            (
                nome_marca_pneu              character varying,
                cod_marca_pneu               bigint,
                codigo                       bigint,
                codigo_cliente               character varying,
                cod_unidade_alocado          bigint,
                cod_regional_alocado         bigint,
                pressao_atual                real,
                vida_atual                   integer,
                vida_total                   integer,
                pneu_novo_nunca_rodado       boolean,
                nome_modelo_pneu             character varying,
                cod_modelo_pneu              bigint,
                qt_sulcos_modelo_pneu        smallint,
                altura_sulcos_modelo_pneu    real,
                altura                       integer,
                largura                      integer,
                aro                          real,
                cod_dimensao                 bigint,
                pressao_recomendada          real,
                altura_sulco_central_interno real,
                altura_sulco_central_externo real,
                altura_sulco_interno         real,
                altura_sulco_externo         real,
                status                       character varying,
                dot                          character varying,
                valor                        real,
                cod_modelo_banda             bigint,
                nome_modelo_banda            character varying,
                qt_sulcos_modelo_banda       smallint,
                altura_sulcos_modelo_banda   real,
                cod_marca_banda              bigint,
                nome_marca_banda             character varying,
                valor_banda                  real,
                posicao_pneu                 integer,
                posicao_aplicado_cliente     character varying,
                cod_veiculo_aplicado         bigint,
                placa_aplicado               character varying
            )
    language sql
as
$$
SELECT MP.NOME                                  AS NOME_MARCA_PNEU,
       MP.CODIGO                                AS COD_MARCA_PNEU,
       P.CODIGO,
       P.CODIGO_CLIENTE,
       U.CODIGO                                 AS COD_UNIDADE_ALOCADO,
       R.CODIGO                                 AS COD_REGIONAL_ALOCADO,
       P.PRESSAO_ATUAL,
       P.VIDA_ATUAL,
       P.VIDA_TOTAL,
       P.PNEU_NOVO_NUNCA_RODADO,
       MOP.NOME                                 AS NOME_MODELO_PNEU,
       MOP.CODIGO                               AS COD_MODELO_PNEU,
       MOP.QT_SULCOS                            AS QT_SULCOS_MODELO_PNEU,
       MOP.ALTURA_SULCOS                        AS ALTURA_SULCOS_MODELO_PNEU,
       PD.ALTURA,
       PD.LARGURA,
       PD.ARO,
       PD.CODIGO                                AS COD_DIMENSAO,
       P.PRESSAO_RECOMENDADA,
       P.ALTURA_SULCO_CENTRAL_INTERNO,
       P.ALTURA_SULCO_CENTRAL_EXTERNO,
       P.ALTURA_SULCO_INTERNO,
       P.ALTURA_SULCO_EXTERNO,
       P.STATUS,
       P.DOT,
       P.VALOR,
       MOB.CODIGO                               AS COD_MODELO_BANDA,
       MOB.NOME                                 AS NOME_MODELO_BANDA,
       MOB.QT_SULCOS                            AS QT_SULCOS_MODELO_BANDA,
       MOB.ALTURA_SULCOS                        AS ALTURA_SULCOS_MODELO_BANDA,
       MAB.CODIGO                               AS COD_MARCA_BANDA,
       MAB.NOME                                 AS NOME_MARCA_BANDA,
       PVV.VALOR                                AS VALOR_BANDA,
       PO.POSICAO_PROLOG                        AS POSICAO_PNEU,
       COALESCE(PPNE.NOMENCLATURA :: TEXT, '-') AS POSICAO_APLICADO_CLIENTE,
       VEI.CODIGO                               AS COD_VEICULO_APLICADO,
       VEI.PLACA                                AS PLACA_APLICADO
FROM PNEU P
         JOIN MODELO_PNEU MOP ON MOP.CODIGO = P.COD_MODELO
         JOIN MARCA_PNEU MP ON MP.CODIGO = MOP.COD_MARCA
         JOIN DIMENSAO_PNEU PD ON PD.CODIGO = P.COD_DIMENSAO
         JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
         JOIN REGIONAL R ON U.COD_REGIONAL = R.CODIGO
         LEFT JOIN VEICULO_PNEU VP ON P.CODIGO = VP.COD_PNEU
         LEFT JOIN VEICULO VEI ON VEI.PLACA = VP.PLACA
         LEFT JOIN VEICULO_TIPO VT ON VT.CODIGO = VEI.COD_TIPO AND VT.COD_EMPRESA = P.COD_EMPRESA
         LEFT JOIN VEICULO_DIAGRAMA VD ON VT.COD_DIAGRAMA = VD.CODIGO
         LEFT JOIN PNEU_ORDEM PO ON VP.POSICAO = PO.POSICAO_PROLOG
         LEFT JOIN MODELO_BANDA MOB ON MOB.CODIGO = P.COD_MODELO_BANDA AND MOB.COD_EMPRESA = U.COD_EMPRESA
         LEFT JOIN MARCA_BANDA MAB ON MAB.CODIGO = MOB.COD_MARCA AND MAB.COD_EMPRESA = MOB.COD_EMPRESA
         LEFT JOIN PNEU_VALOR_VIDA PVV ON PVV.COD_PNEU = P.CODIGO AND PVV.VIDA = P.VIDA_ATUAL
         LEFT JOIN PNEU_POSICAO_NOMENCLATURA_EMPRESA PPNE ON
        PPNE.COD_EMPRESA = P.COD_EMPRESA AND
        PPNE.COD_DIAGRAMA = VD.CODIGO AND
        PPNE.POSICAO_PROLOG = VP.POSICAO
WHERE VP.PLACA = F_PLACA
ORDER BY PO.ORDEM_EXIBICAO ASC;
$$;

create or replace function aferidor.func_aferidor_get_procedimento_teste() returns text[]
    language sql
as
$$
SELECT CT.COMANDOS
FROM AFERIDOR.COMANDOS_TESTE CT;
$$;

create or replace function aferidor.func_aferidor_insere_teste(f_cod_colaborador_execucao bigint,
                                                               f_data_hora_execucao timestamp with time zone,
                                                               f_nome_dispositivo text,
                                                               f_comandos_executados jsonb) returns bigint
    language plpgsql
as
$$
DECLARE
    CODIGO_PROCEDIMENTO_TESTE BIGINT;
BEGIN
    INSERT INTO AFERIDOR.PROCEDIMENTO_TESTE (COD_COLABORADOR_EXECUCAO,
                                             DATA_HORA_EXECUCAO,
                                             NOME_DISPOSITIVO,
                                             VALORES_EXECUCAO)
    VALUES (F_COD_COLABORADOR_EXECUCAO,
            F_DATA_HORA_EXECUCAO,
            F_NOME_DISPOSITIVO,
            F_COMANDOS_EXECUTADOS) RETURNING CODIGO INTO CODIGO_PROCEDIMENTO_TESTE;

    IF NOT FOUND
    THEN
        RAISE EXCEPTION 'Erro ao salvar teste realizado!';
    END IF;

    RETURN CODIGO_PROCEDIMENTO_TESTE;
END;
$$;

create or replace function cs.func_nps_insere_respostas_pesquisa(f_cod_pesquisa_nps bigint,
                                                                 f_cod_colaborador_realizacao bigint,
                                                                 f_data_hora_realizacao_pesquisa timestamp with time zone,
                                                                 f_resposta_pergunta_escala smallint,
                                                                 f_resposta_pergunta_descritiva text) returns bigint
    language plpgsql
as
$$
declare
    cod_respostas_pesquisa_nps bigint;
begin
    -- Propositalmente, não tratamos a constraint de UNIQUE aqui. O front deve tratar para não enviar duplicados.
    insert into cs.nps_respostas (cod_nps_pesquisa,
                                  cod_colaborador_respostas,
                                  data_hora_realizacao_pesquisa,
                                  resposta_pergunta_escala,
                                  resposta_pergunta_descritiva)
    values (f_cod_pesquisa_nps,
            f_cod_colaborador_realizacao,
            f_data_hora_realizacao_pesquisa,
            f_resposta_pergunta_escala,
            f_resposta_pergunta_descritiva) returning codigo into cod_respostas_pesquisa_nps;

    if not FOUND
    then
        raise exception 'Erro ao inserir respostas da pesquisa de NPS % para colaborador %',
            f_cod_pesquisa_nps,
            f_cod_colaborador_realizacao;
    end if;

    return cod_respostas_pesquisa_nps;
end;
$$;

create or replace function cs.func_nps_bloqueia_pesquisa(f_cod_pesquisa_nps bigint, f_cod_colaborador_bloqueio bigint,
                                                         f_data_hora_bloqueio_pesquisa timestamp with time zone) returns void
    language plpgsql
as
$$
begin
    -- Propositalmente, não tratamos a constraint de UNIQUE aqui. O front deve tratar para não enviar duplicados.
    insert into cs.nps_bloqueio_pesquisa_colaborador (cod_nps_pesquisa,
                                                      cod_colaborador_bloqueio,
                                                      data_hora_bloqueio_pesquisa)
    values (f_cod_pesquisa_nps,
            f_cod_colaborador_bloqueio,
            f_data_hora_bloqueio_pesquisa);

    if not found
    then
        raise exception 'Erro ao bloquear pesquisa de NPS % para colaborador %',
            f_cod_pesquisa_nps,
            f_cod_colaborador_bloqueio;
    end if;
end;
$$;

create or replace function integracao.func_geral_salva_log_integracao(f_token_integracao character varying,
                                                                      f_response_status integer, f_request_json jsonb,
                                                                      f_response_json jsonb,
                                                                      f_data_hora_request timestamp with time zone) returns void
    language plpgsql
as
$$
BEGIN
    INSERT INTO INTEGRACAO.LOG_REQUEST_RESPONSE(COD_EMRESA,
                                                TOKEN_INTEGRACAO,
                                                RESPONSE_STATUS,
                                                REQUEST_JSON,
                                                RESPONSE_JSON,
                                                DATA_HORA_REQUEST)
    VALUES ((SELECT TI.COD_EMPRESA FROM INTEGRACAO.TOKEN_INTEGRACAO TI WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO),
            F_TOKEN_INTEGRACAO,
            F_RESPONSE_STATUS,
            F_REQUEST_JSON,
            F_RESPONSE_JSON,
            F_DATA_HORA_REQUEST);

    IF NOT FOUND
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('Não foi possível inserir o Log de request e response');
    END IF;
END;
$$;

create or replace function public.func_marcacao_relatorio_marcacoes_diarias(f_cod_unidade bigint, f_data_inicial date,
                                                                            f_data_final date, f_cpf text)
    returns TABLE
            (
                "NOME"                                         text,
                "MATRÍCULA TRANSPORTADORA"                     text,
                "MATRÍCULA AMBEV"                              text,
                "CARGO"                                        text,
                "SETOR"                                        text,
                "EQUIPE"                                       text,
                "INTERVALO"                                    text,
                "INICIO INTERVALO"                             text,
                "LATITUDE INÍCIO"                              text,
                "LONGITUDE INÍCIO"                             text,
                "FONTE DATA/HORA INÍCIO"                       text,
                "DATA/HORA SINCRONIZAÇÃO INÍCIO"               text,
                "FIM INTERVALO"                                text,
                "LATITUDE FIM"                                 text,
                "LONGITUDE FIM"                                text,
                "FONTE DATA/HORA FIM"                          text,
                "DATA/HORA SINCRONIZAÇÃO FIM"                  text,
                "TEMPO DECORRIDO (MINUTOS)"                    text,
                "TEMPO RECOMENDADO (MINUTOS)"                  bigint,
                "CUMPRIU TEMPO MÍNIMO"                         text,
                "JUSTIFICATIVA NÃO CUMPRIMENTO TEMPO MÍNIMO"   text,
                "JUSTIFICATIVA ESTOURO TEMPO MÁXIMO PERMITIDO" text,
                "DISTANCIA ENTRE INÍCIO E FIM (METROS)"        text,
                "DEVICE IMEI INÍCIO"                           text,
                "DEVICE IMEI INÍCIO RECONHECIDO"               text,
                "DEVICE IMEI FIM"                              text,
                "DEVICE IMEI FIM RECONHECIDO"                  text
            )
    language sql
as
$$
SELECT C.NOME                                                                  AS NOME_COLABORADOR,
       COALESCE(C.MATRICULA_TRANS :: TEXT, '-')                                AS MATRICULA_TRANS,
       COALESCE(C.MATRICULA_AMBEV :: TEXT, '-')                                AS MATRICULA_AMBEV,
       F.NOME                                                                  AS CARGO,
       S.NOME                                                                  AS SETOR,
       E.NOME                                                                  AS EQUIPE,
       IT.NOME                                                                 AS INTERVALO,
       COALESCE(
               TO_CHAR(I.DATA_HORA_INICIO AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE),
                       'DD/MM/YYYY HH24:MI:SS'),
               '')                                                             AS DATA_HORA_INICIO,
       I.LATITUDE_MARCACAO_INICIO :: TEXT                                      AS LATITUDE_INICIO,
       I.LONGITUDE_MARCACAO_INICIO :: TEXT                                     AS LONGITUDE_INICIO,
       I.FONTE_DATA_HORA_INICIO,
       COALESCE(TO_CHAR(I.DATA_HORA_SINCRONIZACAO_INICIO AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE),
                        'DD/MM/YYYY HH24:MI:SS'),
                ''),
       COALESCE(TO_CHAR(I.DATA_HORA_FIM AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE),
                        'DD/MM/YYYY HH24:MI:SS'),
                '')                                                            AS DATA_HORA_FIM,
       I.LATITUDE_MARCACAO_FIM :: TEXT                                         AS LATITUDE_FIM,
       I.LONGITUDE_MARCACAO_FIM :: TEXT                                        AS LONGITUDE_FIM,
       I.FONTE_DATA_HORA_FIM,
       COALESCE(TO_CHAR(I.DATA_HORA_SINCRONIZACAO_FIM AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE),
                        'DD/MM/YYYY HH24:MI:SS'),
                ''),
       COALESCE(TRUNC(EXTRACT(EPOCH FROM I.DATA_HORA_FIM - I.DATA_HORA_INICIO) / 60) :: TEXT,
                '')                                                            AS TEMPO_DECORRIDO_MINUTOS,
       IT.TEMPO_RECOMENDADO_MINUTOS,
       CASE
           WHEN I.DATA_HORA_FIM IS NULL OR I.DATA_HORA_INICIO IS NULL
               THEN ''
           WHEN IT.TEMPO_RECOMENDADO_MINUTOS > (EXTRACT(EPOCH FROM I.DATA_HORA_FIM - I.DATA_HORA_INICIO) / 60)
               THEN 'NÃO'
           ELSE 'SIM' END                                                      AS CUMPRIU_TEMPO_MINIMO,
       I.JUSTIFICATIVA_TEMPO_RECOMENDADO,
       I.JUSTIFICATIVA_ESTOURO,
       COALESCE(TRUNC((ST_DISTANCE(
               ST_POINT(I.LONGITUDE_MARCACAO_INICIO :: FLOAT,
                        I.LATITUDE_MARCACAO_INICIO :: FLOAT) :: GEOGRAPHY,
               ST_POINT(I.LONGITUDE_MARCACAO_FIM :: FLOAT,
                        I.LATITUDE_MARCACAO_FIM :: FLOAT) :: GEOGRAPHY))) :: TEXT,
                '-')                                                           AS DISTANCIA,
       COALESCE(I.DEVICE_IMEI_INICIO :: TEXT, '-')                             AS DEVICE_IMEI_INICIO,
       F_IF(
               I.DEVICE_IMEI_INICIO IS NOT NULL,
               F_IF(I.DEVICE_IMEI_INICIO_RECONHECIDO, 'SIM', 'NÃO' :: TEXT),
               '-' :: TEXT)                                                    AS DEVICE_IMEI_INICIO_RECONHECIDO,
       COALESCE(I.DEVICE_IMEI_FIM :: TEXT, '-')                                AS DEVICE_IMEI_FIM,
       F_IF(
               I.DEVICE_IMEI_FIM IS NOT NULL,
               F_IF(I.DEVICE_IMEI_FIM_RECONHECIDO, 'SIM', 'NÃO' :: TEXT), '-') AS DEVICE_IMEI_FIM_RECONHECIDO
FROM FUNC_INTERVALOS_AGRUPADOS(F_COD_UNIDADE, CASE
                                                  WHEN F_CPF = '%'
                                                      THEN NULL
                                                  ELSE F_CPF :: BIGINT END, NULL) I
         JOIN COLABORADOR C ON C.CPF = I.CPF_COLABORADOR
         JOIN INTERVALO_TIPO IT ON IT.CODIGO = I.COD_TIPO_INTERVALO
         JOIN UNIDADE U ON U.CODIGO = C.COD_UNIDADE
         JOIN FUNCAO F ON F.CODIGO = C.COD_FUNCAO
         JOIN SETOR S ON S.CODIGO = C.COD_SETOR
         JOIN EQUIPE E ON E.CODIGO = C.COD_EQUIPE
WHERE ((I.DATA_HORA_INICIO AT TIME ZONE (SELECT TIMEZONE FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE))) :: DATE
           BETWEEN F_DATA_INICIAL
           AND F_DATA_FINAL
    OR (I.DATA_HORA_FIM AT TIME ZONE (SELECT TIMEZONE FROM FUNC_GET_TIME_ZONE_UNIDADE(F_COD_UNIDADE))) :: DATE
           BETWEEN F_DATA_INICIAL
           AND F_DATA_FINAL)
ORDER BY I.DATA_HORA_INICIO, C.NOME
$$;

create or replace function public.func_relatorio_consolidado_produtividade(f_dt_inicial date, f_dt_final date, f_cod_unidade bigint)
    returns TABLE
            (
                "MATRICULA AMBEV"   integer,
                "COLABORADOR"       text,
                "FUNÇÃO"            text,
                "CXS ENTREGUES"     integer,
                "JORNADAS BATIDAS"  bigint,
                "RESULTADO JORNADA" text,
                "DEV PDV"           text,
                "META DEV PDV"      text,
                "RECEBE BÔNUS"      text,
                "VALOR BÔNUS"       text,
                "Nº FATOR 1"        bigint,
                "Nº FATOR 2"        bigint,
                "Nº ROTAS"          bigint,
                "VALOR ROTA"        text,
                "Nº RECARGAS"       bigint,
                "VALOR RECARGA"     text,
                "Nº ELD"            bigint,
                "DIFERENÇA ELD"     text,
                "Nº AS"             bigint,
                "VALOR AS"          text,
                "Nº MAPAS TOTAL"    bigint,
                "VALOR TOTAL"       text
            )
    language sql
as
$$
SELECT matricula_ambev,
       initcap(nome_colaborador)                                                            AS "COLABORADOR",
       funcao                                                                               AS "FUNÇÃO",
       trunc(sum(cxentreg))::INT                                                            AS "CXS ENTREGUES",
       sum(case
               when (tempo_largada + tempo_rota + tempointerno) <= meta_jornada_liquida_horas
                   then 1
               else 0 end)                                                                  as qtde_jornada_batida,
       trunc((sum(case
                      when (tempo_largada + tempo_rota + tempointerno) <= meta_jornada_liquida_horas
                          then 1
                      else 0 end)::float / count(meta_jornada_liquida_horas)) * 100) || '%' as porcentagem_jornada,
       REPLACE(round(((sum(entregasnaorealizadas + entregasparciais))::numeric /
                      nullif(sum(entregascompletas + entregasparciais + entregasnaorealizadas), 0)::numeric) * 100,
                     2)::TEXT, '.', ',') || '%'                                             as "DEV PDV",
       REPLACE(round((meta_dev_pdv * 100)::numeric, 2)::TEXT, '.', ',') || '%'              AS "META DEV PDV",
       CASE
           WHEN round(1 - sum(entregascompletas) /
                          nullif(sum(entregascompletas + entregasparciais + entregasnaorealizadas), 0)::numeric, 4) <=
                meta_dev_pdv THEN
               'SIM'
           ELSE 'NÃO' END                                                                   as "RECEBE BÔNUS",
       REPLACE((CASE
                    WHEN round(1 - sum(entregascompletas) /
                                   nullif(sum(entregascompletas + entregasparciais + entregasnaorealizadas),
                                          0)::numeric, 4) <= meta_dev_pdv AND VPE.cod_funcao = ufp.cod_funcao_motorista
                        THEN
                        PCI.bonus_motorista
                    WHEN round(1 - sum(entregascompletas) /
                                   nullif(sum(entregascompletas + entregasparciais + entregasnaorealizadas),
                                          0)::numeric, 4) <= meta_dev_pdv AND VPE.cod_funcao = ufp.cod_funcao_ajudante
                        THEN
                        PCI.bonus_ajudante
                    ELSE 0 END)::TEXT, '.', ',')                                            as "VALOR BÔNUS",
       sum(CASE WHEN fator = 1 then 1 else 0 end)                                           as "Nº FATOR 1",
       sum(CASE WHEN fator = 2 then 1 else 0 end)                                           as "Nº FATOR 2",
       sum(CASE WHEN valor_rota > 0 THEN 1 else 0 END)                                      as "Nº ROTAS",
       REPLACE('R$ ' || trunc(sum(valor_rota)::NUMERIC, 2), '.', ',')                       AS "VALOR ROTA",
       sum(CASE WHEN valor_recarga > 0 THEN 1 else 0 END)                                   as "Nº RECARGAS",
       REPLACE('R$ ' || trunc(sum(valor_recarga) :: NUMERIC, 2), '.', ',')                  AS "VALOR RECARGA",
       sum(CASE WHEN valor_diferenca_eld > 0 THEN 1 else 0 END)                             as "Nº ELD",
       REPLACE('R$ ' || trunc(sum(valor_DIFERENCA_ELD) :: NUMERIC, 2), '.', ',')            AS "DIFERENÇA ELD",
       sum(CASE WHEN valor_as > 0 THEN 1 else 0 END)                                        as "Nº AS",
       REPLACE('R$ ' || trunc(sum(valor_AS) :: NUMERIC, 2), '.', ',')                       AS "VALOR AS",
       sum(CASE WHEN valor > 0 THEN 1 else 0 END)                                           as "Nº MAPAS TOTAL",
       REPLACE('R$ ' || trunc(((CASE
                                    WHEN round(1 - sum(entregascompletas) / nullif(
                                            sum(entregascompletas + entregasparciais + entregasnaorealizadas),
                                            0)::numeric, 4) <= meta_dev_pdv AND
                                         VPE.cod_funcao = ufp.cod_funcao_motorista THEN
                                        PCI.bonus_motorista
                                    WHEN round(1 - sum(entregascompletas) / nullif(
                                            sum(entregascompletas + entregasparciais + entregasnaorealizadas),
                                            0)::numeric, 4) <= meta_dev_pdv AND VPE.cod_funcao = ufp.cod_funcao_ajudante
                                        THEN
                                        PCI.bonus_ajudante
                                    ELSE 0 END) +
                               sum(valor)) :: NUMERIC, 2), '.', ',')                        AS "VALOR TOTAL"
FROM view_produtividade_extrato vpe
         LEFT JOIN pre_contracheque_informacoes pci on pci.cod_unidade = vpe.cod_unidade
         LEFT JOIN unidade_funcao_produtividade ufp on ufp.cod_unidade = vpe.cod_unidade
WHERE vpe.cod_unidade = f_cod_unidade
  AND vpe.data BETWEEN f_dt_inicial AND f_dt_final
GROUP BY matricula_ambev, nome_colaborador, vpe.cod_funcao, funcao, meta_dev_pdv, ufp.cod_funcao_ajudante,
         ufp.cod_funcao_motorista, PCI.bonus_ajudante, PCI.bonus_motorista
ORDER BY nome_colaborador;
$$;

create or replace function suporte.func_pneu_cadastra_dimensao_pneu(f_altura bigint, f_largura bigint, f_aro real,
                                                                    OUT aviso_dimensao_criada text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    COD_DIMENSAO_EXISTENTE BIGINT := (SELECT CODIGO
                                      FROM DIMENSAO_PNEU
                                      WHERE LARGURA = F_LARGURA
                                        AND ALTURA = F_ALTURA
                                        AND ARO = F_ARO);
    COD_DIMENSAO_CRIADA    BIGINT;
BEGIN
    --VERIFICA SE OS DADOS INFORMADOS SÃO MAIORES QUE 0.
    IF (F_ALTURA < 0)
    THEN
        RAISE EXCEPTION 'O VALOR ATRIBUÍDO PARA ALTURA DEVE SER MAIOR QUE 0(ZERO). VALOR INFORMADO: %', F_ALTURA;
    END IF;

    IF (F_LARGURA < 0)
    THEN
        RAISE EXCEPTION 'O VALOR ATRIBUÍDO PARA LARGURA DEVE SER MAIOR QUE 0(ZERO). VALOR INFORMADO: %', F_LARGURA;
    END IF;

    IF (F_ARO < 0)
    THEN
        RAISE EXCEPTION 'O VALOR ATRIBUÍDO PARA ARO DEVE SER MAIOR QUE 0(ZERO). VALOR INFORMADO: %', F_ARO;
    END IF;

    --VERIFICA SE ESSA DIMENSÃO EXISTE NA BASE DE DADOS.
    IF (COD_DIMENSAO_EXISTENTE IS NOT NULL)
    THEN
        RAISE EXCEPTION 'ERRO! ESSA DIMENSÃO JÁ ESTÁ CADASTRADA, POSSUI O CÓDIGO = %.', COD_DIMENSAO_EXISTENTE;
    END IF;

    --ADICIONA NOVA DIMENSÃO E RETORNA SEU ID.
    INSERT INTO DIMENSAO_PNEU(ALTURA, LARGURA, ARO)
    VALUES (F_ALTURA, F_LARGURA, F_ARO) RETURNING CODIGO INTO COD_DIMENSAO_CRIADA;

    --MENSAGEM DE SUCESSO.
    SELECT 'DIMENSÃO CADASTRADA COM SUCESSO! DIMENSÃO: ' || F_LARGURA || '/' || F_ALTURA || 'R' || F_ARO ||
           ' COM CÓDIGO: '
               || COD_DIMENSAO_CRIADA || '.'
    INTO AVISO_DIMENSAO_CRIADA;
END
$$;

create or replace function cs.func_nps_busca_pesquisa_disponivel(f_cod_colaborador bigint, f_data_atual date)
    returns TABLE
            (
                cod_pesquisa_nps           bigint,
                titulo_pesquisa            text,
                breve_descricao_pesquisa   text,
                titulo_pergunta_escala     text,
                legenda_escala_baixa       text,
                legenda_escala_alta        text,
                titulo_pergunta_descritiva text
            )
    language plpgsql
as
$$
declare
    f_cod_pesquisa_nps           bigint;
    f_titulo_pesquisa            text;
    f_breve_descricao_pesquisa   text;
    f_titulo_pergunta_escala     text;
    f_legenda_escala_baixa       text;
    f_legenda_escala_alta        text;
    f_titulo_pergunta_descritiva text;
begin
    -- Mesmo tendo o index para permitir apenas uma ativa por vez, esse SELECT já garante isso também.
    select np.codigo,
           np.titulo_pesquisa,
           np.breve_descricao_pesquisa,
           np.titulo_pergunta_escala,
           np.LEGENDA_ESCALA_BAIXA,
           np.LEGENDA_ESCALA_ALTA,
           np.titulo_pergunta_descritiva
    from cs.nps_pesquisa np
         -- Ativo e ainda em veiculação.
    where np.status_ativo
      and f_data_atual <@ periodo_veiculacao_pesquisa
    into
        f_cod_pesquisa_nps,
        f_titulo_pesquisa,
        f_breve_descricao_pesquisa,
        f_titulo_pergunta_escala,
        f_legenda_escala_baixa,
        f_legenda_escala_alta,
        f_titulo_pergunta_descritiva;

    if f_cod_pesquisa_nps is null
    then
        return query
            select null :: bigint, null :: text, null :: text, null :: text, null :: text, null :: text, null :: text;

        -- Break.
        return;
    end if;

    -- Se o colaborador ainda não respondeu e também não bloqueou a pesquisa, então temos uma disponível.
    if ((select not exists(select nbpc.cod_nps_pesquisa
                           from cs.nps_bloqueio_pesquisa_colaborador nbpc
                           where nbpc.cod_nps_pesquisa = f_cod_pesquisa_nps
                             and nbpc.cod_colaborador_bloqueio = f_cod_colaborador))
        and
        (select not exists(select nr.cod_nps_pesquisa
                           from cs.nps_respostas nr
                           where nr.cod_nps_pesquisa = f_cod_pesquisa_nps
                             and nr.cod_colaborador_respostas = f_cod_colaborador)))
    then
        return query
            select f_cod_pesquisa_nps,
                   f_titulo_pesquisa,
                   f_breve_descricao_pesquisa,
                   f_titulo_pergunta_escala,
                   f_legenda_escala_baixa,
                   f_legenda_escala_alta,
                   f_titulo_pergunta_descritiva;
    end if;
end;
$$;

create or replace function cs.func_nps_insere_nova_pesquisa(f_titulo_pesquisa text, f_breve_descricao_pesquisa text,
                                                            f_titulo_pergunta_escala text, f_legenda_escala_baixa text,
                                                            f_legenda_escala_alta text,
                                                            f_titulo_pergunta_descritiva text,
                                                            f_data_inicio_veiculacao_inclusivo date,
                                                            f_data_fim_veiculacao_exclusivo date,
                                                            OUT aviso_pesquisa_inserida text) returns text
    security definer
    language plpgsql
as
$$
begin
    -- Antes de inserir uma nova pesquisa, inativa todas as anteriores.
    update cs.nps_pesquisa set status_ativo = false;

    insert into cs.nps_pesquisa (titulo_pesquisa,
                                 breve_descricao_pesquisa,
                                 periodo_veiculacao_pesquisa,
                                 titulo_pergunta_escala,
                                 legenda_escala_baixa,
                                 legenda_escala_alta,
                                 titulo_pergunta_descritiva)
    values (f_titulo_pesquisa,
            f_breve_descricao_pesquisa,
            daterange(f_data_inicio_veiculacao_inclusivo, f_data_fim_veiculacao_exclusivo),
            f_titulo_pergunta_escala,
            f_legenda_escala_baixa,
            f_legenda_escala_alta,
            f_titulo_pergunta_descritiva);

    if not found
    then
        raise exception 'Erro ao inserir nova pesquisa de NPS';
    end if;

    select 'Pesquisa de NPS inserida com sucesso!'
    into aviso_pesquisa_inserida;
end;
$$;

create or replace function public.func_pneu_cadastra_marca_banda(f_cod_empresa bigint, f_marca_banda character varying) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_MARCA_INSERIDO BIGINT;
BEGIN
    IF EXISTS(SELECT MB.NOME
              FROM MARCA_BANDA MB
              WHERE UNACCENT(TRIM(MB.NOME)) ILIKE UNACCENT(TRIM(F_MARCA_BANDA))
                AND MB.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        FORMAT(E'Já existe uma marca de nome \'%s\' cadastrada na empresa', F_MARCA_BANDA));
    END IF;

    INSERT INTO MARCA_BANDA (COD_EMPRESA, NOME)
    SELECT F_COD_EMPRESA,
           REMOVE_EXTRA_SPACES(F_MARCA_BANDA)
           RETURNING CODIGO INTO COD_MARCA_INSERIDO;

    RETURN COD_MARCA_INSERIDO;
END;
$$;

create or replace function public.func_pneu_edita_marca_banda(f_cod_marca_banda bigint, f_nome_marca_banda character varying) returns bigint
    language sql
as
$$
UPDATE MARCA_BANDA
SET NOME = REMOVE_EXTRA_SPACES(F_NOME_MARCA_BANDA)
WHERE CODIGO = F_COD_MARCA_BANDA RETURNING CODIGO;
$$;

create or replace function public.func_pneu_get_marca_banda_visualizacao(f_cod_marca bigint)
    returns TABLE
            (
                codigo bigint,
                nome   text
            )
    language sql
as
$$
SELECT MB.CODIGO       AS COD_MARCA_PNEU,
       MB.NOME :: TEXT AS NOME_MARCA_PNEU
FROM MARCA_BANDA MB
WHERE MB.CODIGO = F_COD_MARCA;
$$;

create or replace function public.func_pneu_cadastra_modelo_banda(f_cod_empresa bigint, f_cod_marca_banda bigint,
                                                                  f_nome_modelo_banda character varying,
                                                                  f_qtd_sulcos integer,
                                                                  f_altura_sulcos double precision) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_MODELO_INSERIDO BIGINT;
BEGIN
    IF EXISTS(SELECT MB.CODIGO
              FROM MODELO_BANDA MB
              WHERE UNACCENT(TRIM(MB.NOME)) ILIKE UNACCENT(TRIM(F_NOME_MODELO_BANDA))
                AND MB.COD_MARCA = F_COD_MARCA_BANDA
                AND MB.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        FORMAT(E'Já existe um modelo de nome \'%s\' cadastrado na mesma marca', F_NOME_MODELO_BANDA));
    END IF;

    INSERT INTO MODELO_BANDA (COD_EMPRESA,
                              COD_MARCA,
                              NOME,
                              QT_SULCOS,
                              ALTURA_SULCOS)
    SELECT F_COD_EMPRESA,
           F_COD_MARCA_BANDA,
           REMOVE_EXTRA_SPACES(F_NOME_MODELO_BANDA),
           F_QTD_SULCOS,
           F_ALTURA_SULCOS
           RETURNING CODIGO INTO COD_MODELO_INSERIDO;

    RETURN COD_MODELO_INSERIDO;
END;
$$;

create or replace function public.func_pneu_edita_modelo_banda(f_cod_empresa bigint, f_cod_marca_banda bigint,
                                                               f_cod_modelo_banda bigint,
                                                               f_nome_modelo_banda character varying,
                                                               f_qtd_sulcos integer,
                                                               f_altura_sulcos double precision) returns bigint
    language sql
as
$$
UPDATE MODELO_BANDA
SET COD_MARCA     = F_COD_MARCA_BANDA,
    NOME          = REMOVE_EXTRA_SPACES(F_NOME_MODELO_BANDA),
    QT_SULCOS     = F_QTD_SULCOS,
    ALTURA_SULCOS = F_ALTURA_SULCOS
WHERE COD_EMPRESA = F_COD_EMPRESA
  AND CODIGO = F_COD_MODELO_BANDA RETURNING CODIGO;
$$;

create or replace function public.func_pneu_get_modelo_banda_visualizacao(f_cod_modelo_banda bigint)
    returns TABLE
            (
                cod_marca_banda            bigint,
                nome_marca_banda           text,
                cod_modelo_banda           bigint,
                nome_modelo_banda          text,
                qt_sulcos_modelo_banda     smallint,
                altura_sulcos_modelo_banda numeric
            )
    language sql
as
$$
SELECT MAB.CODIGO                            AS COD_MARCA_BANDA,
       MAB.NOME :: TEXT                      AS NOME_MARCA_BANDA,
       MOB.CODIGO                            AS COD_MODELO_BANDA,
       MOB.NOME :: TEXT                      AS NOME_MODELO_BANDA,
       MOB.QT_SULCOS                         AS QT_SULCOS_MODELO_BANDA,
       TRUNC(MOB.ALTURA_SULCOS ::NUMERIC, 2) AS ALTURA_SULCOS_MODELO_BANDA
FROM MODELO_BANDA MOB
         JOIN MARCA_BANDA MAB
              ON MOB.COD_MARCA = MAB.CODIGO
                  AND MOB.COD_EMPRESA = MAB.COD_EMPRESA
WHERE MOB.CODIGO = F_COD_MODELO_BANDA;
$$;

create or replace function public.func_pneu_cadastra_modelo_pneu(f_cod_empresa bigint, f_cod_marca_pneu bigint,
                                                                 f_nome_modelo_pneu character varying,
                                                                 f_qtd_sulcos integer,
                                                                 f_altura_sulcos double precision) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_MODELO_INSERIDO BIGINT;
BEGIN
    IF EXISTS(SELECT MP.CODIGO
              FROM MODELO_PNEU MP
              WHERE UNACCENT(TRIM(MP.NOME)) ILIKE UNACCENT(TRIM(F_NOME_MODELO_PNEU))
                AND MP.COD_MARCA = F_COD_MARCA_PNEU
                AND MP.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        FORMAT(E'Já existe um modelo de nome \'%s\' cadastrado na mesma marca', F_NOME_MODELO_PNEU));
    END IF;

    INSERT INTO MODELO_PNEU (COD_EMPRESA,
                             COD_MARCA,
                             NOME,
                             QT_SULCOS,
                             ALTURA_SULCOS)
    SELECT F_COD_EMPRESA,
           F_COD_MARCA_PNEU,
           REMOVE_EXTRA_SPACES(F_NOME_MODELO_PNEU),
           F_QTD_SULCOS,
           F_ALTURA_SULCOS
           RETURNING CODIGO INTO COD_MODELO_INSERIDO;

    RETURN COD_MODELO_INSERIDO;
END;
$$;

create or replace function public.func_pneu_edita_modelo_pneu(f_cod_empresa bigint, f_cod_marca_pneu bigint,
                                                              f_cod_modelo_pneu bigint,
                                                              f_nome_modelo_pneu character varying,
                                                              f_qtd_sulcos integer,
                                                              f_altura_sulcos double precision) returns bigint
    language sql
as
$$
UPDATE MODELO_PNEU
SET COD_MARCA     = F_COD_MARCA_PNEU,
    NOME          = REMOVE_EXTRA_SPACES(F_NOME_MODELO_PNEU),
    QT_SULCOS     = F_QTD_SULCOS,
    ALTURA_SULCOS = F_ALTURA_SULCOS
WHERE COD_EMPRESA = F_COD_EMPRESA
  AND CODIGO = F_COD_MODELO_PNEU RETURNING CODIGO;
$$;

create or replace function public.func_pneu_get_modelo_pneu_visualizacao(f_cod_modelo bigint)
    returns TABLE
            (
                cod_empresa   bigint,
                cod_marca     bigint,
                cod_modelo    bigint,
                nome_modelo   text,
                qtd_sulcos    smallint,
                altura_sulcos numeric
            )
    language sql
as
$$
SELECT MP.COD_EMPRESA,
       MP.COD_MARCA,
       MP.CODIGO,
       MP.NOME :: TEXT,
       MP.QT_SULCOS,
       TRUNC(MP.ALTURA_SULCOS :: NUMERIC, 2)
FROM MODELO_PNEU MP
WHERE MP.CODIGO = F_COD_MODELO;
$$;

create or replace function suporte.func_pneu_altera_restricao_pneu(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                   f_tolerancia_calibragem real,
                                                                   f_tolerancia_inspecao real,
                                                                   f_sulco_minimo_recapagem real,
                                                                   f_sulco_minimo_descarte real,
                                                                   f_periodo_afericao_pressao bigint,
                                                                   f_periodo_afericao_sulco bigint,
                                                                   OUT parametrizacao_atualizada text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    COD_PARAMETRIZACAO_EXISTENTE   BIGINT := (SELECT COD_EMPRESA
                                              FROM PNEU_RESTRICAO_UNIDADE
                                              WHERE COD_EMPRESA = F_COD_EMPRESA
                                                AND COD_UNIDADE = F_COD_UNIDADE);
    TOLERANCIA_CALIBRAGEM_ATUAL    REAL;
    SULCO_MINIMO_RECAPAGEM_ATUAL   REAL;
    SULCO_MINIMO_DESCARTE_ATUAL    REAL;
    TOLERANCIA_INSPECAO_ATUAL      REAL;
    PERIODO_AFERICAO_PRESSAO_ATUAL BIGINT;
    PERIODO_AFERICAO_SULCO_ATUAL   BIGINT;
BEGIN
    --SETAR VARIÁVEIS
    SELECT TOLERANCIA_CALIBRAGEM,
           SULCO_MINIMO_RECAPAGEM,
           SULCO_MINIMO_DESCARTE,
           TOLERANCIA_INSPECAO,
           PERIODO_AFERICAO_PRESSAO,
           PERIODO_AFERICAO_SULCO
    INTO
        TOLERANCIA_CALIBRAGEM_ATUAL,
        SULCO_MINIMO_RECAPAGEM_ATUAL,
        SULCO_MINIMO_DESCARTE_ATUAL,
        TOLERANCIA_INSPECAO_ATUAL,
        PERIODO_AFERICAO_PRESSAO_ATUAL,
        PERIODO_AFERICAO_SULCO_ATUAL
    FROM PNEU_RESTRICAO_UNIDADE
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND COD_UNIDADE = F_COD_UNIDADE;

    --GARANTE QUE EMPRESA POSSUI UNIDADE.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE);

    --VERIFICA SE A EMPRESA POSSUI PARAMETRIZACÃO NESSA UNIDADE.
    IF (COD_PARAMETRIZACAO_EXISTENTE IS NULL)
    THEN
        RAISE EXCEPTION 'ERRO! A EMPRESA: % NÃO POSSUI PARAMETRIZAÇÃO NA UNIDADE: %', F_COD_EMPRESA, F_COD_UNIDADE;
    END IF;

    --VERIFICA SE ALGUM DADO É MENOR QUE ZERO.
    IF (F_TOLERANCIA_CALIBRAGEM < 0)
    THEN
        RAISE EXCEPTION 'ERRO! O VALOR ATRIBUÍDO PARA TOLERÂNCIA DE CALIBRAGEM DEVE SER MAIOR QUE 0(ZERO)';
    END IF;

    IF (F_SULCO_MINIMO_RECAPAGEM < 0)
    THEN
        RAISE EXCEPTION 'ERRO! O VALOR ATRIBUÍDO PARA SULCO MÍNIMO RECAPAGEM DEVE SER MAIOR QUE 0(ZERO)';
    END IF;

    IF (F_SULCO_MINIMO_DESCARTE < 0)
    THEN
        RAISE EXCEPTION 'ERRO! O VALOR ATRIBUÍDO PARA SULCO MÍNIMO DESCARTE DEVE SER MAIOR QUE 0(ZERO)';
    END IF;

    IF (F_TOLERANCIA_INSPECAO < 0)
    THEN
        RAISE EXCEPTION 'ERRO! O VALOR ATRIBUÍDO PARA TOLERÂNCIA INSPEÇÃO DEVE SER MAIOR QUE 0(ZERO)';
    END IF;

    IF (F_PERIODO_AFERICAO_PRESSAO < 0)
    THEN
        RAISE EXCEPTION 'ERRO! O VALOR ATRIBUÍDO PARA PERÍODO AFERIÇÃO PRESSÃO DEVE SER MAIOR QUE 0(ZERO)';
    END IF;

    IF (F_PERIODO_AFERICAO_SULCO < 0)
    THEN
        RAISE EXCEPTION 'ERRO! O VALOR ATRIBUÍDO PARA PERÍODO AFERIÇÃO SULCO DEVE SER MAIOR QUE 0(ZERO)';
    END IF;

    --ATUALIZA DADOS DA PARAMETRIZAÇÃO.
    UPDATE PNEU_RESTRICAO_UNIDADE
    SET TOLERANCIA_CALIBRAGEM    = F_IF(F_TOLERANCIA_CALIBRAGEM IS NULL, TOLERANCIA_CALIBRAGEM_ATUAL,
                                        F_TOLERANCIA_CALIBRAGEM),
        SULCO_MINIMO_RECAPAGEM   = F_IF(F_SULCO_MINIMO_RECAPAGEM IS NULL, SULCO_MINIMO_RECAPAGEM_ATUAL,
                                        F_SULCO_MINIMO_RECAPAGEM),
        SULCO_MINIMO_DESCARTE    = F_IF(F_SULCO_MINIMO_DESCARTE IS NULL, SULCO_MINIMO_DESCARTE_ATUAL,
                                        F_SULCO_MINIMO_DESCARTE),
        TOLERANCIA_INSPECAO      = F_IF(F_TOLERANCIA_INSPECAO IS NULL, TOLERANCIA_INSPECAO_ATUAL,
                                        F_TOLERANCIA_INSPECAO),
        PERIODO_AFERICAO_PRESSAO = F_IF(F_PERIODO_AFERICAO_PRESSAO IS NULL, PERIODO_AFERICAO_PRESSAO_ATUAL,
                                        F_PERIODO_AFERICAO_PRESSAO),
        PERIODO_AFERICAO_SULCO   = F_IF(F_PERIODO_AFERICAO_SULCO IS NULL, PERIODO_AFERICAO_SULCO_ATUAL,
                                        F_PERIODO_AFERICAO_SULCO)
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND COD_UNIDADE = F_COD_UNIDADE;

    --MENSAGEM DE SUCESSO.
    SELECT 'DADOS ATUALIZADOS COM SUCESSO!!'
               || ' EMPRESA: '
               || COD_EMPRESA
               || ', UNIDADE: '
               || COD_UNIDADE
               || ', TOLERANCIA CALIBRAGEM: '
               || TOLERANCIA_CALIBRAGEM
               || ', SULCO MÍNIMO RECAPAGEM: '
               || SULCO_MINIMO_RECAPAGEM
               || ', SULCO MÍNIMO DESCARTE: '
               || SULCO_MINIMO_DESCARTE
               || ' TOLERANCIA INSPEÇÃO: '
               || TOLERANCIA_INSPECAO
               || ',PERÍODO AFERIÇÃO PRESSÃO: '
               || PERIODO_AFERICAO_PRESSAO
               || ', PERÍODO AFERIÇÃO SULCO: '
               || PERIODO_AFERICAO_SULCO
    FROM PNEU_RESTRICAO_UNIDADE
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND COD_UNIDADE = F_COD_UNIDADE
    INTO PARAMETRIZACAO_ATUALIZADA;
END
$$;

create or replace function integracao.func_marcacao_lista_tipos_marcacoes(f_token_integracao text, f_apenas_tipo_marcacoes_ativas boolean)
    returns TABLE
            (
                cod_empresa                  bigint,
                cod_unidade                  bigint,
                codigo                       bigint,
                nome                         text,
                icone                        text,
                tempo_recomendado_em_minutos bigint,
                tempo_estouro_em_minutos     bigint,
                horario_sugerido_marcar      time without time zone,
                is_tipo_jornada              boolean,
                desconta_jornada_bruta       boolean,
                desconta_jornada_liquida     boolean,
                status_ativo                 boolean
            )
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_TOKEN BIGINT := (SELECT TI.COD_EMPRESA
                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
BEGIN
    -- Validamos se a Empresa é válida.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_TOKEN,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    RETURN QUERY
        SELECT U.COD_EMPRESA                                       AS COD_EMPRESA,
               U.CODIGO                                            AS COD_UNIDADE,
               IT.CODIGO                                           AS CODIGO,
               IT.NOME::TEXT                                       AS NOME,
               IT.ICONE::TEXT                                      AS ICONE,
               IT.TEMPO_RECOMENDADO_MINUTOS                        AS TEMPO_RECOMENDADO_EM_MINNUTOS,
               IT.TEMPO_ESTOURO_MINUTOS                            AS TEMPO_ESTOURO_EM_MINUTOS,
               IT.HORARIO_SUGERIDO                                 AS HORARIO_SUGERIDO_MARCAR,
               F_IF(IT.CODIGO = MTJ.COD_TIPO_JORNADA, TRUE, FALSE) AS IS_TIPO_JORNADA,
               F_IF(MTDCJBL.DESCONTA_JORNADA_BRUTA IS NULL,
                    FALSE,
                    MTDCJBL.DESCONTA_JORNADA_BRUTA)                AS DESCONTA_JORNADA_BRUTA,
               F_IF(MTDCJBL.DESCONTA_JORNADA_LIQUIDA IS NULL,
                    FALSE,
                    MTDCJBL.DESCONTA_JORNADA_LIQUIDA)              AS DESCONTA_JORNADA_LIQUIDA,
               IT.ATIVO                                            AS STATUS_ATIVO
        FROM INTERVALO_TIPO IT
                 JOIN UNIDADE U
                      ON IT.COD_UNIDADE = U.CODIGO
                 LEFT JOIN MARCACAO_TIPO_JORNADA MTJ
                           ON IT.COD_UNIDADE = MTJ.COD_UNIDADE AND IT.CODIGO = MTJ.COD_TIPO_JORNADA
                 LEFT JOIN MARCACAO_TIPOS_DESCONTADOS_CALCULO_JORNADA_BRUTA_LIQUIDA MTDCJBL
                           ON IT.COD_UNIDADE = MTDCJBL.COD_UNIDADE AND IT.CODIGO = MTDCJBL.COD_TIPO_DESCONTADO
        WHERE IT.COD_UNIDADE IN (SELECT U.CODIGO
                                 FROM UNIDADE U
                                 WHERE U.COD_EMPRESA = COD_EMPRESA_TOKEN)
          AND F_IF(F_APENAS_TIPO_MARCACOES_ATIVAS, IT.ATIVO = TRUE, TRUE);
END;
$$;

create or replace function integracao.func_marcacao_lista_marcacoes_realizadas(f_token_integracao text, f_cod_ultima_marcacao_sincronizada bigint)
    returns TABLE
            (
                cod_unidade                        bigint,
                codigo                             bigint,
                cod_marcacao_vinculo               bigint,
                cod_tipo_marcacao                  bigint,
                cpf_colaborador                    text,
                tipo_marcacao                      text,
                data_hora_marcacao_utc             timestamp without time zone,
                fonte_data_hora                    text,
                justificativa_tempo_recomendado    text,
                justificativa_estouro              text,
                latitude_marcacao                  text,
                longitude_marcacao                 text,
                data_hora_sincronizacao_utc        timestamp without time zone,
                device_imei                        text,
                device_id                          text,
                marca_device                       text,
                modelo_device                      text,
                versao_app_momento_marcacao        integer,
                versao_app_momento_sincronizacao   integer,
                device_uptime_realizacao_millis    bigint,
                device_uptime_sincronizacao_millis bigint,
                android_api_version                integer,
                status_ativo                       boolean
            )
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_TOKEN BIGINT := (SELECT TI.COD_EMPRESA
                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
BEGIN
    -- Validamos se a Empresa é válida.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_TOKEN,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    RETURN QUERY
        SELECT I.COD_UNIDADE                                AS COD_UNIDADE,
               I.CODIGO                                     AS CODIGO,
               CASE
                   WHEN I.TIPO_MARCACAO = 'MARCACAO_INICIO'
                       THEN
                       (SELECT MVIF.COD_MARCACAO_FIM
                        FROM MARCACAO_VINCULO_INICIO_FIM MVIF
                        WHERE MVIF.COD_MARCACAO_INICIO = I.CODIGO)
                   ELSE
                       (SELECT MVIF.COD_MARCACAO_INICIO
                        FROM MARCACAO_VINCULO_INICIO_FIM MVIF
                        WHERE MVIF.COD_MARCACAO_FIM = I.CODIGO)
                   END                                      AS COD_MARCACAO_VINCULO,
               I.COD_TIPO_INTERVALO                         AS COD_TIPO_MARCACAO,
               LPAD(I.CPF_COLABORADOR::TEXT, 11, '0')::TEXT AS CPF_COLABORADOR,
               I.TIPO_MARCACAO::TEXT                        AS TIPO_MARCACAO,
               I.DATA_HORA AT TIME ZONE 'UTC'               AS DATA_HORA_MARCACAO_UTC,
               I.FONTE_DATA_HORA::TEXT                      AS FONTE_DATA_HORA,
               I.JUSTIFICATIVA_TEMPO_RECOMENDADO            AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
               I.JUSTIFICATIVA_ESTOURO                      AS JUSTIFICATIVA_ESTOURO,
               I.LATITUDE_MARCACAO                          AS LATITUDE_MARCACAO,
               I.LONGITUDE_MARCACAO                         AS LONGITUDE_MARCACAO,
               I.DATA_HORA_SINCRONIZACAO AT TIME ZONE 'UTC' AS DATA_HORA_SINCRONIZACAO_UTC,
               I.DEVICE_IMEI                                AS DEVICE_IMEI,
               I.DEVICE_ID                                  AS DEVICE_ID,
               I.MARCA_DEVICE                               AS MARCA_DEVICE,
               I.MODELO_DEVICE                              AS MODELO_DEVICE,
               I.VERSAO_APP_MOMENTO_MARCACAO                AS VERSAO_APP_MOMENTO_MARCACAO,
               I.VERSAO_APP_MOMENTO_SINCRONIZACAO           AS VERSAO_APP_MOMENTO_SINCRONIZACAO,
               I.DEVICE_UPTIME_REALIZACAO_MILLIS            AS DEVICE_UPTIME_REALIZACAO_MILLIS,
               I.DEVICE_UPTIME_SINCRONIZACAO_MILLIS         AS DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
               I.ANDROID_API_VERSION                        AS ANDROID_API_VERSION,
               I.STATUS_ATIVO                               AS STATUS_ATIVO
        FROM INTERVALO I
        WHERE I.COD_UNIDADE IN (SELECT U.CODIGO FROM UNIDADE U WHERE U.COD_EMPRESA = COD_EMPRESA_TOKEN)
          AND I.CODIGO > F_COD_ULTIMA_MARCACAO_SINCRONIZADA
        ORDER BY I.CODIGO;
END;
$$;

create or replace function integracao.func_marcacao_lista_ajustes_marcacoes_realizados(f_token_integracao text,
                                                                                       f_cod_ultimo_ajuste_marcacao_sincronizado bigint)
    returns TABLE
            (
                codigo_edicao                        bigint,
                cod_justificativa_selecionada_ajuste bigint,
                justificativa_selecionada_ajuste     text,
                observacao_ajuste_marcacao           text,
                acao_ajuste_marcacao                 text,
                cpf_colaborador_ajuste               text,
                data_hora_ajuste_utc                 timestamp without time zone,
                cod_unidade                          bigint,
                codigo                               bigint,
                cod_marcacao_vinculo                 bigint,
                cod_tipo_marcacao                    bigint,
                cpf_colaborador                      text,
                tipo_marcacao                        text,
                data_hora_marcacao_utc               timestamp without time zone,
                fonte_data_hora                      text,
                justificativa_tempo_recomendado      text,
                justificativa_estouro                text,
                latitude_marcacao                    text,
                longitude_marcacao                   text,
                data_hora_sincronizacao_utc          timestamp without time zone,
                device_imei                          text,
                device_id                            text,
                marca_device                         text,
                modelo_device                        text,
                versao_app_momento_marcacao          integer,
                versao_app_momento_sincronizacao     integer,
                device_uptime_realizacao_millis      bigint,
                device_uptime_sincronizacao_millis   bigint,
                android_api_version                  integer,
                status_ativo                         boolean
            )
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_TOKEN BIGINT := (SELECT TI.COD_EMPRESA
                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
BEGIN
    -- Validamos se a Empresa é válida.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_TOKEN,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    RETURN QUERY
        SELECT MH.CODIGO                                    AS CODIGO_EDICAO,
               MA.COD_JUSTIFICATIVA_AJUSTE                  AS COD_JUSTIFICATIVA_SELECIONADA_AJUSTE,
               MJA.NOME                                     AS JUSTIFICATIVA_SELECIONADA_AJUSTE,
               MA.OBSERVACAO_AJUSTE                         AS OBSERVACAO_AJUSTE_MARCACAO,
               MA.ACAO_AJUSTE::TEXT                         AS ACAO_AJUSTE_MARCACAO,
               LPAD(C.CPF::TEXT, 11, '0')::TEXT             AS CPF_COLABORADOR_AJUSTE,
               MA.DATA_HORA_AJUSTE AT TIME ZONE 'UTC'       AS DATA_HORA_AJUSTE_UTC,
               I.COD_UNIDADE                                AS COD_UNIDADE,
               I.CODIGO                                     AS CODIGO,
               CASE
                   WHEN I.TIPO_MARCACAO = 'MARCACAO_INICIO'
                       THEN
                       (SELECT MVIF.COD_MARCACAO_FIM
                        FROM MARCACAO_VINCULO_INICIO_FIM MVIF
                        WHERE MVIF.COD_MARCACAO_INICIO = I.CODIGO)
                   ELSE
                       (SELECT MVIF.COD_MARCACAO_INICIO
                        FROM MARCACAO_VINCULO_INICIO_FIM MVIF
                        WHERE MVIF.COD_MARCACAO_FIM = I.CODIGO)
                   END                                      AS COD_MARCACAO_VINCULO,
               I.COD_TIPO_INTERVALO                         AS COD_TIPO_MARCACAO,
               LPAD(I.CPF_COLABORADOR::TEXT, 11, '0')::TEXT AS CPF_COLABORADOR,
               I.TIPO_MARCACAO::TEXT                        AS TIPO_MARCACAO,
               I.DATA_HORA AT TIME ZONE 'UTC'               AS DATA_HORA_MARCACAO_UTC,
               I.FONTE_DATA_HORA::TEXT                      AS FONTE_DATA_HORA,
               I.JUSTIFICATIVA_TEMPO_RECOMENDADO            AS JUSTIFICATIVA_TEMPO_RECOMENDADO,
               I.JUSTIFICATIVA_ESTOURO                      AS JUSTIFICATIVA_ESTOURO,
               I.LATITUDE_MARCACAO                          AS LATITUDE_MARCACAO,
               I.LONGITUDE_MARCACAO                         AS LONGITUDE_MARCACAO,
               I.DATA_HORA_SINCRONIZACAO AT TIME ZONE 'UTC' AS DATA_HORA_SINCRONIZACAO_UTC,
               I.DEVICE_IMEI                                AS DEVICE_IMEI,
               I.DEVICE_ID                                  AS DEVICE_ID,
               I.MARCA_DEVICE                               AS MARCA_DEVICE,
               I.MODELO_DEVICE                              AS MODELO_DEVICE,
               I.VERSAO_APP_MOMENTO_MARCACAO                AS VERSAO_APP_MOMENTO_MARCACAO,
               I.VERSAO_APP_MOMENTO_SINCRONIZACAO           AS VERSAO_APP_MOMENTO_SINCRONIZACAO,
               I.DEVICE_UPTIME_REALIZACAO_MILLIS            AS DEVICE_UPTIME_REALIZACAO_MILLIS,
               I.DEVICE_UPTIME_SINCRONIZACAO_MILLIS         AS DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
               I.ANDROID_API_VERSION                        AS ANDROID_API_VERSION,
               I.STATUS_ATIVO                               AS STATUS_ATIVO
        FROM MARCACAO_HISTORICO MH
                 JOIN MARCACAO_AJUSTE MA ON MH.COD_AJUSTE = MA.CODIGO
                 JOIN MARCACAO_JUSTIFICATIVA_AJUSTE MJA ON MA.COD_JUSTIFICATIVA_AJUSTE = MJA.CODIGO
                 JOIN INTERVALO I ON MH.COD_MARCACAO = I.CODIGO
                 JOIN COLABORADOR C ON MA.COD_COLABORADOR_AJUSTE = C.CODIGO
        WHERE MA.COD_UNIDADE_AJUSTE IN (SELECT U.CODIGO FROM UNIDADE U WHERE U.COD_EMPRESA = COD_EMPRESA_TOKEN)
          AND MH.CODIGO > F_COD_ULTIMO_AJUSTE_MARCACAO_SINCRONIZADO
        ORDER BY MH.CODIGO;
END;
$$;

create or replace function integracao.func_marcacao_relatorio_intervalo_portaria_1510_tipo_3(f_token_integracao text,
                                                                                             f_data_inicial date,
                                                                                             f_data_final date,
                                                                                             f_cod_unidade bigint,
                                                                                             f_cod_tipo_intervalo bigint,
                                                                                             f_cpf_colaborador bigint)
    returns TABLE
            (
                nsr              text,
                tipo_registro    text,
                data_marcacao    text,
                horario_marcacao text,
                pis_colaborador  text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT LPAD(VI.CODIGO_MARCACAO_POR_UNIDADE::TEXT, 9, '0')                        AS NSR,
               '3'::TEXT                                                                 AS TIPO_REGISTRO,
               TO_CHAR(VI.DATA_HORA AT TIME ZONE TZ_UNIDADE(VI.COD_UNIDADE), 'DDMMYYYY') AS DATA_MARCACAO,
               TO_CHAR(VI.DATA_HORA AT TIME ZONE TZ_UNIDADE(VI.COD_UNIDADE), 'HH24MI')   AS HORARIO_MARCACAO,
               LPAD(C.PIS::TEXT, 12, '0')                                                AS PIS_COLABORADOR
        FROM VIEW_INTERVALO VI
                 JOIN COLABORADOR C ON VI.CPF_COLABORADOR = C.CPF AND C.PIS IS NOT NULL
                 JOIN UNIDADE U ON U.CODIGO = VI.COD_UNIDADE
                 JOIN EMPRESA E ON U.COD_EMPRESA = E.CODIGO
        WHERE (VI.DATA_HORA AT TIME ZONE TZ_UNIDADE(VI.COD_UNIDADE))::DATE >= F_DATA_INICIAL
          AND (VI.DATA_HORA AT TIME ZONE TZ_UNIDADE(VI.COD_UNIDADE))::DATE <= F_DATA_FINAL
          AND E.CODIGO =
              (SELECT TI.COD_EMPRESA FROM INTEGRACAO.TOKEN_INTEGRACAO TI WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)
          AND F_IF(F_COD_UNIDADE IS NULL, TRUE, VI.COD_UNIDADE = F_COD_UNIDADE)
          AND F_IF(F_COD_TIPO_INTERVALO IS NULL, TRUE, VI.COD_TIPO_INTERVALO = F_COD_TIPO_INTERVALO)
          AND F_IF(F_CPF_COLABORADOR IS NULL, TRUE, VI.CPF_COLABORADOR = F_CPF_COLABORADOR);
END;
$$;

create or replace function integracao.func_integracao_resolve_itens_pendentes_empresa(f_cod_unidade_ordem_servico bigint,
                                                                                      f_cod_ordem_servico bigint,
                                                                                      f_cod_item_resolvido bigint,
                                                                                      f_cpf_colaborador_resolucao bigint,
                                                                                      f_km_momento_resolucao bigint,
                                                                                      f_duracao_resolucao_ms bigint,
                                                                                      f_feedback_resolucao text,
                                                                                      f_data_hora_resolvido_prolog timestamp with time zone,
                                                                                      f_data_hora_inicio_resolucao timestamp with time zone,
                                                                                      f_data_hora_fim_resolucao timestamp with time zone,
                                                                                      f_token_integracao text,
                                                                                      f_data_hora_sincronia_resolucao timestamp with time zone,
                                                                                      f_deve_sobrescrever_dados boolean DEFAULT true) returns bigint
    language plpgsql
as
$$
DECLARE
    F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE  TEXT := 'P';
    F_STATUS_ITEM_ORDEM_SERVICO_RESOLVIDO TEXT := 'R';
    F_STATUS_ORDEM_SERVICO_ABERTA         TEXT := 'A';
    F_STATUS_ORDEM_SERVICO_FECHADA        TEXT := 'F';
    F_QTD_ROWS_ITENS_OS                   BIGINT;
    F_QTD_ROWS_ITENS_RESOLVIDOS_OS        BIGINT;
BEGIN
    -- Antes de realizar o processo de fechamento de Item de Ordem de Serviço, validamos os dados e vínculos
    -- 1° - Validamos se existe a O.S na unidade.
    IF (SELECT NOT EXISTS(
            SELECT COS.CODIGO
            FROM CHECKLIST_ORDEM_SERVICO COS
            WHERE COS.CODIGO = F_COD_ORDEM_SERVICO
              AND COS.COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('A Ordem de Serviço "%s" não existe na unidade "%s" do ProLog',
                               F_COD_ORDEM_SERVICO,
                               F_COD_UNIDADE_ORDEM_SERVICO));
    END IF;

    -- 2° - Validamos se a O.S. está ABERTA.
    -- Apenas validamos se não devemos sobrescrever os dados, caso devemos sobrescrever então não tem necessidade
    -- de validar essa informação pois se a O.S. já está fechada, apenas continuará.
    IF (NOT F_DEVE_SOBRESCREVER_DADOS AND (SELECT COS.STATUS
                                           FROM CHECKLIST_ORDEM_SERVICO COS
                                           WHERE COS.COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
                                             AND COS.CODIGO = F_COD_ORDEM_SERVICO) = F_STATUS_ORDEM_SERVICO_FECHADA)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('A Ordem de Serviço "%s" já está fechada no ProLog', F_COD_ORDEM_SERVICO));
    END IF;

    -- 3° - Validamos se o Item a ser resolvido pertence a O.S..
    IF ((SELECT COSI.COD_OS
         FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
         WHERE COSI.CODIGO = F_COD_ITEM_RESOLVIDO) != F_COD_ORDEM_SERVICO)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O Item "%s" não pertence à O.S "%s" do ProLog',
                                                  F_COD_ITEM_RESOLVIDO,
                                                  F_COD_ORDEM_SERVICO));
    END IF;

    -- 4° - Validamos se o Item da O.S. está PENDENTE. Apenas validamos se não devemos sobrescrever as informações.
    IF (NOT F_DEVE_SOBRESCREVER_DADOS AND (SELECT COSI.STATUS_RESOLUCAO
                                           FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                           WHERE COSI.CODIGO = F_COD_ITEM_RESOLVIDO) !=
                                          F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('O Item "%s" da O.S "%s" já está resolvido no ProLog',
                               F_COD_ITEM_RESOLVIDO,
                               F_COD_ORDEM_SERVICO));
    END IF;

    -- 5° - Validamos se o CPF está presente na empresa.
    IF (SELECT NOT EXISTS(SELECT C.CODIGO
                          FROM COLABORADOR C
                          WHERE C.CPF = F_CPF_COLABORADOR_RESOLUCAO
                            AND C.COD_EMPRESA =
                                (SELECT U.COD_EMPRESA FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_ORDEM_SERVICO)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O CPF %s não encontra-se cadastrado no ProLog',
                                                  PUBLIC.FORMAT_CPF(F_CPF_COLABORADOR_RESOLUCAO)));
    END IF;

    -- Por segurança, verificamos se a integração está fechando os itens de O.S. que pertencem a empresa correta.
    IF (F_COD_UNIDADE_ORDEM_SERVICO NOT IN (SELECT CODIGO
                                            FROM UNIDADE
                                            WHERE COD_EMPRESA = (SELECT TI.COD_EMPRESA
                                                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        'Você está tentando fechar um item de uma OS que não pertence à sua empresa');
    END IF;

    -- Não verificamos a DATA_HORA_CONSERTO no WHERE pois não nos importa se está fechada ou não. Se chegou nesse ponto
    -- iremos atualizar as informações afim de fechar o item ou afim de sobrescrever as informações. Temos segurança de
    -- fazer isso pois o 4º IF verifica se o item já está fechado porém não devemos sobrescrever.
    UPDATE CHECKLIST_ORDEM_SERVICO_ITENS
    SET CPF_MECANICO               = F_CPF_COLABORADOR_RESOLUCAO,
        TEMPO_REALIZACAO           = F_DURACAO_RESOLUCAO_MS,
        KM                         = F_KM_MOMENTO_RESOLUCAO,
        STATUS_RESOLUCAO           = F_STATUS_ITEM_ORDEM_SERVICO_RESOLVIDO,
        DATA_HORA_CONSERTO         = F_DATA_HORA_RESOLVIDO_PROLOG,
        DATA_HORA_INICIO_RESOLUCAO = F_DATA_HORA_INICIO_RESOLUCAO,
        DATA_HORA_FIM_RESOLUCAO    = F_DATA_HORA_FIM_RESOLUCAO,
        FEEDBACK_CONSERTO          = F_FEEDBACK_RESOLUCAO
    WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
      AND CODIGO = F_COD_ITEM_RESOLVIDO;

    -- O atributo 'ROW_COUNT' conterá a quantidade de linhas que foram atualizadas pelo update acima. a funciton
    -- irá retornar esse atributo para que possamos validar se todos os updates aconteceram como deveriam.
    GET DIAGNOSTICS F_QTD_ROWS_ITENS_OS = ROW_COUNT;

    -- O primeiro if verifica se o item está pendente, se após o update nenhuma linha for alterada, significa
    -- que o update não executou corretamente. lançamos aqui uma exceção para rastrear esse erro
    IF F_QTD_ROWS_ITENS_OS <= 0
    THEN
        RAISE EXCEPTION 'Não foi possível resolver o item %', F_COD_ITEM_RESOLVIDO;
    END IF;

    -- Ao resolver um item de ordem de serviço é necessário verificar se a Ordem de Serviço foi finalizada.
    -- uma O.S. fechada consiste em uma O.S. que possui todos os seus itens resolvidos.
    UPDATE CHECKLIST_ORDEM_SERVICO
    SET STATUS               = F_STATUS_ORDEM_SERVICO_FECHADA,
        DATA_HORA_FECHAMENTO = F_DATA_HORA_RESOLVIDO_PROLOG
    WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
      AND CODIGO = F_COD_ORDEM_SERVICO
      -- Utilizamos essa verificação para forçar que o update aconteça apenas se a O.S. tiver
      -- todos seus itens resolvidos.
      AND (SELECT COUNT(*)
           FROM CHECKLIST_ORDEM_SERVICO_ITENS
           WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
             AND COD_OS = F_COD_ORDEM_SERVICO
             AND STATUS_RESOLUCAO = F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE) = 0;

    -- Para garantir a consistência do processo de resolução de itens e fechamento de ordens de serviço
    -- verificamos se a O.S. que possuiu seu item fechado está com o 'status' correto.
    IF (((SELECT COUNT(*)
          FROM CHECKLIST_ORDEM_SERVICO_ITENS
          WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
            AND COD_OS = F_COD_ORDEM_SERVICO
            AND STATUS_RESOLUCAO = F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE) = 0)
        AND (SELECT STATUS
             FROM CHECKLIST_ORDEM_SERVICO
             WHERE CODIGO = F_COD_ORDEM_SERVICO
               AND COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO) = F_STATUS_ORDEM_SERVICO_ABERTA)
        -- Caso a O.S. não tem nenhum item pendente mas o seu status é 'aberta', então temos dados inconsistentes.
    THEN
        RAISE EXCEPTION 'Não foi possível fechar a Ordem de Serviço %', F_COD_ORDEM_SERVICO;
    END IF;

    -- Após realizar o processo de fechamento, inserimos o item resolvido na tabela de mapeamento de itens resolvidos
    -- através da integração.
    IF (F_DEVE_SOBRESCREVER_DADOS)
    THEN
        -- Se devemos sobrescrever as informações, eventualmente, já teremos fechado o item e este já está mapeado na
        -- estrutura de controle de itens fechados, nesse caso, atualizamos a data_hora de sincronia e segue o baile.
        INSERT INTO INTEGRACAO.CHECKLIST_ORDEM_SERVICO_ITEM_RESOLVIDO
        VALUES ((SELECT TI.COD_EMPRESA
                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO),
                F_COD_UNIDADE_ORDEM_SERVICO,
                F_COD_ORDEM_SERVICO,
                F_COD_ITEM_RESOLVIDO,
                F_DATA_HORA_SINCRONIA_RESOLUCAO)
        ON CONFLICT ON CONSTRAINT UNIQUE_ITEM_ORDEM_SERVICO_RESOLVIDO
            DO UPDATE SET DATA_HORA_SINCRONIA_RESOLUCAO = F_DATA_HORA_SINCRONIA_RESOLUCAO;
    ELSE
        -- Caso não é para sobrescrever, temos que estar atentos às constraints, evitando que tente-se inserir um
        -- item que já foi fechado previamente.
        INSERT INTO INTEGRACAO.CHECKLIST_ORDEM_SERVICO_ITEM_RESOLVIDO
        VALUES ((SELECT TI.COD_EMPRESA
                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO),
                F_COD_UNIDADE_ORDEM_SERVICO,
                F_COD_ORDEM_SERVICO,
                F_COD_ITEM_RESOLVIDO,
                F_DATA_HORA_SINCRONIA_RESOLUCAO);
    END IF;

    GET DIAGNOSTICS F_QTD_ROWS_ITENS_RESOLVIDOS_OS = ROW_COUNT;

    -- Verificamos se o insert na tabela de mapeamento de itens resolvidos na integração ocorreu com êxito.
    IF F_QTD_ROWS_ITENS_RESOLVIDOS_OS <= 0
    THEN
        RAISE EXCEPTION
            'Não foi possível inserir o item resolvido na tabela de mapeamento, item %', F_COD_ITEM_RESOLVIDO;
    END IF;

    RETURN F_QTD_ROWS_ITENS_OS;
END;
$$;

create or replace function public.func_prontuario_insert_or_update(f_cpf_colaborador bigint, f_status text,
                                                                   f_motivo text, f_pontuacao integer,
                                                                   f_vencimento_cnh date, f_documentos_rs text,
                                                                   f_documentos_ec text, f_documentos_it text,
                                                                   f_pontuacao_ponderada real, f_acidentes_fai integer,
                                                                   f_acidentes_lti integer, f_acidentes_mdi integer,
                                                                   f_acidentes_mti integer, f_capotamentos integer,
                                                                   f_colisoes integer, f_tombamentos integer,
                                                                   f_fadigas_celular integer,
                                                                   f_fadigas_consumo_alimento integer,
                                                                   f_fadigas_fumando integer, f_fadigas_oclusao integer,
                                                                   f_fadigas_sem_cinto integer, f_multas_leve integer,
                                                                   f_multas_media integer, f_multas_grave integer,
                                                                   f_multas_gravissima integer, f_sac_impericia integer,
                                                                   f_sac_imprudencia integer, f_sav_impericia integer,
                                                                   f_sav_imprudencia integer, f_advertencias integer,
                                                                   f_suspensoes integer, f_excesso_velocidade_1 integer,
                                                                   f_excesso_velocidade_2 integer,
                                                                   f_excesso_velocidade_3 integer, f_forca_g integer,
                                                                   f_frenagem_brusca integer, f_power_on integer,
                                                                   f_data_atualizacao timestamp with time zone) returns void
    language plpgsql
as
$$
BEGIN
    INSERT INTO PRONTUARIO_CONDUTOR_CONSOLIDADO (CPF_COLABORADOR,
                                                 STATUS,
                                                 MOTIVO,
                                                 PONTUACAO,
                                                 VENCIMENTO_CNH,
                                                 DOCUMENTOS_RS,
                                                 DOCUMENTOS_EC,
                                                 DOCUMENTOS_IT,
                                                 PONTUACAO_PONDERADA,
                                                 ACIDENTES_FAI,
                                                 ACIDENTES_LTI,
                                                 ACIDENTES_MDI,
                                                 ACIDENTES_MTI,
                                                 CAPOTAMENTOS,
                                                 COLISOES,
                                                 TOMBAMENTOS,
                                                 FADIGAS_CELULAR,
                                                 FADIGAS_CONSUMO_ALIMENTO,
                                                 FADIGAS_FUMANDO,
                                                 FADIGAS_OCLUSAO,
                                                 FADIGAS_SEM_CINTO,
                                                 MULTAS_LEVE,
                                                 MULTAS_MEDIA,
                                                 MULTAS_GRAVE,
                                                 MULTAS_GRAVISSIMA,
                                                 SAC_IMPERICIA,
                                                 SAC_IMPRUDENCIA,
                                                 SAV_IMPERICIA,
                                                 SAV_IMPRUDENCIA,
                                                 ADVERTENCIAS,
                                                 SUSPENSOES,
                                                 EXCESSO_VELOCIDADE_1,
                                                 EXCESSO_VELOCIDADE_2,
                                                 EXCESSO_VELOCIDADE_3,
                                                 FORCA_G,
                                                 FRENAGEM_BRUSCA,
                                                 POWER_ON,
                                                 DATA_ATUALIZACAO)
    VALUES (F_CPF_COLABORADOR,
            F_STATUS,
            F_MOTIVO,
            F_PONTUACAO,
            F_VENCIMENTO_CNH,
            F_DOCUMENTOS_RS,
            F_DOCUMENTOS_EC,
            F_DOCUMENTOS_IT,
            F_PONTUACAO_PONDERADA,
            F_ACIDENTES_FAI,
            F_ACIDENTES_LTI,
            F_ACIDENTES_MDI,
            F_ACIDENTES_MTI,
            F_CAPOTAMENTOS,
            F_COLISOES,
            F_TOMBAMENTOS,
            F_FADIGAS_CELULAR,
            F_FADIGAS_CONSUMO_ALIMENTO,
            F_FADIGAS_FUMANDO,
            F_FADIGAS_OCLUSAO,
            F_FADIGAS_SEM_CINTO,
            F_MULTAS_LEVE,
            F_MULTAS_MEDIA,
            F_MULTAS_GRAVE,
            F_MULTAS_GRAVISSIMA,
            F_SAC_IMPERICIA,
            F_SAC_IMPRUDENCIA,
            F_SAV_IMPERICIA,
            F_SAV_IMPRUDENCIA,
            F_ADVERTENCIAS,
            F_SUSPENSOES,
            F_EXCESSO_VELOCIDADE_1,
            F_EXCESSO_VELOCIDADE_2,
            F_EXCESSO_VELOCIDADE_3,
            F_FORCA_G,
            F_FRENAGEM_BRUSCA,
            F_POWER_ON,
            F_DATA_ATUALIZACAO)
    ON CONFLICT ON CONSTRAINT PK_PRONTUARIO_CONDUTOR_CONSOLIDADO
        DO UPDATE SET CPF_COLABORADOR          = F_CPF_COLABORADOR,
                      STATUS                   = F_STATUS,
                      MOTIVO                   = F_MOTIVO,
                      PONTUACAO                = F_PONTUACAO,
                      VENCIMENTO_CNH           = F_VENCIMENTO_CNH,
                      DOCUMENTOS_RS            = F_DOCUMENTOS_RS,
                      DOCUMENTOS_EC            = F_DOCUMENTOS_EC,
                      DOCUMENTOS_IT            = F_DOCUMENTOS_IT,
                      PONTUACAO_PONDERADA      = F_PONTUACAO_PONDERADA,
                      ACIDENTES_FAI            = F_ACIDENTES_FAI,
                      ACIDENTES_LTI            = F_ACIDENTES_LTI,
                      ACIDENTES_MDI            = F_ACIDENTES_MDI,
                      ACIDENTES_MTI            = F_ACIDENTES_MTI,
                      CAPOTAMENTOS             = F_CAPOTAMENTOS,
                      COLISOES                 = F_COLISOES,
                      TOMBAMENTOS              = F_TOMBAMENTOS,
                      FADIGAS_CELULAR          = F_FADIGAS_CELULAR,
                      FADIGAS_CONSUMO_ALIMENTO = F_FADIGAS_CONSUMO_ALIMENTO,
                      FADIGAS_FUMANDO          = F_FADIGAS_FUMANDO,
                      FADIGAS_OCLUSAO          = F_FADIGAS_OCLUSAO,
                      FADIGAS_SEM_CINTO        = F_FADIGAS_SEM_CINTO,
                      MULTAS_LEVE              = F_MULTAS_LEVE,
                      MULTAS_MEDIA             = F_MULTAS_MEDIA,
                      MULTAS_GRAVE             = F_MULTAS_GRAVE,
                      MULTAS_GRAVISSIMA        = F_MULTAS_GRAVISSIMA,
                      SAC_IMPERICIA            = F_SAC_IMPERICIA,
                      SAC_IMPRUDENCIA          = F_SAC_IMPRUDENCIA,
                      SAV_IMPERICIA            = F_SAV_IMPERICIA,
                      SAV_IMPRUDENCIA          = F_SAV_IMPRUDENCIA,
                      ADVERTENCIAS             = F_ADVERTENCIAS,
                      SUSPENSOES               = F_SUSPENSOES,
                      EXCESSO_VELOCIDADE_1     = F_EXCESSO_VELOCIDADE_1,
                      EXCESSO_VELOCIDADE_2     = F_EXCESSO_VELOCIDADE_2,
                      EXCESSO_VELOCIDADE_3     = F_EXCESSO_VELOCIDADE_3,
                      FORCA_G                  = F_FORCA_G,
                      FRENAGEM_BRUSCA          = F_FRENAGEM_BRUSCA,
                      POWER_ON                 = F_POWER_ON,
                      DATA_ATUALIZACAO         = F_DATA_ATUALIZACAO;
END;
$$;

create or replace function suporte.func_colaborador_transfere_entre_unidades(f_cod_empresa_origem bigint,
                                                                             f_cod_unidade_origem bigint,
                                                                             f_cod_unidade_destino bigint,
                                                                             f_cpf_colaborador bigint,
                                                                             f_cod_setor_destino bigint,
                                                                             f_cod_equipe_destino bigint,
                                                                             f_cod_funcao_destino integer,
                                                                             OUT colaborador_transferido text) returns text
    security definer
    language plpgsql
as
$$
BEGIN
    -- VERIFICA SE EMPRESA ORIGEM POSSUI UNIDADE ORIGEM.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(F_COD_EMPRESA_ORIGEM, F_COD_UNIDADE_ORIGEM);

    -- VERIFICA SE EMPRESA POSSUI UNIDADE DESTINO.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(F_COD_EMPRESA_ORIGEM, F_COD_UNIDADE_DESTINO);

    -- VERIFICA SE COLABORADOR EXISTE NA UNIDADE ORIGEM.
    PERFORM FUNC_GARANTE_INTEGRIDADE_UNIDADE_COLABORADOR(F_COD_UNIDADE_ORIGEM, F_CPF_COLABORADOR);

    -- VERIFICA SE O SETOR EXISTE NA UNIDADE DESTINO.
    PERFORM FUNC_GARANTE_SETOR_EXISTE(F_COD_UNIDADE_DESTINO, F_COD_SETOR_DESTINO);

    -- VERIFICA SE A EQUIPE EXISTE NA UNIDADE DESTINO.
    PERFORM FUNC_GARANTE_EQUIPE_EXISTE(F_COD_UNIDADE_DESTINO, F_COD_EQUIPE_DESTINO);

    -- VERIFICA SE A FUNÇÃO EXISTE NA EMPRESA DESTINO.
    PERFORM FUNC_GARANTE_CARGO_EXISTE(F_COD_EMPRESA_ORIGEM, F_COD_FUNCAO_DESTINO);

    -- TRANSFERE COLABORADOR.
    UPDATE COLABORADOR_DATA
    SET COD_UNIDADE  = F_COD_UNIDADE_DESTINO,
        COD_SETOR    = F_COD_SETOR_DESTINO,
        COD_EQUIPE   = F_COD_EQUIPE_DESTINO,
        COD_FUNCAO   = F_COD_FUNCAO_DESTINO,
        -- Também ativa o colaborador ao transferir.
        STATUS_ATIVO = TRUE
    WHERE CPF = F_CPF_COLABORADOR
      AND COD_UNIDADE = F_COD_UNIDADE_ORIGEM;

    -- MENSAGEM DE SUCESSO.
    SELECT ('COLABORADOR COM CPF: '
                || (SELECT C.CPF
                    FROM COLABORADOR C
                    WHERE C.CPF = F_CPF_COLABORADOR
                      AND COD_UNIDADE = F_COD_UNIDADE_DESTINO)
                || ', FOI TRANSFERIDO PARA A UNIDADE: '
        || (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_DESTINO))
    INTO COLABORADOR_TRANSFERIDO;
END
$$;

create or replace function public.func_pneu_get_modelos_pneu_listagem(f_cod_empresa bigint, f_cod_marca bigint,
                                                                      f_incluir_marcas_nao_utilizadas boolean)
    returns TABLE
            (
                cod_marca_pneu   bigint,
                nome_marca_pneu  text,
                cod_modelo_pneu  bigint,
                nome_modelo_pneu text,
                qtd_sulcos       smallint,
                altura_sulcos    numeric
            )
    language sql
as
$$
SELECT MAP.CODIGO                             AS COD_MARCA_PNEU,
       MAP.NOME :: TEXT                       AS NOME_MARCA_PNEU,
       MOP.CODIGO                             AS COD_MODELO_PNEU,
       MOP.NOME :: TEXT                       AS NOME_MODELO_PNEU,
       MOP.QT_SULCOS                          AS QTD_SULCOS,
       TRUNC(MOP.ALTURA_SULCOS :: NUMERIC, 2) AS ALTURA_SULCOS
FROM MARCA_PNEU MAP
         LEFT JOIN MODELO_PNEU MOP
                   ON MAP.CODIGO = MOP.COD_MARCA
                       AND MOP.COD_EMPRESA = F_COD_EMPRESA
WHERE F_IF(F_COD_MARCA IS NULL, TRUE, MAP.CODIGO = F_COD_MARCA)
  AND F_IF(F_INCLUIR_MARCAS_NAO_UTILIZADAS IS TRUE, TRUE, MOP.CODIGO IS NOT NULL)
ORDER BY NOME_MARCA_PNEU, NOME_MODELO_PNEU
$$;

create or replace function public.func_pneu_get_marcas_pneu_listagem(f_cod_empresa bigint, f_incluir_marcas_nao_utilizadas boolean)
    returns TABLE
            (
                cod_marca_pneu  bigint,
                nome_marca_pneu text
            )
    language sql
as
$$
SELECT MP.CODIGO       AS COD_MARCA_PNEU,
       MP.NOME :: TEXT AS NOME_MARCA_PNEU
FROM MARCA_PNEU MP
WHERE CASE
          WHEN F_INCLUIR_MARCAS_NAO_UTILIZADAS IS TRUE
              THEN TRUE
          ELSE (SELECT EXISTS(SELECT MOP.COD_MARCA
                              FROM MODELO_PNEU MOP
                              WHERE MOP.COD_EMPRESA = F_COD_EMPRESA
                                AND MOP.COD_MARCA = MP.CODIGO))
          END
ORDER BY MP.NOME;
$$;

create or replace function public.func_pneu_get_modelos_banda_listagem(f_cod_empresa bigint, f_cod_marca bigint,
                                                                       f_incluir_marcas_nao_utilizadas boolean)
    returns TABLE
            (
                cod_marca_banda   bigint,
                nome_marca_banda  text,
                cod_modelo_banda  bigint,
                nome_modelo_banda text,
                qtd_sulcos        smallint,
                altura_sulcos     numeric
            )
    language sql
as
$$
SELECT MAB.CODIGO                             AS COD_MARCA_BANDA,
       MAB.NOME :: TEXT                       AS NOME_MARCA_BANDA,
       MOB.CODIGO                             AS COD_MODELO_BANDA,
       MOB.NOME :: TEXT                       AS NOME_MODELO_BANDA,
       MOB.QT_SULCOS                          AS QTD_SULCOS,
       TRUNC(MOB.ALTURA_SULCOS :: NUMERIC, 2) AS ALTURA_SULCOS
FROM MARCA_BANDA MAB
         LEFT JOIN MODELO_BANDA MOB
                   ON MAB.CODIGO = MOB.COD_MARCA
WHERE MAB.COD_EMPRESA = F_COD_EMPRESA
  AND F_IF(F_COD_MARCA IS NULL, TRUE, MAB.CODIGO = F_COD_MARCA)
  AND F_IF(F_INCLUIR_MARCAS_NAO_UTILIZADAS IS TRUE, TRUE, MOB.CODIGO IS NOT NULL)
ORDER BY NOME_MARCA_BANDA, NOME_MODELO_BANDA
$$;

create or replace function public.func_pneu_get_marcas_banda_listagem(f_cod_empresa bigint)
    returns TABLE
            (
                cod_marca_banda  bigint,
                nome_marca_banda text
            )
    language sql
as
$$
SELECT MB.CODIGO       AS COD_MARCA_PNEU,
       MB.NOME :: TEXT AS NOME_MARCA_PNEU
FROM MARCA_BANDA MB
WHERE MB.COD_EMPRESA = F_COD_EMPRESA
ORDER BY MB.NOME;
$$;

create or replace function public.remove_all_spaces(f_texto text) returns text
    language plpgsql
as
$$
BEGIN
    RETURN REGEXP_REPLACE(F_TEXTO, '\s', '', 'g');
END;
$$;

create or replace function audit_implantacao.func_audit_implantacao() returns trigger
    security definer
    language plpgsql
as
$$
DECLARE
    F_TABLE_NAME_AUDIT TEXT    := TG_RELNAME || '_audit';
    F_TG_OP            TEXT    := SUBSTRING(TG_OP, 1, 1);
    F_JSON             TEXT    := CASE
                                      WHEN F_TG_OP = 'D'
                                          THEN ROW_TO_JSON(OLD)
                                      ELSE ROW_TO_JSON(NEW)
        END;
    IS_NEW_ROW         BOOLEAN := CASE WHEN F_TG_OP = 'D' THEN FALSE ELSE TRUE END;
BEGIN
    EXECUTE FORMAT(
            'CREATE TABLE IF NOT EXISTS audit_implantacao.%I (
        CODIGO                  SERIAL,
        DATA_HORA_UTC           TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
        OPERACAO                VARCHAR(1),
        PG_USERNAME             TEXT,
        PG_APPLICATION_NAME     TEXT,
        ROW_LOG                 JSONB,
        IS_NEW_ROW              BOOLEAN
      );', F_TABLE_NAME_AUDIT);

    EXECUTE FORMAT(
            'INSERT INTO audit_implantacao.%I (operacao, row_log, is_new_row, pg_username, pg_application_name)
       VALUES (%L, %L, %L, %L, %L);', F_TABLE_NAME_AUDIT, F_TG_OP, F_JSON, IS_NEW_ROW, SESSION_USER,
            (SELECT CURRENT_SETTING('application_name')));
    RETURN NULL;
END;
$$;

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_expressonepomuceno_contagem_2019_12_16_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_expressonepomuceno_feiradesantana_2019_12_17_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_expressonepomuceno_ilheus_2019_12_18_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_expressonepomuceno_suzano_2019_12_18_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao."v_expressonepomuceno_jundiaí_2019_12_18_natan"
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao."v_expressonepomuceno_asjundiaí_2019_12_18_natan"
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_expressonepomuceno_cdlasmg_2019_12_18_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao."v_grupoimediato_cdd-campinas_2019_12_18_natan"
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao."v_grupoimediato_emp-ambev-guarulhos_2019_12_18_natan"
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao."v_grupoimediato_emp-ambev-agudos_2019_12_18_natan"
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_54_cod_unidade_369_2020_1_17_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_54_cod_unidade_369_2020_1_17_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_59_cod_unidade_370_2020_1_23_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_59_cod_unidade_370_2020_1_23_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_15_cod_unidade_216_2020_1_27_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_6_cod_unidade_209_2020_1_29_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_6_cod_unidade_209_2020_1_29_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_24_cod_unidade_372_2020_1_29_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_24_cod_unidade_372_2020_1_29_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_15_cod_unidade_208_2020_2_3_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_16_cod_unidade_218_2020_2_3_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_16_cod_unidade_218_2020_2_3_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_6_cod_unidade_83_2020_2_4_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_6_cod_unidade_83_2020_2_4_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_6_cod_unidade_85_2020_2_4_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_6_cod_unidade_85_2020_2_4_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_6_cod_unidade_84_2020_2_5_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_6_cod_unidade_84_2020_2_5_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_6_cod_unidade_74_2020_2_5_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_6_cod_unidade_74_2020_2_5_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_veiculo
    after update or delete
    on implantacao.v_cod_emp_60_cod_unidade_375_2020_2_19_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create trigger tg_func_audit_import_pneu
    after update or delete
    on implantacao.p_cod_emp_61_cod_unidade_380_2020_3_3_natan
    for each row
execute procedure audit_implantacao.func_audit_implantacao();

create or replace function implantacao.func_veiculo_import_cria_tabela_import(f_cod_empresa bigint,
                                                                              f_cod_unidade bigint, f_usuario text,
                                                                              f_data date,
                                                                              OUT nome_tabela_criada text) returns text
    language plpgsql
as
$$
DECLARE
    DIA                TEXT := (SELECT EXTRACT(DAY FROM F_DATA));
    MES                TEXT := (SELECT EXTRACT(MONTH FROM F_DATA));
    ANO                TEXT := (SELECT EXTRACT(YEAR FROM F_DATA)) ;
    NOME_TABELA_IMPORT TEXT := lower(remove_all_spaces(
                                        'V_COD_EMP_' || F_COD_EMPRESA || '_COD_UNIDADE_' || F_COD_UNIDADE || '_' ||
                                        ANO || '_' || MES ||
                                        '_' || DIA || '_' || F_USUARIO));
BEGIN
    EXECUTE FORMAT(
            'CREATE TABLE IF NOT EXISTS IMPLANTACAO.%I (
            CODIGO                  BIGSERIAL,
            COD_DADOS_AUTOR_IMPORT  BIGINT,
            COD_UNIDADE_EDITAVEL    BIGINT,
            PLACA_EDITAVEL          VARCHAR(255),
            KM_EDITAVEL             BIGINT,
            MARCA_EDITAVEL          VARCHAR(255),
            MODELO_EDITAVEL         VARCHAR(255),
            TIPO_EDITAVEL           VARCHAR(255),
            QTD_EIXOS_EDITAVEL      VARCHAR(255),
            PLACA_FORMATADA_IMPORT  VARCHAR(255),
            MARCA_FORMATADA_IMPORT  VARCHAR(255),
            MODELO_FORMATADO_IMPORT VARCHAR(255),
            TIPO_FORMATADO_IMPORT   VARCHAR(255),
            STATUS_IMPORT_REALIZADO BOOLEAN,
            ERROS_ENCONTRADOS       VARCHAR(255),
            USUARIO_UPDATE          VARCHAR(255),
            PRIMARY KEY (CODIGO),
            FOREIGN KEY (COD_DADOS_AUTOR_IMPORT) REFERENCES IMPLANTACAO.DADOS_AUTOR_IMPORT (CODIGO),
            FOREIGN KEY (COD_UNIDADE_EDITAVEL) REFERENCES UNIDADE (CODIGO)
        );', NOME_TABELA_IMPORT);

    --TRIGGER PARA VERIFICAR PLANILHA E REALIZAR O IMPORT DE VEÍCULOS
    EXECUTE format('DROP TRIGGER IF EXISTS TG_FUNC_IMPORT_VEICULO ON IMPLANTACAO.%I;
                   CREATE TRIGGER TG_FUNC_IMPORT_VEICULO
                    BEFORE INSERT OR UPDATE
                        ON IMPLANTACAO.%I
                    FOR EACH ROW
                   EXECUTE PROCEDURE IMPLANTACAO.TG_FUNC_VEICULO_CONFERE_PLANILHA_IMPORTA_VEICULO();',
                   NOME_TABELA_IMPORT,
                   NOME_TABELA_IMPORT);

    --CRIA AUDIT PARA A TABELA
    EXECUTE format('DROP TRIGGER IF EXISTS TG_FUNC_AUDIT_IMPORT_VEICULO ON IMPLANTACAO.%I;
                    CREATE TRIGGER TG_FUNC_AUDIT_IMPORT_VEICULO
                    AFTER UPDATE OR DELETE
                    ON IMPLANTACAO.%I
                    FOR EACH ROW
                    EXECUTE PROCEDURE AUDIT_IMPLANTACAO.FUNC_AUDIT_IMPLANTACAO();',
                   NOME_TABELA_IMPORT,
                   NOME_TABELA_IMPORT);

    -- GARANTE UPDATE PARA O NATAN
    -- TODO REMOVER HARDCODED
    EXECUTE FORMAT(
            'grant select, update on implantacao.%I to prolog_user_natan;', NOME_TABELA_IMPORT
        );

    --RETORNA NOME DA TABELA
    SELECT NOME_TABELA_IMPORT INTO NOME_TABELA_CRIADA;
END ;
$$;

create or replace function implantacao.func_veiculo_insere_planilha_importacao(f_cod_dados_autor_import bigint,
                                                                               f_nome_tabela_import text,
                                                                               f_cod_unidade bigint,
                                                                               f_json_veiculos jsonb) returns void
    language plpgsql
as
$$
BEGIN
    EXECUTE FORMAT('INSERT INTO implantacao.%I (COD_DADOS_AUTOR_IMPORT,
                                                COD_UNIDADE_EDITAVEL,
                                                PLACA_EDITAVEL,
                                                PLACA_FORMATADA_IMPORT,
                                                KM_EDITAVEL,
                                                MARCA_EDITAVEL,
                                                MARCA_FORMATADA_IMPORT,
                                                MODELO_EDITAVEL,
                                                MODELO_FORMATADO_IMPORT,
                                                TIPO_EDITAVEL,
                                                TIPO_FORMATADO_IMPORT,
                                                QTD_EIXOS_EDITAVEL)
                   SELECT %s AS COD_DADOS_AUTOR_IMPORT,
                          %s AS COD_UNIDADE,
                          (SRC ->> ''placa'') :: TEXT                                         AS PLACA,
                          REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS((SRC ->> ''placa'')) :: TEXT  AS PLACA_FORMATADA_IMPORT,
                          (SRC ->> ''km'') :: BIGINT                                          AS KM,
                          (SRC ->> ''marca'') :: TEXT                                         AS MARCA,
                          REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(SRC ->> (''marca'')) :: TEXT  AS MARCA_FORMATADA_IMPORT,
                          (SRC ->> ''modelo'') :: TEXT                                        AS MODELO,
                          REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(SRC ->> (''modelo'')) :: TEXT AS MODELO_FORMATADO_IMPORT,
                          (SRC ->> ''tipo'') :: TEXT                                          AS TIPO,
                          REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(SRC ->> (''tipo'')) :: TEXT   AS TIPO_FORMATADO_IMPORT,
                          (SRC ->> ''qtdEixos'') :: TEXT                                      AS QTD_EIXOS
                   FROM JSONB_ARRAY_ELEMENTS(%L) AS SRC',
                   F_NOME_TABELA_IMPORT,
                   F_COD_DADOS_AUTOR_IMPORT,
                   F_COD_UNIDADE,
                   F_JSON_VEICULOS);
END
$$;

create or replace function implantacao.func_verifica_login_senha(f_username text, f_password text)
    returns TABLE
            (
                username text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT PU.USERNAME
        FROM IMPLANTACAO.PROLOG_USER PU
        WHERE PU.USERNAME = F_USERNAME
          AND PU.PASSWORD = F_PASSWORD;
END;
$$;

create or replace function implantacao.tg_func_veiculo_confere_planilha_importa_veiculo() returns trigger
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_EMPRESA CONSTANT                 BIGINT   := (SELECT U.COD_EMPRESA
                                                        FROM UNIDADE U
                                                        WHERE U.CODIGO = NEW.COD_UNIDADE_EDITAVEL);
    F_VALOR_SIMILARIDADE CONSTANT          REAL     := 0.4;
    F_VALOR_SIMILARIDADE_DIAGRAMA CONSTANT REAL     := 0.5;
    F_SEM_SIMILARIDADE CONSTANT            REAL     := 0.0;
    F_QTD_ERROS                            SMALLINT := 0;
    F_MSGS_ERROS                           TEXT;
    F_QUEBRA_LINHA                         TEXT     := CHR(10);
    F_COD_MARCA_BANCO                      BIGINT;
    F_SIMILARIDADE_MARCA                   REAL;
    F_MARCA_MODELO                         TEXT;
    F_COD_MODELO_BANCO                     BIGINT;
    F_SIMILARIDADE_MODELO                  REAL;
    F_COD_DIAGRAMA_BANCO                   BIGINT;
    F_NOME_DIAGRAMA_BANCO                  TEXT;
    F_SIMILARIDADE_DIAGRAMA                REAL;
    F_DIAGRAMA_TIPO                        TEXT;
    F_EIXOS_DIAGRAMA                       TEXT;
    F_COD_TIPO_BANCO                       BIGINT;
    F_SIMILARIDADE_TIPO                    REAL;
BEGIN
    IF (TG_OP = 'UPDATE' AND OLD.STATUS_IMPORT_REALIZADO IS TRUE)
    THEN
        NEW.CODIGO := OLD.CODIGO;
        NEW.COD_DADOS_AUTOR_IMPORT := OLD.COD_DADOS_AUTOR_IMPORT;
        NEW.ERROS_ENCONTRADOS := OLD.ERROS_ENCONTRADOS;
        NEW.COD_UNIDADE_EDITAVEL := OLD.COD_UNIDADE_EDITAVEL;
        NEW.PLACA_EDITAVEL := OLD.PLACA_EDITAVEL;
        NEW.PLACA_FORMATADA_IMPORT := OLD.PLACA_FORMATADA_IMPORT;
        NEW.KM_EDITAVEL := OLD.KM_EDITAVEL;
        NEW.MARCA_EDITAVEL := OLD.MARCA_EDITAVEL;
        NEW.MARCA_FORMATADA_IMPORT := OLD.MARCA_FORMATADA_IMPORT;
        NEW.MODELO_EDITAVEL := OLD.MODELO_EDITAVEL;
        NEW.MODELO_FORMATADO_IMPORT := OLD.MODELO_FORMATADO_IMPORT;
        NEW.TIPO_EDITAVEL := OLD.TIPO_EDITAVEL;
        NEW.TIPO_FORMATADO_IMPORT := OLD.TIPO_FORMATADO_IMPORT;
        NEW.QTD_EIXOS_EDITAVEL := OLD.QTD_EIXOS_EDITAVEL;
        NEW.STATUS_IMPORT_REALIZADO := OLD.STATUS_IMPORT_REALIZADO;
        NEW.USUARIO_UPDATE := OLD.USUARIO_UPDATE;
    ELSE
        NEW.PLACA_FORMATADA_IMPORT := REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.PLACA_EDITAVEL);
        NEW.MARCA_FORMATADA_IMPORT := REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.MARCA_EDITAVEL);
        NEW.MODELO_FORMATADO_IMPORT := REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.MODELO_EDITAVEL);
        NEW.TIPO_FORMATADO_IMPORT := REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.TIPO_EDITAVEL);
        NEW.USUARIO_UPDATE := SESSION_USER;

        -- VERIFICAÇÕES PLACA.
        -- Placa sem 7 dígitos: Erro.
        -- Pĺaca cadastrada em outra empresa: Erro.
        -- Pĺaca cadastrada em outra unidade da mesma empresa: Erro.
        -- Pĺaca cadastrada na mesma unidade: Atualiza informações.
        IF (NEW.PLACA_FORMATADA_IMPORT IS NOT NULL) THEN
            IF LENGTH(NEW.PLACA_FORMATADA_IMPORT) <> 7
            THEN
                F_QTD_ERROS = F_QTD_ERROS + 1;
                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A PLACA NÃO POSSUI 7 CARACTERES', F_QUEBRA_LINHA);
            ELSE
                IF EXISTS(SELECT V.PLACA
                          FROM VEICULO V
                          WHERE V.PLACA = NEW.PLACA_FORMATADA_IMPORT
                            AND V.COD_EMPRESA != F_COD_EMPRESA)
                THEN
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS =
                            concat(F_MSGS_ERROS, F_QTD_ERROS, '- A PLACA JÁ ESTÁ CADASTRADA E PERTENCE A OUTRA EMPRESA',
                                   F_QUEBRA_LINHA);
                ELSE
                    IF EXISTS(SELECT V.PLACA
                              FROM VEICULO V
                              WHERE V.PLACA = NEW.PLACA_FORMATADA_IMPORT
                                AND V.COD_EMPRESA = F_COD_EMPRESA
                                AND COD_UNIDADE != NEW.COD_UNIDADE_EDITAVEL)
                    THEN
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                              '- A PLACA JÁ ESTÁ CADASTRADA E PERTENCE A OUTRA UNIDADE',
                                              F_QUEBRA_LINHA);
                    END IF;
                END IF;
            END IF;
        ELSE
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A PLACA NÃO PODE SER NULA', F_QUEBRA_LINHA);
        END IF;

        -- VERIFICAÇÕES MARCA: Procura marca similar no banco.
        SELECT DISTINCT ON (NEW.MARCA_FORMATADA_IMPORT) MAV.CODIGO                                                        AS COD_MARCA_BANCO,
                                                        MAX(FUNC_GERA_SIMILARIDADE(NEW.MARCA_FORMATADA_IMPORT, MAV.NOME)) AS SIMILARIEDADE_MARCA
        INTO F_COD_MARCA_BANCO, F_SIMILARIDADE_MARCA
        FROM MARCA_VEICULO MAV
        GROUP BY NEW.MARCA_FORMATADA_IMPORT, NEW.MARCA_EDITAVEL, MAV.NOME, MAV.CODIGO
        ORDER BY NEW.MARCA_FORMATADA_IMPORT, SIMILARIEDADE_MARCA DESC;

        F_MARCA_MODELO := CONCAT(F_COD_MARCA_BANCO, NEW.MODELO_FORMATADO_IMPORT);
        -- Se a similaridade da marca for maior ou igual ao exigido: procura modelo.
        -- Se não for: Mostra erro de marca não encontrada.
        IF (F_SIMILARIDADE_MARCA >= F_VALOR_SIMILARIDADE)
        THEN
            -- VERIFICAÇÕES DE MODELO: Procura modelo similar no banco.
            SELECT DISTINCT ON (F_MARCA_MODELO) MOV.CODIGO AS COD_MODELO_VEICULO,
                                                CASE
                                                    WHEN F_COD_MARCA_BANCO = MOV.COD_MARCA
                                                        THEN
                                                        MAX(FUNC_GERA_SIMILARIDADE(F_MARCA_MODELO,
                                                                                   CONCAT(MOV.COD_MARCA, MOV.NOME)))
                                                    ELSE F_SEM_SIMILARIDADE
                                                    END    AS SIMILARIEDADE_MODELO
            INTO F_COD_MODELO_BANCO, F_SIMILARIDADE_MODELO
            FROM MODELO_VEICULO MOV
            WHERE MOV.COD_EMPRESA = F_COD_EMPRESA
            GROUP BY F_MARCA_MODELO, MOV.NOME, MOV.CODIGO
            ORDER BY F_MARCA_MODELO, SIMILARIEDADE_MODELO DESC;
            -- Se a similaridade do modelo for menor do que o exigido: cadastra novo modelo.

            IF (F_SIMILARIDADE_MODELO < F_VALOR_SIMILARIDADE OR F_SIMILARIDADE_MODELO IS NULL)
            THEN
                INSERT INTO MODELO_VEICULO (NOME, COD_MARCA, COD_EMPRESA)
                VALUES (NEW.MODELO_EDITAVEL, F_COD_MARCA_BANCO, F_COD_EMPRESA) RETURNING CODIGO INTO F_COD_MODELO_BANCO;
            END IF;
        ELSE
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A MARCA NÃO FOI ENCONTRADA', F_QUEBRA_LINHA);
        END IF;

        -- VERIFICAÇÕES DE DIAGRAMA.
        -- O diagrama é obtido através do preenchimento do campo "tipo" da planilha de import.
        F_EIXOS_DIAGRAMA := CONCAT(NEW.QTD_EIXOS_EDITAVEL, NEW.TIPO_FORMATADO_IMPORT);
        -- Procura diagrama no banco:
        WITH INFO_DIAGRAMAS AS (
            SELECT COUNT(VDE.POSICAO) AS QTD_EIXOS, VDE.COD_DIAGRAMA AS CODIGO, VD.NOME AS NOME
            FROM VEICULO_DIAGRAMA_EIXOS VDE
                     JOIN
                 VEICULO_DIAGRAMA VD ON VDE.COD_DIAGRAMA = VD.CODIGO
            GROUP BY VDE.COD_DIAGRAMA, VD.NOME),

             DIAGRAMAS AS (
                 SELECT VDUP.COD_VEICULO_DIAGRAMA AS COD_DIAGRAMA,
                        VDUP.NOME                 AS NOME_DIAGRAMA,
                        VDUP.QTD_EIXOS            AS QTD_EIXOS
                 FROM IMPLANTACAO.VEICULO_DIAGRAMA_USUARIO_PROLOG VDUP
                 UNION ALL
                 SELECT ID.CODIGO AS COD_DIAGRAMA, ID.NOME AS NOME_DIAGRAMA, ID.QTD_EIXOS
                 FROM INFO_DIAGRAMAS ID)

             -- F_EIXOS_DIAGRAMA: Foi necessário concatenar a quantidade de eixos ao nome do diagrama para evitar
             -- similaridades ambiguas.
        SELECT DISTINCT ON (F_EIXOS_DIAGRAMA) D.NOME_DIAGRAMA AS NOME_DIAGRAMA,
                                              D.COD_DIAGRAMA  AS DIAGRAMA_BANCO,
                                              CASE
                                                  WHEN D.QTD_EIXOS ::TEXT = NEW.QTD_EIXOS_EDITAVEL
                                                      THEN
                                                      MAX(FUNC_GERA_SIMILARIDADE(F_EIXOS_DIAGRAMA,
                                                                                 CONCAT(D.QTD_EIXOS, D.NOME_DIAGRAMA)))
                                                  ELSE F_SEM_SIMILARIDADE
                                                  END         AS SIMILARIEDADE_DIAGRAMA
        INTO F_NOME_DIAGRAMA_BANCO, F_COD_DIAGRAMA_BANCO,
            F_SIMILARIDADE_DIAGRAMA
        FROM DIAGRAMAS D
        GROUP BY F_EIXOS_DIAGRAMA, D.NOME_DIAGRAMA, D.COD_DIAGRAMA, D.QTD_EIXOS
        ORDER BY F_EIXOS_DIAGRAMA, SIMILARIEDADE_DIAGRAMA DESC;

        F_DIAGRAMA_TIPO := CONCAT(F_NOME_DIAGRAMA_BANCO, NEW.TIPO_FORMATADO_IMPORT);
        -- Se a similaridade do diagrama for maior ou igual ao exigido: procura tipo.
        -- Se não for: Mostra erro de diagrama não encontrado.
        CASE WHEN (F_SIMILARIDADE_DIAGRAMA >= F_VALOR_SIMILARIDADE_DIAGRAMA)
            THEN
                SELECT DISTINCT ON (F_DIAGRAMA_TIPO) VT.CODIGO AS COD_TIPO_VEICULO,
                                                     CASE
                                                         WHEN F_COD_DIAGRAMA_BANCO = VT.COD_DIAGRAMA
                                                             THEN MAX(FUNC_GERA_SIMILARIDADE(NEW.TIPO_FORMATADO_IMPORT, VT.NOME))
                                                         ELSE F_SEM_SIMILARIDADE
                                                         END   AS SIMILARIEDADE_TIPO_DIAGRAMA
                INTO F_COD_TIPO_BANCO, F_SIMILARIDADE_TIPO
                FROM VEICULO_TIPO VT
                WHERE VT.COD_EMPRESA = F_COD_EMPRESA
                GROUP BY F_DIAGRAMA_TIPO,
                         VT.CODIGO
                ORDER BY F_DIAGRAMA_TIPO, SIMILARIEDADE_TIPO_DIAGRAMA DESC;
                -- Se a similaridade do tipo for menor do que o exigido: cadastra novo modelo.
                IF (F_SIMILARIDADE_TIPO < F_VALOR_SIMILARIDADE OR F_SIMILARIDADE_TIPO IS NULL)
                THEN
                    INSERT INTO VEICULO_TIPO (NOME, STATUS_ATIVO, COD_DIAGRAMA, COD_EMPRESA)
                    VALUES (NEW.TIPO_EDITAVEL, TRUE, F_COD_DIAGRAMA_BANCO, F_COD_EMPRESA) RETURNING CODIGO INTO F_COD_TIPO_BANCO;
                END IF;
            ELSE
                F_QTD_ERROS = F_QTD_ERROS + 1;
                F_MSGS_ERROS =
                        concat(F_MSGS_ERROS, F_QTD_ERROS, '- O DIAGRAMA (TIPO) NÃO FOI ENCONTRADO', F_QUEBRA_LINHA);
            END CASE;
        -- VERIFICA QTD DE ERROS
        IF (F_QTD_ERROS > 0)
        THEN
            NEW.STATUS_IMPORT_REALIZADO = FALSE;
            NEW.ERROS_ENCONTRADOS = F_MSGS_ERROS;
        ELSE
            IF (F_QTD_ERROS = 0 AND EXISTS(SELECT V.PLACA
                                           FROM VEICULO V
                                           WHERE V.PLACA = NEW.PLACA_FORMATADA_IMPORT
                                             AND V.COD_EMPRESA = F_COD_EMPRESA
                                             AND COD_UNIDADE = NEW.COD_UNIDADE_EDITAVEL))
            THEN
                -- ATUALIZA INFORMAÇÕES DO VEÍCULO.
                UPDATE VEICULO_DATA
                SET COD_MODELO = F_COD_MODELO_BANCO,
                    COD_TIPO   = F_COD_TIPO_BANCO,
                    KM         = NEW.KM_EDITAVEL
                WHERE PLACA = NEW.PLACA_FORMATADA_IMPORT
                  AND COD_EMPRESA = F_COD_EMPRESA
                  AND COD_UNIDADE = NEW.COD_UNIDADE_EDITAVEL;
                NEW.STATUS_IMPORT_REALIZADO = NULL;
                NEW.ERROS_ENCONTRADOS = 'A PLACA JÁ ESTAVA CADASTRADA - INFORMAÇÕES FORAM ATUALIZADAS.';
            ELSE
                IF (F_QTD_ERROS = 0 AND NOT EXISTS(SELECT V.PLACA
                                                   FROM VEICULO V
                                                   WHERE V.PLACA = NEW.PLACA_FORMATADA_IMPORT))
                THEN
                    -- CADASTRA VEÍCULO.
                    INSERT INTO VEICULO_DATA (PLACA,
                                              COD_UNIDADE,
                                              KM,
                                              STATUS_ATIVO,
                                              COD_TIPO,
                                              COD_MODELO,
                                              COD_EIXOS,
                                              DATA_HORA_CADASTRO,
                                              COD_UNIDADE_CADASTRO,
                                              COD_EMPRESA)
                    VALUES (NEW.PLACA_FORMATADA_IMPORT,
                            NEW.COD_UNIDADE_EDITAVEL,
                            NEW.KM_EDITAVEL,
                            TRUE,
                            F_COD_TIPO_BANCO,
                            F_COD_MODELO_BANCO,
                            1,
                            NOW(),
                            NEW.COD_UNIDADE_EDITAVEL,
                            F_COD_EMPRESA);
                    NEW.STATUS_IMPORT_REALIZADO = TRUE;
                    NEW.ERROS_ENCONTRADOS = '-';
                END IF;
            END IF;
        END IF;
    END IF;
    RETURN NEW;
END;
$$;

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_expressonepomuceno_contagem_2019_12_16_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_expressonepomuceno_feiradesantana_2019_12_17_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_expressonepomuceno_ilheus_2019_12_18_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_expressonepomuceno_suzano_2019_12_18_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao."v_expressonepomuceno_jundiaí_2019_12_18_natan"
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao."v_expressonepomuceno_asjundiaí_2019_12_18_natan"
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_expressonepomuceno_cdlasmg_2019_12_18_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao."v_grupoimediato_cdd-campinas_2019_12_18_natan"
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao."v_grupoimediato_emp-ambev-guarulhos_2019_12_18_natan"
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao."v_grupoimediato_emp-ambev-agudos_2019_12_18_natan"
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_54_cod_unidade_369_2020_1_17_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_59_cod_unidade_370_2020_1_23_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_15_cod_unidade_216_2020_1_27_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_6_cod_unidade_209_2020_1_29_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_24_cod_unidade_372_2020_1_29_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_15_cod_unidade_208_2020_2_3_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_16_cod_unidade_218_2020_2_3_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_6_cod_unidade_83_2020_2_4_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_6_cod_unidade_85_2020_2_4_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_6_cod_unidade_84_2020_2_5_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_6_cod_unidade_74_2020_2_5_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create trigger tg_func_import_veiculo
    before insert or update
    on implantacao.v_cod_emp_60_cod_unidade_375_2020_2_19_natan
    for each row
execute procedure implantacao.tg_func_veiculo_confere_planilha_importa_veiculo();

create or replace function integracao.func_geral_busca_sistema_key(f_user_token text, f_recurso_integrado text)
    returns TABLE
            (
                chave_sistema text,
                existe_token  boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT (SELECT EIS.CHAVE_SISTEMA
                FROM INTEGRACAO.EMPRESA_INTEGRACAO_SISTEMA EIS
                         JOIN TOKEN_AUTENTICACAO TA ON TA.TOKEN = F_USER_TOKEN
                         LEFT JOIN COLABORADOR C ON C.CPF = TA.CPF_COLABORADOR
                WHERE C.COD_EMPRESA = EIS.COD_EMPRESA
                  AND EIS.RECURSO_INTEGRADO = F_RECURSO_INTEGRADO)                              AS CHAVE_SISTEMA,
               (SELECT EXISTS(SELECT TOKEN FROM TOKEN_AUTENTICACAO WHERE TOKEN = F_USER_TOKEN)) AS TOKEN_EXISTE;
END;
$$;

create or replace function integracao.func_geral_busca_url_sistema_parceiro(f_cod_empresa bigint, f_sistema_key text, f_metodo_integrado text) returns text
    language plpgsql
as
$$
BEGIN
    RETURN (SELECT EIM.URL_COMPLETA AS URL_COMPLETA
            FROM INTEGRACAO.EMPRESA_INTEGRACAO_METODOS EIM
                     JOIN INTEGRACAO.EMPRESA_INTEGRACAO_SISTEMA EIS ON EIM.COD_INTEGRACAO_SISTEMA = EIS.CODIGO
            WHERE EIS.COD_EMPRESA = F_COD_EMPRESA
              AND EIS.CHAVE_SISTEMA = F_SISTEMA_KEY
              AND EIM.METODO_INTEGRADO = F_METODO_INTEGRADO);
END;
$$;

create or replace function public.func_afericao_get_cronograma_afericoes_placas(f_cod_unidades bigint[], f_data_hora_atual timestamp with time zone)
    returns TABLE
            (
                placa                     text,
                nome_modelo               text,
                intervalo_pressao         integer,
                intervalo_sulco           integer,
                periodo_afericao_sulco    integer,
                periodo_afericao_pressao  integer,
                pneus_aplicados           integer,
                status_ativo_tipo_veiculo boolean,
                pode_aferir_sulco         boolean,
                pode_aferir_pressao       boolean,
                pode_aferir_sulco_pressao boolean,
                pode_aferir_estepe        boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT V.PLACA :: TEXT                                                     AS PLACA,
               MV.NOME :: TEXT                                                     AS NOME_MODELO,
               COALESCE(INTERVALO_PRESSAO.INTERVALO, -1) :: INTEGER                AS INTERVALO_PRESSAO,
               COALESCE(INTERVALO_SULCO.INTERVALO, -1) :: INTEGER                  AS INTERVALO_SULCO,
               PRU.PERIODO_AFERICAO_SULCO                                          AS PERIODO_AFERICAO_SULCO,
               PRU.PERIODO_AFERICAO_PRESSAO                                        AS PERIODO_AFERICAO_PRESSAO,
               COALESCE(NUMERO_PNEUS.TOTAL, 0) :: INTEGER                          AS PNEUS_APLICADOS,
               VT.STATUS_ATIVO                                                     AS STATUS_ATIVO_TIPO_VEICULO,
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_SULCO)         AS PODE_AFERIR_SULCO,
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_PRESSAO)       AS PODE_AFERIR_PRESSAO,
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_SULCO_PRESSAO) AS PODE_AFERIR_SULCO_PRESSAO,
               F_IF(CONFIG.CODIGO IS NULL, TRUE, CONFIG.PODE_AFERIR_ESTEPE)        AS PODE_AFERIR_ESTEPE
        FROM VEICULO V
                 JOIN PNEU_RESTRICAO_UNIDADE PRU ON PRU.COD_UNIDADE = V.COD_UNIDADE
                 JOIN VEICULO_TIPO VT ON VT.CODIGO = V.COD_TIPO
                 JOIN MODELO_VEICULO MV ON MV.CODIGO = V.COD_MODELO
                 LEFT JOIN AFERICAO_CONFIGURACAO_TIPO_AFERICAO_VEICULO CONFIG
                           ON CONFIG.COD_TIPO_VEICULO = VT.CODIGO
                               AND CONFIG.COD_UNIDADE = V.COD_UNIDADE
                 LEFT JOIN (SELECT A.PLACA_VEICULO                                                            AS PLACA_INTERVALO,
                                   EXTRACT(DAYS FROM (F_DATA_HORA_ATUAL) -
                                                     MAX(A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE))) AS INTERVALO
                            FROM AFERICAO A
                            WHERE A.TIPO_MEDICAO_COLETADA = 'PRESSAO'
                               OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO'
                            GROUP BY A.PLACA_VEICULO) AS INTERVALO_PRESSAO
                           ON INTERVALO_PRESSAO.PLACA_INTERVALO = V.PLACA
                 LEFT JOIN (SELECT A.PLACA_VEICULO                                                            AS PLACA_INTERVALO,
                                   EXTRACT(DAYS FROM (F_DATA_HORA_ATUAL) -
                                                     MAX(A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE))) AS INTERVALO
                            FROM AFERICAO A
                            WHERE A.TIPO_MEDICAO_COLETADA = 'SULCO'
                               OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO'
                            GROUP BY A.PLACA_VEICULO) AS INTERVALO_SULCO
                           ON INTERVALO_SULCO.PLACA_INTERVALO = V.PLACA
                 LEFT JOIN (SELECT VP.PLACA           AS PLACA_PNEUS,
                                   COUNT(VP.COD_PNEU) AS TOTAL
                            FROM VEICULO_PNEU VP
                            WHERE VP.COD_UNIDADE = ANY (F_COD_UNIDADES)
                            GROUP BY VP.PLACA) AS NUMERO_PNEUS ON PLACA_PNEUS = V.PLACA
        WHERE V.STATUS_ATIVO = TRUE
          AND V.COD_UNIDADE = ANY (F_COD_UNIDADES)
        ORDER BY MV.NOME, INTERVALO_PRESSAO DESC, INTERVALO_SULCO DESC, PNEUS_APLICADOS DESC;
END;
$$;

create or replace function public.func_pneu_relatorio_farol_afericao(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "UNIDADE"                             text,
                "QTD DE FROTAS"                       text,
                "QTD DE PNEUS"                        text,
                "QTD DE PNEUS AFERIDOS - PRESSÃO"     text,
                "PERCENTUAL PNEUS AFERIDOS - PRESSÃO" text,
                "QTD DE PNEUS AFERIDOS - SULCO"       text,
                "PERCENTUAL PNEUS AFERIDOS - SULCO"   text
            )
    language sql
as
$$
WITH FAROL_AFERICAO AS (
    SELECT U.NOME                                                AS NOME_UNIDADE,
           COUNT(DISTINCT V.PLACA)                               AS QTD_VEICULOS,
           COUNT(DISTINCT VP.*)                                  AS QTD_PNEUS,
           COUNT(DISTINCT VP.COD_PNEU) FILTER (
               WHERE A.TIPO_MEDICAO_COLETADA = 'PRESSAO'
                   OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO') AS TOTAL_PRESSAO,
           COUNT(DISTINCT VP.COD_PNEU) FILTER (
               WHERE A.TIPO_MEDICAO_COLETADA = 'SULCO'
                   OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO') AS TOTAL_SULCO
    FROM VEICULO_DATA V
             JOIN UNIDADE U ON V.COD_UNIDADE = U.CODIGO
             JOIN VEICULO_PNEU VP ON V.PLACA = VP.PLACA AND V.COD_UNIDADE = VP.COD_UNIDADE
             LEFT JOIN AFERICAO_VALORES AV ON AV.COD_PNEU = VP.COD_PNEU
             LEFT JOIN AFERICAO A ON V.PLACA = A.PLACA_VEICULO AND A.CODIGO = AV.COD_AFERICAO
    WHERE V.COD_UNIDADE = ANY (F_COD_UNIDADES)
      AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE))::DATE >= (F_DATA_INICIAL)
      AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE))::DATE <= (F_DATA_FINAL)
    GROUP BY V.COD_UNIDADE, U.NOME
)
SELECT NOME_UNIDADE :: TEXT,
       QTD_VEICULOS :: TEXT,
       QTD_PNEUS :: TEXT,
       TOTAL_PRESSAO :: TEXT,
       COALESCE_PERCENTAGE(TOTAL_PRESSAO, QTD_PNEUS) :: TEXT AS PERCENTUAL_PRESSAO,
       TOTAL_SULCO :: TEXT,
       COALESCE_PERCENTAGE(TOTAL_SULCO, QTD_PNEUS) :: TEXT   AS PERCENTUAL_SULCO
FROM FAROL_AFERICAO
ORDER BY (TOTAL_PRESSAO :: REAL / NULLIF(QTD_PNEUS, 0) :: REAL) ASC NULLS LAST;
$$;

create or replace function public.func_afericao_upsert_configuracao_cronograma_servico(f_codigo_empresa bigint,
                                                                                       f_codigo_unidade bigint,
                                                                                       f_tolerancia_calibragem numeric,
                                                                                       f_tolerancia_inspecao numeric,
                                                                                       f_sulco_minimo_recapagem numeric,
                                                                                       f_sulco_minimo_descarte numeric,
                                                                                       f_periodo_afericao_pressao integer,
                                                                                       f_periodo_afericao_sulco integer,
                                                                                       f_cod_colaborador bigint,
                                                                                       f_data_hora_atual_utc timestamp with time zone) returns void
    language plpgsql
as
$$
DECLARE
    CODIGO_CONFIG                          BIGINT;
    OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO BIGINT;
    OLD_DATA_HORA_ULTIMA_ATUALIZACAO       TIMESTAMP WITH TIME ZONE;
    OLD_TOLERANCIA_CALIBRAGEM              NUMERIC;
    OLD_TOLERANCIA_INSPECAO                NUMERIC;
    OLD_SULCO_MINIMO_RECAPAGEM             NUMERIC;
    OLD_SULCO_MINIMO_DESCARTE              NUMERIC;
    OLD_PERIODO_AFERICAO_PRESSAO           INTEGER;
    OLD_PERIODO_AFERICAO_SULCO             INTEGER;
BEGIN
    -- BUSCA E ARMAZENA OS DADOS ANTIGOS
    SELECT CODIGO,
           COD_COLABORADOR_ULTIMA_ATUALIZACAO,
           DATA_HORA_ULTIMA_ATUALIZACAO,
           TOLERANCIA_CALIBRAGEM,
           TOLERANCIA_INSPECAO,
           SULCO_MINIMO_RECAPAGEM,
           SULCO_MINIMO_DESCARTE,
           PERIODO_AFERICAO_PRESSAO,
           PERIODO_AFERICAO_SULCO
    FROM PNEU_RESTRICAO_UNIDADE
    WHERE COD_EMPRESA = F_CODIGO_EMPRESA
      AND COD_UNIDADE = F_CODIGO_UNIDADE
    INTO CODIGO_CONFIG, OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO, OLD_DATA_HORA_ULTIMA_ATUALIZACAO,
        OLD_TOLERANCIA_CALIBRAGEM,OLD_TOLERANCIA_INSPECAO, OLD_SULCO_MINIMO_RECAPAGEM, OLD_SULCO_MINIMO_DESCARTE,
        OLD_PERIODO_AFERICAO_PRESSAO, OLD_PERIODO_AFERICAO_SULCO;

    -- CASO A CONFIG EXISTA, VERIFICA SE HOUVE MUDANÇAS, ATUALIZA E SALVA O HISTÓRICO.
    IF CODIGO_CONFIG > 0 THEN
        -- VERIFICA SE HOUVE MUDANÇAS
        IF OLD_TOLERANCIA_CALIBRAGEM != F_TOLERANCIA_CALIBRAGEM OR
           OLD_TOLERANCIA_INSPECAO != F_TOLERANCIA_INSPECAO OR
           OLD_SULCO_MINIMO_RECAPAGEM != F_SULCO_MINIMO_RECAPAGEM OR
           OLD_SULCO_MINIMO_DESCARTE != F_SULCO_MINIMO_DESCARTE OR
           OLD_PERIODO_AFERICAO_PRESSAO != F_PERIODO_AFERICAO_PRESSAO OR
           OLD_PERIODO_AFERICAO_SULCO != F_PERIODO_AFERICAO_SULCO THEN
            -- ATUALIZA.
            UPDATE PNEU_RESTRICAO_UNIDADE
            SET TOLERANCIA_CALIBRAGEM              = F_TOLERANCIA_CALIBRAGEM,
                COD_COLABORADOR_ULTIMA_ATUALIZACAO = F_COD_COLABORADOR,
                DATA_HORA_ULTIMA_ATUALIZACAO       = F_DATA_HORA_ATUAL_UTC,
                TOLERANCIA_INSPECAO                = F_TOLERANCIA_INSPECAO,
                SULCO_MINIMO_RECAPAGEM             = F_SULCO_MINIMO_RECAPAGEM,
                SULCO_MINIMO_DESCARTE              = F_SULCO_MINIMO_DESCARTE,
                PERIODO_AFERICAO_PRESSAO           = F_PERIODO_AFERICAO_PRESSAO,
                PERIODO_AFERICAO_SULCO             = F_PERIODO_AFERICAO_SULCO
            WHERE COD_EMPRESA = F_CODIGO_EMPRESA
              AND COD_UNIDADE = F_CODIGO_UNIDADE;

            -- SALVA O HISTÓRICO.
            INSERT INTO PNEU_RESTRICAO_UNIDADE_HISTORICO (COD_RESTRICAO_UNIDADE_PNEU,
                                                          COD_EMPRESA,
                                                          COD_UNIDADE,
                                                          COD_COLABORADOR,
                                                          DATA_HORA_ALTERACAO,
                                                          TOLERANCIA_CALIBRAGEM,
                                                          TOLERANCIA_INSPECAO,
                                                          SULCO_MINIMO_RECAPAGEM,
                                                          SULCO_MINIMO_DESCARTE,
                                                          PERIODO_AFERICAO_PRESSAO,
                                                          PERIODO_AFERICAO_SULCO)
            VALUES (CODIGO_CONFIG,
                    F_CODIGO_EMPRESA,
                    F_CODIGO_UNIDADE,
                    OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO,
                    OLD_DATA_HORA_ULTIMA_ATUALIZACAO,
                    OLD_TOLERANCIA_CALIBRAGEM,
                    OLD_TOLERANCIA_INSPECAO,
                    OLD_SULCO_MINIMO_RECAPAGEM,
                    OLD_SULCO_MINIMO_DESCARTE,
                    OLD_PERIODO_AFERICAO_PRESSAO,
                    OLD_PERIODO_AFERICAO_SULCO);
        END IF;
        -- SE NÃO EXISTIR.
    ELSE
        -- INSERE A CONFIG.
        INSERT INTO PNEU_RESTRICAO_UNIDADE (COD_EMPRESA,
                                            COD_UNIDADE,
                                            COD_COLABORADOR_ULTIMA_ATUALIZACAO,
                                            DATA_HORA_ULTIMA_ATUALIZACAO,
                                            TOLERANCIA_CALIBRAGEM,
                                            TOLERANCIA_INSPECAO,
                                            SULCO_MINIMO_RECAPAGEM,
                                            SULCO_MINIMO_DESCARTE,
                                            PERIODO_AFERICAO_PRESSAO,
                                            PERIODO_AFERICAO_SULCO)
        VALUES (F_CODIGO_EMPRESA,
                F_CODIGO_UNIDADE,
                F_COD_COLABORADOR,
                F_DATA_HORA_ATUAL_UTC,
                F_TOLERANCIA_CALIBRAGEM,
                F_TOLERANCIA_INSPECAO,
                F_SULCO_MINIMO_RECAPAGEM,
                F_SULCO_MINIMO_DESCARTE,
                F_PERIODO_AFERICAO_PRESSAO,
                F_PERIODO_AFERICAO_SULCO);
    END IF;
END;
$$;

create or replace function public.func_afericao_get_configuracao_cronograma_servico_by_colaborado(f_cod_colaborador bigint)
    returns TABLE
            (
                codigo                             bigint,
                codigo_empresa                     bigint,
                codigo_regional                    bigint,
                nome_regional                      text,
                codigo_unidade                     bigint,
                nome_unidade                       text,
                cod_colaborador_ultima_atualizacao bigint,
                data_hora_ultima_atualizacao       timestamp without time zone,
                tolerancia_calibragem              real,
                tolerancia_inspecao                real,
                sulco_minimo_recapagem             real,
                sulco_minimo_descarte              real,
                periodo_afericao_pressao           integer,
                periodo_afericao_sulco             integer
            )
    language plpgsql
as
$$
DECLARE
BEGIN
    RETURN QUERY
        WITH UNIDADES_ACESSO AS (
            SELECT DISTINCT ON (F.CODIGO_UNIDADE) F.CODIGO_UNIDADE,
                                                  F.NOME_UNIDADE,
                                                  F.CODIGO_EMPRESA,
                                                  F.CODIGO_REGIONAL,
                                                  F.NOME_REGIONAL
            FROM FUNC_COLABORADOR_GET_UNIDADES_ACESSO(F_COD_COLABORADOR, FALSE) F
        )
        SELECT PRU.CODIGO                                                                AS CODIGO,
               UA.CODIGO_EMPRESA                                                         AS CODIGO_EMPRESA,
               UA.CODIGO_REGIONAL                                                        AS CODIGO_REGIONAL,
               UA.NOME_REGIONAL                                                          AS NOME_REGIONAL,
               UA.CODIGO_UNIDADE                                                         AS CODIGO_UNIDADE,
               UA.NOME_UNIDADE                                                           AS NOME_UNIDADE,
               PRU.COD_COLABORADOR_ULTIMA_ATUALIZACAO                                    AS COD_COLABORADOR_ULTIMA_ATUALIZACAO,
               PRU.DATA_HORA_ULTIMA_ATUALIZACAO AT TIME ZONE
               TZ_UNIDADE(PRU.COD_UNIDADE)                                               AS DATA_HORA_ULTIMA_ATUALIZACAO,
               PRU.TOLERANCIA_CALIBRAGEM                                                 AS TOLERANCIA_CALIBRAGEM,
               PRU.TOLERANCIA_INSPECAO                                                   AS TOLERANCIA_INSPECAO,
               PRU.SULCO_MINIMO_RECAPAGEM                                                AS SULCO_MINIMO_RECAPAGEM,
               PRU.SULCO_MINIMO_DESCARTE                                                 AS SULCO_MINIMO_DESCARTE,
               PRU.PERIODO_AFERICAO_PRESSAO                                              AS PERIODO_AFERICAO_PRESSAO,
               PRU.PERIODO_AFERICAO_SULCO                                                AS PERIODO_AFERICAO_SULCO
        FROM UNIDADES_ACESSO UA
                 LEFT JOIN PNEU_RESTRICAO_UNIDADE PRU ON UA.CODIGO_UNIDADE = PRU.COD_UNIDADE
        ORDER BY UA.NOME_REGIONAL ASC, UA.NOME_UNIDADE ASC;
END;
$$;

create or replace function public.func_afericao_get_configuracao_cronograma_servico_historico(f_cod_restricao_unidade_pneu bigint)
    returns TABLE
            (
                nome_unidade             text,
                nome_colaborador         text,
                data_hora_alteracao      timestamp without time zone,
                tolerancia_calibragem    real,
                tolerancia_inspecao      real,
                sulco_minimo_recapagem   real,
                sulco_minimo_descarte    real,
                periodo_afericao_pressao integer,
                periodo_afericao_sulco   integer,
                atual                    boolean
            )
    language plpgsql
as
$$
DECLARE
BEGIN
    RETURN QUERY
        SELECT U.NOME :: TEXT                                                            AS NOME_UNIDADE,
               F_IF(CD.NOME IS NULL, 'Cadastrado pelo Prolog', CD.NOME) :: TEXT          AS NOME_COLABORADOR,
               PRU.DATA_HORA_ULTIMA_ATUALIZACAO AT TIME ZONE TZ_UNIDADE(PRU.COD_UNIDADE) AS DATA_HORA_ALTERACAO,
               PRU.TOLERANCIA_CALIBRAGEM                                                 AS TOLERANCIA_CALIBRAGEM,
               PRU.TOLERANCIA_INSPECAO                                                   AS TOLERANCIA_INSPECAO,
               PRU.SULCO_MINIMO_RECAPAGEM                                                AS SULCO_MINIMO_RECAPAGEM,
               PRU.SULCO_MINIMO_DESCARTE                                                 AS SULCO_MINIMO_DESCARTE,
               PRU.PERIODO_AFERICAO_PRESSAO                                              AS PERIODO_AFERICAO_PRESSAO,
               PRU.PERIODO_AFERICAO_SULCO                                                AS PERIODO_AFERICAO_SULCO,
               TRUE                                                                      AS ATUAL
        FROM PNEU_RESTRICAO_UNIDADE PRU
                 JOIN UNIDADE U ON PRU.COD_UNIDADE = U.CODIGO
                 LEFT JOIN COLABORADOR CD ON PRU.COD_COLABORADOR_ULTIMA_ATUALIZACAO = CD.CODIGO
        WHERE PRU.CODIGO = F_COD_RESTRICAO_UNIDADE_PNEU
        UNION ALL
        SELECT U.NOME :: TEXT                                                     AS NOME_UNIDADE,
               F_IF(CD.NOME IS NULL, 'Cadastrado pelo Prolog', CD.NOME) :: TEXT   AS NOME_COLABORADOR,
               PRUH.DATA_HORA_ALTERACAO AT TIME ZONE TZ_UNIDADE(PRUH.COD_UNIDADE) AS DATA_HORA_ALTERACAO,
               PRUH.TOLERANCIA_CALIBRAGEM                                         AS TOLERANCIA_CALIBRAGEM,
               PRUH.TOLERANCIA_INSPECAO                                           AS TOLERANCIA_INSPECAO,
               PRUH.SULCO_MINIMO_RECAPAGEM                                        AS SULCO_MINIMO_RECAPAGEM,
               PRUH.SULCO_MINIMO_DESCARTE                                         AS SULCO_MINIMO_DESCARTE,
               PRUH.PERIODO_AFERICAO_PRESSAO                                      AS PERIODO_AFERICAO_PRESSAO,
               PRUH.PERIODO_AFERICAO_SULCO                                        AS PERIODO_AFERICAO_SULCO,
               FALSE                                                              AS ATUAL
        FROM PNEU_RESTRICAO_UNIDADE_HISTORICO PRUH
                 JOIN UNIDADE U ON PRUH.COD_UNIDADE = U.CODIGO
                 LEFT JOIN COLABORADOR CD ON PRUH.COD_COLABORADOR = CD.CODIGO
        WHERE PRUH.COD_RESTRICAO_UNIDADE_PNEU = F_COD_RESTRICAO_UNIDADE_PNEU
        ORDER BY ATUAL DESC, DATA_HORA_ALTERACAO DESC;
END;
$$;

create or replace function integracao.func_pneu_remove_vinculo_pneu_placa_posicao(f_token_integracao text, f_cod_sistema_integrado_pneus bigint[]) returns void
    language plpgsql
as
$$
DECLARE
    COD_PNEUS_PROLOG CONSTANT BIGINT[] := (SELECT ARRAY_AGG(PC.COD_PNEU_CADASTRO_PROLOG)
                                           FROM INTEGRACAO.PNEU_CADASTRADO PC
                                           WHERE PC.COD_EMPRESA_CADASTRO = (SELECT TI.COD_EMPRESA
                                                                            FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                                            WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)
                                             AND PC.COD_PNEU_SISTEMA_INTEGRADO = ANY (F_COD_SISTEMA_INTEGRADO_PNEUS));
BEGIN
    DELETE
    FROM PUBLIC.VEICULO_PNEU
    WHERE COD_PNEU = ANY (COD_PNEUS_PROLOG);

    UPDATE PNEU
    SET STATUS = 'ESTOQUE'
    WHERE CODIGO = ANY (COD_PNEUS_PROLOG);
END;
$$;

create or replace function integracao.func_geral_busca_infos_autenticacao(f_cod_empresa bigint, f_sistema_key text, f_metodo_integrado text)
    returns TABLE
            (
                url_completa     text,
                api_token_client text,
                api_short_code   bigint
            )
    language sql
as
$$
SELECT EIM.URL_COMPLETA     AS URL_COMPLETA,
       EIM.API_TOKEN_CLIENT AS API_TOKEN_CLIENT,
       EIM.API_SHORT_CODE   AS API_SHORT_CODE
FROM INTEGRACAO.EMPRESA_INTEGRACAO_METODOS EIM
         JOIN INTEGRACAO.EMPRESA_INTEGRACAO_SISTEMA EIS ON EIM.COD_INTEGRACAO_SISTEMA = EIS.CODIGO
WHERE EIS.COD_EMPRESA = F_COD_EMPRESA
  AND EIS.CHAVE_SISTEMA = F_SISTEMA_KEY
  AND EIM.METODO_INTEGRADO = F_METODO_INTEGRADO;
$$;

create or replace function implantacao.func_import_insere_dados_autor(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                      f_usuario text, f_tipo_import text)
    returns TABLE
            (
                cod_dados_autor_import bigint,
                nome_tabela_import     text
            )
    language plpgsql
as
$$
DECLARE
    DATA_HORA_IMPORT       TIMESTAMP WITH TIME ZONE := NOW();
    DATA_IMPORT            DATE                     := CURRENT_DATE;
    COD_DADOS_AUTOR_IMPORT BIGINT;
    NOME_TABELA_CRIADA     TEXT;
BEGIN
    -- VERIFICA SE UNIDADE DESTINO EXISTE E SE PERTENCE A EMPRESA.
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_UNIDADE(F_COD_EMPRESA, F_COD_UNIDADE);

    INSERT INTO IMPLANTACAO.DADOS_AUTOR_IMPORT (COD_EMPRESA, COD_UNIDADE, TIPO_IMPORT, USUARIO, DATA_HORA)
    VALUES (F_COD_EMPRESA, F_COD_UNIDADE, F_TIPO_IMPORT, F_USUARIO, DATA_HORA_IMPORT) RETURNING CODIGO
        INTO COD_DADOS_AUTOR_IMPORT;

    -- Verificamos se o insert funcionou.
    IF COD_DADOS_AUTOR_IMPORT > 0
    THEN
        CASE
            WHEN F_TIPO_IMPORT = 'PNEU'
                THEN
                    SELECT *
                    FROM IMPLANTACAO.FUNC_PNEU_IMPORT_CRIA_TABELA_IMPORT(
                                 F_COD_EMPRESA,
                                 F_COD_UNIDADE,
                                 F_USUARIO,
                                 DATA_IMPORT)
                    INTO NOME_TABELA_CRIADA;
            WHEN F_TIPO_IMPORT = 'VEICULO'
                THEN
                    SELECT *
                    FROM IMPLANTACAO.FUNC_VEICULO_IMPORT_CRIA_TABELA_IMPORT(
                                 F_COD_EMPRESA,
                                 F_COD_UNIDADE,
                                 F_USUARIO,
                                 DATA_IMPORT)
                    INTO NOME_TABELA_CRIADA;
            WHEN F_TIPO_IMPORT = 'COLABORADOR' --Preparado para quando for criado o import de colaborador
                THEN
                    SELECT *
                    FROM IMPLANTACAO.FUNC_COLABORADOR_IMPORT_CRIA_TABELA_IMPORT(
                                 F_COD_EMPRESA,
                                 F_COD_UNIDADE,
                                 F_USUARIO,
                                 DATA_IMPORT)
                    INTO NOME_TABELA_CRIADA;
            ELSE
                PERFORM THROW_GENERIC_ERROR(
                                'Não foi possível identificar o tipo de import, verifique para tentar novamente.');
            END CASE;
    ELSE
        PERFORM THROW_GENERIC_ERROR('Não foi possível inserir os dados do autor de import, tente novamente');
    END IF;

    RETURN QUERY SELECT COD_DADOS_AUTOR_IMPORT, NOME_TABELA_CRIADA;
END ;
$$;

create or replace function implantacao.func_pneu_import_cria_tabela_import(f_cod_empresa bigint, f_cod_unidade bigint,
                                                                           f_usuario text, f_data date,
                                                                           OUT f_nome_tabela_criada text) returns text
    language plpgsql
as
$$
DECLARE
    F_DIA                TEXT := (SELECT EXTRACT(DAY FROM F_DATA));
    F_MES                TEXT := (SELECT EXTRACT(MONTH FROM F_DATA));
    F_ANO                TEXT := (SELECT EXTRACT(YEAR FROM F_DATA)) ;
    F_NOME_TABELA_IMPORT TEXT := UNACCENT(LOWER(REMOVE_ALL_SPACES(
                                        'P_COD_EMP_' || F_COD_EMPRESA || '_COD_UNIDADE_' || F_COD_UNIDADE || '_' ||
                                        F_ANO || '_' || F_MES || '_' || F_DIA || '_' ||
                                        F_USUARIO)));
BEGIN
    EXECUTE FORMAT(
            'CREATE TABLE IF NOT EXISTS IMPLANTACAO.%I (
            CODIGO                                   BIGSERIAL,
            COD_DADOS_AUTOR_IMPORT                   BIGINT,
            COD_UNIDADE                              BIGINT,
            NUMERO_FOGO_EDITAVEL                     VARCHAR(255),
            MARCA_EDITAVEL                           VARCHAR(255),
            MODELO_EDITAVEL                          VARCHAR(255),
            DOT_EDITAVEL                             VARCHAR(20),
            DIMENSAO_EDITAVEL                        VARCHAR(255),
            PRESSAO_RECOMENDADA_EDITAVEL             VARCHAR(255),
            QTD_SULCOS_EDITAVEL                      VARCHAR(255),
            ALTURA_SULCOS_EDITAVEL                   VARCHAR(255),
            VALOR_PNEU_EDITAVEL                      VARCHAR(255),
            VALOR_BANDA_EDITAVEL                     VARCHAR(255),
            VIDA_ATUAL_EDITAVEL                      VARCHAR(255),
            VIDA_TOTAL_EDITAVEL                      VARCHAR(255),
            MARCA_BANDA_EDITAVEL                     VARCHAR(255),
            MODELO_BANDA_EDITAVEL                    VARCHAR(255),
            QTD_SULCOS_BANDA_EDITAVEL                VARCHAR(255),
            ALTURA_SULCOS_BANDA_EDITAVEL             VARCHAR(255),
            PNEU_NOVO_NUNCA_RODADO_EDITAVEL          VARCHAR(255),
            NUMERO_FOGO_FORMATADO_IMPORT             VARCHAR(255),
            MARCA_FORMATADA_IMPORT                   VARCHAR(255),
            MODELO_FORMATADO_IMPORT                  VARCHAR(255),
            DOT_FORMATADO_IMPORT                     VARCHAR(255),
            DIMENSAO_FORMATADA_IMPORT                VARCHAR(255),
            PRESSAO_RECOMENDADA_FORMATADA_IMPORT     REAL,
            QTD_SULCOS_FORMATADA_IMPORT              SMALLINT,
            ALTURA_SULCOS_FORMATADA_IMPORT           REAL,
            VALOR_PNEU_FORMATADO_IMPORT              REAL,
            VALOR_BANDA_FORMATADO_IMPORT             REAL,
            VIDA_ATUAL_FORMATADA_IMPORT              SMALLINT,
            VIDA_TOTAL_FORMATADA_IMPORT              SMALLINT,
            MARCA_BANDA_FORMATADA_IMPORT             VARCHAR(255),
            MODELO_BANDA_FORMATADO_IMPORT            VARCHAR(255),
            QTD_SULCOS_BANDA_FORMATADA_IMPORT        SMALLINT,
            ALTURA_SULCOS_BANDA_FORMATADA_IMPORT     REAL,
            PNEU_NOVO_NUNCA_RODADO_FORMATADO_IMPORT  BOOLEAN,
            STATUS_IMPORT_REALIZADO                  BOOLEAN,
            ERROS_ENCONTRADOS                        TEXT,
            USUARIO_UPDATE                           VARCHAR(255),
            FOREIGN KEY (COD_DADOS_AUTOR_IMPORT) REFERENCES IMPLANTACAO.DADOS_AUTOR_IMPORT (CODIGO),
            FOREIGN KEY (COD_UNIDADE) REFERENCES UNIDADE (CODIGO)
        );', F_NOME_TABELA_IMPORT);

    --TRIGGER PARA VERIFICAR PLANILHA E REALIZAR O IMPORT DE PNEUS
    EXECUTE format('DROP TRIGGER IF EXISTS TG_FUNC_IMPORT_PNEU ON IMPLANTACAO.%I;
                   CREATE TRIGGER TG_FUNC_IMPORT_PNEU
                    BEFORE INSERT OR UPDATE
                    ON IMPLANTACAO.%I
                    FOR EACH ROW
                   EXECUTE PROCEDURE IMPLANTACAO.TG_FUNC_PNEU_CONFERE_PLANILHA_IMPORTA_PNEU();',
                   F_NOME_TABELA_IMPORT,
                   F_NOME_TABELA_IMPORT);

    --CRIA AUDIT PARA A TABELA
    EXECUTE format('DROP TRIGGER IF EXISTS TG_FUNC_AUDIT_IMPORT_PNEU ON IMPLANTACAO.%I;
                    CREATE TRIGGER TG_FUNC_AUDIT_IMPORT_PNEU
                    AFTER UPDATE OR DELETE
                    ON IMPLANTACAO.%I
                    FOR EACH ROW
                    EXECUTE PROCEDURE AUDIT_IMPLANTACAO.FUNC_AUDIT_IMPLANTACAO();',
                   F_NOME_TABELA_IMPORT,
                   F_NOME_TABELA_IMPORT);

    -- GARANTE UPDATE PARA O NATAN
    -- TODO REMOVER HARDCODED
    EXECUTE FORMAT(
            'grant select, update on implantacao.%I to prolog_user_natan;', F_NOME_TABELA_IMPORT
        );

    --RETORNA NOME DA TABELA
    SELECT F_NOME_TABELA_IMPORT INTO F_NOME_TABELA_CRIADA;
END ;
$$;

create or replace function implantacao.func_pneu_insere_planilha_importacao(f_cod_dados_autor_import bigint,
                                                                            f_nome_tabela_import text,
                                                                            f_cod_unidade bigint,
                                                                            f_json_pneus jsonb) returns void
    language plpgsql
as
$$
BEGIN
    EXECUTE FORMAT('INSERT INTO IMPLANTACAO.%I (COD_DADOS_AUTOR_IMPORT,
                                                COD_UNIDADE,
                                                NUMERO_FOGO_EDITAVEL,
                                                MARCA_EDITAVEL,
                                                MODELO_EDITAVEL,
                                                DOT_EDITAVEL,
                                                DIMENSAO_EDITAVEL,
                                                PRESSAO_RECOMENDADA_EDITAVEL,
                                                QTD_SULCOS_EDITAVEL,
                                                ALTURA_SULCOS_EDITAVEL,
                                                VALOR_PNEU_EDITAVEL,
                                                VALOR_BANDA_EDITAVEL,
                                                VIDA_ATUAL_EDITAVEL,
                                                VIDA_TOTAL_EDITAVEL,
                                                MARCA_BANDA_EDITAVEL,
                                                MODELO_BANDA_EDITAVEL,
                                                QTD_SULCOS_BANDA_EDITAVEL,
                                                ALTURA_SULCOS_BANDA_EDITAVEL,
                                                PNEU_NOVO_NUNCA_RODADO_EDITAVEL)
                   SELECT %s AS COD_DADOS_AUTOR_IMPORT,
                          %s AS COD_UNIDADE,
                          (SRC ->> ''numeroFogo'') :: TEXT,
                          (SRC ->> ''marca'') :: TEXT,
                          (SRC ->> ''modelo'') :: TEXT,
                          (SRC ->> ''dot'') :: TEXT,
                          (SRC ->> ''dimensao'') :: TEXT,
                          (SRC ->> ''pressaoIdeal'') :: TEXT,
                          (SRC ->> ''qtdSulcos'') :: TEXT,
                          (SRC ->> ''alturaSulcos'') :: TEXT,
                          (SRC ->> ''valorPneu'') :: TEXT,
                          (SRC ->> ''valorBanda'') :: TEXT,
                          (SRC ->> ''vidaAtual'') :: TEXT,
                          (SRC ->> ''vidaTotal'') :: TEXT,
                          (SRC ->> ''marcaBanda'') :: TEXT,
                          (SRC ->> ''modeloBanda'') :: TEXT,
                          (SRC ->> ''qtdSulcosBanda'') :: TEXT,
                          (SRC ->> ''alturaSulcos'') :: TEXT,
                          (SRC ->> ''pneuNovoNuncaRodado'') :: TEXT
                   FROM JSONB_ARRAY_ELEMENTS(%L) AS SRC',
                   F_NOME_TABELA_IMPORT,
                   F_COD_DADOS_AUTOR_IMPORT,
                   F_COD_UNIDADE,
                   F_JSON_PNEUS);
END
$$;

create or replace function public.remove_non_numeric_characters(f_texto text) returns text
    immutable
    strict
    language plpgsql
as
$$
BEGIN
    -- Remove letras, characteres especiais e espaços.
    -- A flag 'g' indica que serão removidas todas as aparições do padrão específicado não somente o primeiro caso.
    RETURN REGEXP_REPLACE(F_TEXTO, '[^0-9]+', '', 'g');
END;
$$;

create or replace function implantacao.tg_func_pneu_confere_planilha_importa_pneu() returns trigger
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_EMPRESA                              BIGINT;
    F_VALOR_SIMILARIDADE CONSTANT              REAL     := 0.4;
    F_VALOR_SIMILARIDADE_DIMENSAO CONSTANT     REAL     := 0.55;
    F_SEM_SIMILARIDADE CONSTANT                REAL     := 0.0;
    F_QTD_ERROS                                SMALLINT := 0;
    F_MSGS_ERROS                               TEXT;
    F_QUEBRA_LINHA                             TEXT     := CHR(10);
    F_COD_MARCA_BANCO                          BIGINT;
    F_SIMILARIDADE_MARCA                       REAL;
    F_MARCA_MODELO                             TEXT;
    F_COD_MODELO_BANCO                         BIGINT;
    F_SIMILARIDADE_MODELO                      REAL;
    F_COD_MARCA_BANDA_BANCO                    BIGINT;
    F_SIMILARIDADE_MARCA_BANDA                 REAL;
    F_MARCA_MODELO_BANDA                       TEXT;
    F_COD_MODELO_BANDA_BANCO                   BIGINT;
    F_SIMILARIDADE_MODELO_BANDA                REAL;
    DATE_CONVERTER                             TEXT     := 'YYYYWW';
    PREFIXO_ANO                                TEXT     := SUBSTRING(CURRENT_TIMESTAMP::TEXT, 1, 2);
    DOT_EM_DATA                                DATE;
    F_COD_DIMENSAO                             BIGINT;
    F_SIMILARIDADE_DIMENSAO                    REAL;
    F_ALTURA_MIN_SULCOS                        REAL     := 1;
    F_ALTURA_MAX_SULCOS                        REAL     := 50;
    F_QTD_MIN_SULCOS                           SMALLINT := 1;
    F_QTD_MAX_SULCOS                           SMALLINT := 6;
    F_QTD_SULCOS_DEFAULT                       SMALLINT := 4;
    F_ERRO_SULCOS                              BOOLEAN  := FALSE;
    F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO      REAL     := 0;
    F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO_LOOP REAL;
    F_PNEU_NOVO_NUNCA_RODADO_ARRAY             TEXT[]   := ('{"SIM", "OK", "TRUE"}');
    F_PNEU_NOVO_NUNCA_RODADO                   TEXT;
    F_COD_TIPO_SERVICO                         BIGINT;
    F_COD_SERVICO_REALIZADO                    BIGINT;
    F_COD_PNEU                                 BIGINT;


BEGIN
    IF (TG_OP = 'UPDATE' AND OLD.STATUS_IMPORT_REALIZADO IS TRUE)
    THEN
        RETURN OLD;
    ELSE
        IF (TG_OP = 'UPDATE')
        THEN
            NEW.COD_UNIDADE = OLD.COD_UNIDADE;
        END IF;
        F_COD_EMPRESA := (SELECT U.COD_EMPRESA FROM UNIDADE U WHERE U.CODIGO = NEW.COD_UNIDADE);
        NEW.USUARIO_UPDATE := SESSION_USER;
        NEW.NUMERO_FOGO_FORMATADO_IMPORT = UPPER(REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.NUMERO_FOGO_EDITAVEL));
        NEW.MARCA_FORMATADA_IMPORT = REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.MARCA_EDITAVEL);
        NEW.MODELO_FORMATADO_IMPORT := REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.MODELO_EDITAVEL);
        NEW.DOT_FORMATADO_IMPORT := REMOVE_ALL_SPACES(NEW.DOT_EDITAVEL);
        NEW.DIMENSAO_FORMATADA_IMPORT := REMOVE_ALL_SPACES(NEW.DIMENSAO_EDITAVEL);
        NEW.MARCA_BANDA_FORMATADA_IMPORT := REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.MARCA_BANDA_EDITAVEL);
        NEW.MODELO_BANDA_FORMATADO_IMPORT := REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(NEW.MODELO_BANDA_EDITAVEL);

        -- VERIFICAÇÕES NÚMERO DE FOGO.
        -- Número de fogo nulo: Erro.
        -- Número de fogo cadastrado em outra unidade da mesma empresa: Erro.
        -- Número de fogo cadastrado na mesma unidade: Erro.
        IF (NEW.NUMERO_FOGO_FORMATADO_IMPORT IS NOT NULL)
        THEN
            IF EXISTS(SELECT P.CODIGO_CLIENTE
                      FROM PNEU P
                      WHERE REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(P.CODIGO_CLIENTE) ILIKE
                            NEW.NUMERO_FOGO_FORMATADO_IMPORT
                        AND P.COD_EMPRESA = F_COD_EMPRESA
                        AND P.COD_UNIDADE != NEW.COD_UNIDADE)
            THEN
                F_QTD_ERROS = F_QTD_ERROS + 1;
                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                      '- O PNEU JÁ ESTÁ CADASTRADO E PERTENCE A OUTRA UNIDADE',
                                      F_QUEBRA_LINHA);
                NEW.STATUS_IMPORT_REALIZADO = TRUE;
            ELSE
                IF EXISTS(SELECT P.CODIGO_CLIENTE
                          FROM PNEU P
                          WHERE REMOVE_ESPACOS_E_CARACTERES_ESPECIAIS(P.CODIGO_CLIENTE) ILIKE
                                NEW.NUMERO_FOGO_FORMATADO_IMPORT
                            AND P.COD_EMPRESA = F_COD_EMPRESA
                            AND P.COD_UNIDADE = NEW.COD_UNIDADE)
                THEN
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                          '- O PNEU JÁ ESTÁ CADASTRADO NA UNIDADE INFORMADA',
                                          F_QUEBRA_LINHA);
                    NEW.STATUS_IMPORT_REALIZADO = TRUE;
                END IF;
            END IF;
        ELSE
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- O NÚMERO DE FOGO NÃO PODE SER NULO', F_QUEBRA_LINHA);
        END IF;

        -- VERIFICAÇÕES MARCA.
        -- Marca nula: Erro.
        IF (NEW.MARCA_FORMATADA_IMPORT IS NOT NULL)
        THEN
            -- Procura marca similar no banco.
            SELECT DISTINCT ON (NEW.MARCA_FORMATADA_IMPORT) MAP.CODIGO                                                        AS COD_MARCA_BANCO,
                                                            MAX(FUNC_GERA_SIMILARIDADE(NEW.MARCA_FORMATADA_IMPORT, MAP.NOME)) AS SIMILARIEDADE_MARCA
            INTO F_COD_MARCA_BANCO, F_SIMILARIDADE_MARCA
            FROM MARCA_PNEU MAP
            GROUP BY NEW.MARCA_FORMATADA_IMPORT, NEW.MARCA_EDITAVEL, MAP.NOME, MAP.CODIGO
            ORDER BY NEW.MARCA_FORMATADA_IMPORT, SIMILARIEDADE_MARCA DESC;

            F_MARCA_MODELO := CONCAT(F_COD_MARCA_BANCO, NEW.MODELO_FORMATADO_IMPORT);
            -- Se a similaridade da marca for maior ou igual ao exigido: procura modelo.
            -- Se não for: Mostra erro de marca não encontrada (Não cadastra pois é nível Prolog).
            IF (F_SIMILARIDADE_MARCA >= F_VALOR_SIMILARIDADE)
            THEN
                -- VERIFICAÇÕES DE MODELO: Procura modelo similar no banco.
                IF (NEW.MODELO_FORMATADO_IMPORT IS NOT NULL)
                THEN
                    SELECT DISTINCT ON (F_MARCA_MODELO) MOP.CODIGO AS COD_MODELO_PNEU,
                                                        CASE
                                                            WHEN F_COD_MARCA_BANCO = MOP.COD_MARCA
                                                                THEN
                                                                MAX(FUNC_GERA_SIMILARIDADE(F_MARCA_MODELO,
                                                                                           CONCAT(MOP.COD_MARCA, MOP.NOME)))
                                                            ELSE F_SEM_SIMILARIDADE
                                                            END    AS SIMILARIEDADE_MODELO
                    INTO F_COD_MODELO_BANCO, F_SIMILARIDADE_MODELO
                    FROM MODELO_PNEU MOP
                    WHERE MOP.COD_EMPRESA = F_COD_EMPRESA
                    GROUP BY F_MARCA_MODELO, MOP.NOME, MOP.CODIGO
                    ORDER BY F_MARCA_MODELO, SIMILARIEDADE_MODELO DESC;

                    -- Se a similaridade do modelo for menor do que o exigido: cadastra novo modelo.
                    IF (F_SIMILARIDADE_MODELO < F_VALOR_SIMILARIDADE OR F_SIMILARIDADE_MODELO IS NULL)
                    THEN
                        BEGIN
                            -- VERIFICAÇÃO DE SULCOS.
                            -- Parse para smallint.
                            NEW.QTD_SULCOS_FORMATADA_IMPORT :=
                                    REPLACE(REMOVE_NON_NUMERIC_CHARACTERS_EXCEPT_COMMA_PERIOD(
                                                    NEW.QTD_SULCOS_EDITAVEL), ',', '.')::SMALLINT;
                            IF (NEW.QTD_SULCOS_FORMATADA_IMPORT IS NULL)
                            THEN
                                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                      '- A QUANTIDADE DE SULCOS ESTAVA NULA, PORTANTO ASSUMIU O ' ||
                                                      'VALOR DEFAULT = 4',
                                                      F_QUEBRA_LINHA);
                                NEW.QTD_SULCOS_FORMATADA_IMPORT := F_QTD_SULCOS_DEFAULT;
                            ELSE
                                IF (NEW.QTD_SULCOS_FORMATADA_IMPORT < F_QTD_MIN_SULCOS)
                                THEN
                                    F_ERRO_SULCOS := TRUE;
                                    F_QTD_ERROS = F_QTD_ERROS + 1;
                                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                          '- A QUANTIDADE DE SULCOS NÃO PODE SER MENOR QUE 1',
                                                          F_QUEBRA_LINHA);
                                ELSE
                                    IF (NEW.QTD_SULCOS_FORMATADA_IMPORT > F_QTD_MAX_SULCOS)
                                    THEN
                                        F_ERRO_SULCOS := TRUE;
                                        F_QTD_ERROS = F_QTD_ERROS + 1;
                                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                              '- A QUANTIDADE DE SULCOS NÃO PODE SER MAIOR QUE 6',
                                                              F_QUEBRA_LINHA);
                                    END IF;
                                END IF;
                            END IF;
                        EXCEPTION
                            WHEN invalid_text_representation THEN -- error that can be handled
                                F_ERRO_SULCOS := TRUE;
                                F_QTD_ERROS = F_QTD_ERROS + 1;
                                F_MSGS_ERROS =
                                        concat(F_MSGS_ERROS, F_QTD_ERROS,
                                               '- QUANTIDADE DE SULCOS COM VALOR INCORRETO',
                                               F_QUEBRA_LINHA);
                        END;
                        IF (NEW.ALTURA_SULCOS_EDITAVEL IS NOT NULL)
                        THEN
                            BEGIN
                                NEW.ALTURA_SULCOS_FORMATADA_IMPORT :=
                                        REPLACE(REMOVE_NON_NUMERIC_CHARACTERS_EXCEPT_COMMA_PERIOD(
                                                        NEW.ALTURA_SULCOS_EDITAVEL), ',', '.')::REAL;
                                IF (NEW.ALTURA_SULCOS_FORMATADA_IMPORT < F_ALTURA_MIN_SULCOS)
                                THEN
                                    F_ERRO_SULCOS := TRUE;
                                    F_QTD_ERROS = F_QTD_ERROS + 1;
                                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                          '- A ALTURA DOS SULCOS NÃO PODE SER MENOR QUE 1mm',
                                                          F_QUEBRA_LINHA);
                                ELSE
                                    IF (NEW.ALTURA_SULCOS_FORMATADA_IMPORT > F_ALTURA_MAX_SULCOS)
                                    THEN
                                        F_ERRO_SULCOS := TRUE;
                                        F_QTD_ERROS = F_QTD_ERROS + 1;
                                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                              '- A ALTURA DOS SULCOS NÃO PODE SER MAIOR QUE 50mm',
                                                              F_QUEBRA_LINHA);
                                    END IF;
                                END IF;
                            EXCEPTION
                                WHEN invalid_text_representation THEN -- error that can be handled
                                    F_ERRO_SULCOS := TRUE;
                                    F_QTD_ERROS = F_QTD_ERROS + 1;
                                    F_MSGS_ERROS =
                                            concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                   '- ALTURA DOS SULCOS COM VALOR INCORRETO',
                                                   F_QUEBRA_LINHA);
                            END;
                        ELSE
                            F_ERRO_SULCOS := TRUE;
                            F_QTD_ERROS = F_QTD_ERROS + 1;
                            F_MSGS_ERROS =
                                    concat(F_MSGS_ERROS, F_QTD_ERROS, '- A ALTURA DOS SULCOS NÃO PODE SER NULA',
                                           F_QUEBRA_LINHA);

                        END IF;
                        IF (F_ERRO_SULCOS = FALSE)
                        THEN
                            INSERT INTO MODELO_PNEU (NOME, COD_MARCA, COD_EMPRESA, QT_SULCOS, ALTURA_SULCOS)
                            VALUES (NEW.MODELO_EDITAVEL, F_COD_MARCA_BANCO, F_COD_EMPRESA,
                                    NEW.QTD_SULCOS_FORMATADA_IMPORT,
                                    NEW.ALTURA_SULCOS_FORMATADA_IMPORT) RETURNING CODIGO INTO F_COD_MODELO_BANCO;
                        END IF;
                    END IF;
                ELSE
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                          '- O MODELO DE PNEU NÃO PODE SER NULO', F_QUEBRA_LINHA);
                END IF;
            ELSE
                F_QTD_ERROS = F_QTD_ERROS + 1;
                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A MARCA NÃO FOI ENCONTRADA', F_QUEBRA_LINHA);
            END IF;
        ELSE
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A MARCA NÃO PODE SER NULA', F_QUEBRA_LINHA);
        END IF;

        -- VERIFICAÇÕES DOT
        IF (CHAR_LENGTH(NEW.DOT_FORMATADO_IMPORT) > 4)
        THEN
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- O DOT DEVE POSSUIR NO MÁXIMO 4 DÍGITOS',
                                  F_QUEBRA_LINHA);

        ELSE
            IF (CHAR_LENGTH(NEW.DOT_FORMATADO_IMPORT) < 4)
            THEN
                NEW.DOT_FORMATADO_IMPORT = LPAD(NEW.DOT_FORMATADO_IMPORT, 4, '0');
            END IF;
            IF (CHAR_LENGTH(NEW.DOT_FORMATADO_IMPORT) = 4)
            THEN
                BEGIN
                    -- Transforma o DOT_FORMATADO em data
                    DOT_EM_DATA := TO_DATE(CONCAT(PREFIXO_ANO, (SUBSTRING(NEW.DOT_FORMATADO_IMPORT, 3, 4)),
                                                  (SUBSTRING(NEW.DOT_FORMATADO_IMPORT, 1, 2))),
                                           DATE_CONVERTER);
                    -- Verifica se a data do DOT que foi transformado é maior que a data atual, se for está errado.
                    IF (DOT_EM_DATA > CURRENT_DATE)
                    THEN
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS =
                                concat(F_MSGS_ERROS, F_QTD_ERROS, '- O DOT NÃO PODE SER MAIOR QUE A DATA ATUAL',
                                       F_QUEBRA_LINHA);
                    END IF;
                EXCEPTION
                    WHEN invalid_datetime_format THEN -- error that can be handled
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS =
                                concat(F_MSGS_ERROS, F_QTD_ERROS,
                                       '- DOT COM CARACTERES INCORRETOS - DEVE POSSUIR APENAS NÚMEROS',
                                       F_QUEBRA_LINHA);
                END;
            END IF;
        END IF;

        -- VERIFICAÇÕES DIMENSÃO
        IF (NEW.DIMENSAO_FORMATADA_IMPORT IS NULL)
        THEN
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A DIMENSÃO NÃO PODE SER NULA',
                                  F_QUEBRA_LINHA);
        ELSE
            SELECT DISTINCT ON (NEW.DIMENSAO_FORMATADA_IMPORT) DP.CODIGO                                                                    AS COD_DIMENSAO_BANCO,
                                                               MAX(func_gera_similaridade(NEW.DIMENSAO_FORMATADA_IMPORT,
                                                                                          CONCAT(DP.LARGURA, '/', DP.ALTURA, 'R', DP.ARO))) AS SIMILARIDADE_DIMENSAO
            INTO F_COD_DIMENSAO, F_SIMILARIDADE_DIMENSAO
            FROM DIMENSAO_PNEU DP
            GROUP BY NEW.DIMENSAO_FORMATADA_IMPORT, NEW.DIMENSAO_EDITAVEL,
                     CONCAT(DP.LARGURA, '/', DP.ALTURA, 'R', DP.ARO),
                     DP.CODIGO
            ORDER BY NEW.DIMENSAO_FORMATADA_IMPORT, SIMILARIDADE_DIMENSAO DESC;

            IF (F_SIMILARIDADE_DIMENSAO < F_VALOR_SIMILARIDADE_DIMENSAO)
            THEN
                F_QTD_ERROS = F_QTD_ERROS + 1;
                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A DIMENSÃO NÃO FOI ENCONTRADA', F_QUEBRA_LINHA);
            END IF;
        END IF;

        -- VERIFICAÇÕES PRESSÃO IDEAL
        IF (NEW.PRESSAO_RECOMENDADA_EDITAVEL IS NULL)
        THEN
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A PRESSÃO RECOMENDADA NÃO PODE SER NULA',
                                  F_QUEBRA_LINHA);
        ELSE
            BEGIN
                NEW.PRESSAO_RECOMENDADA_FORMATADA_IMPORT :=
                        REPLACE(REMOVE_NON_NUMERIC_CHARACTERS_EXCEPT_COMMA_PERIOD(
                                        NEW.PRESSAO_RECOMENDADA_EDITAVEL), ',', '.')::REAL;
                IF (NEW.PRESSAO_RECOMENDADA_FORMATADA_IMPORT < 0)
                THEN
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                          '- A PRESSÃO RECOMENDADA NÃO PODE SER NEGATIVA',
                                          F_QUEBRA_LINHA);
                ELSE
                    IF (NEW.PRESSAO_RECOMENDADA_FORMATADA_IMPORT > 150)
                    THEN
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                              '- A PRESSÃO RECOMENDADA NÃO PODE SER MAIOR QUE 150',
                                              F_QUEBRA_LINHA);
                    END IF;
                END IF;
            EXCEPTION
                WHEN invalid_text_representation THEN -- error that can be handled
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS =
                            concat(F_MSGS_ERROS, F_QTD_ERROS, '- PRESSÃO IDEAL COM CARACTERES INCORRETOS',
                                   F_QUEBRA_LINHA);
            END;
        END IF;

        -- VERIFICAÇÕES VALOR PNEU
        IF (NEW.VALOR_PNEU_EDITAVEL IS NULL)
        THEN
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- O VALOR DO PNEU NÃO PODE SER NULO',
                                  F_QUEBRA_LINHA);
        ELSE
            BEGIN
                NEW.VALOR_PNEU_FORMATADO_IMPORT :=
                        REPLACE(REMOVE_NON_NUMERIC_CHARACTERS_EXCEPT_COMMA_PERIOD(
                                        NEW.VALOR_PNEU_EDITAVEL), ',', '.')::REAL;
                IF (NEW.VALOR_PNEU_FORMATADO_IMPORT < 0)
                THEN
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- O VALOR DO PNEU NÃO PODE SER NEGATIVO',
                                          F_QUEBRA_LINHA);
                END IF;
            EXCEPTION
                WHEN invalid_text_representation THEN -- error that can be handled
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS =
                            concat(F_MSGS_ERROS, F_QTD_ERROS, '- VALOR DO PNEU COM CARACTERES INCORRETOS',
                                   F_QUEBRA_LINHA);
            END;
        END IF;

        -- VERIFICAÇÕES VIDA TOTAL.
        IF (NEW.VIDA_TOTAL_EDITAVEL IS NULL)
        THEN
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A VIDA TOTAL DO PNEU NÃO PODE SER NULA',
                                  F_QUEBRA_LINHA);
        ELSE
            BEGIN
                -- ACRESCENTA +1 NA VIDA_TOTAL_FORMATADA_IMPORT.
                -- Acrescentado +1 à vida_total devido ao prolog considerar que a vida_atual do pneu novo é = 1, não 0.
                NEW.VIDA_TOTAL_FORMATADA_IMPORT := (NEW.VIDA_TOTAL_EDITAVEL :: INTEGER + 1);
                IF (NEW.VIDA_TOTAL_FORMATADA_IMPORT < 1)
                THEN
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                          '- A VIDA TOTAL DO PNEU NÃO PODE SER NEGATIVA',
                                          F_QUEBRA_LINHA);
                ELSE
                    IF (NEW.VIDA_TOTAL_FORMATADA_IMPORT > 10)
                    THEN
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                              '- A VIDA TOTAL DO PNEU NÃO PODE SER MAIOR QUE 10',
                                              F_QUEBRA_LINHA);
                    END IF;
                END IF;
            EXCEPTION
                WHEN invalid_text_representation THEN -- error that can be handled
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS =
                            concat(F_MSGS_ERROS, F_QTD_ERROS, '- VIDA TOTAL COM CARACTERES INCORRETOS',
                                   F_QUEBRA_LINHA);
            END;
        END IF;

        -- VERIFICAÇÕES VIDA ATUAL
        IF (NEW.VIDA_ATUAL_EDITAVEL IS NULL)
        THEN
            F_QTD_ERROS = F_QTD_ERROS + 1;
            F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- A VIDA ATUAL DO PNEU NÃO PODE SER NULA',
                                  F_QUEBRA_LINHA);
        ELSE
            BEGIN
                -- ACRESCENTA +1 NA VIDA_ATUAL_FORMATADA_IMPORT.
                -- É incrementado +1 à vida_atual devido ao prolog considerar que a vida do pneu novo é = 1 e não 0.
                NEW.VIDA_ATUAL_FORMATADA_IMPORT := (NEW.VIDA_ATUAL_EDITAVEL :: INTEGER + 1);

                --VIDA_ATUAL FOR MAIOR QUE A VIDA TOTAL: Erro.
                IF (NEW.VIDA_ATUAL_FORMATADA_IMPORT > NEW.VIDA_TOTAL_FORMATADA_IMPORT)
                THEN
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                          '- A VIDA ATUAL NÃO PODE SER MAIOR QUE A VIDA TOTAL',
                                          F_QUEBRA_LINHA);
                ELSE
                    IF (NEW.VIDA_ATUAL_FORMATADA_IMPORT < 1)
                    THEN
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                              '- A VIDA ATUAL DO PNEU NÃO PODE SER NEGATIVA',
                                              F_QUEBRA_LINHA);
                    END IF;
                END IF;

                IF (NEW.VIDA_ATUAL_FORMATADA_IMPORT = 1)
                THEN
                    IF (NEW.PNEU_NOVO_NUNCA_RODADO_EDITAVEL IS NOT NULL)
                    THEN
                        FOREACH F_PNEU_NOVO_NUNCA_RODADO IN ARRAY F_PNEU_NOVO_NUNCA_RODADO_ARRAY
                            LOOP
                                F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO_LOOP :=
                                        MAX(FUNC_GERA_SIMILARIDADE(NEW.PNEU_NOVO_NUNCA_RODADO_EDITAVEL,
                                                                   F_PNEU_NOVO_NUNCA_RODADO));
                                IF (F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO_LOOP >
                                    F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO)
                                THEN
                                    F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO := F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO_LOOP;
                                END IF;
                            END LOOP;
                    END IF;
                END IF;
                IF (F_SIMILARIDADE_PNEU_NOVO_NUNCA_RODADO >= F_VALOR_SIMILARIDADE)
                THEN
                    NEW.PNEU_NOVO_NUNCA_RODADO_FORMATADO_IMPORT := TRUE;
                ELSE
                    NEW.PNEU_NOVO_NUNCA_RODADO_FORMATADO_IMPORT := FALSE;
                END IF;
            EXCEPTION
                WHEN invalid_text_representation THEN -- error that can be handled
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS =
                            concat(F_MSGS_ERROS, F_QTD_ERROS, '- VIDA ATUAL COM CARACTERES INCORRETOS',
                                   F_QUEBRA_LINHA);
            END;
        END IF;

        --VERIFICAÇÕES BANDA
        IF (NEW.VIDA_ATUAL_FORMATADA_IMPORT IS NOT NULL AND NEW.VIDA_ATUAL_FORMATADA_IMPORT > 1)
        THEN
            IF (NEW.MARCA_BANDA_FORMATADA_IMPORT IS NULL)
            THEN
                F_QTD_ERROS = F_QTD_ERROS + 1;
                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                      '- A MARCA DE BANDA NÃO PODE SER NULA PARA PNEUS ACIMA DA PRIMEIRA VIDA',
                                      F_QUEBRA_LINHA);
            ELSE
                -- VERIFICAÇÕES MARCA DE BANDA: Procura marca de banda similar no banco.
                SELECT DISTINCT ON (NEW.MARCA_BANDA_FORMATADA_IMPORT) MAB.CODIGO                                                                  AS COD_MARCA_BANDA_BANCO,
                                                                      MAX(
                                                                              FUNC_GERA_SIMILARIDADE(NEW.MARCA_BANDA_FORMATADA_IMPORT, MAB.NOME)) AS SIMILARIEDADE_MARCA_BANDA
                INTO F_COD_MARCA_BANDA_BANCO, F_SIMILARIDADE_MARCA_BANDA
                FROM MARCA_BANDA MAB
                WHERE MAB.COD_EMPRESA = F_COD_EMPRESA
                GROUP BY NEW.MARCA_BANDA_FORMATADA_IMPORT, NEW.MARCA_BANDA_EDITAVEL, MAB.NOME, MAB.CODIGO
                ORDER BY NEW.MARCA_BANDA_FORMATADA_IMPORT, SIMILARIEDADE_MARCA_BANDA DESC;

                F_MARCA_MODELO_BANDA := CONCAT(F_COD_MARCA_BANDA_BANCO, NEW.MODELO_BANDA_FORMATADO_IMPORT);
                -- Se a similaridade da marca de banda for menor que o exigido: Cadastra.
                IF (F_SIMILARIDADE_MARCA_BANDA < F_VALOR_SIMILARIDADE OR F_SIMILARIDADE_MARCA_BANDA IS NULL)
                THEN
                    INSERT INTO MARCA_BANDA (NOME, COD_EMPRESA)
                    VALUES (NEW.MARCA_BANDA_EDITAVEL, F_COD_EMPRESA) RETURNING CODIGO INTO F_COD_MARCA_BANDA_BANCO;
                END IF;

                IF (NEW.MODELO_BANDA_FORMATADO_IMPORT IS NULL)
                THEN
                    F_QTD_ERROS = F_QTD_ERROS + 1;
                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                          '- O MODELO DE BANDA NÃO PODE SER NULO PARA PNEUS ACIMA DA PRIMEIRA VIDA',
                                          F_QUEBRA_LINHA);
                ELSE
                    -- VERIFICAÇÕES MODELO DE BANDA: Procura modelo SIMILAR NO banco.
                    SELECT DISTINCT ON (F_MARCA_MODELO_BANDA) MOB.CODIGO AS COD_MODELO_BANDA,
                                                              CASE
                                                                  WHEN F_COD_MARCA_BANDA_BANCO = MOB.COD_MARCA
                                                                      THEN
                                                                      MAX(FUNC_GERA_SIMILARIDADE(
                                                                              F_MARCA_MODELO_BANDA,
                                                                              CONCAT(MOB.COD_MARCA, MOB.NOME)))
                                                                  ELSE F_SEM_SIMILARIDADE
                                                                  END    AS SIMILARIEDADE_MODELO_BANDA
                    INTO F_COD_MODELO_BANDA_BANCO, F_SIMILARIDADE_MODELO_BANDA
                    FROM MODELO_BANDA MOB
                    WHERE MOB.COD_EMPRESA = F_COD_EMPRESA
                    GROUP BY F_MARCA_MODELO_BANDA, MOB.NOME, MOB.CODIGO
                    ORDER BY F_MARCA_MODELO_BANDA, SIMILARIEDADE_MODELO_BANDA DESC;

                    -- Se a similaridade do modelo de banda for menor do que o exigido: cadastra novo modelo de banda.
                    IF (F_SIMILARIDADE_MODELO_BANDA < F_VALOR_SIMILARIDADE OR F_SIMILARIDADE_MODELO_BANDA IS NULL)
                    THEN
                        BEGIN
                            NEW.QTD_SULCOS_BANDA_FORMATADA_IMPORT :=
                                    REPLACE(REMOVE_NON_NUMERIC_CHARACTERS_EXCEPT_COMMA_PERIOD(
                                                    NEW.QTD_SULCOS_BANDA_EDITAVEL), ',', '.')::SMALLINT;
                            IF (NEW.QTD_SULCOS_BANDA_FORMATADA_IMPORT IS NULL)
                            THEN
                                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                      '- A QUANTIDADE DE SULCOS ESTAVA NULA, PORTANTO ASSUMIU O' ||
                                                      ' VALOR DEFAULT = 4',
                                                      F_QUEBRA_LINHA);
                                NEW.QTD_SULCOS_BANDA_FORMATADA_IMPORT := F_QTD_SULCOS_DEFAULT;
                            ELSE
                                IF (NEW.QTD_SULCOS_BANDA_FORMATADA_IMPORT < F_QTD_MIN_SULCOS)
                                THEN
                                    F_ERRO_SULCOS := TRUE;
                                    F_QTD_ERROS = F_QTD_ERROS + 1;
                                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                          '- A QUANTIDADE DE SULCOS DE BANDA NÃO PODE SER MENOR QUE 1',
                                                          F_QUEBRA_LINHA);
                                ELSE
                                    IF (NEW.QTD_SULCOS_BANDA_FORMATADA_IMPORT > F_QTD_MAX_SULCOS)
                                    THEN
                                        F_ERRO_SULCOS := TRUE;
                                        F_QTD_ERROS = F_QTD_ERROS + 1;
                                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                              '- A QUANTIDADE DE SULCOS DE BANDA NÃO PODE SER MAIOR' ||
                                                              ' QUE 6',
                                                              F_QUEBRA_LINHA);
                                    END IF;
                                END IF;
                            END IF;
                        EXCEPTION
                            WHEN invalid_text_representation THEN -- error that can be handled
                                F_ERRO_SULCOS := TRUE;
                                F_QTD_ERROS = F_QTD_ERROS + 1;
                                F_MSGS_ERROS =
                                        concat(F_MSGS_ERROS, F_QTD_ERROS,
                                               '- QUANTIDADE DE SULCOS DE BANDA COM VALOR INCORRETO',
                                               F_QUEBRA_LINHA);
                        END;
                        IF (NEW.ALTURA_SULCOS_BANDA_EDITAVEL IS NOT NULL)
                        THEN
                            BEGIN
                                NEW.ALTURA_SULCOS_BANDA_FORMATADA_IMPORT :=
                                        REPLACE(REMOVE_NON_NUMERIC_CHARACTERS_EXCEPT_COMMA_PERIOD(
                                                        NEW.ALTURA_SULCOS_BANDA_EDITAVEL), ',', '.')::REAL;
                                IF (NEW.ALTURA_SULCOS_BANDA_FORMATADA_IMPORT < F_ALTURA_MIN_SULCOS)
                                THEN
                                    F_ERRO_SULCOS := TRUE;
                                    F_QTD_ERROS = F_QTD_ERROS + 1;
                                    F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                          '- A ALTURA DOS SULCOS DA BANDA NÃO PODE SER MENOR QUE 1mm',
                                                          F_QUEBRA_LINHA);
                                ELSE
                                    IF (NEW.ALTURA_SULCOS_BANDA_FORMATADA_IMPORT > F_ALTURA_MAX_SULCOS)
                                    THEN
                                        F_ERRO_SULCOS := TRUE;
                                        F_QTD_ERROS = F_QTD_ERROS + 1;
                                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                              '- A ALTURA DOS SULCOS DA BANDA NÃO PODE SER MAIOR ' ||
                                                              'QUE 50mm',
                                                              F_QUEBRA_LINHA);
                                    END IF;
                                END IF;
                            EXCEPTION
                                WHEN invalid_text_representation THEN -- error that can be handled
                                    F_ERRO_SULCOS := TRUE;
                                    F_QTD_ERROS = F_QTD_ERROS + 1;
                                    F_MSGS_ERROS =
                                            concat(F_MSGS_ERROS, F_QTD_ERROS,
                                                   '- ALTURA DOS SULCOS DE BANDA COM VALOR INCORRETO',
                                                   F_QUEBRA_LINHA);
                            END;
                        ELSE
                            F_ERRO_SULCOS := TRUE;
                            F_QTD_ERROS = F_QTD_ERROS + 1;
                            F_MSGS_ERROS =
                                    concat(F_MSGS_ERROS, F_QTD_ERROS,
                                           '- A ALTURA DOS SULCOS DE BANDA NÃO PODE SER NULA',
                                           F_QUEBRA_LINHA);
                        END IF;
                        IF (F_ERRO_SULCOS = FALSE)
                        THEN
                            INSERT INTO MODELO_BANDA (NOME, COD_MARCA, COD_EMPRESA, QT_SULCOS, ALTURA_SULCOS)
                            VALUES (NEW.MODELO_BANDA_EDITAVEL, F_COD_MARCA_BANDA_BANCO, F_COD_EMPRESA,
                                    NEW.QTD_SULCOS_BANDA_FORMATADA_IMPORT,
                                    NEW.ALTURA_SULCOS_BANDA_FORMATADA_IMPORT) RETURNING CODIGO INTO F_COD_MODELO_BANDA_BANCO;
                        END IF;
                    END IF;
                END IF;
                --ELSE MARCA DE BANDA
            END IF;

            --VERIFICAÇÕES VALOR DE BANDA.
            IF (NEW.VALOR_BANDA_EDITAVEL IS NULL)
            THEN
                F_QTD_ERROS = F_QTD_ERROS + 1;
                F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS,
                                      '- O VALOR DA BANDA NÃO PODE SER NULO PARA PNEUS ACIMA DA PRIMEIRA VIDA',
                                      F_QUEBRA_LINHA);
            ELSE
                BEGIN
                    NEW.VALOR_BANDA_FORMATADO_IMPORT :=
                            REPLACE(REMOVE_NON_NUMERIC_CHARACTERS_EXCEPT_COMMA_PERIOD(
                                            NEW.VALOR_BANDA_EDITAVEL), ',', '.')::REAL;
                    IF (NEW.VALOR_BANDA_FORMATADO_IMPORT < 0)
                    THEN
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS = concat(F_MSGS_ERROS, F_QTD_ERROS, '- O VALOR DA BANDA NÃO PODE SER NEGATIVO',
                                              F_QUEBRA_LINHA);
                    END IF;
                EXCEPTION
                    WHEN invalid_text_representation THEN -- error that can be handled
                        F_QTD_ERROS = F_QTD_ERROS + 1;
                        F_MSGS_ERROS =
                                concat(F_MSGS_ERROS, F_QTD_ERROS, '- VALOR DO PNEU COM CARACTERES INCORRETOS',
                                       F_QUEBRA_LINHA);
                END;
            END IF;
        END IF;

        IF (F_QTD_ERROS > 0)
        THEN
            NEW.ERROS_ENCONTRADOS = F_MSGS_ERROS;
        ELSE
            INSERT INTO PNEU (CODIGO_CLIENTE,
                              COD_MODELO,
                              COD_DIMENSAO,
                              PRESSAO_RECOMENDADA,
                              COD_UNIDADE,
                              STATUS,
                              VIDA_ATUAL,
                              VIDA_TOTAL,
                              PNEU_NOVO_NUNCA_RODADO,
                              COD_MODELO_BANDA,
                              DOT,
                              VALOR,
                              COD_EMPRESA,
                              COD_UNIDADE_CADASTRO)
            VALUES (NEW.NUMERO_FOGO_FORMATADO_IMPORT,
                    F_COD_MODELO_BANCO,
                    F_COD_DIMENSAO,
                    NEW.PRESSAO_RECOMENDADA_FORMATADA_IMPORT,
                    NEW.COD_UNIDADE,
                    'ESTOQUE',
                    NEW.VIDA_ATUAL_FORMATADA_IMPORT,
                    NEW.VIDA_TOTAL_FORMATADA_IMPORT,
                    NEW.PNEU_NOVO_NUNCA_RODADO_FORMATADO_IMPORT,
                    F_COD_MODELO_BANDA_BANCO,
                    NEW.DOT_FORMATADO_IMPORT,
                    NEW.VALOR_PNEU_FORMATADO_IMPORT,
                    F_COD_EMPRESA,
                    NEW.COD_UNIDADE) RETURNING CODIGO INTO F_COD_PNEU;


            IF (NEW.VIDA_ATUAL_FORMATADA_IMPORT > 1)
            THEN
                SELECT PTS.CODIGO AS CODIGO
                FROM PNEU_TIPO_SERVICO AS PTS
                WHERE PTS.COD_EMPRESA IS NULL
                  AND PTS.STATUS_ATIVO = TRUE
                  AND PTS.INCREMENTA_VIDA = TRUE
                  AND PTS.UTILIZADO_CADASTRO_PNEU = TRUE
                INTO F_COD_TIPO_SERVICO;

                INSERT INTO PNEU_SERVICO_REALIZADO (COD_TIPO_SERVICO,
                                                    COD_UNIDADE,
                                                    COD_PNEU,
                                                    CUSTO,
                                                    VIDA,
                                                    FONTE_SERVICO_REALIZADO)
                VALUES (F_COD_TIPO_SERVICO,
                        NEW.COD_UNIDADE,
                        F_COD_PNEU,
                        NEW.VALOR_BANDA_FORMATADO_IMPORT,
                        (NEW.VIDA_ATUAL_FORMATADA_IMPORT - 1),
                        'FONTE_CADASTRO') RETURNING CODIGO INTO F_COD_SERVICO_REALIZADO;

                INSERT INTO PNEU_SERVICO_REALIZADO_INCREMENTA_VIDA (COD_SERVICO_REALIZADO,
                                                                    COD_MODELO_BANDA,
                                                                    VIDA_NOVA_PNEU,
                                                                    FONTE_SERVICO_REALIZADO)
                VALUES (F_COD_SERVICO_REALIZADO,
                        F_COD_MODELO_BANDA_BANCO,
                        NEW.VIDA_ATUAL_FORMATADA_IMPORT,
                        'FONTE_CADASTRO');

                INSERT INTO PNEU_SERVICO_CADASTRO (COD_PNEU,
                                                   COD_SERVICO_REALIZADO)
                VALUES (F_COD_PNEU, F_COD_SERVICO_REALIZADO);
            END IF;
            NEW.STATUS_IMPORT_REALIZADO = TRUE;
            NEW.ERROS_ENCONTRADOS = '-';
        END IF;
    END IF;
    RETURN NEW;
END;
$$;

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_54_cod_unidade_369_2020_1_17_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_59_cod_unidade_370_2020_1_23_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_6_cod_unidade_209_2020_1_29_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_24_cod_unidade_372_2020_1_29_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_16_cod_unidade_218_2020_2_3_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_6_cod_unidade_83_2020_2_4_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_6_cod_unidade_85_2020_2_4_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_6_cod_unidade_84_2020_2_5_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_6_cod_unidade_74_2020_2_5_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create trigger tg_func_import_pneu
    before insert or update
    on implantacao.p_cod_emp_61_cod_unidade_380_2020_3_3_natan
    for each row
execute procedure implantacao.tg_func_pneu_confere_planilha_importa_pneu();

create or replace function public.remove_non_numeric_characters_except_comma_period(f_texto text) returns text
    immutable
    strict
    language plpgsql
as
$$
BEGIN
    -- Remove letras, characteres especiais e espaços, exceto vírgula e ponto final..
    -- A flag 'g' indica que serão removidas todas as aparições do padrão específicado não somente o primeiro caso.
    RETURN REGEXP_REPLACE(F_TEXTO, '[^-,.0-9]+', '', 'g');
END;
$$;

create or replace function public.func_relatorio_pneu_afericoes_avulsas(f_cod_unidades bigint[], f_data_inicial date, f_data_final date)
    returns TABLE
            (
                "DATA/HORA AFERIÇÃO"    text,
                "QUEM AFERIU?"          character varying,
                "UNIDADE ALOCADO"       character varying,
                "PNEU"                  character varying,
                "MARCA"                 character varying,
                "MODELO"                character varying,
                "MEDIDAS"               text,
                "SULCO INTERNO"         text,
                "SULCO CENTRAL INTERNO" text,
                "SULCO CENTRAL EXTERNO" text,
                "SULCO EXTERNO"         text,
                "MENOR SULCO"           text,
                "PRESSÃO"               text,
                "TIPO DE MEDIÇÃO"       text,
                "VIDA"                  text,
                "DOT"                   character varying
            )
    language plpgsql
as
$$
DECLARE
    DATE_FORMAT                   TEXT := 'DD/MM/YYYY HH24:MI';
    PNEU_NUNCA_AFERIDO            TEXT := 'Nunca Aferido';
    PROCESSO_AFERICAO_PNEU_AVULSO TEXT := 'PNEU_AVULSO';
BEGIN
    RETURN QUERY
        SELECT COALESCE(TO_CHAR(A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE), DATE_FORMAT),
                        PNEU_NUNCA_AFERIDO)                                                  AS ULTIMA_AFERICAO,
               C.NOME,
               U.NOME                                                                        AS UNIDADE_ALOCADO,
               P.CODIGO_CLIENTE                                                              AS COD_PNEU,
               MAP.NOME                                                                      AS NOME_MARCA,
               MP.NOME                                                                       AS NOME_MODELO,
               ((((DP.LARGURA || '/'::TEXT) || DP.ALTURA) || ' R'::TEXT) || DP.ARO)          AS MEDIDAS,
               FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_INTERNO)                               AS SULCO_INTERNO,
               FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_CENTRAL_INTERNO)                       AS SULCO_CENTRAL_INTERNO,
               FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_CENTRAL_EXTERNO)                       AS SULCO_CENTRAL_EXTERNO,
               FUNC_PNEU_FORMAT_SULCO(AV.ALTURA_SULCO_EXTERNO)                               AS SULCO_EXTERNO,
               FUNC_PNEU_FORMAT_SULCO(LEAST(AV.ALTURA_SULCO_EXTERNO, AV.ALTURA_SULCO_CENTRAL_EXTERNO,
                                            AV.ALTURA_SULCO_CENTRAL_INTERNO,
                                            AV.ALTURA_SULCO_INTERNO))                        AS MENOR_SULCO,
               REPLACE(COALESCE(TRUNC(AV.PSI :: NUMERIC, 1) :: TEXT, '-'), '.', ',') :: TEXT AS PRESSAO,
               A.TIPO_MEDICAO_COLETADA :: TEXT                                               AS TIPO_MEDICAO,
               P.VIDA_ATUAL::TEXT                                                            AS VIDA_ATUAL,
               COALESCE(P.DOT, '-')                                                          AS DOT
        FROM PNEU P
                 JOIN DIMENSAO_PNEU DP ON DP.CODIGO = P.COD_DIMENSAO
                 JOIN UNIDADE U ON U.CODIGO = P.COD_UNIDADE
                 JOIN MODELO_PNEU MP ON MP.CODIGO = P.COD_MODELO AND MP.COD_EMPRESA = U.COD_EMPRESA
                 JOIN MARCA_PNEU MAP ON MAP.CODIGO = MP.COD_MARCA
                 JOIN AFERICAO_VALORES AV ON AV.COD_PNEU = P.CODIGO
                 JOIN AFERICAO A ON A.CODIGO = AV.COD_AFERICAO
                 JOIN COLABORADOR C ON A.CPF_AFERIDOR = C.CPF
        WHERE P.COD_UNIDADE = ANY (F_COD_UNIDADES)
          AND A.TIPO_PROCESSO_COLETA = PROCESSO_AFERICAO_PNEU_AVULSO
          AND (A.DATA_HORA AT TIME ZONE TZ_UNIDADE(A.COD_UNIDADE))::DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
        ORDER BY U.NOME ASC, ULTIMA_AFERICAO DESC NULLS LAST;
END;
$$;

create or replace function public.func_afericao_upsert_config_alerta_sulco(f_codigo bigint, f_cod_unidade bigint,
                                                                           f_variacao_sulco_menor double precision,
                                                                           f_variacao_sulco_maior double precision,
                                                                           f_bloquear_valores_menores boolean,
                                                                           f_bloquear_valores_maiores boolean) returns boolean
    language plpgsql
as
$$
BEGIN
    IF F_CODIGO IS NULL
    THEN
        INSERT INTO AFERICAO_CONFIGURACAO_ALERTA_SULCO (COD_UNIDADE,
                                                        VARIACAO_ACEITA_SULCO_MENOR_MILIMETROS,
                                                        VARIACAO_ACEITA_SULCO_MAIOR_MILIMETROS,
                                                        BLOQUEAR_VALORES_MENORES,
                                                        BLOQUEAR_VALORES_MAIORES)
        VALUES (F_COD_UNIDADE,
                F_VARIACAO_SULCO_MENOR,
                F_VARIACAO_SULCO_MAIOR,
                F_BLOQUEAR_VALORES_MENORES,
                F_BLOQUEAR_VALORES_MAIORES);
    ELSE
        UPDATE AFERICAO_CONFIGURACAO_ALERTA_SULCO
        SET VARIACAO_ACEITA_SULCO_MENOR_MILIMETROS = F_VARIACAO_SULCO_MENOR,
            VARIACAO_ACEITA_SULCO_MAIOR_MILIMETROS = F_VARIACAO_SULCO_MAIOR,
            BLOQUEAR_VALORES_MENORES               = F_BLOQUEAR_VALORES_MENORES,
            BLOQUEAR_VALORES_MAIORES               = F_BLOQUEAR_VALORES_MAIORES
        WHERE CODIGO = F_CODIGO;
    END IF;

    -- Validamos se houve alguma inserção ou atualização dos valores.
    IF NOT FOUND
    THEN
        PERFORM THROW_GENERIC_ERROR(FORMAT('Erro ao atualizar configurações da unidade %s', F_COD_UNIDADE));
    END IF;

    RETURN FOUND;
END;
$$;

create or replace function public.func_afericao_get_configuracoes_nova_afericao_avulsa(f_cod_pneu bigint)
    returns TABLE
            (
                sulco_minimo_descarte                  real,
                sulco_minimo_recapagem                 real,
                tolerancia_calibragem                  real,
                tolerancia_inspecao                    real,
                periodo_afericao_sulco                 integer,
                periodo_afericao_pressao               integer,
                variacao_aceita_sulco_menor_milimetros double precision,
                variacao_aceita_sulco_maior_milimetros double precision,
                bloquear_valores_menores               boolean,
                bloquear_valores_maiores               boolean,
                variacoes_sulco_default_prolog         boolean
            )
    language plpgsql
as
$$
DECLARE
    F_COD_UNIDADE BIGINT;
BEGIN
    SELECT INTO F_COD_UNIDADE P.COD_UNIDADE
    FROM PNEU P
    WHERE P.CODIGO = F_COD_PNEU;

    RETURN QUERY
        SELECT PRU.SULCO_MINIMO_DESCARTE                                  AS SULCO_MINIMO_DESCARTE,
               PRU.SULCO_MINIMO_RECAPAGEM                                 AS SULCO_MINIMO_RECAPAGEM,
               PRU.TOLERANCIA_INSPECAO                                    AS TOLERANCIA_INSPECAO,
               PRU.TOLERANCIA_CALIBRAGEM                                  AS TOLERANCIA_CALIBRAGEM,
               PRU.PERIODO_AFERICAO_SULCO                                 AS PERIODO_AFERICAO_SULCO,
               PRU.PERIODO_AFERICAO_PRESSAO                               AS PERIODO_AFERICAO_PRESSAO,
               CONFIG_ALERTA_SULCO.VARIACAO_ACEITA_SULCO_MENOR_MILIMETROS AS VARIACAO_ACEITA_SULCO_MENOR_MILIMETROS,
               CONFIG_ALERTA_SULCO.VARIACAO_ACEITA_SULCO_MAIOR_MILIMETROS AS VARIACAO_ACEITA_SULCO_MAIOR_MILIMETROS,
               CONFIG_ALERTA_SULCO.BLOQUEAR_VALORES_MENORES               AS BLOQUEAR_VALORES_MENORES,
               CONFIG_ALERTA_SULCO.BLOQUEAR_VALORES_MAIORES               AS BLOQUEAR_VALORES_MAIORES,
               CONFIG_ALERTA_SULCO.USA_DEFAULT_PROLOG                     AS VARIACOES_SULCO_DEFAULT_PROLOG
        FROM VIEW_AFERICAO_CONFIGURACAO_ALERTA_SULCO CONFIG_ALERTA_SULCO
                 JOIN PNEU_RESTRICAO_UNIDADE PRU
                      ON PRU.COD_UNIDADE = CONFIG_ALERTA_SULCO.COD_UNIDADE
        WHERE CONFIG_ALERTA_SULCO.COD_UNIDADE = F_COD_UNIDADE;
END;
$$;

create or replace function public.func_afericao_get_configuracoes_nova_afericao_placa(f_placa_veiculo text)
    returns TABLE
            (
                sulco_minimo_descarte                  real,
                sulco_minimo_recapagem                 real,
                tolerancia_calibragem                  real,
                tolerancia_inspecao                    real,
                periodo_afericao_sulco                 integer,
                periodo_afericao_pressao               integer,
                pode_aferir_sulco                      boolean,
                pode_aferir_pressao                    boolean,
                pode_aferir_sulco_pressao              boolean,
                pode_aferir_estepe                     boolean,
                variacao_aceita_sulco_menor_milimetros double precision,
                variacao_aceita_sulco_maior_milimetros double precision,
                bloquear_valores_menores               boolean,
                bloquear_valores_maiores               boolean,
                variacoes_sulco_default_prolog         boolean
            )
    language plpgsql
as
$$
DECLARE
    F_COD_UNIDADE      BIGINT;
    F_COD_TIPO_VEICULO BIGINT;
BEGIN
    SELECT INTO F_COD_UNIDADE, F_COD_TIPO_VEICULO V.COD_UNIDADE,
                                                  V.COD_TIPO
    FROM VEICULO V
    WHERE V.PLACA = F_PLACA_VEICULO;

    RETURN QUERY
        SELECT PRU.SULCO_MINIMO_DESCARTE,
               PRU.SULCO_MINIMO_RECAPAGEM,
               PRU.TOLERANCIA_INSPECAO,
               PRU.TOLERANCIA_CALIBRAGEM,
               PRU.PERIODO_AFERICAO_SULCO,
               PRU.PERIODO_AFERICAO_PRESSAO,
               CONFIG_PODE_AFERIR.PODE_AFERIR_SULCO,
               CONFIG_PODE_AFERIR.PODE_AFERIR_PRESSAO,
               CONFIG_PODE_AFERIR.PODE_AFERIR_SULCO_PRESSAO,
               CONFIG_PODE_AFERIR.PODE_AFERIR_ESTEPE,
               CONFIG_ALERTA_SULCO.VARIACAO_ACEITA_SULCO_MENOR_MILIMETROS,
               CONFIG_ALERTA_SULCO.VARIACAO_ACEITA_SULCO_MAIOR_MILIMETROS,
               CONFIG_ALERTA_SULCO.BLOQUEAR_VALORES_MENORES,
               CONFIG_ALERTA_SULCO.BLOQUEAR_VALORES_MAIORES,
               CONFIG_ALERTA_SULCO.USA_DEFAULT_PROLOG AS VARIACOES_SULCO_DEFAULT_PROLOG
        FROM FUNC_AFERICAO_GET_CONFIG_TIPO_AFERICAO_VEICULO(F_COD_UNIDADE) AS CONFIG_PODE_AFERIR
                 JOIN VIEW_AFERICAO_CONFIGURACAO_ALERTA_SULCO AS CONFIG_ALERTA_SULCO
                      ON CONFIG_PODE_AFERIR.COD_UNIDADE_CONFIGURACAO = CONFIG_ALERTA_SULCO.COD_UNIDADE
                 JOIN PNEU_RESTRICAO_UNIDADE PRU
                      ON PRU.COD_UNIDADE = CONFIG_PODE_AFERIR.COD_UNIDADE_CONFIGURACAO
        WHERE CONFIG_PODE_AFERIR.COD_UNIDADE_CONFIGURACAO = F_COD_UNIDADE
          AND CONFIG_PODE_AFERIR.COD_TIPO_VEICULO = F_COD_TIPO_VEICULO;
END;
$$;

create or replace function public.func_afericao_get_config_alerta_coleta_sulco(f_cod_colaborador bigint)
    returns TABLE
            (
                cod_unidade                            bigint,
                nome_unidade                           text,
                codigo                                 bigint,
                variacao_aceita_sulco_menor_milimetros double precision,
                variacao_aceita_sulco_maior_milimetros double precision,
                bloquear_valores_menores               boolean,
                bloquear_valores_maiores               boolean
            )
    language plpgsql
as
$$
DECLARE
    VARIACAO_MENOR_DEFAULT           DOUBLE PRECISION := (SELECT AP.VARIACAO_ACEITA_SULCO_MENOR_MILIMETROS
                                                          FROM AFERICAO_CONFIGURACAO_PROLOG AP);
    VARIACAO_MAIOR_DEFAULT           DOUBLE PRECISION := (SELECT AP.VARIACAO_ACEITA_SULCO_MAIOR_MILIMETROS
                                                          FROM AFERICAO_CONFIGURACAO_PROLOG AP);
    BLOQUEAR_VALORES_MENORES_DEFAULT BOOLEAN          := (SELECT AP.BLOQUEAR_VALORES_MENORES
                                                          FROM AFERICAO_CONFIGURACAO_PROLOG AP);
    BLOQUEAR_VALORES_MAIORES_DEFAULT BOOLEAN          := (SELECT AP.BLOQUEAR_VALORES_MAIORES
                                                          FROM AFERICAO_CONFIGURACAO_PROLOG AP);
BEGIN
    RETURN QUERY
        WITH UNIDADES_ACESSO AS (
            SELECT DISTINCT ON (F.CODIGO_UNIDADE) F.CODIGO_UNIDADE,
                                                  F.NOME_UNIDADE
            FROM FUNC_COLABORADOR_GET_UNIDADES_ACESSO(F_COD_COLABORADOR) F
        )

        SELECT
            -- Precisamos utilizar o código de unidade de UA pois a unidade pode não possuir config criada e ainda
            -- assim precisamos retornar o código dela.
            UA.CODIGO_UNIDADE,
            UA.NOME_UNIDADE,
            CONFIG.CODIGO,
            COALESCE(CONFIG.VARIACAO_ACEITA_SULCO_MENOR_MILIMETROS, VARIACAO_MENOR_DEFAULT),
            COALESCE(CONFIG.VARIACAO_ACEITA_SULCO_MAIOR_MILIMETROS, VARIACAO_MAIOR_DEFAULT),
            COALESCE(CONFIG.BLOQUEAR_VALORES_MENORES, BLOQUEAR_VALORES_MENORES_DEFAULT),
            COALESCE(CONFIG.BLOQUEAR_VALORES_MAIORES, BLOQUEAR_VALORES_MAIORES_DEFAULT)
        FROM UNIDADES_ACESSO UA
                 LEFT JOIN AFERICAO_CONFIGURACAO_ALERTA_SULCO CONFIG
                           ON UA.CODIGO_UNIDADE = CONFIG.COD_UNIDADE
        ORDER BY UA.NOME_UNIDADE;
END;
$$;

create or replace function integracao.func_pneu_carga_inicial_pneu_prolog(f_cod_pneu_sistema_integrado bigint,
                                                                          f_codigo_pneu_cliente character varying,
                                                                          f_cod_unidade_pneu bigint,
                                                                          f_cod_modelo_pneu bigint,
                                                                          f_cod_dimensao_pneu bigint,
                                                                          f_pressao_correta_pneu double precision,
                                                                          f_vida_atual_pneu integer,
                                                                          f_vida_total_pneu integer,
                                                                          f_dot_pneu character varying,
                                                                          f_valor_pneu numeric,
                                                                          f_pneu_novo_nunca_rodado boolean,
                                                                          f_cod_modelo_banda_pneu bigint,
                                                                          f_valor_banda_pneu numeric,
                                                                          f_status_pneu character varying,
                                                                          f_placa_veiculo_pneu_aplicado character varying,
                                                                          f_posicao_veiculo_pneu_aplicado integer,
                                                                          f_data_hora_pneu_cadastro timestamp with time zone,
                                                                          f_token_integracao character varying) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_PNEU                 BIGINT  := (SELECT TI.COD_EMPRESA
                                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_VEICULO_PROLOG               BIGINT  := (SELECT V.CODIGO
                                                 FROM PUBLIC.VEICULO V
                                                 WHERE V.PLACA = F_PLACA_VEICULO_PNEU_APLICADO
                                                   AND V.COD_UNIDADE IN (SELECT U.CODIGO
                                                                         FROM PUBLIC.UNIDADE U
                                                                         WHERE U.COD_EMPRESA = COD_EMPRESA_PNEU));
    IS_POSICAO_ESTEPE                BOOLEAN := F_IF(F_POSICAO_VEICULO_PNEU_APLICADO >= 900
                                                         AND F_POSICAO_VEICULO_PNEU_APLICADO <= 908, TRUE, FALSE);
    STATUS_APLICADO_VEICULO CONSTANT TEXT    := 'EM_USO';
    DEVE_SOBRESCREVER_PNEU           BOOLEAN := (SELECT *
                                                 FROM INTEGRACAO.FUNC_EMPRESA_GET_CONFIG_SOBRESCREVE_PNEUS(
                                                              COD_EMPRESA_PNEU));
    COD_PNEU_PROLOG                  BIGINT;
    F_QTD_ROWS_ALTERADAS             BIGINT;
BEGIN
    -- Inserimos o pneu utilizando a function de inserção padrão. Essa function pode sobrescrever as informações do
    -- pneu caso for necessário.
    SELECT *
    FROM INTEGRACAO.FUNC_PNEU_INSERE_PNEU_PROLOG(
                 F_COD_PNEU_SISTEMA_INTEGRADO,
                 F_CODIGO_PNEU_CLIENTE,
                 F_COD_UNIDADE_PNEU,
                 F_COD_MODELO_PNEU,
                 F_COD_DIMENSAO_PNEU,
                 F_PRESSAO_CORRETA_PNEU,
                 F_VIDA_ATUAL_PNEU,
                 F_VIDA_TOTAL_PNEU,
                 F_DOT_PNEU,
                 F_VALOR_PNEU,
                 F_PNEU_NOVO_NUNCA_RODADO,
                 F_COD_MODELO_BANDA_PNEU,
                 F_VALOR_BANDA_PNEU,
                 F_DATA_HORA_PNEU_CADASTRO,
                 F_TOKEN_INTEGRACAO,
                 DEVE_SOBRESCREVER_PNEU)
    INTO COD_PNEU_PROLOG;

    -- Validamos se a inserção do pneu aconteceu com sucesso.
    IF (COD_PNEU_PROLOG IS NULL OR COD_PNEU_PROLOG <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Não foi possível cadastrar o pneu %s no Sistema ProLog',
                                                  F_CODIGO_PNEU_CLIENTE));
    END IF;

    -- Atualiza o pneu para o status em que ele deve estar.
    UPDATE PUBLIC.PNEU
    SET STATUS = F_STATUS_PNEU
    WHERE CODIGO = COD_PNEU_PROLOG;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Validamos se o status do pneu foi atualizado com sucesso
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('Não foi possível inserir o pneu %s com status %s',
                                                  F_CODIGO_PNEU_CLIENTE,
                                                  F_STATUS_PNEU));
    END IF;

    -- Precisamos vincular o pneu ao veículo apenas se o status for aplicado.
    IF (F_STATUS_PNEU = STATUS_APLICADO_VEICULO)
    THEN
        -- Transferimos o pneu para a unidade do veículo, caso ele já não esteja.
        IF ((SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG) <> F_COD_UNIDADE_PNEU)
        THEN
            UPDATE PUBLIC.PNEU
            SET COD_UNIDADE = (SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG)
            WHERE CODIGO = COD_PNEU_PROLOG;

            SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG INTO F_COD_UNIDADE_PNEU;
        END IF;

        PERFORM INTEGRACAO.FUNC_PNEU_VINCULA_PNEU_POSICAO_PLACA(COD_VEICULO_PROLOG,
                                                                F_PLACA_VEICULO_PNEU_APLICADO,
                                                                COD_PNEU_PROLOG,
                                                                F_CODIGO_PNEU_CLIENTE,
                                                                F_COD_UNIDADE_PNEU,
                                                                F_POSICAO_VEICULO_PNEU_APLICADO,
                                                                IS_POSICAO_ESTEPE);
    END IF;
    RETURN COD_PNEU_PROLOG;
END;
$$;

create or replace function integracao.func_pneu_lista_marcas_modelos_banda_empresa(f_token_integracao text, apenas_marcas_pneu_ativas boolean)
    returns TABLE
            (
                cod_marca_banda                bigint,
                nome_marca_banda               text,
                status_ativo_marca_bada        boolean,
                cod_modelo_banda               bigint,
                nome_modelo_banda              text,
                cod_empresa_marca_modelo_banda bigint,
                qtd_sulcos_modelo_banda        integer,
                altura_sulcos_modelo_banda     real,
                status_ativo_modelo_banda      boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT MB.CODIGO                      AS COD_MARCA_BANDA,
               MB.NOME::TEXT                  AS NOME_MARCA_BANDA,
               TRUE                           AS STATUS_ATIVO_MARCA_BADA,
               MBE.COD_MODELO_BANDA           AS COD_MODELO_BANDA,
               MBE.NOME_MODELO_BANDA          AS NOME_MODELO_BANDA,
               MBE.COD_EMPRESA_MODELO_BANDA   AS COD_EMPRESA_MARCA_MODELO_BANDA,
               MBE.QTD_SULCOS_MODELO_BANDA    AS QTD_SULCOS_MODELO_BANDA,
               MBE.ALTURA_SULCOS_MODELO_BANDA AS ALTURA_SULCOS_MODELO_BANDA,
               MBE.STATUS_ATIVO_MODELO_BANDA  AS STATUS_ATIVO_MODELO_BANDA
        FROM PUBLIC.MARCA_BANDA MB
                 LEFT JOIN (SELECT * FROM INTEGRACAO.FUNC_PNEU_LISTA_MODELOS_BANDAS_EMPRESA(F_TOKEN_INTEGRACAO)) MBE
                           ON MBE.COD_MARCA_BANDA = MB.CODIGO
        WHERE MB.COD_EMPRESA IN (SELECT TI.COD_EMPRESA
                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)
        ORDER BY MB.CODIGO, MBE.COD_MODELO_BANDA;
END;
$$;

create or replace function integracao.func_pneu_lista_modelos_bandas_empresa(f_token_integracao text,
                                                                             f_cod_marca_banda bigint DEFAULT NULL::bigint,
                                                                             f_apenas_modelos_banda_ativos boolean DEFAULT true)
    returns TABLE
            (
                cod_empresa_modelo_banda   bigint,
                cod_marca_banda            bigint,
                cod_modelo_banda           bigint,
                nome_modelo_banda          text,
                qtd_sulcos_modelo_banda    integer,
                altura_sulcos_modelo_banda real,
                status_ativo_modelo_banda  boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT MB.COD_EMPRESA        AS COD_EMPRESA_MODELO_BANDA,
               MB.COD_MARCA          AS COD_MARCA_BANDA,
               MB.CODIGO             AS COD_MODELO_BANDA,
               MB.NOME::TEXT         AS NOME_MODELO_BANDA,
               MB.QT_SULCOS::INTEGER AS QTD_SULCOS_MODELO_BANDA,
               MB.ALTURA_SULCOS      AS ALTURA_SULCOS_MODELO_BANDA,
               TRUE                  AS STATUS_ATIVO_MODELO_BANDA
        FROM PUBLIC.MODELO_BANDA MB
        WHERE MB.COD_EMPRESA IN (SELECT TI.COD_EMPRESA
                                 FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                 WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)
          AND F_IF(F_COD_MARCA_BANDA IS NULL, TRUE, MB.COD_MARCA = F_COD_MARCA_BANDA)
        ORDER BY MB.CODIGO;
END;
$$;

create or replace function public.func_pneu_get_cod_pneu_by_codigo_cliente(f_cod_empresa bigint, f_cod_cliente text[])
    returns TABLE
            (
                cod_pneu bigint
            )
    language sql
as
$$
SELECT P.CODIGO AS COD_PNEU
FROM PNEU P
WHERE P.COD_EMPRESA = F_COD_EMPRESA
  AND P.CODIGO_CLIENTE LIKE ANY (F_COD_CLIENTE);
$$;

create or replace function integracao.func_pneu_atualiza_status_pneu_prolog(f_cod_pneu_sistema_integrado bigint,
                                                                            f_codigo_pneu_cliente character varying,
                                                                            f_cod_unidade_pneu bigint,
                                                                            f_cpf_colaborador_alteracao_status character varying,
                                                                            f_data_hora_alteracao_status timestamp with time zone,
                                                                            f_status_pneu character varying,
                                                                            f_trocou_de_banda boolean,
                                                                            f_cod_novo_modelo_banda_pneu bigint,
                                                                            f_valor_nova_banda_pneu numeric,
                                                                            f_placa_veiculo_pneu_aplicado character varying,
                                                                            f_posicao_veiculo_pneu_aplicado integer,
                                                                            f_token_integracao character varying) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_PNEU            BIGINT  := (SELECT TI.COD_EMPRESA
                                            FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                            WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_VEICULO_PROLOG          BIGINT  := (SELECT V.CODIGO
                                            FROM PUBLIC.VEICULO V
                                            WHERE V.PLACA = F_PLACA_VEICULO_PNEU_APLICADO
                                              AND V.COD_UNIDADE IN (SELECT U.CODIGO
                                                                    FROM PUBLIC.UNIDADE U
                                                                    WHERE U.COD_EMPRESA = COD_EMPRESA_PNEU));
    IS_POSICAO_ESTEPE           BOOLEAN := F_IF(F_POSICAO_VEICULO_PNEU_APLICADO >= 900
                                                    AND F_POSICAO_VEICULO_PNEU_APLICADO <= 908, TRUE, FALSE);
    COD_PNEU_PROLOG             BIGINT  := (SELECT PC.COD_PNEU_CADASTRO_PROLOG
                                            FROM INTEGRACAO.PNEU_CADASTRADO PC
                                            WHERE PC.COD_PNEU_SISTEMA_INTEGRADO = F_COD_PNEU_SISTEMA_INTEGRADO
                                              AND PC.COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU);
    VIDA_ATUAL_PNEU             INTEGER := (SELECT P.VIDA_ATUAL
                                            FROM PUBLIC.PNEU P
                                            WHERE P.CODIGO = COD_PNEU_PROLOG);
    PROXIMA_VIDA_PNEU           INTEGER := VIDA_ATUAL_PNEU + 1;
    STATUS_APLICADO_VEICULO     TEXT    := 'EM_USO';
    COD_SERVICO_INCREMENTA_VIDA BIGINT;
    F_QTD_ROWS_ALTERADAS        BIGINT;
BEGIN
    -- Validamos se a Empresa é válida.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_PNEU,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    -- Validamos se a Unidade repassada existe.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE_PNEU,
                                        FORMAT('A Unidade %s repassada não existe no Sistema ProLog',
                                               F_COD_UNIDADE_PNEU));

    -- Validamos se a Unidade pertence a Empresa do token repassado.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(COD_EMPRESA_PNEU,
                                                F_COD_UNIDADE_PNEU,
                                                FORMAT('A Unidade %s não está configurada para esta empresa',
                                                       F_COD_UNIDADE_PNEU));

    -- Validamos se o código do pneu no sistema integrado está mapeado na tabela interna do ProLog.
    IF (COD_PNEU_PROLOG IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O pneu de código interno %s não está mapeado no Sistema ProLog',
                                                  F_COD_PNEU_SISTEMA_INTEGRADO));
    END IF;

    -- Deletamos o vinculo do pneu com a placa. Caso o pneu não estava vinculado, nada irá acontecer.
    DELETE FROM VEICULO_PNEU VP WHERE VP.COD_PNEU = COD_PNEU_PROLOG;

    -- Atualiza o pneu para o status em que ele deve estar.
    UPDATE PUBLIC.PNEU
    SET STATUS      = F_STATUS_PNEU,
        COD_UNIDADE = F_COD_UNIDADE_PNEU
    WHERE CODIGO = COD_PNEU_PROLOG;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Validamos se o status do pneu foi atualizado com sucesso
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('Não foi possível atualizar as informações do pneu %s para o status %s',
                               F_CODIGO_PNEU_CLIENTE,
                               F_STATUS_PNEU));
    END IF;

    -- Precisamos vincular o pneu ao veículo apenas se o status for aplicado.
    IF (F_STATUS_PNEU = STATUS_APLICADO_VEICULO)
    THEN
        -- Transferimos o pneu para a unidade do veículo, caso ele já não esteja.
        IF ((SELECT P.COD_UNIDADE FROM PUBLIC.PNEU P WHERE P.CODIGO = COD_PNEU_PROLOG) <> F_COD_UNIDADE_PNEU)
        THEN
            UPDATE PUBLIC.PNEU
            SET COD_UNIDADE = (SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG)
            WHERE CODIGO = COD_PNEU_PROLOG;

            SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG INTO F_COD_UNIDADE_PNEU;
        END IF;

        PERFORM INTEGRACAO.FUNC_PNEU_VINCULA_PNEU_POSICAO_PLACA(COD_VEICULO_PROLOG,
                                                                F_PLACA_VEICULO_PNEU_APLICADO,
                                                                COD_PNEU_PROLOG,
                                                                F_CODIGO_PNEU_CLIENTE,
                                                                F_COD_UNIDADE_PNEU,
                                                                F_POSICAO_VEICULO_PNEU_APLICADO,
                                                                IS_POSICAO_ESTEPE);
    END IF;

    IF (F_TROCOU_DE_BANDA)
    THEN
        -- Validamos se o código do modelo de banda é válido. Apenas validamos se o pneu possuir banda.
        IF (F_COD_NOVO_MODELO_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O código do modelo da banda deve ser informado');
        END IF;

        -- Validamos se o código do modelo da banda é válido. Apenas validamos se o pneu possuir banda.
        IF ((SELECT NOT EXISTS(SELECT MB.CODIGO
                               FROM PUBLIC.MODELO_BANDA MB
                               WHERE MB.COD_EMPRESA = COD_EMPRESA_PNEU
                                 AND MB.CODIGO = F_COD_NOVO_MODELO_BANDA_PNEU)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O modelo da banda do pneu %s não está mapeado no Sistema ProLog',
                                                      F_COD_NOVO_MODELO_BANDA_PNEU));
        END IF;

        -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
        IF (F_VALOR_NOVA_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da banda do pneu deve ser informado');
        END IF;

        -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
        IF (F_VALOR_NOVA_BANDA_PNEU < 0)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da banda do pneu não pode ser um número negativo');
        END IF;

        -- Busca serviço que incrementa a vida do pneu dentro da empresa em questão.
        SELECT *
        FROM PUBLIC.FUNC_PNEU_GET_SERVICO_INCREMENTA_VIDA_PNEU_EMPRESA(COD_EMPRESA_PNEU)
        INTO COD_SERVICO_INCREMENTA_VIDA;

        IF (COD_SERVICO_INCREMENTA_VIDA IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('Erro ao vincular banda ao pneu');
        END IF;

        -- Incrementa a vida do pneu simulando um processo de movimentação.
        PERFORM INTEGRACAO.FUNC_PNEU_REALIZA_INCREMENTO_VIDA_MOVIMENTACAO(F_COD_UNIDADE_PNEU,
                                                                          COD_PNEU_PROLOG,
                                                                          F_COD_NOVO_MODELO_BANDA_PNEU,
                                                                          F_VALOR_NOVA_BANDA_PNEU,
                                                                          PROXIMA_VIDA_PNEU,
                                                                          COD_SERVICO_INCREMENTA_VIDA);

        -- Após incrementar a vida e criar o serviço, atualizamos o pneu para ficar com a banda e a vida correta.
        PERFORM PUBLIC.FUNC_PNEUS_INCREMENTA_VIDA_PNEU(COD_PNEU_PROLOG, F_COD_NOVO_MODELO_BANDA_PNEU);
    END IF;

    -- Qualquer alteração de status do pneu deve verificar se o pneu tem serviços aberto e fechá-los.
    PERFORM INTEGRACAO.FUNC_PNEU_FECHA_SERVICO_PNEU_AUTOMATICAMENTE(COD_PNEU_PROLOG,
                                                                    F_DATA_HORA_ALTERACAO_STATUS);

    RETURN COD_PNEU_PROLOG;
END;
$$;

create or replace function migration_checklist.func_checklist_setar_versao_modelo() returns trigger
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_ATUALIZADAS BIGINT;
BEGIN
    UPDATE CHECKLIST_DATA
    SET COD_VERSAO_CHECKLIST_MODELO = NEW.COD_CHECKLIST_MODELO_VERSAO
    WHERE CODIGO = ANY (OLD.CHECKLISTS_REALIZADOS_VERSAO);

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF QTD_LINHAS_ATUALIZADAS IS NULL OR QTD_LINHAS_ATUALIZADAS <> ARRAY_LENGTH(OLD.CHECKLISTS_REALIZADOS_VERSAO, 1)
    THEN
        RAISE EXCEPTION 'Erro ao setar versão na tabela CHECKLIST_DATA';
    END IF;

    RETURN NEW;
END
$$;

create trigger tg_func_checklist_setar_versao_modelo
    after update
    on migration_checklist.migration_checklist_modelos
    for each row
execute procedure migration_checklist.func_checklist_setar_versao_modelo();

create or replace function migration_checklist.func_migration_1_cria_estrutura_versionamento_modelo() returns void
    language plpgsql
as
$$
begin
    --######################################################################################################################
    --######################################################################################################################
    --######################################### Migra estrutura da tabela de respostas #####################################
    --######################################################################################################################
    --######################################################################################################################
    -- PL-2184
    -- Dropa constraints e views necessárias.
    drop view estratificacao_os;
    alter table checklist_modelo_data
        drop constraint unico_modelo_por_unidade;
    alter table checklist_alternativa_pergunta_data
        drop constraint fk_checklist_alternativa_pergunta_pergunta;
    alter table checklist_perguntas_data
        drop constraint unica_pergunta_por_modelo;
    alter table checklist_alternativa_pergunta_data
        drop constraint unica_alternativa_por_pergunta;

    -- Recria constraint.
    alter table checklist_alternativa_pergunta_data
        add constraint fk_checklist_alternativa_pergunta_pergunta
            foreign key (cod_pergunta) references checklist_perguntas_data (codigo);

    -- Cria tabela para salvar as versões dos modelos de checklist.
    create table if not exists checklist_modelo_versao
    (
        cod_versao_checklist_modelo    bigserial                not null,
        cod_versao_user_friendly       bigint                   not null,
        cod_checklist_modelo           bigint                   not null,
        data_hora_criacao_versao       timestamp with time zone not null,
        cod_colaborador_criacao_versao bigint,
        constraint pk_checklist_modelo_versao
            primary key (cod_versao_checklist_modelo),
        constraint fk_checklist_modelo_versao_checklist_modelo
            foreign key (cod_checklist_modelo) references checklist_modelo_data (codigo) DEFERRABLE INITIALLY IMMEDIATE,
        constraint fk_checklist_modelo_versao_colaborador
            foreign key (cod_colaborador_criacao_versao) references colaborador_data (codigo),
        constraint unique_versao_user_friendly_modelo_checklist unique (cod_checklist_modelo, cod_versao_user_friendly),
        constraint unique_versao_modelo_checklist unique (cod_checklist_modelo, cod_versao_checklist_modelo)
    );

    comment on table checklist_modelo_versao is 'Salva as versões de um modelo de checklist. data_hora_criacao_versao e cod_colaborador_criacao_versao
    podem ser nulos pois na primeira versão não tínhamos quando foi criada e nem quem criou. Porém, existem checks que impedem que essas colunas
    sejam nulas em novas versões.';

    --######################################################################################################################
    -- CHECKLIST_MODELO_DATA
    -- Cria coluna de versão atual na tabela de modelo.
    alter table checklist_modelo_data
        add column cod_versao_atual bigint;
    alter table checklist_modelo_data
        add constraint fk_checklist_modelo_checklist_modelo_versao
            foreign key (cod_versao_atual)
                references checklist_modelo_versao (cod_versao_checklist_modelo) DEFERRABLE INITIALLY IMMEDIATE;

    drop view checklist_modelo;
    create or replace view checklist_modelo as
    select cm.cod_unidade,
           cm.codigo,
           cm.cod_versao_atual,
           cm.nome,
           cm.status_ativo
    from checklist_modelo_data cm
    where cm.deletado = false;
    --######################################################################################################################

    --######################################################################################################################
    -- CHECKLIST_DATA
    -- Cria versão na tabela CHECKLIST_DATA.
    alter table checklist_data
        add column cod_versao_checklist_modelo bigint;

    -- Dropa a view checklist
    drop view checklist;

    -- Recria a view checklist com a coluna cod_versao_checklist_modelo
    create view checklist(cod_unidade, cod_checklist_modelo, codigo, data_hora, data_hora_importado_prolog,
                          cpf_colaborador,
                          placa_veiculo, tipo, tempo_realizacao, km_veiculo, data_hora_sincronizacao,
                          fonte_data_hora_realizacao, versao_app_momento_realizacao, versao_app_momento_sincronizacao,
                          device_id, device_imei, device_uptime_realizacao_millis, device_uptime_sincronizacao_millis,
                          foi_offline, total_perguntas_ok, total_perguntas_nok, total_alternativas_ok,
                          total_alternativas_nok, cod_versao_checklist_modelo) as
    select c.cod_unidade,
           c.cod_checklist_modelo,
           c.codigo,
           c.data_hora,
           c.data_hora_importado_prolog,
           c.cpf_colaborador,
           c.placa_veiculo,
           c.tipo,
           c.tempo_realizacao,
           c.km_veiculo,
           c.data_hora_sincronizacao,
           c.fonte_data_hora_realizacao,
           c.versao_app_momento_realizacao,
           c.versao_app_momento_sincronizacao,
           c.device_id,
           c.device_imei,
           c.device_uptime_realizacao_millis,
           c.device_uptime_sincronizacao_millis,
           c.foi_offline,
           c.total_perguntas_ok,
           c.total_perguntas_nok,
           c.total_alternativas_ok,
           c.total_alternativas_nok,
           c.cod_versao_checklist_modelo
    from checklist_data c
    where (c.deletado = false);

    -- Essa constraint não precisa mais pois a fk com a versão já garante a existência do modelo.
    alter table checklist_data
        drop constraint fk_checklist_checklist_modelo;
    alter table checklist_data
        add constraint fk_checklist_data_checklist_modelo_versao
            foreign key (cod_checklist_modelo, cod_versao_checklist_modelo)
                references checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo);
    --######################################################################################################################

    --######################################################################################################################
    -- CHECKLIST_PERGUNTAS_DATA
    -- Cria versão na tabela CHECKLIST_PERGUNTAS_DATA.
    alter table checklist_perguntas_data
        add column cod_versao_checklist_modelo bigint;
    -- Para perguntas antigas (inativas) o código gerado será diferente da pergunta ativa atual. Iremos ignorar esses casos.
    alter table checklist_perguntas_data
        add column codigo_contexto bigserial not null;

    -- Constraint útil para servir como FK na COSI.
    alter table checklist_perguntas_data
        add constraint unica_pergunta_versao unique (codigo_contexto, codigo);

    drop view checklist_perguntas;
    create or replace view checklist_perguntas as
    select cp.cod_checklist_modelo,
           cp.cod_versao_checklist_modelo,
           cp.cod_unidade,
           cp.ordem,
           cp.pergunta,
           cp.status_ativo,
           cp.single_choice,
           cp.cod_imagem,
           cp.codigo,
           cp.codigo_contexto
    from checklist_perguntas_data cp
    where cp.deletado = false;
    --######################################################################################################################

    --######################################################################################################################
    -- CHECKLIST_ALTERNATIVA_PERGUNTA_DATA
    -- Cria versão na tabela CHECKLIST_ALTERNATIVA_PERGUNTA_DATA.
    alter table checklist_alternativa_pergunta_data
        add column cod_versao_checklist_modelo bigint;
    -- Para alternativas antigas (inativas) o código gerado será diferente da alternativas ativa atual.
    -- Iremos ignorar esses casos.
    alter table checklist_alternativa_pergunta_data
        add column codigo_contexto bigserial not null;

    -- Constraint útil para servir como FK na COSI.
    alter table checklist_alternativa_pergunta_data
        add constraint unica_alternativa_versao unique (codigo_contexto, codigo);

    drop view checklist_alternativa_pergunta;
    create or replace view checklist_alternativa_pergunta as
    select cap.cod_checklist_modelo,
           cap.cod_versao_checklist_modelo,
           cap.cod_unidade,
           cap.alternativa,
           cap.ordem,
           cap.status_ativo,
           cap.cod_pergunta,
           cap.codigo,
           cap.codigo_contexto,
           cap.alternativa_tipo_outros,
           cap.prioridade,
           cap.deve_abrir_ordem_servico
    from checklist_alternativa_pergunta_data cap
    where cap.deletado = false;
    --######################################################################################################################

    --######################################################################################################################
    delete from checklist_alternativa_pergunta_data where cod_checklist_modelo = 2;
    delete from checklist_perguntas_data where cod_checklist_modelo = 2;
    delete from checklist_modelo_funcao where cod_checklist_modelo = 2;
    delete from checklist_modelo_veiculo_tipo where cod_modelo = 2;
    delete from checklist_modelo_data where codigo = 2;
    --######################################################################################################################

    -- Cria as tabelas e functions que o JAVA irá utilizar.
    create table migration_checklist.check_perguntas_aux
    (
        cod_modelo          bigint not null references checklist_modelo_data (codigo),
        cod_modelo_versao   bigint not null references checklist_modelo_versao (cod_versao_checklist_modelo),
        cod_pergunta_antigo bigint not null references checklist_perguntas_data (codigo),
        cod_pergunta_novo   bigint not null references checklist_perguntas_data (codigo)
    );

    create index idx_perguntas_aux on migration_checklist.check_perguntas_aux (cod_pergunta_antigo, cod_modelo_versao);

    create table migration_checklist.check_alternativas_aux
    (
        cod_modelo             bigint not null references checklist_modelo_data (codigo),
        cod_modelo_versao      bigint not null references checklist_modelo_versao (cod_versao_checklist_modelo),
        cod_alternativa_antigo bigint not null references checklist_alternativa_pergunta_data (codigo),
        cod_alternativa_novo   bigint not null references checklist_alternativa_pergunta_data (codigo)
    );

    create index idx_alternativas_aux on migration_checklist.check_alternativas_aux (cod_alternativa_antigo, cod_modelo_versao);

    create or replace function migration_checklist.func_checklist_cria_versao_modelo(f_cod_modelo bigint,
                                                                                     f_cod_primeiro_check_versao_modelo bigint,
                                                                                     f_data_hora_atual timestamp with time zone)
        returns bigint
    as
    $func$
    declare
        cod_pergunta_criado          bigint;
        cod_alternativa_criado       bigint;
        pergunta_modelo_checklist    checklist_perguntas_data%rowtype;
        alternativa_modelo_checklist checklist_alternativa_pergunta_data%rowtype;
        qtd_linhas_inseridas         bigint;
        qtd_linhas_atualizadas       bigint;
        novo_cod_versao_modelo       bigint := nextval(
                pg_get_serial_sequence('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
    begin
        -- 1 -> Insere a versão.
        insert into checklist_modelo_versao(cod_versao_checklist_modelo,
                                            cod_versao_user_friendly,
                                            cod_checklist_modelo,
                                            data_hora_criacao_versao,
                                            cod_colaborador_criacao_versao)
        values (novo_cod_versao_modelo,
                (select coalesce(max(cmv.cod_versao_user_friendly) + 1, 1)
                 from checklist_modelo_versao cmv
                 where cmv.cod_checklist_modelo = f_cod_modelo),
                f_cod_modelo,
                f_data_hora_atual,
                null);

        get diagnostics qtd_linhas_inseridas = row_count;

        if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
        then
            raise exception 'Erro ao inserir versão do modelo';
        end if;
        --

        -- 2 -> Criamos as perguntas e alternativas, mesmo que seja a versão 1.
        -- insere as perguntas e alternativas.
        for pergunta_modelo_checklist in
            select cp.*
            from checklist_respostas cr
                     join checklist_perguntas_data cp on cp.codigo = cr.cod_pergunta
            where cr.cod_checklist = f_cod_primeiro_check_versao_modelo
            group by cr.cod_pergunta,
                     cp.cod_checklist_modelo,
                     cp.cod_unidade,
                     cp.ordem,
                     cp.pergunta,
                     cp.status_ativo,
                     cp.single_choice,
                     cp.cod_imagem,
                     cp.codigo,
                     cp.deletado,
                     cp.data_hora_deletado,
                     cp.codigo_contexto
            loop
                -- Pergunta.
                insert into checklist_perguntas_data (cod_checklist_modelo,
                                                      cod_unidade,
                                                      ordem,
                                                      pergunta,
                                                      status_ativo,
                                                      single_choice,
                                                      cod_imagem,
                                                      codigo_contexto,
                                                      cod_versao_checklist_modelo)
                values (pergunta_modelo_checklist.cod_checklist_modelo,
                        pergunta_modelo_checklist.cod_unidade,
                        pergunta_modelo_checklist.ordem,
                        pergunta_modelo_checklist.pergunta,
                        pergunta_modelo_checklist.status_ativo,
                        pergunta_modelo_checklist.single_choice,
                        pergunta_modelo_checklist.cod_imagem,
                        pergunta_modelo_checklist.codigo_contexto,
                        novo_cod_versao_modelo) returning codigo
                           into cod_pergunta_criado;

                insert into migration_checklist.check_perguntas_aux (cod_modelo,
                                                                     cod_modelo_versao,
                                                                     cod_pergunta_antigo,
                                                                     cod_pergunta_novo)
                values (f_cod_modelo, novo_cod_versao_modelo, pergunta_modelo_checklist.codigo, cod_pergunta_criado);

                get diagnostics qtd_linhas_inseridas = row_count;

                if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
                then
                    raise exception 'Erro ao inserir pergunta aux';
                end if;

                -- Alternativa.
                for alternativa_modelo_checklist in
                    select cap.*
                    from checklist_respostas cr
                             join checklist_alternativa_pergunta_data cap on cap.codigo = cr.cod_alternativa
                    where cr.cod_checklist = f_cod_primeiro_check_versao_modelo
                      and cr.cod_pergunta = pergunta_modelo_checklist.codigo
                    loop
                        insert into checklist_alternativa_pergunta_data (cod_checklist_modelo,
                                                                         cod_unidade,
                                                                         alternativa,
                                                                         ordem,
                                                                         status_ativo,
                                                                         cod_pergunta,
                                                                         alternativa_tipo_outros,
                                                                         prioridade,
                                                                         deve_abrir_ordem_servico,
                                                                         codigo_contexto,
                                                                         cod_versao_checklist_modelo)
                        values (alternativa_modelo_checklist.cod_checklist_modelo,
                                alternativa_modelo_checklist.cod_unidade,
                                alternativa_modelo_checklist.alternativa,
                                alternativa_modelo_checklist.ordem,
                                alternativa_modelo_checklist.status_ativo,
                                alternativa_modelo_checklist.cod_pergunta,
                                alternativa_modelo_checklist.alternativa_tipo_outros,
                                alternativa_modelo_checklist.prioridade,
                                alternativa_modelo_checklist.deve_abrir_ordem_servico,
                                alternativa_modelo_checklist.codigo_contexto,
                                novo_cod_versao_modelo) returning codigo
                                   into cod_alternativa_criado;

                        insert into migration_checklist.check_alternativas_aux (cod_modelo,
                                                                                cod_modelo_versao,
                                                                                cod_alternativa_antigo,
                                                                                cod_alternativa_novo)
                        values (f_cod_modelo,
                                novo_cod_versao_modelo,
                                alternativa_modelo_checklist.codigo,
                                cod_alternativa_criado);

                        get diagnostics qtd_linhas_inseridas = row_count;

                        if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
                        then
                            raise exception 'Erro ao inserir alternativa aux';
                        end if;

                    end loop;
            end loop;
        --

        -- 3 -> Atualiza na tabela de mapeamento da migração para setar a versão criada.
        -- Isso vai fazer a versão ser setada em todos os CHECKLIST_DATA.
        update migration_checklist.migration_checklist_modelos
        set cod_checklist_modelo_versao = novo_cod_versao_modelo
        where cod_checklist_modelo = f_cod_modelo
          and cod_checklist_primeira_realizacao_modelo = f_cod_primeiro_check_versao_modelo;

        get diagnostics qtd_linhas_atualizadas = row_count;

        if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas <> 1
        then
            raise exception 'Erro ao setar versão na tabela migration_checklist_modelos %, %',
                f_cod_modelo,
                f_cod_primeiro_check_versao_modelo;
        end if;
        --

        return novo_cod_versao_modelo;
    end
    $func$ language plpgsql;


    create or replace function migration_checklist.func_checklist_cria_modelo_ultima_versao(f_cod_modelo bigint,
                                                                                            f_data_hora_atual timestamp with time zone)
        returns bigint
        language plpgsql
    as
    $func$
    declare
        qtd_linhas_inseridas   bigint;
        qtd_linhas_atualizadas bigint;
        novo_cod_versao_modelo bigint := nextval(
                pg_get_serial_sequence('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
    begin
        -- 1 -> Insere a versão.
        insert into checklist_modelo_versao(cod_versao_checklist_modelo,
                                            cod_versao_user_friendly,
                                            cod_checklist_modelo,
                                            data_hora_criacao_versao,
                                            cod_colaborador_criacao_versao)
        values (novo_cod_versao_modelo,
                (select coalesce(max(cmv.cod_versao_user_friendly) + 1, 1)
                 from checklist_modelo_versao cmv
                 where cmv.cod_checklist_modelo = f_cod_modelo),
                f_cod_modelo,
                f_data_hora_atual,
                null);

        get diagnostics qtd_linhas_inseridas = row_count;

        if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
        then
            raise exception 'Erro ao inserir versão do modelo';
        end if;
        --

        -- 2 -> Atualiza modelo para setar versão atual.
        update checklist_modelo_data
        set cod_versao_atual = novo_cod_versao_modelo
        where codigo = f_cod_modelo
          and cod_versao_atual is null;

        get diagnostics qtd_linhas_atualizadas = row_count;

        if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas <> 1
        then
            raise exception 'Erro ao setar versão na tabela checklist_modelo_data, %, %, %',
                f_cod_modelo,
                novo_cod_versao_modelo,
                (select cod_versao_atual from checklist_modelo_data where codigo = f_cod_modelo);
        end if;


        update checklist_perguntas_data
        set cod_versao_checklist_modelo = novo_cod_versao_modelo
        where cod_checklist_modelo = f_cod_modelo
          and cod_versao_checklist_modelo is null;

        get diagnostics qtd_linhas_atualizadas = row_count;

        if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas < 1
        then
            raise exception 'Erro ao setar versão na tabela checklist_perguntas_data';
        end if;


        update checklist_alternativa_pergunta_data
        set cod_versao_checklist_modelo = novo_cod_versao_modelo
        where cod_checklist_modelo = f_cod_modelo
          and cod_versao_checklist_modelo is null;

        get diagnostics qtd_linhas_atualizadas = row_count;

        if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas < 1
        then
            raise exception 'Erro ao setar versão na tabela checklist_alternativa_pergunta_data';
        end if;
        --

        return novo_cod_versao_modelo;
    end
    $func$;
end
$$;

create or replace function migration_checklist.func_migration_2_migra_estrutura_respostas_nok() returns void
    language plpgsql
as
$$
begin
    -- CHECKLIST_RESPOSTAS migração
    -- Cria tabela que conterá as respostas NOK.
    create table checklist_respostas_nok
    (
        codigo                      bigserial not null,
        cod_unidade                 bigint    not null,
        cod_checklist_modelo        bigint    not null,
        cod_versao_checklist_modelo bigint    not null,
        cod_checklist               bigint    not null,
        cod_pergunta                bigint    not null,
        cod_alternativa             bigint    not null,
        resposta_outros             text,
        constraint pk_checklist_respostas_nok primary key (codigo),
        constraint fk_checklist_respostas_unidade foreign key (cod_unidade) references unidade (codigo),
        constraint fk_checklist_respostas_checklist_modelo_versao
            foreign key (cod_checklist_modelo, cod_versao_checklist_modelo)
                references checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo),
        constraint fk_checklist_respostas_checklist foreign key (cod_checklist) references checklist_data (codigo),
        constraint fk_checklist_respostas_checklist_perguntas foreign key (cod_pergunta) references checklist_perguntas_data (codigo),
        constraint fk_checklist_respostas_checklist_alternativa foreign key (cod_alternativa) references checklist_alternativa_pergunta_data (codigo),
        constraint unica_resposta_alternativa_por_check unique (cod_checklist, cod_alternativa)
    );

    comment on table checklist_respostas_nok is 'Tabela que salva apenas as respostas NOK de um checklist realizado.';
    comment on column checklist_respostas_nok.resposta_outros is 'Se a alternativa selecionada for do tipo outros e o
    usuário a tiver selecionado na realização do checklist, essa coluna irá conter a descrição que ele forneceu do problema.
    Caso contrário será NULL.';


    -- Insere na tabela criada apenas as respostas NOK dos checklists já realizados.
    with respostas_nok as (
        select cr.cod_unidade,
               cr.cod_checklist_modelo,
               cr.cod_checklist,
               cr.cod_pergunta,
               cr.cod_alternativa,
               f_if(cr.resposta <> 'NOK', cr.resposta, null) as resposta_outros
        from checklist_respostas cr
        where cr.resposta <> 'OK'
    ),
         checks_com_nok as (
             select rn.cod_unidade,
                    rn.cod_checklist_modelo,
                    cd.cod_versao_checklist_modelo,
                    rn.cod_checklist,
                    cpa.cod_pergunta_novo    as cod_pergunta,
                    caa.cod_alternativa_novo as cod_alternativa,
                    rn.resposta_outros
             from respostas_nok rn
                      join checklist_data cd on rn.cod_checklist = cd.codigo
                      join migration_checklist.check_perguntas_aux cpa
                           on cpa.cod_pergunta_antigo = rn.cod_pergunta
                               and cpa.cod_modelo_versao = cd.cod_versao_checklist_modelo
                      join migration_checklist.check_alternativas_aux caa
                           on caa.cod_alternativa_antigo = rn.cod_alternativa
                               and caa.cod_modelo_versao = cd.cod_versao_checklist_modelo
         )

    insert
    into checklist_respostas_nok
    (cod_unidade,
     cod_checklist_modelo,
     cod_versao_checklist_modelo,
     cod_checklist,
     cod_pergunta,
     cod_alternativa,
     resposta_outros)
    select ccn.cod_unidade,
           ccn.cod_checklist_modelo,
           ccn.cod_versao_checklist_modelo,
           ccn.cod_checklist,
           ccn.cod_pergunta,
           ccn.cod_alternativa,
           ccn.resposta_outros
    from checks_com_nok ccn;
end;
$$;

create or replace function migration_checklist.func_migration_3_migra_estrutura_cosi() returns void
    language plpgsql
as
$fun$
begin
    --######################################################################################################################
    -- Renomeia as colunas atuais.
    alter table checklist_ordem_servico_itens_data
        rename column cod_pergunta to cod_pergunta_primeiro_apontamento;
    alter table checklist_ordem_servico_itens_data
        rename column cod_alternativa to cod_alternativa_primeiro_apontamento;

    -- Cria colunas para referenciarmos os códigos de contexto das perguntas e alternativas.
    -- Isso vai nos ajudar a criar a unique que impedirá dois itens iguais, em aberto, da mesma alternativa.
    alter table checklist_ordem_servico_itens_data
        add column cod_contexto_pergunta bigint;
    alter table checklist_ordem_servico_itens_data
        add column cod_contexto_alternativa bigint;

    -- Remove constraints para o update funcionar.
    alter table checklist_ordem_servico_itens_data
        drop constraint check_data_hora_inicio_resolucao_not_null;
    alter table checklist_ordem_servico_itens_data
        drop constraint check_data_hora_fim_resolucao_not_null;

    update checklist_ordem_servico_itens_data
    set cod_contexto_pergunta = (select cpd.codigo_contexto
                                 from checklist_perguntas_data cpd
                                 where cpd.codigo = cod_pergunta_primeiro_apontamento);
    update checklist_ordem_servico_itens_data
    set cod_contexto_alternativa = (select capd.codigo_contexto
                                    from checklist_alternativa_pergunta_data capd
                                    where capd.codigo = cod_alternativa_primeiro_apontamento);
    --######################################################################################################################
    -- PL-2438
    -- Corrige problema da COSI.
    -- Na migração da versão dos modelos, o estado atual de cada modelo virou a última versão. Essa última versão nunca
    -- teve checks realizados e não tem entradas na CHECKLIST_RESPOSTAS_NOK (CRN). Porém, checks antigos já abriram itens de
    -- OS dessa versão. Pois antes só existia ela. Então, chegamos em um cenário onde um código de
    -- alternativa/pergunta estava na COSI mas não na CRN. Os updates abaixo corrigem isso tanto para pergguntas quanto
    -- para alternativas.
    -- Corrige alternativas.
    create table migration_checklist.migra_cosi_aux_alternativa
    (
        codigo_cosi             bigint,
        codigo_alternativa_novo bigint
    );

    create index idx_migra_cosi_aux_codigo_cosi_alternativa1 on migration_checklist.migra_cosi_aux_alternativa (codigo_cosi);
    create index idx_migra_cosi_aux_codigo_alternativa_novo1 on migration_checklist.migra_cosi_aux_alternativa (codigo_alternativa_novo);

    insert into migration_checklist.migra_cosi_aux_alternativa (codigo_cosi, codigo_alternativa_novo)
    select cosid.codigo as codigo_cosid,
           aux.cod_alternativa_novo
    from migration_checklist.check_alternativas_aux aux
             join checklist_ordem_servico_itens_data cosid
                  on aux.cod_alternativa_antigo = cosid.cod_alternativa_primeiro_apontamento
                      and aux.cod_modelo_versao = (select cd.cod_versao_checklist_modelo
                                                   from checklist_ordem_servico_data cosd
                                                            join checklist_data cd on cosd.cod_checklist = cd.codigo
                                                   where cosd.codigo = cosid.cod_os
                                                     and cosd.cod_unidade = cosid.cod_unidade);

    update checklist_ordem_servico_itens_data
    set cod_alternativa_primeiro_apontamento = (select codigo_alternativa_novo
                                                from migration_checklist.migra_cosi_aux_alternativa
                                                where codigo_cosi = codigo);
    -- Fim alternativas.


    -- Corrige perguntas.
    create table migration_checklist.migra_cosi_aux_pergunta
    (
        codigo_cosi          bigint,
        codigo_pergunta_novo bigint
    );

    create index idx_migra_cosi_aux_codigo_cosi_pergunta1 on migration_checklist.migra_cosi_aux_pergunta (codigo_cosi);
    create index idx_migra_cosi_aux_codigo_pergunta_novo1 on migration_checklist.migra_cosi_aux_pergunta (codigo_pergunta_novo);

    insert into migration_checklist.migra_cosi_aux_pergunta (codigo_cosi, codigo_pergunta_novo)
    select cosid.codigo as codigo_cosid,
           aux.cod_pergunta_novo
    from migration_checklist.check_perguntas_aux aux
             join checklist_ordem_servico_itens_data cosid
                  on aux.cod_pergunta_antigo = cosid.cod_pergunta_primeiro_apontamento
                      and aux.cod_modelo_versao = (select cd.cod_versao_checklist_modelo
                                                   from checklist_ordem_servico_data cosd
                                                            join checklist_data cd on cosd.cod_checklist = cd.codigo
                                                   where cosd.codigo = cosid.cod_os
                                                     and cosd.cod_unidade = cosid.cod_unidade);


    update checklist_ordem_servico_itens_data
    set cod_pergunta_primeiro_apontamento = (select codigo_pergunta_novo
                                             from migration_checklist.migra_cosi_aux_pergunta
                                             where codigo_cosi = codigo);
    -- Fim perguntas.
    --######################################################################################################################

    -- Recria as constraints após o update.
    alter table checklist_ordem_servico_itens_data
        add constraint check_data_hora_inicio_resolucao_not_null check (
                deletado or ((data_hora_conserto is not null and data_hora_inicio_resolucao is not null)
                or (data_hora_conserto is null and data_hora_inicio_resolucao is null))) not valid;
    alter table checklist_ordem_servico_itens_data
        add constraint check_data_hora_fim_resolucao_not_null check (
                deletado or ((data_hora_conserto is not null and data_hora_fim_resolucao is not null)
                or (data_hora_conserto is null and data_hora_fim_resolucao is null))) not valid;
    comment on constraint check_data_hora_inicio_resolucao_not_null
        on checklist_ordem_servico_itens_data
        is 'Constraint para impedir que novas linhas adicionadas tenham a DATA_HORA_INICIO_RESOLUCAO nula.
    Ela foi criada usando NOT VALID para pular a verificação das linhas já existentes.
    Além disso, a verificação é ignorada para linhas deletadas, desse modo podemos deletar itens antigos que não
    têm essa informação salva.';
    comment on constraint check_data_hora_fim_resolucao_not_null
        on checklist_ordem_servico_itens_data
        is 'Constraint para impedir que novas linhas adicionadas tenham a DATA_HORA_FIM_RESOLUCAO nula.
    Ela foi criada usando NOT VALID para pular a verificação das linhas já existentes.
    Além disso, a verificação é ignorada para linhas deletadas, desse modo podemos deletar itens antigos que não
    têm essa informação salva.';


    alter table checklist_ordem_servico_itens_data
        drop constraint fk_checklist_ordem_servico_itens_perguntas;
    alter table checklist_ordem_servico_itens_data
        drop constraint fk_checklist_ordem_servico_itens_alternativa_pergunta;

    alter table checklist_ordem_servico_itens_data
        add constraint fk_checklist_ordem_servico_itens_perguntas
            foreign key (cod_contexto_pergunta, cod_pergunta_primeiro_apontamento)
                references checklist_perguntas_data (codigo_contexto, codigo);
    alter table checklist_ordem_servico_itens_data
        add constraint fk_checklist_ordem_servico_itens_alternativa_pergunta
            foreign key (cod_contexto_alternativa, cod_alternativa_primeiro_apontamento)
                references checklist_alternativa_pergunta_data (codigo_contexto, codigo);
    --######################################################################################################################
    -- Cria a tabela que armazena quais checklists abriram itens de O.S.
    CREATE TABLE IF NOT EXISTS CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS
    (
        CODIGO                  BIGSERIAL NOT NULL
            CONSTRAINT PK_CHECKLIST_APONTAMENTOS
                PRIMARY KEY,
        COD_ITEM_ORDEM_SERVICO  BIGINT    NOT NULL
            CONSTRAINT FK_CHECKLIST_APONTAMENTOS_ITEM_ORDEM_SERVICO
                REFERENCES CHECKLIST_ORDEM_SERVICO_ITENS_DATA (CODIGO),
        COD_CHECKLIST_REALIZADO BIGINT    NOT NULL
            CONSTRAINT FK_CHECKLIST_APONTAMENTOS_CHECKLIST
                REFERENCES CHECKLIST_DATA (CODIGO),
        COD_ALTERNATIVA         BIGINT    NOT NULL
            CONSTRAINT FK_CHECKLIST_ALTERNATIVA
                REFERENCES CHECKLIST_ALTERNATIVA_PERGUNTA_DATA (CODIGO),
        NOVA_QTD_APONTAMENTOS   INTEGER   NOT NULL,
        CONSTRAINT UNICA_QTD_APONTAMENTOS_POR_ITEM_ORDEM_SERVICO
            UNIQUE (COD_ITEM_ORDEM_SERVICO, NOVA_QTD_APONTAMENTOS),
        CONSTRAINT UNICA_ALTERNATIVA_POR_CHECKLIST
            UNIQUE (COD_CHECKLIST_REALIZADO, COD_ALTERNATIVA),
        CONSTRAINT UNICO_ITEM_ORDEM_SERVICO_POR_CHECKLIST
            UNIQUE (COD_CHECKLIST_REALIZADO, COD_ITEM_ORDEM_SERVICO)
    );

    CREATE INDEX IDX_CHECK_ITENS_APONTAMENTOS_COD_ITEM_OS ON CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS (COD_ITEM_ORDEM_SERVICO);

    COMMENT ON TABLE CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS IS 'Salva os apontamentos que houveram nos itens abertos de OS.
        Cada checklist é responsável por incrementar um apontamento de um item já em aberto, com essa tabela conseguiremos
        saber quais checklists foram responsáveis por cada apontamento do item de OS.';
    --######################################################################################################################

    --######################################################################################################################
    -- Alterado colunas COD_ALTERNATIVA e COD_PERGUNTA para COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO e
    -- COD_PERGUNTA_PRIMEIRO_APONTAMENTO, respectivamente.
    drop view checklist_ordem_servico_itens;
    CREATE OR REPLACE VIEW CHECKLIST_ORDEM_SERVICO_ITENS AS
    SELECT COSI.COD_UNIDADE,
           COSI.CODIGO,
           COSI.COD_OS,
           COSI.CPF_MECANICO,
           COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
           COSI.COD_CONTEXTO_PERGUNTA,
           COSI.COD_CONTEXTO_ALTERNATIVA,
           COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
           COSI.STATUS_RESOLUCAO,
           COSI.QT_APONTAMENTOS,
           COSI.KM,
           COSI.DATA_HORA_CONSERTO,
           COSI.DATA_HORA_INICIO_RESOLUCAO,
           COSI.DATA_HORA_FIM_RESOLUCAO,
           COSI.TEMPO_REALIZACAO,
           COSI.FEEDBACK_CONSERTO
    FROM CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSI
    WHERE COSI.DELETADO = FALSE;
    --######################################################################################################################

    --######################################################################################################################
    -- Altera JOIN para utilizar colunas de novo nome da tabela COSI e passa a usar CHECKLIST_RESPOSTAS_NOK ao invés
    -- de CHECKLIST_RESPOSTAS.
    -- Também altera um F_IF para um CASE por questões de otimização.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_GET_ORDEM_SERVICO_RESOLUCAO(F_COD_UNIDADE BIGINT,
                                                                             F_COD_OS BIGINT,
                                                                             F_DATA_HORA_ATUAL_UTC TIMESTAMP WITH TIME ZONE)
        RETURNS TABLE
                (
                    PLACA_VEICULO                         TEXT,
                    KM_ATUAL_VEICULO                      BIGINT,
                    COD_OS                                BIGINT,
                    COD_UNIDADE_OS                        BIGINT,
                    STATUS_OS                             TEXT,
                    DATA_HORA_ABERTURA_OS                 TIMESTAMP WITHOUT TIME ZONE,
                    DATA_HORA_FECHAMENTO_OS               TIMESTAMP WITHOUT TIME ZONE,
                    COD_ITEM_OS                           BIGINT,
                    COD_UNIDADE_ITEM_OS                   BIGINT,
                    DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM   TIMESTAMP WITHOUT TIME ZONE,
                    STATUS_ITEM_OS                        TEXT,
                    PRAZO_RESOLUCAO_ITEM_HORAS            INTEGER,
                    PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS BIGINT,
                    QTD_APONTAMENTOS                      INTEGER,
                    COD_COLABORADOR_RESOLUCAO             BIGINT,
                    NOME_COLABORADOR_RESOLUCAO            TEXT,
                    DATA_HORA_RESOLUCAO                   TIMESTAMP WITHOUT TIME ZONE,
                    DATA_HORA_INICIO_RESOLUCAO            TIMESTAMP WITHOUT TIME ZONE,
                    DATA_HORA_FIM_RESOLUCAO               TIMESTAMP WITHOUT TIME ZONE,
                    FEEDBACK_RESOLUCAO                    TEXT,
                    DURACAO_RESOLUCAO_MINUTOS             BIGINT,
                    KM_VEICULO_COLETADO_RESOLUCAO         BIGINT,
                    COD_PERGUNTA                          BIGINT,
                    DESCRICAO_PERGUNTA                    TEXT,
                    COD_ALTERNATIVA                       BIGINT,
                    DESCRICAO_ALTERNATIVA                 TEXT,
                    ALTERNATIVA_TIPO_OUTROS               BOOLEAN,
                    DESCRICAO_TIPO_OUTROS                 TEXT,
                    PRIORIDADE_ALTERNATIVA                TEXT
                )
        LANGUAGE PLPGSQL
    as
    $$
    BEGIN
        RETURN QUERY
            SELECT C.PLACA_VEICULO :: TEXT                                                AS PLACA_VEICULO,
                   V.KM                                                                   AS KM_ATUAL_VEICULO,
                   COS.CODIGO                                                             AS COD_OS,
                   COS.COD_UNIDADE                                                        AS COD_UNIDADE_OS,
                   COS.STATUS :: TEXT                                                     AS STATUS_OS,
                   C.DATA_HORA_REALIZACAO_TZ_APLICADO                                     AS DATA_HORA_ABERTURA_OS,
                   COS.DATA_HORA_FECHAMENTO AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE)        AS DATA_HORA_FECHAMENTO_OS,
                   COSI.CODIGO                                                            AS COD_ITEM_OS,
                   COS.COD_UNIDADE                                                        AS COD_UNIDADE_ITEM_OS,
                   C.DATA_HORA_REALIZACAO_TZ_APLICADO                                     AS DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM,
                   COSI.STATUS_RESOLUCAO                                                  AS STATUS_ITEM_OS,
                   PRIO.PRAZO                                                             AS PRAZO_RESOLUCAO_ITEM_HORAS,
                   TO_MINUTES_TRUNC((C.DATA_HORA
                       + (PRIO.PRAZO || ' HOURS') :: INTERVAL)
                       -
                                    F_DATA_HORA_ATUAL_UTC)                                AS PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS,
                   COSI.QT_APONTAMENTOS                                                   AS QTD_APONTAMENTOS,
                   CO.CODIGO                                                              AS COD_COLABORADOR_RESOLUCAO,
                   CO.NOME :: TEXT                                                        AS NOME_COLABORADOR_RESOLUCAO,
                   COSI.DATA_HORA_CONSERTO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)         AS DATA_HORA_RESOLUCAO,
                   COSI.DATA_HORA_INICIO_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE) AS DATA_HORA_INICIO_RESOLUCAO,
                   COSI.DATA_HORA_FIM_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)    AS DATA_HORA_FIM_RESOLUCAO,
                   COSI.FEEDBACK_CONSERTO                                                 AS FEEDBACK_RESOLUCAO,
                   MILLIS_TO_MINUTES(COSI.TEMPO_REALIZACAO)                               AS DURACAO_RESOLUCAO_MINUTOS,
                   COSI.KM                                                                AS KM_VEICULO_COLETADO_RESOLUCAO,
                   CP.CODIGO                                                              AS COD_PERGUNTA,
                   CP.PERGUNTA                                                            AS DESCRICAO_PERGUNTA,
                   CAP.CODIGO                                                             AS COD_ALTERNATIVA,
                   CAP.ALTERNATIVA                                                        AS DESCRICAO_ALTERNATIVA,
                   CAP.ALTERNATIVA_TIPO_OUTROS                                            AS ALTERNATIVA_TIPO_OUTROS,
                   CASE
                       WHEN CAP.ALTERNATIVA_TIPO_OUTROS
                           THEN
                           (SELECT CRN.RESPOSTA_OUTROS
                            FROM CHECKLIST_RESPOSTAS_NOK CRN
                            WHERE CRN.COD_CHECKLIST = C.CODIGO
                              AND CRN.COD_ALTERNATIVA = CAP.CODIGO) :: TEXT
                       ELSE NULL
                       END                                                                AS DESCRICAO_TIPO_OUTROS,
                   CAP.PRIORIDADE :: TEXT                                                 AS PRIORIDADE_ALTERNATIVA
            FROM CHECKLIST C
                     JOIN CHECKLIST_ORDEM_SERVICO COS
                          ON C.CODIGO = COS.COD_CHECKLIST
                     JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          ON COS.CODIGO = COSI.COD_OS
                              AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                     JOIN CHECKLIST_PERGUNTAS CP
                          ON COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO = CP.CODIGO
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO
                     JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE PRIO
                          ON CAP.PRIORIDADE = PRIO.PRIORIDADE
                     JOIN VEICULO V
                          ON C.PLACA_VEICULO = V.PLACA
                     LEFT JOIN COLABORADOR CO
                               ON CO.CPF = COSI.CPF_MECANICO
            WHERE COS.CODIGO = F_COD_OS
              AND COS.COD_UNIDADE = F_COD_UNIDADE;
    END;
    $$;
    --######################################################################################################################

    --######################################################################################################################
    -- Altera JOIN para utilizar colunas de novo nome da tabela COSI e passa a usar CHECKLIST_RESPOSTAS_NOK ao invés
    -- de CHECKLIST_RESPOSTAS.
    -- Também altera um F_IF para um CASE por questões de otimização.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_GET_ITENS_RESOLUCAO(F_COD_UNIDADE BIGINT,
                                                                     F_COD_OS BIGINT,
                                                                     F_PLACA_VEICULO TEXT,
                                                                     F_PRIORIDADE_ALTERNATIVA TEXT,
                                                                     F_STATUS_ITENS TEXT,
                                                                     F_DATA_HORA_ATUAL_UTC TIMESTAMP WITH TIME ZONE,
                                                                     F_LIMIT INTEGER,
                                                                     F_OFFSET INTEGER)
        RETURNS TABLE
                (
                    PLACA_VEICULO                         TEXT,
                    KM_ATUAL_VEICULO                      BIGINT,
                    COD_OS                                BIGINT,
                    COD_UNIDADE_ITEM_OS                   BIGINT,
                    COD_ITEM_OS                           BIGINT,
                    DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM   TIMESTAMP WITHOUT TIME ZONE,
                    STATUS_ITEM_OS                        TEXT,
                    PRAZO_RESOLUCAO_ITEM_HORAS            INTEGER,
                    PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS BIGINT,
                    QTD_APONTAMENTOS                      INTEGER,
                    COD_COLABORADOR_RESOLUCAO             BIGINT,
                    NOME_COLABORADOR_RESOLUCAO            TEXT,
                    DATA_HORA_RESOLUCAO                   TIMESTAMP WITHOUT TIME ZONE,
                    DATA_HORA_INICIO_RESOLUCAO            TIMESTAMP WITHOUT TIME ZONE,
                    DATA_HORA_FIM_RESOLUCAO               TIMESTAMP WITHOUT TIME ZONE,
                    FEEDBACK_RESOLUCAO                    TEXT,
                    DURACAO_RESOLUCAO_MINUTOS             BIGINT,
                    KM_VEICULO_COLETADO_RESOLUCAO         BIGINT,
                    COD_PERGUNTA                          BIGINT,
                    DESCRICAO_PERGUNTA                    TEXT,
                    COD_ALTERNATIVA                       BIGINT,
                    DESCRICAO_ALTERNATIVA                 TEXT,
                    ALTERNATIVA_TIPO_OUTROS               BOOLEAN,
                    DESCRICAO_TIPO_OUTROS                 TEXT,
                    PRIORIDADE_ALTERNATIVA                TEXT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    BEGIN
        RETURN QUERY
            WITH DADOS AS (
                SELECT C.PLACA_VEICULO :: TEXT                                                AS PLACA_VEICULO,
                       V.KM                                                                   AS KM_ATUAL_VEICULO,
                       COS.CODIGO                                                             AS COD_OS,
                       COS.COD_UNIDADE                                                        AS COD_UNIDADE_ITEM_OS,
                       COSI.CODIGO                                                            AS COD_ITEM_OS,
                       C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)                     AS DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM,
                       COSI.STATUS_RESOLUCAO                                                  AS STATUS_ITEM_OS,
                       PRIO.PRAZO                                                             AS PRAZO_RESOLUCAO_ITEM_HORAS,
                       TO_MINUTES_TRUNC((C.DATA_HORA
                           + (PRIO.PRAZO || ' HOURS') :: INTERVAL)
                           -
                                        F_DATA_HORA_ATUAL_UTC)                                AS PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS,
                       COSI.QT_APONTAMENTOS                                                   AS QTD_APONTAMENTOS,
                       CO.CODIGO                                                              AS COD_COLABORADOR_RESOLUCAO,
                       CO.NOME :: TEXT                                                        AS NOME_COLABORADOR_RESOLUCAO,
                       COSI.DATA_HORA_CONSERTO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)         AS DATA_HORA_RESOLUCAO,
                       COSI.DATA_HORA_INICIO_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE) AS DATA_HORA_INICIO_RESOLUCAO,
                       COSI.DATA_HORA_FIM_RESOLUCAO AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)    AS DATA_HORA_FIM_RESOLUCAO,
                       COSI.FEEDBACK_CONSERTO                                                 AS FEEDBACK_RESOLUCAO,
                       MILLIS_TO_MINUTES(COSI.TEMPO_REALIZACAO)                               AS DURACAO_RESOLUCAO_MINUTOS,
                       COSI.KM                                                                AS KM_VEICULO_COLETADO_RESOLUCAO,
                       CP.CODIGO                                                              AS COD_PERGUNTA,
                       CP.PERGUNTA                                                            AS DESCRICAO_PERGUNTA,
                       CAP.CODIGO                                                             AS COD_ALTERNATIVA,
                       CAP.ALTERNATIVA                                                        AS DESCRICAO_ALTERNATIVA,
                       CAP.ALTERNATIVA_TIPO_OUTROS                                            AS ALTERNATIVA_TIPO_OUTROS,
                       CASE
                           WHEN CAP.ALTERNATIVA_TIPO_OUTROS
                               THEN
                               (SELECT CRN.RESPOSTA_OUTROS
                                FROM CHECKLIST_RESPOSTAS_NOK CRN
                                WHERE CRN.COD_CHECKLIST = C.CODIGO
                                  AND CRN.COD_ALTERNATIVA = CAP.CODIGO) :: TEXT
                           ELSE NULL
                           END                                                                AS DESCRICAO_TIPO_OUTROS,
                       CAP.PRIORIDADE :: TEXT                                                 AS PRIORIDADE_ALTERNATIVA
                FROM CHECKLIST C
                         JOIN CHECKLIST_ORDEM_SERVICO COS
                              ON C.CODIGO = COS.COD_CHECKLIST
                         JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                              ON COS.CODIGO = COSI.COD_OS
                                  AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                         JOIN CHECKLIST_PERGUNTAS CP
                              ON COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO = CP.CODIGO
                         JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                              ON COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO
                         JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE PRIO
                              ON CAP.PRIORIDADE = PRIO.PRIORIDADE
                         JOIN VEICULO V
                              ON C.PLACA_VEICULO = V.PLACA
                         LEFT JOIN COLABORADOR CO
                                   ON CO.CPF = COSI.CPF_MECANICO
                WHERE F_IF(F_COD_UNIDADE IS NULL, TRUE, COS.COD_UNIDADE = F_COD_UNIDADE)
                  AND F_IF(F_COD_OS IS NULL, TRUE, COS.CODIGO = F_COD_OS)
                  AND F_IF(F_PLACA_VEICULO IS NULL, TRUE, C.PLACA_VEICULO = F_PLACA_VEICULO)
                  AND F_IF(F_PRIORIDADE_ALTERNATIVA IS NULL, TRUE, CAP.PRIORIDADE = F_PRIORIDADE_ALTERNATIVA)
                  AND F_IF(F_STATUS_ITENS IS NULL, TRUE, COSI.STATUS_RESOLUCAO = F_STATUS_ITENS)
                LIMIT F_LIMIT
                    OFFSET F_OFFSET
            ),
                 DADOS_VEICULO AS (
                     SELECT V.PLACA :: TEXT AS PLACA_VEICULO,
                            V.KM            AS KM_ATUAL_VEICULO
                     FROM VEICULO V
                     WHERE V.PLACA = F_PLACA_VEICULO
                 )

                 -- NÓS USAMOS ESSE DADOS_VEICULO COM F_IF POIS PODE ACONTECER DE NÃO EXISTIR DADOS PARA OS FILTROS APLICADOS E
                 -- DESSE MODO ACABARÍAMOS NÃO RETORNANDO PLACA E KM TAMBÉM, MAS ESSAS SÃO INFORMAÇÕES NECESSÁRIAS POIS O OBJETO
                 -- CONSTRUÍDO A PARTIR DESSA FUNCTION USA ELAS.
            SELECT F_IF(D.PLACA_VEICULO IS NULL, DV.PLACA_VEICULO, D.PLACA_VEICULO)          AS PLACA_VEICULO,
                   F_IF(D.KM_ATUAL_VEICULO IS NULL, DV.KM_ATUAL_VEICULO, D.KM_ATUAL_VEICULO) AS KM_ATUAL_VEICULO,
                   D.COD_OS                                                                  AS COD_OS,
                   D.COD_UNIDADE_ITEM_OS                                                     AS COD_UNIDADE_ITEM_OS,
                   D.COD_ITEM_OS                                                             AS COD_ITEM_OS,
                   D.DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM                                     AS DATA_HORA_PRIMEIRO_APONTAMENTO_ITEM,
                   D.STATUS_ITEM_OS                                                          AS STATUS_ITEM_OS,
                   D.PRAZO_RESOLUCAO_ITEM_HORAS                                              AS PRAZO_RESOLUCAO_ITEM_HORAS,
                   D.PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS                                   AS PRAZO_RESTANTE_RESOLUCAO_ITEM_MINUTOS,
                   D.QTD_APONTAMENTOS                                                        AS QTD_APONTAMENTOS,
                   D.COD_COLABORADOR_RESOLUCAO                                               AS COD_COLABORADOR_RESOLUCAO,
                   D.NOME_COLABORADOR_RESOLUCAO                                              AS NOME_COLABORADOR_RESOLUCAO,
                   D.DATA_HORA_RESOLUCAO                                                     AS DATA_HORA_RESOLUCAO,
                   D.DATA_HORA_INICIO_RESOLUCAO                                              AS DATA_HORA_INICIO_RESOLUCAO,
                   D.DATA_HORA_FIM_RESOLUCAO                                                 AS DATA_HORA_FIM_RESOLUCAO,
                   D.FEEDBACK_RESOLUCAO                                                      AS FEEDBACK_RESOLUCAO,
                   D.DURACAO_RESOLUCAO_MINUTOS                                               AS DURACAO_RESOLUCAO_MINUTOS,
                   D.KM_VEICULO_COLETADO_RESOLUCAO                                           AS KM_VEICULO_COLETADO_RESOLUCAO,
                   D.COD_PERGUNTA                                                            AS COD_PERGUNTA,
                   D.DESCRICAO_PERGUNTA                                                      AS DESCRICAO_PERGUNTA,
                   D.COD_ALTERNATIVA                                                         AS COD_ALTERNATIVA,
                   D.DESCRICAO_ALTERNATIVA                                                   AS DESCRICAO_ALTERNATIVA,
                   D.ALTERNATIVA_TIPO_OUTROS                                                 AS ALTERNATIVA_TIPO_OUTROS,
                   D.DESCRICAO_TIPO_OUTROS                                                   AS DESCRICAO_TIPO_OUTROS,
                   D.PRIORIDADE_ALTERNATIVA                                                  AS PRIORIDADE_ALTERNATIVA
            FROM DADOS D
                     RIGHT JOIN DADOS_VEICULO DV
                                ON D.PLACA_VEICULO = DV.PLACA_VEICULO;
    END;
    $$;
    --######################################################################################################################

    --######################################################################################################################
    -- Altera JOIN para utilizar colunas de novo nome da tabela COSI.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_GET_QTD_ITENS_PLACA_LISTAGEM(F_COD_UNIDADE BIGINT,
                                                                              F_COD_TIPO_VEICULO BIGINT,
                                                                              F_PLACA_VEICULO TEXT,
                                                                              F_STATUS_ITENS_OS TEXT,
                                                                              F_LIMIT INTEGER,
                                                                              F_OFFSET INTEGER)
        RETURNS TABLE
                (
                    PLACA_VEICULO                TEXT,
                    QTD_ITENS_PRIORIDADE_CRITICA BIGINT,
                    QTD_ITENS_PRIORIDADE_ALTA    BIGINT,
                    QTD_ITENS_PRIORIDADE_BAIXA   BIGINT,
                    TOTAL_ITENS                  BIGINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        TIPO_ITEM_PRIORIDADE_CRITICA TEXT := 'CRITICA';
        TIPO_ITEM_PRIORIDADE_ALTA    TEXT := 'ALTA';
        TIPO_ITEM_PRIORIDADE_BAIXA   TEXT := 'BAIXA';
    BEGIN
        RETURN QUERY
            SELECT V.PLACA :: TEXT           AS PLACA_VEICULO,
                   COUNT(CASE
                             WHEN CAP.PRIORIDADE = TIPO_ITEM_PRIORIDADE_CRITICA
                                 THEN 1 END) AS QTD_ITENS_PRIORIDADE_CRITICA,
                   COUNT(CASE
                             WHEN CAP.PRIORIDADE = TIPO_ITEM_PRIORIDADE_ALTA
                                 THEN 1 END) AS QTD_ITENS_PRIORIDADE_ALTA,
                   COUNT(CASE
                             WHEN CAP.PRIORIDADE = TIPO_ITEM_PRIORIDADE_BAIXA
                                 THEN 1 END) AS QTD_ITENS_PRIORIDADE_BAIXA,
                   COUNT(CAP.PRIORIDADE)     AS TOTAL_ITENS
            FROM VEICULO V
                     JOIN CHECKLIST C
                          ON V.PLACA = C.PLACA_VEICULO
                     JOIN CHECKLIST_ORDEM_SERVICO COS
                          ON C.CODIGO = COS.COD_CHECKLIST
                     JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          ON COS.CODIGO = COSI.COD_OS
                              AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                     JOIN VEICULO_TIPO VT
                          ON V.COD_TIPO = VT.CODIGO
            WHERE V.COD_UNIDADE = F_COD_UNIDADE
              AND F_IF(F_COD_TIPO_VEICULO IS NULL, TRUE, VT.CODIGO = F_COD_TIPO_VEICULO)
              AND F_IF(F_PLACA_VEICULO IS NULL, TRUE, V.PLACA = F_PLACA_VEICULO)
              AND F_IF(F_STATUS_ITENS_OS IS NULL, TRUE, COSI.STATUS_RESOLUCAO = F_STATUS_ITENS_OS)
            GROUP BY V.PLACA
            ORDER BY QTD_ITENS_PRIORIDADE_CRITICA DESC,
                     QTD_ITENS_PRIORIDADE_ALTA DESC,
                     QTD_ITENS_PRIORIDADE_BAIXA DESC,
                     PLACA_VEICULO ASC
            LIMIT F_LIMIT
                OFFSET F_OFFSET;
    END;
    $$;
    --######################################################################################################################
end;
$fun$;

create or replace function migration_checklist.func_migration_4_adiciona_constraints_versao_modelo() returns void
    language plpgsql
as
$$
begin
    -- Impede novas versão com cod_colaborador_criacao_versao nulo.
    alter table checklist_modelo_versao
        add constraint check_colaborador_not_null_acima_versao_1 check (cod_colaborador_criacao_versao is not null) not valid;

    -- Agora pode ser NOT NULL.
    alter table checklist_modelo_data
        alter column cod_versao_atual set not null;
    alter table checklist_data
        alter column cod_versao_checklist_modelo set not null;

    -- Remove FK única com cod_modelo e usa uma dupla compondo com versão do modelo.
    alter table checklist_perguntas_data
        drop constraint fk_checklist_perguntas_checklist_modelo;
    alter table checklist_perguntas_data
        add constraint fk_checklist_perguntas_checklist_modelo_versao
            foreign key (cod_checklist_modelo, cod_versao_checklist_modelo)
                references checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo);

    -- Remove FK única com cod_modelo e usa uma dupla compondo com versão do modelo.
    alter table checklist_alternativa_pergunta_data
        drop constraint fk_checklist_alternativa_pergunta_checklist_modelo;
    alter table checklist_alternativa_pergunta_data
        add constraint fk_checklist_alternativa_pergunta_checklist_modelo_versao
            foreign key (cod_checklist_modelo, cod_versao_checklist_modelo)
                references checklist_modelo_versao (cod_checklist_modelo, cod_versao_checklist_modelo);
end
$$;

create or replace function migration_checklist.func_migration_5_corrige_modelo() returns void
    language plpgsql
as
$$
begin
    -- #####################################################################################################################
-- #####################################################################################################################
-- ####### CORRIGE OS ÚLTIMOS MODELOS DE CHECK PARA DELETAR LOGICAMENTE AS PERGUNTAS E ALTERNATIVAS INATIVAS ###########
-- #####################################################################################################################
-- #####################################################################################################################
-- PL-2230
-- Sobre: Encontramos divergências na contagem de perguntas e alternativas nos modelos de checklist devido a um problema
-- na antiga estrutura, para corrigir, precisamos deletar logicamente todas as perguntas e alternativas inativas das
-- últimas versões de modelos de checklist na estrutura nova e alterar as dependências.

-- Deleta logicamente as alternativas inativas do últimos modelos de checklist
    UPDATE CHECKLIST_ALTERNATIVA_PERGUNTA_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_VERSAO_CHECKLIST_MODELO IN
          (SELECT COD_VERSAO_ATUAL FROM CHECKLIST_MODELO_DATA ORDER BY COD_VERSAO_ATUAL DESC)
      AND STATUS_ATIVO = FALSE;

-- Deleta logicamente as perguntas inativas do últimos modelos de checklist
    UPDATE CHECKLIST_PERGUNTAS_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_VERSAO_CHECKLIST_MODELO IN
          (SELECT COD_VERSAO_ATUAL FROM CHECKLIST_MODELO_DATA ORDER BY COD_VERSAO_ATUAL DESC)
      AND STATUS_ATIVO = FALSE;

-- DROPA A VIEW CHECKLIST_ALTERNATIVA_PERGUNTA
    DROP VIEW CHECKLIST_ALTERNATIVA_PERGUNTA;

-- DROPA COLUNA DE STATUS DAS ALTERNATIVAS
    ALTER TABLE CHECKLIST_ALTERNATIVA_PERGUNTA_DATA
        DROP COLUMN STATUS_ATIVO;

    -- RECRIA VIEW SEM A COLUNA STATUS_ATIVO
    CREATE OR REPLACE VIEW CHECKLIST_ALTERNATIVA_PERGUNTA AS
    SELECT CAP.COD_CHECKLIST_MODELO,
           CAP.COD_VERSAO_CHECKLIST_MODELO,
           CAP.COD_UNIDADE,
           CAP.ALTERNATIVA,
           CAP.ORDEM,
           CAP.COD_PERGUNTA,
           CAP.CODIGO,
           CAP.CODIGO_CONTEXTO,
           CAP.ALTERNATIVA_TIPO_OUTROS,
           CAP.PRIORIDADE,
           CAP.DEVE_ABRIR_ORDEM_SERVICO
    FROM CHECKLIST_ALTERNATIVA_PERGUNTA_DATA CAP
    WHERE CAP.DELETADO = FALSE;


-- DROPA A VIEW CHECKLIST_PERGUNTAS
    DROP VIEW CHECKLIST_PERGUNTAS;

-- DROPA COLUNA DE STATUS DAS ALTERNATIVAS
    ALTER TABLE CHECKLIST_PERGUNTAS_DATA
        DROP COLUMN STATUS_ATIVO;

    -- RECRIA VIEW SEM A COLUNA STATUS_ATIVO
    CREATE OR REPLACE VIEW CHECKLIST_PERGUNTAS AS
    SELECT CP.COD_CHECKLIST_MODELO,
           CP.COD_VERSAO_CHECKLIST_MODELO,
           CP.COD_UNIDADE,
           CP.ORDEM,
           CP.PERGUNTA,
           CP.SINGLE_CHOICE,
           CP.COD_IMAGEM,
           CP.CODIGO,
           CP.CODIGO_CONTEXTO
    FROM CHECKLIST_PERGUNTAS_DATA CP
    WHERE CP.DELETADO = FALSE;

    -- #####################################################################################################################
-- #####################################################################################################################
-- CORRIGE O VÍNCULO DAS PERGUNTAS MIGRADAS NAS ALTERNATIVAS
-- TODO REFATORAR PARA OTIMIZAR (JANELA)
    UPDATE CHECKLIST_ALTERNATIVA_PERGUNTA_DATA CAP
    SET COD_PERGUNTA = (
        SELECT CPA.COD_PERGUNTA_NOVO
        FROM MIGRATION_CHECKLIST.CHECK_PERGUNTAS_AUX CPA
        WHERE CPA.COD_PERGUNTA_ANTIGO = CAP.COD_PERGUNTA
          AND CPA.COD_MODELO_VERSAO = CAP.COD_VERSAO_CHECKLIST_MODELO)
    WHERE COD_PERGUNTA IN
          (SELECT CPA.COD_PERGUNTA_ANTIGO FROM MIGRATION_CHECKLIST.CHECK_PERGUNTAS_AUX CPA)
      AND COD_VERSAO_CHECKLIST_MODELO IN
          (SELECT CPA.COD_MODELO_VERSAO FROM MIGRATION_CHECKLIST.CHECK_PERGUNTAS_AUX CPA);
    -- #####################################################################################################################
-- #####################################################################################################################

end;
$$;

create or replace function migration_checklist.func_migration_6_ws_realizacao_checklist() returns void
    language plpgsql
as
$fun$
begin

    --##################################################################################################################
    -- PL-2299
    -- Adiciona nova coluna na tabela de checklists para salvar diretamente a data de realização com o tz da unidade
    -- já aplicado.
    ALTER TABLE CHECKLIST_DATA
        ADD COLUMN DATA_HORA_REALIZACAO_TZ_APLICADO TIMESTAMP;

    COMMENT ON COLUMN CHECKLIST_DATA.DATA_HORA_REALIZACAO_TZ_APLICADO IS 'A data/hora de realização do checklist já com o TZ da unidade onde foi realizado aplicado.';

    UPDATE checklist_data
    SET DATA_HORA_REALIZACAO_TZ_APLICADO = CHECKLIST_DATA.DATA_HORA AT TIME ZONE TZ_UNIDADE(COD_UNIDADE);

    ALTER TABLE CHECKLIST_DATA
        ALTER COLUMN DATA_HORA_REALIZACAO_TZ_APLICADO SET NOT NULL;

    CREATE INDEX IDX_CHECKLIST_DATA_HORA_REALIZACAO_TZ ON CHECKLIST_DATA ((DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE));

    DROP VIEW CHECKLIST;

    create view checklist as
    select c.cod_unidade,
           c.cod_checklist_modelo,
           c.cod_versao_checklist_modelo,
           c.codigo,
           c.data_hora,
           c.data_hora_realizacao_tz_aplicado,
           c.data_hora_importado_prolog,
           c.cpf_colaborador,
           c.placa_veiculo,
           c.tipo,
           c.tempo_realizacao,
           c.km_veiculo,
           c.data_hora_sincronizacao,
           c.fonte_data_hora_realizacao,
           c.versao_app_momento_realizacao,
           c.versao_app_momento_sincronizacao,
           c.device_id,
           c.device_imei,
           c.device_uptime_realizacao_millis,
           c.device_uptime_sincronizacao_millis,
           c.foi_offline,
           c.total_perguntas_ok,
           c.total_perguntas_nok,
           c.total_alternativas_ok,
           c.total_alternativas_nok
    from checklist_data c
    where (c.deletado = false);
    --##################################################################################################################


    --######################################################################################################################
    --######################################################################################################################
    --################################ Refatora métodos SQLs usados na ChecklistDao e no Offline ###########################
    --######################################################################################################################
    --######################################################################################################################
    -- PL-2227
    -- '[
    --   {
    --     "codPergunta": 1,
    --     "codAlternativas": [
    --       1,
    --       2,
    --       3,
    --       4
    --     ]
    --   },
    --   {
    --     "codPergunta": 2,
    --     "codAlternativas": [
    --       1,
    --       2,
    --       3,
    --       4
    --     ]
    --   }
    -- ]'
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_ENCONTRA_VERSAO_MODELO(F_COD_MODELO_CHECKLIST BIGINT,
                                                                     F_PERGUNTAS_ALTERNATIVAS JSONB)
        RETURNS BIGINT
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        COD_VERSAO_MODELO_CHECKLIST_PROCURADO BIGINT;
        F_ALTERNATIVA                         BIGINT;
    BEGIN
        -- CRIA UM JSONB DAS ALTERNATIVAS EXTRAÍDAS DO JSON DO MODELO.
        WITH CHECKLIST AS (
            SELECT JSONB_ARRAY_ELEMENTS_TEXT(F_PERGUNTAS_ALTERNATIVAS)::JSONB -> 'codAlternativas' AS COD_ALTERNATIVAS
        ),
             DADOS_MODELO_WS AS (
                 SELECT F_COD_MODELO_CHECKLIST                           AS COD_MODELO_CHECKLIST,
                        JSONB_ARRAY_ELEMENTS(CHECKLIST.COD_ALTERNATIVAS) AS COD_ALTERNATIVA
                 FROM CHECKLIST
                 ORDER BY 2
             )
        SELECT COD_ALTERNATIVA
        FROM DADOS_MODELO_WS WS
        INTO F_ALTERNATIVA;

        -- IDENTIFICA A VERSÃO DO MODELO ATRAVÉS DO CÓDIGO DE ALTERNATIVA E CÓDIGO DO MODELO.
        SELECT COD_VERSAO_CHECKLIST_MODELO
        FROM CHECKLIST_ALTERNATIVA_PERGUNTA_DATA
        WHERE CODIGO = F_ALTERNATIVA
          AND COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
        INTO COD_VERSAO_MODELO_CHECKLIST_PROCURADO;

        IF COD_VERSAO_MODELO_CHECKLIST_PROCURADO IS NOT NULL AND COD_VERSAO_MODELO_CHECKLIST_PROCURADO > 0
        THEN
            -- ENCONTRAMOS A VERSÃO DO MODELO NA BUSCA.
            RETURN COD_VERSAO_MODELO_CHECKLIST_PROCURADO;
        ELSE
            RAISE EXCEPTION 'Não foi possível encontrar a versão do modelo de checklist';
        END IF;
    END;
    $$;

    -- Para testar a func acima:
    -- with dados_json as (
    --     select '[
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1120,
    --         "codAlternativas": [
    --           319,
    --           321,
    --           320
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1121,
    --         "codAlternativas": [
    --           322,
    --           361,
    --           327,
    --           393
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1122,
    --         "codAlternativas": [
    --           373,
    --           397,
    --           398,
    --           374,
    --           372
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1124,
    --         "codAlternativas": [
    --           350,
    --           70,
    --           349,
    --           348
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1126,
    --         "codAlternativas": [
    --           356,
    --           72,
    --           71,
    --           385,
    --           351
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1128,
    --         "codAlternativas": [
    --           289,
    --           290,
    --           291
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1130,
    --         "codAlternativas": [
    --           295,
    --           294,
    --           293
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1132,
    --         "codAlternativas": [
    --           300,
    --           301,
    --           299
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1135,
    --         "codAlternativas": [
    --           389,
    --           326,
    --           314,
    --           358,
    --           387,
    --           388
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1136,
    --         "codAlternativas": [
    --           325,
    --           305,
    --           362
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1138,
    --         "codAlternativas": [
    --           386,
    --           306,
    --           307,
    --           357
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1140,
    --         "codAlternativas": [
    --           310,
    --           308,
    --           309
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1141,
    --         "codAlternativas": [
    --           311,
    --           313,
    --           312
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1143,
    --         "codAlternativas": [
    --           395,
    --           323,
    --           324,
    --           1
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1144,
    --         "codAlternativas": [
    --           333,
    --           334,
    --           9,
    --           10,
    --           332
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1146,
    --         "codAlternativas": [
    --           377,
    --           375,
    --           376,
    --           378
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1148,
    --         "codAlternativas": [
    --           315,
    --           316,
    --           390,
    --           359
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1150,
    --         "codAlternativas": [
    --           340,
    --           339,
    --           341
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1152,
    --         "codAlternativas": [
    --           15827,
    --           344,
    --           343,
    --           15846,
    --           342,
    --           22091
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1154,
    --         "codAlternativas": [
    --           391,
    --           392,
    --           317,
    --           318
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1156,
    --         "codAlternativas": [
    --           285,
    --           281,
    --           282
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1157,
    --         "codAlternativas": [
    --           286,
    --           383,
    --           382,
    --           353
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1158,
    --         "codAlternativas": [
    --           287,
    --           288,
    --           352
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1159,
    --         "codAlternativas": [
    --           384,
    --           355,
    --           354,
    --           292
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1160,
    --         "codAlternativas": [
    --           345,
    --           364,
    --           365,
    --           366
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1161,
    --         "codAlternativas": [
    --           363,
    --           296,
    --           297,
    --           298,
    --           394
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1162,
    --         "codAlternativas": [
    --           367,
    --           368
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1163,
    --         "codAlternativas": [
    --           379,
    --           380,
    --           381
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1164,
    --         "codAlternativas": [
    --           278,
    --           277,
    --           276,
    --           275,
    --           274
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1165,
    --         "codAlternativas": [
    --           328,
    --           331,
    --           329,
    --           330
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1166,
    --         "codAlternativas": [
    --           13330,
    --           371,
    --           369,
    --           370
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1167,
    --         "codAlternativas": [
    --           399,
    --           400
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1169,
    --         "codAlternativas": [
    --           302,
    --           303,
    --           304
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1178,
    --         "codAlternativas": [
    --           335,
    --           346,
    --           68,
    --           69,
    --           347
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 1863,
    --         "codAlternativas": [
    --           337,
    --           338,
    --           396,
    --           360,
    --           336
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 11068,
    --         "codAlternativas": [
    --           27838,
    --           27839,
    --           27840
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 13232,
    --         "codAlternativas": [
    --           34776,
    --           34775,
    --           34774
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 13233,
    --         "codAlternativas": [
    --           34779,
    --           34778,
    --           34777
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 13234,
    --         "codAlternativas": [
    --           34782,
    --           34781,
    --           34780
    --         ]
    --       },
    --       {
    --         "codModeloChecklist": 1,
    --         "codPergunta": 13235,
    --         "codAlternativas": [
    --           34783
    --         ]
    --       }
    --     ]' :: jsonb as data
    -- )
    --     select * from func_checklist_encontra_versao_modelo(1, (select dados_json.data from dados_json));


    -- Altera function de insert de um checklist offline.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_INSERT_CHECKLIST_INFOS(F_COD_UNIDADE_CHECKLIST BIGINT,
                                                                     F_COD_MODELO_CHECKLIST BIGINT,
                                                                     F_COD_VERSAO_MODELO_CHECKLIST BIGINT,
                                                                     F_DATA_HORA_REALIZACAO TIMESTAMP WITH TIME ZONE,
                                                                     F_COD_COLABORADOR BIGINT,
                                                                     F_COD_VEICULO BIGINT,
                                                                     F_PLACA_VEICULO TEXT,
                                                                     F_TIPO_CHECKLIST CHAR,
                                                                     F_KM_COLETADO BIGINT,
                                                                     F_TEMPO_REALIZACAO BIGINT,
                                                                     F_DATA_HORA_SINCRONIZACAO TIMESTAMP WITH TIME ZONE,
                                                                     F_FONTE_DATA_HORA_REALIZACAO TEXT,
                                                                     F_VERSAO_APP_MOMENTO_REALIZACAO INTEGER,
                                                                     F_VERSAO_APP_MOMENTO_SINCRONIZACAO INTEGER,
                                                                     F_DEVICE_ID TEXT,
                                                                     F_DEVICE_IMEI TEXT,
                                                                     F_DEVICE_UPTIME_REALIZACAO_MILLIS BIGINT,
                                                                     F_DEVICE_UPTIME_SINCRONIZACAO_MILLIS BIGINT,
                                                                     F_FOI_OFFLINE BOOLEAN,
                                                                     F_TOTAL_PERGUNTAS_OK INTEGER,
                                                                     F_TOTAL_PERGUNTAS_NOK INTEGER,
                                                                     F_TOTAL_ALTERNATIVAS_OK INTEGER,
                                                                     F_TOTAL_ALTERNATIVAS_NOK INTEGER)
        RETURNS BIGINT
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        -- Iremos atualizar o KM do Veículo somente para o caso em que o KM atual do veículo for menor que o KM coletado.
        DEVE_ATUALIZAR_KM_VEICULO BOOLEAN := (CASE
                                                  WHEN (F_KM_COLETADO > (SELECT V.KM
                                                                         FROM VEICULO V
                                                                         WHERE V.CODIGO = F_COD_VEICULO))
                                                      THEN
                                                      TRUE
                                                  ELSE FALSE END);
        COD_CHECKLIST_INSERIDO    BIGINT;
        QTD_LINHAS_ATUALIZADAS    BIGINT;
    BEGIN

        INSERT INTO CHECKLIST(COD_UNIDADE,
                              COD_CHECKLIST_MODELO,
                              COD_VERSAO_CHECKLIST_MODELO,
                              DATA_HORA,
                              DATA_HORA_REALIZACAO_TZ_APLICADO,
                              CPF_COLABORADOR,
                              PLACA_VEICULO,
                              TIPO,
                              TEMPO_REALIZACAO,
                              KM_VEICULO,
                              DATA_HORA_SINCRONIZACAO,
                              FONTE_DATA_HORA_REALIZACAO,
                              VERSAO_APP_MOMENTO_REALIZACAO,
                              VERSAO_APP_MOMENTO_SINCRONIZACAO,
                              DEVICE_ID,
                              DEVICE_IMEI,
                              DEVICE_UPTIME_REALIZACAO_MILLIS,
                              DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
                              FOI_OFFLINE,
                              TOTAL_PERGUNTAS_OK,
                              TOTAL_PERGUNTAS_NOK,
                              TOTAL_ALTERNATIVAS_OK,
                              TOTAL_ALTERNATIVAS_NOK)
        VALUES (F_COD_UNIDADE_CHECKLIST,
                F_COD_MODELO_CHECKLIST,
                F_COD_VERSAO_MODELO_CHECKLIST,
                F_DATA_HORA_REALIZACAO,
                (F_DATA_HORA_REALIZACAO AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE_CHECKLIST)),
                (SELECT C.CPF FROM COLABORADOR C WHERE C.CODIGO = F_COD_COLABORADOR),
                F_PLACA_VEICULO,
                F_TIPO_CHECKLIST,
                F_TEMPO_REALIZACAO,
                F_KM_COLETADO,
                F_DATA_HORA_SINCRONIZACAO,
                F_FONTE_DATA_HORA_REALIZACAO,
                F_VERSAO_APP_MOMENTO_REALIZACAO,
                F_VERSAO_APP_MOMENTO_SINCRONIZACAO,
                F_DEVICE_ID,
                F_DEVICE_IMEI,
                F_DEVICE_UPTIME_REALIZACAO_MILLIS,
                F_DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
                F_FOI_OFFLINE,
                F_TOTAL_PERGUNTAS_OK,
                F_TOTAL_PERGUNTAS_NOK,
                F_TOTAL_ALTERNATIVAS_OK,
                F_TOTAL_ALTERNATIVAS_NOK) RETURNING CODIGO INTO COD_CHECKLIST_INSERIDO;

        -- Verificamos se o insert funcionou.
        IF COD_CHECKLIST_INSERIDO <= 0
        THEN
            RAISE EXCEPTION 'Não foi possível inserir o checklist';
        END IF;

        IF DEVE_ATUALIZAR_KM_VEICULO
        THEN
            UPDATE VEICULO SET KM = F_KM_COLETADO WHERE CODIGO = F_COD_VEICULO;
        END IF;

        GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

        -- Se devemos atualizar o KM mas nenhuma linha foi alterada, então temos um erro.
        IF (DEVE_ATUALIZAR_KM_VEICULO AND QTD_LINHAS_ATUALIZADAS <= 0)
        THEN
            RAISE EXCEPTION 'Não foi possível atualizar o km do veículo';
        END IF;

        RETURN COD_CHECKLIST_INSERIDO;
    END;
    $$;


    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_INSERT_RESPOSTAS_CHECKLIST(F_COD_UNIDADE_CHECKLIST BIGINT,
                                                                         F_COD_MODELO_CHECKLIST BIGINT,
                                                                         F_COD_VERSAO_MODELO_CHECKLIST BIGINT,
                                                                         F_COD_CHECKLIST BIGINT,
                                                                         F_COD_PERGUNTA BIGINT,
                                                                         F_COD_ALTERNATIVA BIGINT,
                                                                         F_RESPOSTA_OUTROS TEXT)
        RETURNS BIGINT
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        QTD_LINHAS_INSERIDAS BIGINT;
    BEGIN
        INSERT INTO CHECKLIST_RESPOSTAS_NOK(COD_UNIDADE,
                                            COD_CHECKLIST_MODELO,
                                            COD_VERSAO_CHECKLIST_MODELO,
                                            COD_CHECKLIST,
                                            COD_PERGUNTA,
                                            COD_ALTERNATIVA,
                                            RESPOSTA_OUTROS)
        VALUES (F_COD_UNIDADE_CHECKLIST,
                F_COD_MODELO_CHECKLIST,
                F_COD_VERSAO_MODELO_CHECKLIST,
                F_COD_CHECKLIST,
                F_COD_PERGUNTA,
                F_COD_ALTERNATIVA,
                F_RESPOSTA_OUTROS);

        GET DIAGNOSTICS QTD_LINHAS_INSERIDAS = ROW_COUNT;

        IF QTD_LINHAS_INSERIDAS <> 1
        THEN
            RAISE EXCEPTION 'Não foi possível inserir a(s) resposta(s)';
        END IF;

        RETURN QTD_LINHAS_INSERIDAS;
    END;
    $$;

    --######################################################################################################################
--######################################################################################################################
--######################################################################################################################
--######################################################################################################################
--######################################################################################################################

    --######################################################################################################################
--######################################################################################################################
-- PL-2228
-- Function para buscar os modelos de checklist disponíveis para realização.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_GET_MODELOS_SELECAO_REALIZACAO(F_COD_UNIDADE BIGINT,
                                                                             F_COD_CARGO BIGINT)
        RETURNS TABLE
                (
                    COD_MODELO              BIGINT,
                    COD_VERSAO_ATUAL_MODELO BIGINT,
                    COD_UNIDADE_MODELO      BIGINT,
                    NOME_MODELO             TEXT,
                    COD_VEICULO             BIGINT,
                    PLACA_VEICULO           TEXT,
                    KM_ATUAL_VEICULO        BIGINT
                )
        LANGUAGE SQL
    AS
    $$
    SELECT CM.CODIGO           AS COD_MODELO,
           CM.COD_VERSAO_ATUAL AS COD_VERSAO_ATUAL_MODELO,
           CM.COD_UNIDADE      AS COD_UNIDADE_MODELO,
           CM.NOME :: TEXT     AS NOME_MODELO,
           V.CODIGO            AS COD_VEICULO,
           V.PLACA :: TEXT     AS PLACA_VEICULO,
           V.KM                AS KM_ATUAL_VEICULO
    FROM CHECKLIST_MODELO CM
             JOIN CHECKLIST_MODELO_FUNCAO CMF
                  ON CMF.COD_CHECKLIST_MODELO = CM.CODIGO AND CM.COD_UNIDADE = CMF.COD_UNIDADE
             JOIN CHECKLIST_MODELO_VEICULO_TIPO CMVT
                  ON CMVT.COD_MODELO = CM.CODIGO AND CMVT.COD_UNIDADE = CM.COD_UNIDADE
             JOIN VEICULO_TIPO VT
                  ON VT.CODIGO = CMVT.COD_TIPO_VEICULO
             JOIN VEICULO V
                  ON V.COD_TIPO = VT.CODIGO AND V.COD_UNIDADE = CM.COD_UNIDADE
    WHERE CM.COD_UNIDADE = F_COD_UNIDADE
      AND CMF.COD_FUNCAO = F_COD_CARGO
      AND CM.STATUS_ATIVO = TRUE
      AND V.STATUS_ATIVO = TRUE
    ORDER BY CM.CODIGO, V.PLACA
    $$;

    -- PL-2228
-- Function para buscar os modelos de checklist disponíveis para realização.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_GET_MODELO_REALIZACAO(F_COD_MODELO_CHECKLIST BIGINT,
                                                                    F_COD_VEICULO_REALIZACAO BIGINT)
        RETURNS TABLE
                (
                    COD_UNIDADE_MODELO_CHECKLIST BIGINT,
                    COD_MODELO_CHECKLIST         BIGINT,
                    COD_VERSAO_MODELO_CHECKLIST  BIGINT,
                    NOME_MODELO_CHECKLIST        TEXT,
                    COD_PERGUNTA                 BIGINT,
                    DESCRICAO_PERGUNTA           TEXT,
                    COD_IMAGEM                   BIGINT,
                    URL_IMAGEM                   TEXT,
                    PERGUNTA_ORDEM_EXIBICAO      INTEGER,
                    SINGLE_CHOICE                BOOLEAN,
                    COD_ALTERNATIVA              BIGINT,
                    DESCRICAO_ALTERNATIVA        TEXT,
                    TIPO_OUTROS                  BOOLEAN,
                    ALTERNATIVA_ORDEM_EXIBICAO   INTEGER,
                    PRIORIDADE_ALTERNATIVA       TEXT,
                    KM_ATUAL_VEICULO_REALIZACAO  BIGINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        KM_ATUAL_VEICULO CONSTANT BIGINT := (SELECT V.KM FROM VEICULO V WHERE V.CODIGO = F_COD_VEICULO_REALIZACAO);
    BEGIN
        IF KM_ATUAL_VEICULO IS NULL
        THEN
            RAISE EXCEPTION 'Erro ao buscar KM atual do veículo para realização do checklist!';
        END IF;

        RETURN QUERY
            SELECT CM.COD_UNIDADE              AS COD_UNIDADE_MODELO_CHECKLIST,
                   CM.CODIGO                   AS COD_MODELO_CHECKLIST,
                   CM.COD_VERSAO_ATUAL         AS COD_VERSAO_MODELO_CHECKLIST,
                   CM.NOME :: TEXT             AS NOME_MODELO_CHECKLIST,
                   CP.CODIGO                   AS COD_PERGUNTA,
                   CP.PERGUNTA                 AS DESCRICAO_PERGUNTA,
                   CP.COD_IMAGEM               AS COD_IMAGEM,
                   CGI.URL_IMAGEM              AS URL_IMAGEM,
                   CP.ORDEM                    AS PERGUNTA_ORDEM_EXIBICAO,
                   CP.SINGLE_CHOICE            AS SINGLE_CHOICE,
                   CAP.CODIGO                  AS COD_ALTERNATIVA,
                   CAP.ALTERNATIVA             AS DESCRICAO_ALTERNATIVA,
                   CAP.ALTERNATIVA_TIPO_OUTROS AS TIPO_OUTROS,
                   CAP.ORDEM                   AS ALTERNATIVA_ORDEM_EXIBICAO,
                   CAP.PRIORIDADE :: TEXT      AS PRIORIDADE_ALTERNATIVA,
                   KM_ATUAL_VEICULO            AS KM_ATUAL_VEICULO_REALIZACAO
            FROM CHECKLIST_MODELO CM
                     JOIN CHECKLIST_PERGUNTAS CP
                          ON CM.CODIGO = CP.COD_CHECKLIST_MODELO AND
                             CM.COD_VERSAO_ATUAL = CP.COD_VERSAO_CHECKLIST_MODELO
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON CP.CODIGO = CAP.COD_PERGUNTA AND CM.COD_VERSAO_ATUAL = CAP.COD_VERSAO_CHECKLIST_MODELO
                -- Precisamos que seja LEFT JOIN para o caso de perguntas sem imagem associada.
                     LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                               ON CP.COD_IMAGEM = CGI.COD_IMAGEM
            WHERE CM.CODIGO = F_COD_MODELO_CHECKLIST
              AND CM.STATUS_ATIVO
            ORDER BY COD_MODELO_CHECKLIST,
                     PERGUNTA_ORDEM_EXIBICAO,
                     COD_PERGUNTA,
                     ALTERNATIVA_ORDEM_EXIBICAO,
                     COD_ALTERNATIVA;
    END ;
    $$;

    -- Como a busca dos modelos mudou de DAO, a Avilan precisa ter o recurso de modelos integrado agora.
    INSERT INTO INTEGRACAO.EMPRESA_INTEGRACAO_SISTEMA (COD_EMPRESA, CHAVE_SISTEMA, RECURSO_INTEGRADO)
    VALUES (2, 'AVACORP_AVILAN', 'CHECKLIST_MODELO');
    --######################################################################################################################
--######################################################################################################################


--######################################################################################################################
--######################################################################################################################
    -- Function foi refatorada para a nova estrutura. Usando CHECKLIST_RESPOSTAS_NOK. Agora também retorna a versão do
    -- modelo.
    DROP FUNCTION FUNC_CHECKLIST_GET_BY_CODIGO(F_COD_CHECKLIST BIGINT);
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_GET_BY_CODIGO(F_COD_CHECKLIST BIGINT)
        RETURNS TABLE
                (
                    COD_CHECKLIST                 BIGINT,
                    COD_CHECKLIST_MODELO          BIGINT,
                    COD_VERSAO_CHECKLIST_MODELO   BIGINT,
                    DATA_HORA_REALIZACAO          TIMESTAMP WITHOUT TIME ZONE,
                    DATA_HORA_IMPORTADO_PROLOG    TIMESTAMP WITHOUT TIME ZONE,
                    KM_VEICULO_MOMENTO_REALIZACAO BIGINT,
                    DURACAO_REALIZACAO_MILLIS     BIGINT,
                    CPF_COLABORADOR               BIGINT,
                    PLACA_VEICULO                 TEXT,
                    TIPO_CHECKLIST                CHAR,
                    NOME_COLABORADOR              TEXT,
                    COD_PERGUNTA                  BIGINT,
                    ORDEM_PERGUNTA                INTEGER,
                    DESCRICAO_PERGUNTA            TEXT,
                    PERGUNTA_SINGLE_CHOICE        BOOLEAN,
                    COD_ALTERNATIVA               BIGINT,
                    PRIORIDADE_ALTERNATIVA        TEXT,
                    ORDEM_ALTERNATIVA             INTEGER,
                    DESCRICAO_ALTERNATIVA         TEXT,
                    ALTERNATIVA_TIPO_OUTROS       BOOLEAN,
                    COD_IMAGEM                    BIGINT,
                    URL_IMAGEM                    TEXT,
                    ALTERNATIVA_SELECIONADA       BOOLEAN,
                    RESPOSTA_OUTROS               TEXT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    BEGIN
        RETURN QUERY
            SELECT C.CODIGO                                                            AS COD_CHECKLIST,
                   C.COD_CHECKLIST_MODELO                                              AS COD_CHECKLIST_MODELO,
                   C.COD_VERSAO_CHECKLIST_MODELO                                       AS COD_CHECKLIST_MODELO,
                   C.DATA_HORA_REALIZACAO_TZ_APLICADO                                  AS DATA_HORA_REALIZACAO,
                   C.DATA_HORA_IMPORTADO_PROLOG AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE) AS DATA_HORA_IMPORTADO_PROLOG,
                   C.KM_VEICULO                                                        AS KM_VEICULO_MOMENTO_REALIZACAO,
                   C.TEMPO_REALIZACAO                                                  AS DURACAO_REALIZACAO_MILLIS,
                   C.CPF_COLABORADOR                                                   AS CPF_COLABORADOR,
                   C.PLACA_VEICULO :: TEXT                                             AS PLACA_VEICULO,
                   C.TIPO                                                              AS TIPO_CHECKLIST,
                   CO.NOME :: TEXT                                                     AS NOME_COLABORADOR,
                   CP.CODIGO                                                           AS COD_PERGUNTA,
                   CP.ORDEM                                                            AS ORDEM_PERGUNTA,
                   CP.PERGUNTA                                                         AS DESCRICAO_PERGUNTA,
                   CP.SINGLE_CHOICE                                                    AS PERGUNTA_SINGLE_CHOICE,
                   CAP.CODIGO                                                          AS COD_ALTERNATIVA,
                   CAP.PRIORIDADE :: TEXT                                              AS PRIORIDADE_ALTERNATIVA,
                   CAP.ORDEM                                                           AS ORDEM_ALTERNATIVA,
                   CAP.ALTERNATIVA                                                     AS DESCRICAO_ALTERNATIVA,
                   CAP.ALTERNATIVA_TIPO_OUTROS                                         AS ALTERNATIVA_TIPO_OUTROS,
                   CGI.COD_IMAGEM                                                      AS COD_IMAGEM,
                   CGI.URL_IMAGEM                                                      AS URL_IMAGEM,
                   CRN.CODIGO IS NOT NULL                                              AS ALTERNATIVA_SELECIONADA,
                   CRN.RESPOSTA_OUTROS                                                 AS RESPOSTA_OUTROS
            FROM CHECKLIST C
                     JOIN COLABORADOR CO
                          ON CO.CPF = C.CPF_COLABORADOR
                     JOIN CHECKLIST_PERGUNTAS CP
                          ON CP.COD_VERSAO_CHECKLIST_MODELO = C.COD_VERSAO_CHECKLIST_MODELO
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON CAP.COD_PERGUNTA = CP.CODIGO
                     LEFT JOIN CHECKLIST_RESPOSTAS_NOK CRN
                               ON C.CODIGO = CRN.COD_CHECKLIST
                                   AND CAP.CODIGO = CRN.COD_ALTERNATIVA
                     LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                               ON CP.COD_IMAGEM = CGI.COD_IMAGEM
            WHERE C.CODIGO = F_COD_CHECKLIST
            ORDER BY CP.CODIGO, CAP.CODIGO;
    END ;
    $$;
    --######################################################################################################################
    --######################################################################################################################
    -- PL-2346
    -- Dropa a FUNC_CHECKLIST_OS_ALTERNATIVAS_ABERTURA_OS
    DROP FUNCTION FUNC_CHECKLIST_OS_ALTERNATIVAS_ABERTURA_OS(BIGINT, TEXT);

    -- Recria a FUNC_CHECKLIST_OS_ALTERNATIVAS_ABERTURA_OS para considerar o código da versão do modelo de checklist.
    -- Agora ela também retorna se a alternativa é do tipo_outros. E, caso tenha item em aberto, retorna o texto
    -- tipo_outros que o usuário forneceu como resposta.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_ALTERNATIVAS_ABERTURA_OS(F_COD_MODELO_CHECKLIST BIGINT,
                                                                          F_COD_VERSAO_MODELO_CHECKLIST BIGINT,
                                                                          F_PLACA_VEICULO TEXT)
        RETURNS TABLE
                (
                    COD_ALTERNATIVA                    BIGINT,
                    COD_CONTEXTO_PERGUNTA              BIGINT,
                    COD_CONTEXTO_ALTERNATIVA           BIGINT,
                    COD_ITEM_ORDEM_SERVICO             BIGINT,
                    RESPOSTA_TIPO_OUTROS_ABERTURA_ITEM TEXT,
                    TEM_ITEM_OS_PENDENTE               BOOLEAN,
                    DEVE_ABRIR_ORDEM_SERVICO           BOOLEAN,
                    ALTERNATIVA_TIPO_OUTROS            BOOLEAN,
                    QTD_APONTAMENTOS_ITEM              INTEGER,
                    PRIORIDADE_ALTERNATIVA             TEXT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        STATUS_ITEM_PENDENTE TEXT = 'P';
    BEGIN
        RETURN QUERY
            WITH ITENS_PENDENTES AS (
                SELECT COSI.CODIGO                               AS COD_ITEM_ORDEM_SERVICO,
                       COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO AS COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                       COSI.COD_CONTEXTO_ALTERNATIVA             AS COD_CONTEXTO_ALTERNATIVA,
                       COSI.QT_APONTAMENTOS                      AS QTD_APONTAMENTOS_ITEM,
                       COS.COD_CHECKLIST                         AS COD_CHECKLIST,
                       C.COD_CHECKLIST_MODELO                    AS COD_CHECKLIST_MODELO
                FROM CHECKLIST_DATA C
                         JOIN CHECKLIST_ORDEM_SERVICO_DATA COS
                              ON C.CODIGO = COS.COD_CHECKLIST
                         JOIN CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSI
                              ON COS.CODIGO = COSI.COD_OS
                                  AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                WHERE C.PLACA_VEICULO = F_PLACA_VEICULO
                  AND C.COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
                  AND COSI.STATUS_RESOLUCAO = STATUS_ITEM_PENDENTE
            )
            SELECT CAP.CODIGO                                          AS COD_ALTERNATIVA,
                   CP.CODIGO_CONTEXTO                                  AS COD_CONTEXTO_PERGUNTA,
                   CAP.CODIGO_CONTEXTO                                 AS COD_CONTEXTO_ALTERNATIVA,
                   IP.COD_ITEM_ORDEM_SERVICO                           AS COD_ITEM_ORDEM_SERVICO,
                   CRN.RESPOSTA_OUTROS                                 AS RESPOSTA_TIPO_OUTROS_ABERTURA_ITEM,
                   F_IF(IP.COD_ITEM_ORDEM_SERVICO ISNULL, FALSE, TRUE) AS TEM_ITEM_OS_PENDENTE,
                   CAP.DEVE_ABRIR_ORDEM_SERVICO                        AS DEVE_ABRIR_ORDEM_SERVICO,
                   CAP.ALTERNATIVA_TIPO_OUTROS                         AS ALTERNATIVA_TIPO_OUTROS,
                   IP.QTD_APONTAMENTOS_ITEM                            AS QTD_APONTAMENTOS_ITEM,
                   CAP.PRIORIDADE::TEXT                                AS PRIORIDADE_ALTERNATIVA
            FROM CHECKLIST_ALTERNATIVA_PERGUNTA_DATA CAP
                     JOIN CHECKLIST_PERGUNTAS_DATA CP
                          ON CAP.COD_PERGUNTA = CP.CODIGO
                     LEFT JOIN ITENS_PENDENTES IP
                               ON IP.COD_CONTEXTO_ALTERNATIVA = CAP.CODIGO_CONTEXTO
                     LEFT JOIN CHECKLIST_RESPOSTAS_NOK CRN
                               ON CRN.COD_ALTERNATIVA = IP.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                                   AND CRN.COD_CHECKLIST = IP.COD_CHECKLIST
            WHERE CAP.COD_VERSAO_CHECKLIST_MODELO = F_COD_VERSAO_MODELO_CHECKLIST;
    END ;
    $$;
    --######################################################################################################################
--######################################################################################################################
END ;
$fun$;

create or replace function migration_checklist.func_migration_7_mudancas_dao_modelos_check() returns void
    language plpgsql
as
$fun$
begin
    --######################################################################################################################
--######################################################################################################################
--################################ DESCRIÇÃO ###########################################################################
--######################################################################################################################
--######################################################################################################################
-- PL-2231
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_INSERT_MODELO_CHECKLIST_INFOS(F_COD_UNIDADE_MODELO BIGINT,
                                                                            F_NOME_MODELO TEXT,
                                                                            F_STATUS_ATIVO BOOLEAN,
                                                                            F_COD_CARGOS BIGINT[],
                                                                            F_COD_TIPOS_VEICULOS BIGINT[],
                                                                            F_DATA_HORA_ATUAL TIMESTAMP WITH TIME ZONE,
                                                                            F_TOKEN_COLABORADOR TEXT)
        RETURNS TABLE
                (
                    COD_MODELO_CHECKLIST        BIGINT,
                    COD_VERSAO_MODELO_CHECKLIST BIGINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        ERROR_MESSAGE          TEXT   := 'Erro ao salvar modelo de checklist, tente novamente';
        QTD_LINHAS_INSERIDAS   BIGINT;
        COD_MODELO_INSERIDO    BIGINT;
        NOVO_COD_VERSAO_MODELO BIGINT := NEXTVAL(
                PG_GET_SERIAL_SEQUENCE('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
    BEGIN
        -- Assim conseguimos inserir mantendo a referência circular entre modelo e versão.
        SET CONSTRAINTS ALL DEFERRED;

        -- 1 -> Insere o modelo.
        INSERT INTO CHECKLIST_MODELO(COD_UNIDADE,
                                     COD_VERSAO_ATUAL,
                                     NOME,
                                     STATUS_ATIVO)
        VALUES (F_COD_UNIDADE_MODELO,
                NOVO_COD_VERSAO_MODELO,
                F_NOME_MODELO,
                F_STATUS_ATIVO) RETURNING CODIGO INTO COD_MODELO_INSERIDO;


        IF COD_MODELO_INSERIDO IS NULL OR COD_MODELO_INSERIDO <= 0
        THEN
            PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
        END IF;
        --

        -- 2 -> Insere a versão.
        INSERT INTO CHECKLIST_MODELO_VERSAO(COD_VERSAO_CHECKLIST_MODELO,
                                            COD_VERSAO_USER_FRIENDLY,
                                            COD_CHECKLIST_MODELO,
                                            DATA_HORA_CRIACAO_VERSAO,
                                            COD_COLABORADOR_CRIACAO_VERSAO)
        VALUES (NOVO_COD_VERSAO_MODELO,
                1,
                COD_MODELO_INSERIDO,
                F_DATA_HORA_ATUAL,
                (SELECT TA.COD_COLABORADOR FROM TOKEN_AUTENTICACAO TA WHERE TA.TOKEN = F_TOKEN_COLABORADOR));

        GET DIAGNOSTICS QTD_LINHAS_INSERIDAS = ROW_COUNT;

        IF QTD_LINHAS_INSERIDAS IS NULL OR QTD_LINHAS_INSERIDAS <> 1
        THEN
            PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
        END IF;
        --

        -- 3 -> Insere os tipos de veículos.
        INSERT INTO CHECKLIST_MODELO_VEICULO_TIPO(COD_UNIDADE, COD_MODELO, COD_TIPO_VEICULO)
        VALUES (F_COD_UNIDADE_MODELO, COD_MODELO_INSERIDO, UNNEST(F_COD_TIPOS_VEICULOS));
        --

        -- 4 -> Insere os cargos.
        INSERT INTO CHECKLIST_MODELO_FUNCAO(COD_UNIDADE, COD_CHECKLIST_MODELO, COD_FUNCAO)
        VALUES (F_COD_UNIDADE_MODELO, COD_MODELO_INSERIDO, UNNEST(F_COD_CARGOS));
        --

        RETURN QUERY
            SELECT COD_MODELO_INSERIDO              AS COD_MODELO_CHECKLIST,
                   NOVO_COD_VERSAO_MODELO :: BIGINT AS COD_VERSAO_MODELO_CHECKLIST;
    END;
    $$;


    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_INSERT_NOVA_VERSAO_MODELO(F_COD_UNIDADE_MODELO BIGINT,
                                                                        F_COD_MODELO BIGINT,
                                                                        F_NOME_MODELO TEXT,
                                                                        F_STATUS_ATIVO BOOLEAN,
                                                                        F_DATA_HORA_ATUAL TIMESTAMP WITH TIME ZONE,
                                                                        F_TOKEN_COLABORADOR TEXT)
        RETURNS TABLE
                (
                    COD_MODELO_CHECKLIST        BIGINT,
                    COD_VERSAO_MODELO_CHECKLIST BIGINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        ERROR_MESSAGE          TEXT   := 'Erro ao atualizar modelo de checklist, tente novamente';
        QTD_LINHAS_ATUALIZADAS BIGINT;
        NOVO_COD_VERSAO_MODELO BIGINT := NEXTVAL(
                PG_GET_SERIAL_SEQUENCE('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
    BEGIN
        -- 1 -> Primeiro criamos uma nova versão.
        INSERT INTO CHECKLIST_MODELO_VERSAO(COD_VERSAO_CHECKLIST_MODELO,
                                            COD_VERSAO_USER_FRIENDLY,
                                            COD_CHECKLIST_MODELO,
                                            DATA_HORA_CRIACAO_VERSAO,
                                            COD_COLABORADOR_CRIACAO_VERSAO)
        VALUES (NOVO_COD_VERSAO_MODELO,
                (SELECT MAX(COD_VERSAO_USER_FRIENDLY) + 1
                 FROM CHECKLIST_MODELO_VERSAO CMV
                 WHERE CMV.COD_CHECKLIST_MODELO = F_COD_MODELO),
                F_COD_MODELO,
                F_DATA_HORA_ATUAL,
                (SELECT TA.COD_COLABORADOR
                 FROM TOKEN_AUTENTICACAO TA
                 WHERE TA.TOKEN = F_TOKEN_COLABORADOR));

        GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

        IF QTD_LINHAS_ATUALIZADAS IS NULL
            OR QTD_LINHAS_ATUALIZADAS <> 1
            OR NOVO_COD_VERSAO_MODELO IS NULL
            OR NOVO_COD_VERSAO_MODELO <= 0
        THEN
            PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
        END IF;

        -- 2 -> Agora atualizamos o modelo de checklist.
        UPDATE CHECKLIST_MODELO
        SET NOME             = F_NOME_MODELO,
            STATUS_ATIVO     = F_STATUS_ATIVO,
            COD_VERSAO_ATUAL = NOVO_COD_VERSAO_MODELO
        WHERE CODIGO = F_COD_MODELO
          AND COD_UNIDADE = F_COD_UNIDADE_MODELO;

        GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

        IF QTD_LINHAS_ATUALIZADAS IS NULL OR QTD_LINHAS_ATUALIZADAS <> 1
        THEN
            PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
        END IF;

        RETURN QUERY
            SELECT F_COD_MODELO           AS COD_MODELO_CHECKLIST,
                   NOVO_COD_VERSAO_MODELO AS COD_VERSAO_MODELO_CHECKLIST;
    END;
    $$;


    DROP FUNCTION FUNC_CHECKLIST_UPDATE_MODELO_CHECKLIST(F_NOME_MODELO TEXT,
        F_COD_UNIDADE BIGINT,
        F_COD_MODELO BIGINT,
        F_COD_CARGOS BIGINT[],
        F_COD_TIPOS_VEICULOS BIGINT[]);

    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_UPDATE_MODELO_CHECKLIST_INFOS(F_COD_UNIDADE BIGINT,
                                                                            F_COD_MODELO BIGINT,
                                                                            F_NOME_MODELO TEXT,
                                                                            F_COD_CARGOS BIGINT[],
                                                                            F_COD_TIPOS_VEICULOS BIGINT[])
        RETURNS VOID
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        QTD_TIPOS_VEICULO_PARA_DELETAR BIGINT := (SELECT COUNT(*)
                                                  FROM CHECKLIST_MODELO_VEICULO_TIPO
                                                  WHERE COD_UNIDADE = F_COD_UNIDADE
                                                    AND COD_MODELO = F_COD_MODELO);
        QTD_CARGOS_PARA_DELETAR        BIGINT := (SELECT COUNT(*)
                                                  FROM CHECKLIST_MODELO_FUNCAO
                                                  WHERE COD_UNIDADE = F_COD_UNIDADE
                                                    AND COD_CHECKLIST_MODELO = F_COD_MODELO);
        QTD_LINHAS_IMPACTADAS          BIGINT;
    BEGIN
        -- 1 -> Atualiza o modelo.
        UPDATE CHECKLIST_MODELO
        SET NOME = F_NOME_MODELO
        WHERE COD_UNIDADE = F_COD_UNIDADE
          AND CODIGO = F_COD_MODELO;

        GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

        IF QTD_LINHAS_IMPACTADAS IS NULL OR QTD_LINHAS_IMPACTADAS <> 1
        THEN
            RAISE EXCEPTION 'Erro ao atualizar o nome do modelo de checklist';
        END IF;
        --

        -- 2 -> Atualiza os tipos de veículos.
        DELETE FROM CHECKLIST_MODELO_VEICULO_TIPO WHERE COD_UNIDADE = F_COD_UNIDADE AND COD_MODELO = F_COD_MODELO;

        GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

        IF QTD_TIPOS_VEICULO_PARA_DELETAR = QTD_LINHAS_IMPACTADAS
        THEN
            INSERT INTO CHECKLIST_MODELO_VEICULO_TIPO(COD_UNIDADE, COD_MODELO, COD_TIPO_VEICULO)
            VALUES (F_COD_UNIDADE, F_COD_MODELO, UNNEST(F_COD_TIPOS_VEICULOS));

            GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

            IF QTD_LINHAS_IMPACTADAS IS NULL OR QTD_LINHAS_IMPACTADAS <> ARRAY_LENGTH(F_COD_TIPOS_VEICULOS, 1)
            THEN
                RAISE EXCEPTION 'Erro ao inserir tipos de veículo liberados no modelo de checklist %', F_COD_MODELO;
            END IF;
        ELSE
            RAISE EXCEPTION 'Não foi possível limpar as entradas da tabela CHECKLIST_MODELO_VEICULO_TIPO';
        END IF;
        --

        -- 3 -> Atualiza os cargos.
        DELETE FROM CHECKLIST_MODELO_FUNCAO WHERE COD_UNIDADE = F_COD_UNIDADE AND COD_CHECKLIST_MODELO = F_COD_MODELO;

        GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

        IF QTD_CARGOS_PARA_DELETAR = QTD_LINHAS_IMPACTADAS
        THEN
            INSERT INTO CHECKLIST_MODELO_FUNCAO(COD_UNIDADE, COD_CHECKLIST_MODELO, COD_FUNCAO)
            VALUES (F_COD_UNIDADE, F_COD_MODELO, UNNEST(F_COD_CARGOS));

            GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

            IF QTD_LINHAS_IMPACTADAS IS NULL OR QTD_LINHAS_IMPACTADAS <> ARRAY_LENGTH(F_COD_CARGOS, 1)
            THEN
                RAISE EXCEPTION 'Erro ao inserir cargos liberados no modelo de checklist %', F_COD_MODELO;
            END IF;
        ELSE
            RAISE EXCEPTION 'Não foi possível limpar as entradas da tabela CHECKLIST_MODELO_FUNCAO';
        END IF;
        --
    END;
    $$;


    create extension fuzzystrmatch;

    -- Nova versão:
    --

    create or replace function func_checklist_analisa_mudancas_modelo(f_cod_modelo bigint,
                                                                      f_cod_versao_modelo bigint,
                                                                      f_nome_modelo text,
                                                                      f_cod_cargos bigint[],
                                                                      f_cod_tipos_veiculos bigint[],
                                                                      f_perguntas_alternativas_json jsonb)
        returns table
                (
                    codigo_item                   bigint,
                    item_novo                     boolean,
                    item_mudou_contexto           boolean,
                    item_tipo_pergunta            boolean,
                    algo_mudou_no_modelo          boolean,
                    algo_mudou_no_contexto        boolean,
                    deve_criar_nova_versao_modelo boolean
                )
        language plpgsql
    as
    $$
    declare
        algo_mudou_no_modelo          boolean := false;
        algo_mudou_no_contexto        boolean := false;
        deve_criar_nova_versao_modelo boolean := false;
    begin
        -- Verifica se o nome do modelo sofreu alteração, cria nova versão sem alterar contexto.
        if (select exists(
                           select soundex(f_nome_modelo)
                               except
                           select soundex(nome)
                           from checklist_modelo
                           where cod_versao_atual = f_cod_versao_modelo
                       ))
        then
            algo_mudou_no_modelo := true;
            deve_criar_nova_versao_modelo := true;
        end if;

        -- 1 -> Cria tabelas temporárias para nos ajudarem a trabalhar com os dados.
        create temp table if not exists perguntas
        (
            _id                     bigserial not null,
            codigo                  bigint,
            cod_imagem              bigint,
            descricao               text      not null,
            single_choice           boolean   not null,
            ordem_exibicao          integer   not null,
            pergunta_nova           boolean   not null,
            pergunta_mudou          boolean,
            pergunta_mudou_contexto boolean
        ) on commit delete rows;

        create temp table if not exists alternativas
        (
            _id                        bigserial not null,
            codigo                     bigint,
            descricao                  text      not null,
            prioridade                 text      not null,
            tipo_outros                boolean   not null,
            ordem_exibicao             integer   not null,
            deve_abrir_ordem_servico   boolean   not null,
            alternativa_nova           boolean   not null,
            alternativa_mudou          boolean,
            alternativa_mudou_contexto boolean
        ) on commit delete rows;
        --

        -- 2 -> Insere as perguntas.
        with cte as (
            select jsonb_array_elements(f_perguntas_alternativas_json) src
        )
        insert
        into perguntas (codigo, cod_imagem, descricao, single_choice, ordem_exibicao, pergunta_nova)
        select (src ->> 'codigo') :: bigint,
               (src ->> 'codImagem') :: bigint,
               (src ->> 'descricao'),
               (src ->> 'singleChoice') :: boolean,
               (src ->> 'ordemExibicao') :: integer,
               -- Se for uma pergunta sendo cadastrada, então ainda não tem código.
               (src ->> 'codigo') is null
        from cte;
        --


        -- 3 -> Insere as alternativas.
        with cte as (
            select jsonb_array_elements(jsonb_array_elements(f_perguntas_alternativas_json) -> 'alternativas') src
        )
        insert
        into alternativas (codigo, descricao, prioridade, tipo_outros, ordem_exibicao, deve_abrir_ordem_servico,
                           alternativa_nova)
        select (src ->> 'codigo') :: bigint,
               (src ->> 'descricao'),
               (src ->> 'prioridade'),
               (src ->> 'tipoOutros') :: boolean,
               (src ->> 'ordemExibicao') :: integer,
               (src ->> 'deveAbrirOrdemServico') :: boolean,
               -- Se for uma alternativa sendo cadastrada, então ainda não tem código.
               (src ->> 'codigo') is null
        from cte;
        --

        -- 4.1 -> Verifica se alguma pergunta foi deletada.
        if (select exists(select cp.codigo
                          from checklist_perguntas cp
                          where cp.cod_checklist_modelo = f_cod_modelo
                            and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
                              except
                          select codigo
                          from perguntas
                          where codigo is not null
                       ))
        then
            algo_mudou_no_contexto := true;
            algo_mudou_no_modelo := true;
            deve_criar_nova_versao_modelo := true;
        end if;

        -- 4.2 -> Verifica se alguma alternativa foi deletada.
        if (select exists(select cap.codigo
                          from checklist_alternativa_pergunta cap
                          where cap.cod_checklist_modelo = f_cod_modelo
                            and cap.cod_versao_checklist_modelo = f_cod_versao_modelo
                              except
                          select codigo
                          from alternativas
                          where codigo is not null
                       ))
        then
            algo_mudou_no_contexto := true;
            algo_mudou_no_modelo := true;
            deve_criar_nova_versao_modelo := true;
        end if;


        -- 4.3 -> Verifica se as perguntas mudaram com alteração de contexto.
        with perguntas_novas_ou_editadas as (
            select codigo,
                   cod_imagem,
                   -- Usamos o soundex para verificar se a descrição mudou e não o texto em si.
                   soundex(descricao)
            from perguntas
                except
            select cp.codigo,
                   cp.cod_imagem,
                   soundex(cp.pergunta)
            from checklist_perguntas cp
            where cp.cod_checklist_modelo = f_cod_modelo
              and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
        )

        update perguntas p
        set pergunta_mudou_contexto = true
            -- CTE irá conter apenas as novas e/ou alteradas.
        from perguntas_novas_ou_editadas pne
             -- Só considera como alterada as perguntas que já existiam.
        where pne.codigo is not null
          and pne.codigo = p.codigo;

        if (select count(*) from perguntas where pergunta_mudou_contexto is true or pergunta_nova is true) > 0
        then
            algo_mudou_no_contexto := true;
            deve_criar_nova_versao_modelo := true;
        end if;
        --

        -- 4.4 -> Verifica se o tipo de escolha das perguntas mudou sem alteração de contexto.
        with perguntas_tipo_selecao_alterada as (
            select codigo,
                   single_choice
            from perguntas
                except
            select cp.codigo,
                   cp.single_choice
            from checklist_perguntas cp
            where cp.cod_checklist_modelo = f_cod_modelo
              and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
        )

        update perguntas p
        set pergunta_mudou = true
            -- CTE irá conter apenas as perguntas que mudaram o tipo de seleção.
        from perguntas_tipo_selecao_alterada pne
             -- Só considera como alterada as perguntas que já existiam.
        where pne.codigo is not null
          and pne.codigo = p.codigo;

        if (select count(*) from perguntas where pergunta_mudou is true) > 0 and deve_criar_nova_versao_modelo is false
        then
            algo_mudou_no_modelo := true;
            deve_criar_nova_versao_modelo := true;
        end if;
        --

        -- 4.5 -> Verifica se a ordem das perguntas mudou sem alteração de contexto.
        with perguntas_ordem_alterada as (
            select codigo,
                   ordem_exibicao
            from perguntas
                except
            select cp.codigo,
                   cp.ordem
            from checklist_perguntas cp
            where cp.cod_checklist_modelo = f_cod_modelo
              and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
        )

        update perguntas p
        set pergunta_mudou = true
            -- CTE irá conter apenas as perguntas que mudaram a ordem de exibição.
        from perguntas_ordem_alterada pne
             -- Só considera como alterada as perguntas que já existiam.
        where pne.codigo is not null
          and pne.codigo = p.codigo;

        if (select count(*) from perguntas where pergunta_mudou is true) > 0 and deve_criar_nova_versao_modelo is false
        then
            algo_mudou_no_modelo := true;
            deve_criar_nova_versao_modelo := true;
        end if;
        --

        -- 4.6 -> Verifica se as perguntas mudaram sem alteração de contexto.
        with perguntas_novas_ou_editadas as (
            select codigo,
                   descricao
            from perguntas
                except
            select cp.codigo,
                   cp.pergunta
            from checklist_perguntas cp
            where cp.cod_checklist_modelo = f_cod_modelo
              and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
        )

        update perguntas p
        set pergunta_mudou = true
            -- CTE irá conter apenas as novas e/ou alteradas.
        from perguntas_novas_ou_editadas pne
             -- Só considera como alterada as perguntas que já existiam.
        where pne.codigo is not null
          and pne.codigo = p.codigo;

        if (select count(*) from perguntas where pergunta_mudou is true) > 0 AND deve_criar_nova_versao_modelo is false
        then
            algo_mudou_no_modelo := true;
        end if;
        --

        -- 5.1 -> Verifica se as alternativas mudaram com alteração de contexto.
        with alternativas_novas_ou_editadas as (
            select codigo,
                   -- Usamos o soundex para verificar se a descrição mudou e não o texto em si.
                   soundex(descricao),
                   prioridade,
                   tipo_outros,
                   deve_abrir_ordem_servico
            from alternativas
                except
            select cap.codigo,
                   soundex(cap.alternativa),
                   cap.prioridade,
                   cap.alternativa_tipo_outros,
                   cap.deve_abrir_ordem_servico
            from checklist_alternativa_pergunta cap
            where cap.cod_checklist_modelo = f_cod_modelo
              and cap.cod_versao_checklist_modelo = f_cod_versao_modelo
        )

        update alternativas a
        set alternativa_mudou_contexto = true
            -- CTE irá conter apenas as novas e/ou alteradas.
        from alternativas_novas_ou_editadas ane
             -- Só considera como alterada as alternativas que já existiam.
        where ane.codigo is not null
          and a.codigo = ane.codigo;

        if (select count(*) from alternativas where alternativa_mudou_contexto is true or alternativa_nova is true) > 0
        then
            algo_mudou_no_contexto := true;
            deve_criar_nova_versao_modelo := true;
        end if;
        --

        -- 5.2 -> Verifica se as alternativas mudaram sem alteração de contexto.
        with alternativas_novas_ou_editadas as (
            select codigo,
                   descricao,
                   ordem_exibicao
            from alternativas
                except
            select cap.codigo,
                   cap.alternativa,
                   cap.ordem
            from checklist_alternativa_pergunta cap
            where cap.cod_checklist_modelo = f_cod_modelo
              and cap.cod_versao_checklist_modelo = f_cod_versao_modelo
        )

        update alternativas a
        set alternativa_mudou = true
            -- CTE irá conter apenas as novas e/ou alteradas.
        from alternativas_novas_ou_editadas ane
             -- Só considera como alterada as alternativas que já existiam.
        where ane.codigo is not null
          and a.codigo = ane.codigo;

        if (select count(*) from alternativas where alternativa_mudou is true) > 0 and
           deve_criar_nova_versao_modelo is false
        then
            algo_mudou_no_modelo := true;
            deve_criar_nova_versao_modelo := false;
        end if;
        --

        -- 6 -> Verifica se os cargos mudaram.
        if (select count(*)
            from (select codigo
                  from unnest(f_cod_cargos) codigo
                      except
                  select cmf.cod_funcao
                  from checklist_modelo_funcao cmf
                  where cmf.cod_checklist_modelo = f_cod_modelo) t) > 0
        then
            algo_mudou_no_modelo := true;
        end if;
        --

        -- 7 -> Verifica se os tipos de veículos mudaram.
        if (select count(*)
            from (select codigo
                  from unnest(f_cod_tipos_veiculos) codigo
                      except
                  select cmvt.cod_tipo_veiculo
                  from checklist_modelo_veiculo_tipo cmvt
                  where cmvt.cod_modelo = f_cod_modelo) t) > 0
        then
            algo_mudou_no_modelo := true;
        end if;
        --

        case
            -- A) Caso mais simples: nada mudou, não precisamos fazer nada.
            when algo_mudou_no_contexto is false and deve_criar_nova_versao_modelo is false and
                 algo_mudou_no_modelo is false
                then
                    return query
                        select null :: bigint  as codigo_item,
                               null :: boolean as item_novo,
                               null :: boolean as item_mudou_contexto,
                               null :: boolean as item_tipo_pergunta,
                               false           as algo_mudou_no_modelo,
                               false           as algo_mudou_no_contexto,
                               false           as deve_criar_nova_versao_modelo;

            -- B) Caso intermediário: algo mudou no modelo porém nada que justifique a criação de uma nova versão.
            when algo_mudou_no_modelo is true and deve_criar_nova_versao_modelo is false
                then
                    return query
                        select null :: bigint  as codigo_item,
                               null :: boolean as item_novo,
                               null :: boolean as item_mudou_contexto,
                               null :: boolean as item_tipo_pergunta,
                               true            as algo_mudou_no_modelo,
                               false           as algo_mudou_no_contexto,
                               false           as deve_criar_nova_versao_modelo;

            -- C) Caso intermediário: algo mudou no modelo com a criação de uma nova versão e mantendo o código de contexto.
            when algo_mudou_no_modelo is true and deve_criar_nova_versao_modelo is true and
                 algo_mudou_no_contexto is false
                then
                    return query
                        select p.codigo                      as codigo_item,
                               p.pergunta_nova               as item_novo,
                               p.pergunta_mudou_contexto     as item_mudou_contexto,
                               true                          as item_tipo_pergunta,
                               true                          as algo_mudou_no_modelo,
                               false                         as algo_mudou_no_contexto,
                               deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                        from perguntas p
                        union all
                        select a.codigo                      as codigo_item,
                               a.alternativa_nova            as item_novo,
                               a.alternativa_mudou_contexto  as item_mudou_contexto,
                               false                         as item_tipo_pergunta,
                               true                          as algo_mudou_no_modelo,
                               false                         as algo_mudou_no_contexto,
                               deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                        from alternativas a;

            -- D) Caso mais complexo: algo mudou e iremos precisar criar nova versão. Nesse cenário temos que retornar
            -- todas as informações.
            when algo_mudou_no_contexto is true and deve_criar_nova_versao_modelo is true
                then
                    return query
                        select p.codigo                      as codigo_item,
                               p.pergunta_nova               as item_novo,
                               p.pergunta_mudou_contexto     as item_mudou_contexto,
                               true                          as item_tipo_pergunta,
                               true                          as algo_mudou_no_modelo,
                               true                          as algo_mudou_no_contexto,
                               deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                        from perguntas p
                        union all
                        select a.codigo                      as codigo_item,
                               a.alternativa_nova            as item_novo,
                               a.alternativa_mudou_contexto  as item_mudou_contexto,
                               false                         as item_tipo_pergunta,
                               true                          as algo_mudou_no_modelo,
                               true                          as algo_mudou_no_contexto,
                               deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                        from alternativas a;
            else
                raise exception
                    'Erro! Estado ilegal dos dados. algo_mudou_no_modelo = false AND deve_criar_nova_versao_modelo = true';
            end case;

        drop table alternativas;
        drop table perguntas;
    END;
    $$;

    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_GET_LISTAGEM_MODELOS_CHECKLIST(F_COD_UNIDADE BIGINT)
        RETURNS TABLE
                (
                    MODELO          TEXT,
                    COD_MODELO      BIGINT,
                    COD_UNIDADE     BIGINT,
                    NOME_CARGO      TEXT,
                    TIPO_VEICULO    TEXT,
                    TOTAL_PERGUNTAS BIGINT,
                    STATUS_ATIVO    BOOLEAN
                )
        LANGUAGE SQL
    AS
    $$
    SELECT CM.NOME          AS MODELO,
           CM.CODIGO        AS COD_MODELO,
           CM.COD_UNIDADE   AS COD_UNIDADE,
           F.NOME           AS NOME_CARGO,
           VT.NOME          AS TIPO_VEICULO,
           COUNT(CP.CODIGO) AS TOTAL_PERGUNTAS,
           CM.STATUS_ATIVO  AS STATUS_ATIVO
    FROM CHECKLIST_MODELO CM
             JOIN CHECKLIST_PERGUNTAS CP ON CM.COD_UNIDADE = CP.COD_UNIDADE
        AND CM.CODIGO = CP.COD_CHECKLIST_MODELO
        AND CM.COD_VERSAO_ATUAL = CP.COD_VERSAO_CHECKLIST_MODELO
             LEFT JOIN CHECKLIST_MODELO_FUNCAO CMF ON CM.COD_UNIDADE = CMF.COD_UNIDADE
        AND CM.CODIGO = CMF.COD_CHECKLIST_MODELO
             LEFT JOIN FUNCAO F ON CMF.COD_FUNCAO = F.CODIGO
             LEFT JOIN CHECKLIST_MODELO_VEICULO_TIPO CMVT ON CM.COD_UNIDADE = CMVT.COD_UNIDADE
        AND CM.CODIGO = CMVT.COD_MODELO
             LEFT JOIN VEICULO_TIPO VT ON CMVT.COD_TIPO_VEICULO = VT.CODIGO
    WHERE CM.COD_UNIDADE = F_COD_UNIDADE
    GROUP BY CM.NOME, CM.CODIGO, CM.COD_UNIDADE, F.NOME, VT.CODIGO, CM.STATUS_ATIVO
    ORDER BY CM.STATUS_ATIVO DESC, CM.CODIGO ASC;
    $$;

    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_GET_PERGUNTAS_MODELOS_CHECKLIST(F_COD_UNIDADE BIGINT,
                                                                              F_COD_MODELO BIGINT,
                                                                              F_COD_VERSAO_MODELO BIGINT)
        RETURNS TABLE
                (
                    COD_PERGUNTA             BIGINT,
                    COD_CONTEXTO_PERGUNTA    BIGINT,
                    COD_IMAGEM               BIGINT,
                    URL_IMAGEM               TEXT,
                    PERGUNTA                 TEXT,
                    ORDEM_PERGUNTA           INTEGER,
                    SINGLE_CHOICE            BOOLEAN,
                    COD_ALTERNATIVA          BIGINT,
                    COD_CONTEXTO_ALTERNATIVA BIGINT,
                    ALTERNATIVA              TEXT,
                    PRIORIDADE               TEXT,
                    ORDEM_ALTERNATIVA        INTEGER,
                    DEVE_ABRIR_ORDEM_SERVICO BOOLEAN,
                    ALTERNATIVA_TIPO_OUTROS  BOOLEAN
                )
        LANGUAGE SQL
    AS
    $$
    SELECT CP.CODIGO                    AS COD_PERGUNTA,
           CP.CODIGO_CONTEXTO           AS COD_CONTEXTO_PERGUNTA,
           CGI.COD_IMAGEM               AS COD_IMAGEM,
           CGI.URL_IMAGEM               AS URL_IMAGEM,
           CP.PERGUNTA                  AS PERGUNTA,
           CP.ORDEM                     AS ORDEM_PERGUNTA,
           CP.SINGLE_CHOICE             AS SINGLE_CHOICE,
           CAP.CODIGO                   AS COD_ALTERNATIVA,
           CAP.CODIGO_CONTEXTO          AS COD_CONTEXTO_ALTERNATIVA,
           CAP.ALTERNATIVA              AS ALTERNATIVA,
           CAP.PRIORIDADE :: TEXT       AS PRIORIDADE,
           CAP.ORDEM                    AS ORDEM_ALTERNATIVA,
           CAP.DEVE_ABRIR_ORDEM_SERVICO AS DEVE_ABRIR_ORDEM_SERVICO,
           CAP.ALTERNATIVA_TIPO_OUTROS  AS ALTERNATIVA_TIPO_OUTROS
    FROM CHECKLIST_PERGUNTAS CP
             JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                  ON CP.CODIGO = CAP.COD_PERGUNTA
                      AND CAP.COD_UNIDADE = CP.COD_UNIDADE
                      AND CAP.COD_CHECKLIST_MODELO = CP.COD_CHECKLIST_MODELO
                      AND CAP.COD_VERSAO_CHECKLIST_MODELO = CP.COD_VERSAO_CHECKLIST_MODELO
             LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                       ON CGI.COD_IMAGEM = CP.COD_IMAGEM
    WHERE CP.COD_UNIDADE = F_COD_UNIDADE
      AND CP.COD_CHECKLIST_MODELO = F_COD_MODELO
      AND CP.COD_VERSAO_CHECKLIST_MODELO = F_COD_VERSAO_MODELO
    ORDER BY CP.ORDEM, CP.PERGUNTA, CAP.ORDEM;
    $$;

    --######################################################################################################################
--######################################################################################################################
--######################################################################################################################
--######################################################################################################################
--######################################################################################################################
end;
$fun$;

create or replace function migration_checklist.func_migration_9_criacao_indexes() returns void
    language plpgsql
as
$$
begin
    CREATE INDEX IDX_CHECKLIST_RESPOSTAS_NOK_COD_CHECKLIST
        ON CHECKLIST_RESPOSTAS_NOK (COD_CHECKLIST);

    CREATE INDEX IDX_CHECKLIST_RESPOSTAS_NOK_COD_ALTERNATIVA
        ON CHECKLIST_RESPOSTAS_NOK (COD_ALTERNATIVA);

    CREATE INDEX IDX_CHECKLIST_ALTERNATIVA_PERGUNTA_COD_PERGUNTA
        ON CHECKLIST_ALTERNATIVA_PERGUNTA_DATA (COD_PERGUNTA);
end;
$$;

create or replace function migration_checklist.func_migration_10_alteracoes_check_off() returns void
    language plpgsql
as
$fun$
begin
    --######################################################################################################################
    --######################################################################################################################
    -- Alteramos para retornar também as colunas: COD_VERSAO_MODELO_CHECKLIST, COD_CONTEXTO_PERGUNTA e
    -- COD_CONTEXTO_ALTERNATIVA. Além disso, os filtros de STATUS_ATIVO em pergunta e alternativa foram removidos, já
    -- que essas colunas não existem mais na nova estrutura e os JOINS com perguntas e alternativas agora também
    -- utilizam a versão atual do modelo.
    --######################################################################################################################
    --######################################################################################################################
    -- Como o retonro muda, dropamos a function antes.
    DROP FUNCTION FUNC_CHECKLIST_OFFLINE_GET_MODELOS_DISPONIVEIS(F_COD_UNIDADE BIGINT);
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OFFLINE_GET_MODELOS_DISPONIVEIS(F_COD_UNIDADE BIGINT)
        RETURNS TABLE
                (
                    COD_UNIDADE_MODELO_CHECKLIST      BIGINT,
                    COD_MODELO_CHECKLIST              BIGINT,
                    COD_VERSAO_ATUAL_MODELO_CHECKLIST BIGINT,
                    NOME_MODELO_CHECKLIST             TEXT,
                    COD_PERGUNTA                      BIGINT,
                    COD_CONTEXTO_PERGUNTA             BIGINT,
                    DESCRICAO_PERGUNTA                TEXT,
                    COD_IMAGEM                        BIGINT,
                    URL_IMAGEM                        TEXT,
                    PERGUNTA_ORDEM_EXIBICAO           INTEGER,
                    SINGLE_CHOICE                     BOOLEAN,
                    COD_ALTERNATIVA                   BIGINT,
                    COD_CONTEXTO_ALTERNATIVA          BIGINT,
                    DESCRICAO_ALTERNATIVA             TEXT,
                    TIPO_OUTROS                       BOOLEAN,
                    ALTERNATIVA_ORDEM_EXIBICAO        INTEGER,
                    PRIORIDADE_ALTERNATIVA            TEXT,
                    COD_CARGO                         BIGINT,
                    COD_TIPO_VEICULO                  BIGINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    BEGIN
        RETURN QUERY
            WITH CHECKLIST_MODELO_ATIVO AS (
                SELECT CM.COD_UNIDADE              AS COD_UNIDADE_MODELO_CHECKLIST,
                       CM.CODIGO                   AS COD_MODELO_CHECKLIST,
                       CM.COD_VERSAO_ATUAL         AS COD_VERSAO_MODELO_CHECKLIST,
                       CM.NOME :: TEXT             AS NOME_MODELO_CHECKLIST,
                       CP.CODIGO                   AS COD_PERGUNTA,
                       CP.CODIGO_CONTEXTO          AS COD_CONTEXTO_PERGUNTA,
                       CP.PERGUNTA                 AS DESCRICAO_PERGUNTA,
                       CP.COD_IMAGEM               AS COD_IMAGEM,
                       CGI.URL_IMAGEM              AS URL_IMAGEM,
                       CP.ORDEM                    AS PERGUNTA_ORDEM_EXIBICAO,
                       CP.SINGLE_CHOICE            AS SINGLE_CHOICE,
                       CAP.CODIGO                  AS COD_ALTERNATIVA,
                       CAP.CODIGO_CONTEXTO         AS COD_CONTEXTO_ALTERNATIVA,
                       CAP.ALTERNATIVA             AS DESCRICAO_ALTERNATIVA,
                       CAP.ALTERNATIVA_TIPO_OUTROS AS TIPO_OUTROS,
                       CAP.ORDEM                   AS ALTERNATIVA_ORDEM_EXIBICAO,
                       CAP.PRIORIDADE :: TEXT      AS PRIORIDADE_ALTERNATIVA,
                       NULL :: BIGINT              AS COD_CARGO,
                       NULL :: BIGINT              AS COD_TIPO_VEICULO
                FROM CHECKLIST_MODELO CM
                         JOIN CHECKLIST_PERGUNTAS CP
                              ON CM.CODIGO = CP.COD_CHECKLIST_MODELO
                                  AND CM.COD_VERSAO_ATUAL = CP.COD_VERSAO_CHECKLIST_MODELO
                         JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                              ON CP.CODIGO = CAP.COD_PERGUNTA
                    -- Precisamos que seja LEFT JOIN para o caso de perguntas sem imagem associada.
                         LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                                   ON CP.COD_IMAGEM = CGI.COD_IMAGEM
                WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                  AND CM.STATUS_ATIVO
            ),

                 CHECKLIST_MODELO_CARGO AS (
                     SELECT NULL :: BIGINT           AS COD_UNIDADE_MODELO_CHECKLIST,
                            CMF.COD_CHECKLIST_MODELO AS COD_MODELO_CHECKLIST,
                            NULL :: BIGINT           AS COD_VERSAO_MODELO_CHECKLIST,
                            NULL :: TEXT             AS NOME_MODELO_CHECKLIST,
                            NULL :: BIGINT           AS COD_PERGUNTA,
                            NULL :: BIGINT           AS COD_CONTEXTO_PERGUNTA,
                            NULL :: TEXT             AS DESCRICAO_PERGUNTA,
                            NULL :: BIGINT           AS COD_IMAGEM,
                            NULL :: TEXT             AS URL_IMAGEM,
                            NULL :: INTEGER          AS PERGUNTA_ORDEM_EXIBICAO,
                            NULL :: BOOLEAN          AS SINGLE_CHOICE,
                            NULL :: BIGINT           AS COD_ALTERNATIVA,
                            NULL :: BIGINT           AS COD_CONTEXTO_ALTERNATIVA,
                            NULL :: TEXT             AS DESCRICAO_ALTERNATIVA,
                            NULL :: BOOLEAN          AS TIPO_OUTROS,
                            NULL :: INTEGER          AS ALTERNATIVA_ORDEM_EXIBICAO,
                            NULL :: TEXT             AS PRIORIDADE_ALTERNATIVA,
                            CMF.COD_FUNCAO           AS COD_CARGO,
                            NULL :: BIGINT           AS COD_TIPO_VEICULO
                     FROM CHECKLIST_MODELO_FUNCAO CMF
                     WHERE CMF.COD_CHECKLIST_MODELO IN (SELECT CODIGO
                                                        FROM CHECKLIST_MODELO CM
                                                        WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                                                          AND CM.STATUS_ATIVO = TRUE)
                 ),

                 CHECKLIST_MODELO_TIPO_VEICULO AS (
                     SELECT NULL :: BIGINT        AS COD_UNIDADE_MODELO_CHECKLIST,
                            CMVT.COD_MODELO       AS COD_MODELO_CHECKLIST,
                            NULL :: BIGINT        AS COD_VERSAO_MODELO_CHECKLIST,
                            NULL :: TEXT          AS NOME_MODELO_CHECKLIST,
                            NULL :: BIGINT        AS COD_PERGUNTA,
                            NULL :: BIGINT        AS COD_CONTEXTO_PERGUNTA,
                            NULL :: TEXT          AS DESCRICAO_PERGUNTA,
                            NULL :: BIGINT        AS COD_IMAGEM,
                            NULL :: TEXT          AS URL_IMAGEM,
                            NULL :: INTEGER       AS PERGUNTA_ORDEM_EXIBICAO,
                            NULL :: BOOLEAN       AS SINGLE_CHOICE,
                            NULL :: BIGINT        AS COD_ALTERNATIVA,
                            NULL :: BIGINT        AS COD_CONTEXTO_ALTERNATIVA,
                            NULL :: TEXT          AS DESCRICAO_ALTERNATIVA,
                            NULL :: BOOLEAN       AS TIPO_OUTROS,
                            NULL :: INTEGER       AS ALTERNATIVA_ORDEM_EXIBICAO,
                            NULL :: TEXT          AS PRIORIDADE_ALTERNATIVA,
                            NULL :: BIGINT        AS COD_CARGO,
                            CMVT.COD_TIPO_VEICULO AS COD_TIPO_VEICULO
                     FROM CHECKLIST_MODELO_VEICULO_TIPO CMVT
                     WHERE CMVT.COD_MODELO IN (SELECT CODIGO
                                               FROM CHECKLIST_MODELO CM
                                               WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                                                 AND CM.STATUS_ATIVO = TRUE)
                 ),

                 CHECKLISTS_FILTRADOS AS (
                     SELECT *
                     FROM CHECKLIST_MODELO_ATIVO
                     UNION ALL
                     SELECT *
                     FROM CHECKLIST_MODELO_CARGO
                     UNION ALL
                     SELECT *
                     FROM CHECKLIST_MODELO_TIPO_VEICULO
                 )

            SELECT CF.COD_UNIDADE_MODELO_CHECKLIST AS COD_UNIDADE_MODELO_CHECKLIST,
                   CF.COD_MODELO_CHECKLIST         AS COD_MODELO_CHECKLIST,
                   CF.COD_VERSAO_MODELO_CHECKLIST  AS COD_VERSAO_MODELO_CHECKLIST,
                   CF.NOME_MODELO_CHECKLIST        AS NOME_MODELO_CHECKLIST,
                   CF.COD_PERGUNTA                 AS COD_PERGUNTA,
                   CF.COD_CONTEXTO_PERGUNTA        AS COD_CONTEXTO_PERGUNTA,
                   CF.DESCRICAO_PERGUNTA           AS DESCRICAO_PERGUNTA,
                   CF.COD_IMAGEM                   AS COD_IMAGEM,
                   CF.URL_IMAGEM                   AS URL_IMAGEM,
                   CF.PERGUNTA_ORDEM_EXIBICAO      AS PERGUNTA_ORDEM_EXIBICAO,
                   CF.SINGLE_CHOICE                AS SINGLE_CHOICE,
                   CF.COD_ALTERNATIVA              AS COD_ALTERNATIVA,
                   CF.COD_CONTEXTO_ALTERNATIVA     AS COD_CONTEXTO_ALTERNATIVA,
                   CF.DESCRICAO_ALTERNATIVA        AS DESCRICAO_ALTERNATIVA,
                   CF.TIPO_OUTROS                  AS TIPO_OUTROS,
                   CF.ALTERNATIVA_ORDEM_EXIBICAO   AS ALTERNATIVA_ORDEM_EXIBICAO,
                   CF.PRIORIDADE_ALTERNATIVA       AS PRIORIDADE_ALTERNATIVA,
                   CF.COD_CARGO                    AS COD_CARGO,
                   CF.COD_TIPO_VEICULO             AS COD_TIPO_VEICULO
            FROM CHECKLISTS_FILTRADOS CF
            ORDER BY CF.COD_MODELO_CHECKLIST,
                     CF.PERGUNTA_ORDEM_EXIBICAO,
                     CF.COD_PERGUNTA,
                     CF.ALTERNATIVA_ORDEM_EXIBICAO,
                     CF.COD_ALTERNATIVA,
                     CF.COD_CARGO,
                     CF.COD_TIPO_VEICULO;
    END;
    $$;
end;
$fun$;

create or replace function migration_checklist.func_migration_11_corrigir_componentes_dash() returns void
    language plpgsql
as
$fun$
begin

    -- Altera JOIN da COSI com a CAP para usar COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO ao invés de COD_ALTERNATIVA.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_RELATORIO_PLACAS_MAIOR_QTD_ITENS_ABERTOS(F_COD_UNIDADES BIGINT[],
                                                                                          F_TOTAL_PLACAS_PARA_BUSCAR INTEGER)
        RETURNS TABLE
                (
                    NOME_UNIDADE                      CHARACTER VARYING,
                    PLACA                             CHARACTER VARYING,
                    QUANTIDADE_ITENS_ABERTOS          BIGINT,
                    QUANTIDADE_ITENS_CRITICOS_ABERTOS BIGINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        STATUS_ITENS_ABERTOS CHAR    := 'P';
        PRIORIDADE_CRITICA   VARCHAR := 'CRITICA';
    BEGIN
        RETURN QUERY
            WITH PLACAS AS (
                SELECT C.PLACA_VEICULO           AS PLACA_VEICULO,
                       COUNT(COSI.CODIGO)        AS QUANTIDADE_ITENS_ABERTOS,
                       COUNT(CASE
                                 WHEN CAP.PRIORIDADE = PRIORIDADE_CRITICA
                                     THEN 1 END) AS QUANTIDADE_ITENS_CRITICOS_ABERTOS
                FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                         JOIN CHECKLIST_ORDEM_SERVICO COS
                              ON COSI.COD_OS = COS.CODIGO
                                  AND COSI.COD_UNIDADE = COS.COD_UNIDADE
                         JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                              ON COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO
                         JOIN CHECKLIST C
                              ON C.CODIGO = COS.COD_CHECKLIST
                WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
                  AND COSI.STATUS_RESOLUCAO = STATUS_ITENS_ABERTOS
                GROUP BY C.PLACA_VEICULO
                LIMIT F_TOTAL_PLACAS_PARA_BUSCAR
            )

            SELECT U.NOME AS NOME_UNIDADE,
                   P.PLACA_VEICULO,
                   P.QUANTIDADE_ITENS_ABERTOS,
                   P.QUANTIDADE_ITENS_CRITICOS_ABERTOS
            FROM PLACAS P
                     JOIN VEICULO V ON V.PLACA = P.PLACA_VEICULO
                     JOIN UNIDADE U ON V.COD_UNIDADE = U.CODIGO
            ORDER BY P.QUANTIDADE_ITENS_ABERTOS DESC,
                     P.PLACA_VEICULO ASC
            LIMIT F_TOTAL_PLACAS_PARA_BUSCAR;
    END;
    $$;

    -- Altera JOIN da COSI com a CAP para usar COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO ao invés de COD_ALTERNATIVA.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_RELATORIO_QTD_ITENS_POR_PRIORIDADE(F_COD_UNIDADES BIGINT[],
                                                                                    F_STATUS_ITENS TEXT)
        RETURNS TABLE
                (
                    PRIORIDADE TEXT,
                    QUANTIDADE BIGINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    BEGIN
        RETURN QUERY
            WITH PRIORIDADES AS (
                SELECT CAP.PRIORIDADE :: TEXT AS PRIORIDADE
                FROM CHECKLIST_ALTERNATIVA_PRIORIDADE CAP
                ORDER BY CAP.PRAZO ASC
            )

            SELECT P.PRIORIDADE       AS PRIORIDADE,
                   COUNT(COSI.CODIGO) AS QUANTIDADE
            FROM CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                     JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          ON CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                              AND COSI.COD_UNIDADE = ANY (F_COD_UNIDADES)
                              AND COSI.STATUS_RESOLUCAO = F_STATUS_ITENS
                     RIGHT JOIN PRIORIDADES P
                                ON CAP.PRIORIDADE = P.PRIORIDADE
            GROUP BY P.PRIORIDADE
            ORDER BY CASE P.PRIORIDADE
                         WHEN 'CRITICA'
                             THEN 1
                         WHEN 'ALTA'
                             THEN 2
                         WHEN 'BAIXA'
                             THEN 3
                         END;
    END;
    $$;
end;
$fun$;

create or replace function migration_checklist.func_migration_12_move_tabela_respostas_antiga() returns void
    language plpgsql
as
$$
begin
    ALTER TABLE checklist_respostas
        SET SCHEMA migration_checklist;
    -- CRIA TRIGGER PARA IMPEDIR A INSERÇÃO/ATUALIZAÇÃO DE REGISTROS NA TABELA CHECKLIST_RESPOSTAS ANTIGA.
    CREATE TRIGGER TG_BLOQUEIO_INSERT_UPDATE_DELETE_CHECKLIST_RESPOSTAS_ANTIGA
        BEFORE INSERT OR UPDATE OR DELETE
        ON MIGRATION_CHECKLIST.CHECKLIST_RESPOSTAS
        FOR EACH ROW
    EXECUTE PROCEDURE TG_FUNC_BLOQUEIO();
end;
$$;

create or replace function migration_checklist.func_migration_13_atualiza_os_integracao() returns void
    language plpgsql
as
$fun$
begin
    DROP FUNCTION INTEGRACAO.FUNC_INTEGRACAO_BUSCA_ITENS_OS_EMPRESA(BIGINT, TEXT);
    CREATE OR REPLACE FUNCTION
        INTEGRACAO.FUNC_INTEGRACAO_BUSCA_ITENS_OS_EMPRESA(F_COD_ULTIMO_ITEM_PENDENTE_SINCRONIZADO BIGINT,
                                                          F_TOKEN_INTEGRACAO TEXT)
        RETURNS TABLE
                (
                    PLACA_VEICULO                      TEXT,
                    KM_ABERTURA_SERVICO                BIGINT,
                    COD_ORDEM_SERVICO                  BIGINT,
                    COD_UNIDADE_ORDEM_SERVICO          BIGINT,
                    STATUS_ORDEM_SERVICO               TEXT,
                    DATA_HORA_ABERTURA_SERVICO         TIMESTAMP WITHOUT TIME ZONE,
                    COD_ITEM_ORDEM_SERVICO             BIGINT,
                    COD_UNIDADE_ITEM_ORDEM_SERVICO     BIGINT,
                    DATA_HORA_PRIMEIRO_APONTAMENTO     TIMESTAMP WITHOUT TIME ZONE,
                    STATUS_ITEM_ORDEM_SERVICO          TEXT,
                    PRAZO_RESOLUCAO_ITEM_HORAS         INTEGER,
                    QTD_APONTAMENTOS                   INTEGER,
                    COD_CHECKLIST_PRIMEIRO_APONTAMENTO BIGINT,
                    COD_CONTEXTO_PERGUNTA              BIGINT,
                    DESCRICAO_PERGUNTA                 TEXT,
                    COD_CONTEXTO_ALTERNATIVA           BIGINT,
                    DESCRICAO_ALTERNATIVA              TEXT,
                    IS_TIPO_OUTROS                     BOOLEAN,
                    DESCRICAO_TIPO_OUTROS              TEXT,
                    PRIORIDADE_ALTERNATIVA             TEXT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE TEXT := 'P';
    BEGIN
        RETURN QUERY
            SELECT CD.PLACA_VEICULO::TEXT                               AS PLACA_VEICULO,
                   CD.KM_VEICULO                                        AS KM_ABERTURA_SERVICO,
                   COSD.CODIGO                                          AS COD_ORDEM_SERVICO,
                   COSD.COD_UNIDADE                                     AS COD_UNIDADE_ORDEM_SERVICO,
                   COSD.STATUS::TEXT                                    AS STATUS_ORDEM_SERVICO,
                   CD.DATA_HORA AT TIME ZONE TZ_UNIDADE(CD.COD_UNIDADE) AS DATA_HORA_ABERTURA_SERVICO,
                   COSID.CODIGO                                         AS COD_ITEM_ORDEM_SERVICO,
                   COSID.COD_UNIDADE                                    AS COD_UNIDADE_ITEM_ORDEM_SERVICO,
                   CD.DATA_HORA AT TIME ZONE TZ_UNIDADE(CD.COD_UNIDADE) AS DATA_HORA_PRIMEIRO_APONTAMENTO,
                   COSID.STATUS_RESOLUCAO::TEXT                         AS STATUS_ITEM_ORDEM_SERVICO,
                   CAP.PRAZO                                            AS PRAZO_RESOLUCAO_ITEM_HORAS,
                   COSID.QT_APONTAMENTOS                                AS QTD_APONTAMENTOS,
                   CD.CODIGO                                            AS COD_CHECKLIST_PRIMEIRO_APONTAMENTO,
                   COSID.COD_CONTEXTO_PERGUNTA                          AS COD_CONTEXTO_PERGUNTA,
                   CPD.PERGUNTA                                         AS DESCRICAO_PERGUNTA,
                   COSID.COD_CONTEXTO_ALTERNATIVA                       AS COD_CONTEXTO_ALTERNATIVA,
                   CAPD.ALTERNATIVA                                     AS DESCRICAO_ALTERNATIVA,
                   CAPD.ALTERNATIVA_TIPO_OUTROS                         AS IS_TIPO_OUTROS,
                   CASE
                       WHEN CAPD.ALTERNATIVA_TIPO_OUTROS
                           THEN
                           (SELECT CRN.RESPOSTA_OUTROS
                            FROM CHECKLIST_RESPOSTAS_NOK CRN
                            WHERE CRN.COD_CHECKLIST = CD.CODIGO
                              AND CRN.COD_ALTERNATIVA = CAPD.CODIGO)
                       ELSE
                           NULL
                       END                                              AS DESCRICAO_TIPO_OUTROS,
                   CAPD.PRIORIDADE::TEXT                                AS PRIORIDADE_ALTERNATIVA
            FROM CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSID
                     JOIN CHECKLIST_ORDEM_SERVICO_DATA COSD
                          ON COSID.COD_OS = COSD.CODIGO AND COSID.COD_UNIDADE = COSD.COD_UNIDADE
                     JOIN CHECKLIST_DATA CD ON COSD.COD_CHECKLIST = CD.CODIGO
                     JOIN CHECKLIST_PERGUNTAS_DATA CPD ON COSID.COD_PERGUNTA_PRIMEIRO_APONTAMENTO = CPD.CODIGO
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA_DATA CAPD
                          ON COSID.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAPD.CODIGO
                     JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE CAP ON CAPD.PRIORIDADE = CAP.PRIORIDADE
            WHERE COSID.COD_UNIDADE IN (SELECT U.CODIGO
                                        FROM UNIDADE U
                                        WHERE U.COD_EMPRESA = (SELECT TI.COD_EMPRESA
                                                               FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                               WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO))
              AND COSID.STATUS_RESOLUCAO = F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE
              AND COSID.CODIGO > F_COD_ULTIMO_ITEM_PENDENTE_SINCRONIZADO
            ORDER BY COSID.CODIGO;
    END;
    $$;

    CREATE OR REPLACE FUNCTION
        INTEGRACAO.FUNC_INTEGRACAO_RESOLVE_ITENS_PENDENTES_EMPRESA(F_COD_UNIDADE_ORDEM_SERVICO BIGINT,
                                                                   F_COD_ORDEM_SERVICO BIGINT,
                                                                   F_COD_ITEM_RESOLVIDO BIGINT,
                                                                   F_CPF_COLABORADOR_RESOLUCAO BIGINT,
                                                                   F_KM_MOMENTO_RESOLUCAO BIGINT,
                                                                   F_DURACAO_RESOLUCAO_MS BIGINT,
                                                                   F_FEEDBACK_RESOLUCAO TEXT,
                                                                   F_DATA_HORA_RESOLVIDO_PROLOG TIMESTAMP WITH TIME ZONE,
                                                                   F_DATA_HORA_INICIO_RESOLUCAO TIMESTAMP WITH TIME ZONE,
                                                                   F_DATA_HORA_FIM_RESOLUCAO TIMESTAMP WITH TIME ZONE,
                                                                   F_TOKEN_INTEGRACAO TEXT,
                                                                   F_DATA_HORA_SINCRONIA_RESOLUCAO TIMESTAMP WITH TIME ZONE,
                                                                   F_DEVE_SOBRESCREVER_DADOS BOOLEAN DEFAULT TRUE)
        RETURNS BIGINT
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE  TEXT := 'P';
        F_STATUS_ITEM_ORDEM_SERVICO_RESOLVIDO TEXT := 'R';
        F_STATUS_ORDEM_SERVICO_ABERTA         TEXT := 'A';
        F_STATUS_ORDEM_SERVICO_FECHADA        TEXT := 'F';
        F_QTD_ROWS_ITENS_OS                   BIGINT;
        F_QTD_ROWS_ITENS_RESOLVIDOS_OS        BIGINT;
    BEGIN
        -- Antes de realizar o processo de fechamento de Item de Ordem de Serviço, validamos os dados e vínculos
        -- 1° - Validamos se existe a O.S na unidade.
        IF (SELECT NOT EXISTS(
                SELECT COS.CODIGO
                FROM CHECKLIST_ORDEM_SERVICO COS
                WHERE COS.CODIGO = F_COD_ORDEM_SERVICO
                  AND COS.COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('A Ordem de Serviço "%s" não existe na unidade "%s" do ProLog',
                                   F_COD_ORDEM_SERVICO,
                                   F_COD_UNIDADE_ORDEM_SERVICO));
        END IF;

        -- 2° - Validamos se a O.S. está ABERTA.
        -- Apenas validamos se não devemos sobrescrever os dados, caso devemos sobrescrever então não tem necessidade
        -- de validar essa informação pois se a O.S. já está fechada, apenas continuará.
        IF (NOT F_DEVE_SOBRESCREVER_DADOS AND (SELECT COS.STATUS
                                               FROM CHECKLIST_ORDEM_SERVICO COS
                                               WHERE COS.COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
                                                 AND COS.CODIGO = F_COD_ORDEM_SERVICO) = F_STATUS_ORDEM_SERVICO_FECHADA)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('A Ordem de Serviço "%s" já está fechada no ProLog', F_COD_ORDEM_SERVICO));
        END IF;

        -- 3° - Validamos se o Item a ser resolvido pertence a O.S..
        IF ((SELECT COSI.COD_OS
             FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
             WHERE COSI.CODIGO = F_COD_ITEM_RESOLVIDO) != F_COD_ORDEM_SERVICO)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O Item "%s" não pertence à O.S "%s" do ProLog',
                                                      F_COD_ITEM_RESOLVIDO,
                                                      F_COD_ORDEM_SERVICO));
        END IF;

        -- 4° - Validamos se o Item da O.S. está PENDENTE. Apenas validamos se não devemos sobrescrever as informações.
        IF (NOT F_DEVE_SOBRESCREVER_DADOS AND (SELECT COSI.STATUS_RESOLUCAO
                                               FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                               WHERE COSI.CODIGO = F_COD_ITEM_RESOLVIDO) !=
                                              F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('O Item "%s" da O.S "%s" já está resolvido no ProLog',
                                   F_COD_ITEM_RESOLVIDO,
                                   F_COD_ORDEM_SERVICO));
        END IF;

        -- 5° - Validamos se o CPF está presente na empresa.
        IF (SELECT NOT EXISTS(SELECT C.CODIGO
                              FROM COLABORADOR C
                              WHERE C.CPF = F_CPF_COLABORADOR_RESOLUCAO
                                AND C.COD_EMPRESA =
                                    (SELECT U.COD_EMPRESA FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_ORDEM_SERVICO)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O CPF %s não encontra-se cadastrado no ProLog',
                                                      PUBLIC.FORMAT_CPF(F_CPF_COLABORADOR_RESOLUCAO)));
        END IF;

        -- Por segurança, verificamos se a integração está fechando os itens de O.S. que pertencem a empresa correta.
        IF (F_COD_UNIDADE_ORDEM_SERVICO NOT IN (SELECT CODIGO
                                                FROM UNIDADE
                                                WHERE COD_EMPRESA = (SELECT TI.COD_EMPRESA
                                                                     FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                                     WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            'Você está tentando fechar um item de uma OS que não pertence à sua empresa');
        END IF;

        -- Não verificamos a DATA_HORA_CONSERTO no WHERE pois não nos importa se está fechada ou não. Se chegou nesse ponto
        -- iremos atualizar as informações afim de fechar o item ou afim de sobrescrever as informações. Temos segurança de
        -- fazer isso pois o 4º IF verifica se o item já está fechado porém não devemos sobrescrever.
        UPDATE CHECKLIST_ORDEM_SERVICO_ITENS
        SET CPF_MECANICO               = F_CPF_COLABORADOR_RESOLUCAO,
            TEMPO_REALIZACAO           = F_DURACAO_RESOLUCAO_MS,
            KM                         = F_KM_MOMENTO_RESOLUCAO,
            STATUS_RESOLUCAO           = F_STATUS_ITEM_ORDEM_SERVICO_RESOLVIDO,
            DATA_HORA_CONSERTO         = F_DATA_HORA_RESOLVIDO_PROLOG,
            DATA_HORA_INICIO_RESOLUCAO = F_DATA_HORA_INICIO_RESOLUCAO,
            DATA_HORA_FIM_RESOLUCAO    = F_DATA_HORA_FIM_RESOLUCAO,
            FEEDBACK_CONSERTO          = F_FEEDBACK_RESOLUCAO
        WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
          AND CODIGO = F_COD_ITEM_RESOLVIDO;

        -- O atributo 'ROW_COUNT' conterá a quantidade de linhas que foram atualizadas pelo update acima. a funciton
        -- irá retornar esse atributo para que possamos validar se todos os updates aconteceram como deveriam.
        GET DIAGNOSTICS F_QTD_ROWS_ITENS_OS = ROW_COUNT;

        -- O primeiro if verifica se o item está pendente, se após o update nenhuma linha for alterada, significa
        -- que o update não executou corretamente. lançamos aqui uma exceção para rastrear esse erro
        IF F_QTD_ROWS_ITENS_OS <= 0
        THEN
            RAISE EXCEPTION 'Não foi possível resolver o item %', F_COD_ITEM_RESOLVIDO;
        END IF;

        -- Ao resolver um item de ordem de serviço é necessário verificar se a Ordem de Serviço foi finalizada.
        -- uma O.S. fechada consiste em uma O.S. que possui todos os seus itens resolvidos.
        UPDATE CHECKLIST_ORDEM_SERVICO
        SET STATUS               = F_STATUS_ORDEM_SERVICO_FECHADA,
            DATA_HORA_FECHAMENTO = F_DATA_HORA_RESOLVIDO_PROLOG
        WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
          AND CODIGO = F_COD_ORDEM_SERVICO
          -- Utilizamos essa verificação para forçar que o update aconteça apenas se a O.S. tiver
          -- todos seus itens resolvidos.
          AND (SELECT COUNT(*)
               FROM CHECKLIST_ORDEM_SERVICO_ITENS
               WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
                 AND COD_OS = F_COD_ORDEM_SERVICO
                 AND STATUS_RESOLUCAO = F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE) = 0;

        -- Para garantir a consistência do processo de resolução de itens e fechamento de ordens de serviço
        -- verificamos se a O.S. que possuiu seu item fechado está com o 'status' correto.
        IF (((SELECT COUNT(*)
              FROM CHECKLIST_ORDEM_SERVICO_ITENS
              WHERE COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO
                AND COD_OS = F_COD_ORDEM_SERVICO
                AND STATUS_RESOLUCAO = F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE) = 0)
            AND (SELECT STATUS
                 FROM CHECKLIST_ORDEM_SERVICO
                 WHERE CODIGO = F_COD_ORDEM_SERVICO
                   AND COD_UNIDADE = F_COD_UNIDADE_ORDEM_SERVICO) = F_STATUS_ORDEM_SERVICO_ABERTA)
            -- Caso a O.S. não tem nenhum item pendente mas o seu status é 'aberta', então temos dados inconsistentes.
        THEN
            RAISE EXCEPTION 'Não foi possível fechar a Ordem de Serviço %', F_COD_ORDEM_SERVICO;
        END IF;

        -- Após realizar o processo de fechamento, inserimos o item resolvido na tabela de mapeamento de itens resolvidos
        -- através da integração.
        IF (F_DEVE_SOBRESCREVER_DADOS)
        THEN
            -- Se devemos sobrescrever as informações, eventualmente, já teremos fechado o item e este já está mapeado na
            -- estrutura de controle de itens fechados, nesse caso, atualizamos a data_hora de sincronia e segue o baile.
            INSERT INTO INTEGRACAO.CHECKLIST_ORDEM_SERVICO_ITEM_RESOLVIDO
            VALUES ((SELECT TI.COD_EMPRESA
                     FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                     WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO),
                    F_COD_UNIDADE_ORDEM_SERVICO,
                    F_COD_ORDEM_SERVICO,
                    F_COD_ITEM_RESOLVIDO,
                    F_DATA_HORA_SINCRONIA_RESOLUCAO)
            ON CONFLICT ON CONSTRAINT UNIQUE_ITEM_ORDEM_SERVICO_RESOLVIDO
                DO UPDATE SET DATA_HORA_SINCRONIA_RESOLUCAO = F_DATA_HORA_SINCRONIA_RESOLUCAO;
        ELSE
            -- Caso não é para sobrescrever, temos que estar atentos às constraints, evitando que tente-se inserir um
            -- item que já foi fechado previamente.
            INSERT INTO INTEGRACAO.CHECKLIST_ORDEM_SERVICO_ITEM_RESOLVIDO
            VALUES ((SELECT TI.COD_EMPRESA
                     FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                     WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO),
                    F_COD_UNIDADE_ORDEM_SERVICO,
                    F_COD_ORDEM_SERVICO,
                    F_COD_ITEM_RESOLVIDO,
                    F_DATA_HORA_SINCRONIA_RESOLUCAO);
        END IF;

        GET DIAGNOSTICS F_QTD_ROWS_ITENS_RESOLVIDOS_OS = ROW_COUNT;

        -- Verificamos se o insert na tabela de mapeamento de itens resolvidos na integração ocorreu com êxito.
        IF F_QTD_ROWS_ITENS_RESOLVIDOS_OS <= 0
        THEN
            RAISE EXCEPTION
                'Não foi possível inserir o item resolvido na tabela de mapeamento, item %', F_COD_ITEM_RESOLVIDO;
        END IF;

        RETURN F_QTD_ROWS_ITENS_OS;
    END;
    $$;

    ALTER TABLE PICCOLOTUR.CHECKLIST_ITEM_NOK_ENVIADO_GLOBUS
        RENAME COD_PERGUNTA TO COD_CONTEXTO_PERGUNTA;
    ALTER TABLE PICCOLOTUR.CHECKLIST_ITEM_NOK_ENVIADO_GLOBUS
        RENAME COD_ALTERNATIVA TO COD_CONTEXTO_ALTERNATIVA;
    ALTER TABLE PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
        RENAME COD_PERGUNTA_OS_PROLOG TO COD_CONTEXTO_PERGUNTA_OS_PROLOG;
    ALTER TABLE PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
        RENAME COD_ALTERNATIVA_OS_PROLOG TO COD_CONTEXTO_ALTERNATIVA_OS_PROLOG;

    DROP FUNCTION PICCOLOTUR.FUNC_CHECK_OS_INSERE_ITEM_OS_ABERTA(BIGINT, BIGINT, BIGINT, BIGINT, BIGINT, BIGINT, TIMESTAMP WITH TIME ZONE, TEXT);
    CREATE OR REPLACE FUNCTION
        PICCOLOTUR.FUNC_CHECK_OS_INSERE_ITEM_OS_ABERTA(F_COD_OS_GLOBUS BIGINT,
                                                       F_COD_UNIDADE_OS BIGINT,
                                                       F_COD_CHECKLIST BIGINT,
                                                       F_COD_ITEM_OS_GLOBUS BIGINT,
                                                       F_COD_CONTEXTO_PERGUNTA_CHECKLIST BIGINT,
                                                       F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST BIGINT,
                                                       F_DATA_HORA_SINCRONIZACAO_PENDENCIA TIMESTAMP WITH TIME ZONE,
                                                       F_TOKEN_INTEGRACAO TEXT)
        RETURNS BIGINT
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        STATUS_OS_ABERTA        TEXT   := 'A';
        STATUS_OS_FECHADA       TEXT   := 'F';
        STATUS_ITEM_OS_PENDENTE TEXT   := 'P';
        CODIGO_PERGUNTA         BIGINT := (SELECT CP.CODIGO
                                           FROM CHECKLIST_PERGUNTAS CP
                                           WHERE CP.CODIGO_CONTEXTO = F_COD_CONTEXTO_PERGUNTA_CHECKLIST
                                             AND CP.COD_VERSAO_CHECKLIST_MODELO =
                                                 (SELECT C.COD_VERSAO_CHECKLIST_MODELO
                                                  FROM CHECKLIST C
                                                  WHERE C.CODIGO = F_COD_CHECKLIST));
        CODIGO_ALTERNATIVA      BIGINT := (SELECT CAP.CODIGO
                                           FROM CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                                           WHERE CAP.CODIGO_CONTEXTO = F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST
                                             AND CAP.COD_PERGUNTA = CODIGO_PERGUNTA
                                             AND CAP.COD_VERSAO_CHECKLIST_MODELO = (SELECT C.COD_VERSAO_CHECKLIST_MODELO
                                                                                    FROM CHECKLIST C
                                                                                    WHERE C.CODIGO = F_COD_CHECKLIST));
        COD_ITEM_OS_PROLOG      BIGINT;
    BEGIN
        -- Antes de processarmos a abertura da O.S e inserção de Itens, validamos todos os códigos de vínculo.
        -- Validamos se o código da unidade da O.S bate com a empresa do Token
        IF ((SELECT U.COD_EMPRESA FROM PUBLIC.UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_OS)
            <>
            (SELECT TI.COD_EMPRESA
             FROM INTEGRACAO.TOKEN_INTEGRACAO TI
             WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('[ERRO DE VÍNCULO] O token "%s" não está autorizado a inserir dados da unidade "%s"',
                                   F_TOKEN_INTEGRACAO,
                                   F_COD_UNIDADE_OS));
        END IF;

        -- Validamos se o Item da Ordem de Serviço já existe no ProLog.
        IF (SELECT EXISTS(
                           SELECT *
                           FROM PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS
                           WHERE COD_OS = F_COD_OS_GLOBUS
                             AND COD_UNIDADE = F_COD_UNIDADE_OS
                             AND CODIGO = F_COD_ITEM_OS_GLOBUS))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        -- TODO - Será que devemos lançar o erro, incrementar a quantidade, ou não fazer nada?
                            FORMAT('[ERRO DE STATUS] O serviço "%s" já está existe na O.S "%s" do ProLog',
                                   F_COD_ITEM_OS_GLOBUS,
                                   F_COD_OS_GLOBUS));
        END IF;

        -- Validamos se a Ordem de Serviço já está fechada. Se estiver aberta, iremos adicionar o item nela.
        IF ((SELECT COS.STATUS
             FROM PUBLIC.CHECKLIST_ORDEM_SERVICO COS
             WHERE COS.CODIGO = F_COD_OS_GLOBUS
               AND COS.COD_UNIDADE = F_COD_UNIDADE_OS) = STATUS_OS_FECHADA)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        -- TODO - Será que devemos lançar um erro, ou ignorar pois já está fechada, ou reabrir e inserir o item?
                            FORMAT('[ERRO DE STATUS] A O.S "%s" já está FECHADA no ProLog', F_COD_OS_GLOBUS));
        END IF;

        -- Validamos se o código do checklist existe.
        IF (SELECT NOT EXISTS(
                SELECT C.CODIGO
                FROM PUBLIC.CHECKLIST C
                WHERE C.CODIGO = F_COD_CHECKLIST
                  AND C.COD_UNIDADE = F_COD_UNIDADE_OS))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('[ERRO DE VÍNCULO] O checklist "%s" não encontra-se na base de dados do ProLog',
                                   F_COD_CHECKLIST));
        END IF;

        -- Validamos se a pergunta existe e está mesmo vinculada ao checklist realizado.
        IF (SELECT NOT EXISTS(
                SELECT CRN.COD_PERGUNTA
                FROM PUBLIC.CHECKLIST_RESPOSTAS_NOK CRN
                WHERE CRN.COD_CHECKLIST = F_COD_CHECKLIST
                  AND CRN.COD_PERGUNTA = CODIGO_PERGUNTA))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('[ERRO DE VÍNCULO] A pergunta "%s" não possui vínculo com o checklist "%s"',
                                   F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
                                   F_COD_CHECKLIST));
        END IF;

        -- Validamos se a alternativa existe e pertence a pergunta do checklist realizado.
        IF (SELECT NOT EXISTS(
                SELECT CRN.COD_ALTERNATIVA
                FROM PUBLIC.CHECKLIST_RESPOSTAS_NOK CRN
                WHERE CRN.COD_CHECKLIST = F_COD_CHECKLIST
                  AND CRN.COD_PERGUNTA = CODIGO_PERGUNTA
                  AND CRN.COD_ALTERNATIVA = CODIGO_ALTERNATIVA))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('[ERRO DE VÍNCULO] A alternativa "%s" não possui vínculo com a pergunta "%s"',
                                   F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST,
                                   F_COD_CONTEXTO_PERGUNTA_CHECKLIST));
        END IF;

        -- Validamos se o Item da O.S pertencem a um checklist que de fato foi enviado para o Globus.
        IF (NOT (SELECT EXISTS(
                                SELECT *
                                FROM PICCOLOTUR.CHECKLIST_ITEM_NOK_ENVIADO_GLOBUS CINEG
                                WHERE CINEG.COD_CHECKLIST = F_COD_CHECKLIST
                                  AND CINEG.COD_CONTEXTO_PERGUNTA = F_COD_CONTEXTO_PERGUNTA_CHECKLIST
                                  AND CINEG.COD_CONTEXTO_ALTERNATIVA = F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT(
                                    '[ERRO DE VÍNCULO] Não existe vínculo entre o cod_checklist "%s", cod_pergunta "%s" e cod_alternativa "%s"',
                                    F_COD_CHECKLIST,
                                    F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
                                    F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST));
        END IF;

        -- Se a Ordem de Serviço não existe, então criamos ela.
        IF (SELECT NOT EXISTS(
                SELECT COS.CODIGO
                FROM PUBLIC.CHECKLIST_ORDEM_SERVICO COS
                WHERE COS.CODIGO = F_COD_OS_GLOBUS
                  AND COS.COD_UNIDADE = F_COD_UNIDADE_OS))
        THEN
            INSERT INTO PUBLIC.CHECKLIST_ORDEM_SERVICO(CODIGO,
                                                       COD_UNIDADE,
                                                       COD_CHECKLIST,
                                                       STATUS)
            VALUES (F_COD_OS_GLOBUS, F_COD_UNIDADE_OS, F_COD_CHECKLIST, STATUS_OS_ABERTA);
        END IF;

        -- Não precisamos validar novamente se o item já existe no banco de dados, apenas inserimos.
        INSERT INTO PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS(COD_UNIDADE,
                                                         COD_OS,
                                                         STATUS_RESOLUCAO,
                                                         COD_CONTEXTO_PERGUNTA,
                                                         COD_CONTEXTO_ALTERNATIVA,
                                                         COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
                                                         COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO)
        VALUES (F_COD_UNIDADE_OS,
                F_COD_OS_GLOBUS,
                STATUS_ITEM_OS_PENDENTE,
                F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
                F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST,
                CODIGO_PERGUNTA,
                CODIGO_ALTERNATIVA) RETURNING CODIGO INTO COD_ITEM_OS_PROLOG;

        -- Não chegará nesse ponto um 'item', 'checklist' ou 'alternativa' que não existam, então podemos inserir os
        -- dados com segurança. Também, não chegará aqui um item que não deveremos inserir ou que devemos aumentar a
        -- quantidade de apontamentos, nesse estágio o item SEMPRE tera 'NOVA_QTD_APONTAMENTOS' = 1 (primeiro apontamento).
        INSERT INTO PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS(COD_ITEM_ORDEM_SERVICO,
                                                                      COD_CHECKLIST_REALIZADO,
                                                                      COD_ALTERNATIVA,
                                                                      NOVA_QTD_APONTAMENTOS)
        VALUES (COD_ITEM_OS_PROLOG, F_COD_CHECKLIST, CODIGO_ALTERNATIVA, 1);

        -- Após salvar o item, criamos o vínculo dele na tabela DE-PARA.
        INSERT INTO PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO(COD_UNIDADE,
                                                                    COD_OS_GLOBUS,
                                                                    COD_ITEM_OS_GLOBUS,
                                                                    COD_ITEM_OS_PROLOG,
                                                                    PLACA_VEICULO_OS,
                                                                    COD_CHECKLIST_OS_PROLOG,
                                                                    COD_CONTEXTO_PERGUNTA_OS_PROLOG,
                                                                    COD_CONTEXTO_ALTERNATIVA_OS_PROLOG,
                                                                    DATA_HORA_SINCRONIA_PENDENCIA)
        VALUES (F_COD_UNIDADE_OS,
                F_COD_OS_GLOBUS,
                F_COD_ITEM_OS_GLOBUS,
                COD_ITEM_OS_PROLOG,
                (SELECT C.PLACA_VEICULO FROM PUBLIC.CHECKLIST C WHERE C.CODIGO = F_COD_CHECKLIST),
                F_COD_CHECKLIST,
                F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
                F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST,
                F_DATA_HORA_SINCRONIZACAO_PENDENCIA);

        RETURN COD_ITEM_OS_PROLOG;
    END;
    $$;

    CREATE OR REPLACE FUNCTION
        PICCOLOTUR.FUNC_CHECK_OS_RESOLVE_ITEM_PENDENTE(F_COD_UNIDADE_ITEM_OS BIGINT,
                                                       F_COD_OS_GLOBUS BIGINT,
                                                       F_COD_ITEM_RESOLVIDO_GLOBUS BIGINT,
                                                       F_CPF_COLABORADOR_RESOLUCAO BIGINT,
                                                       F_PLACA_VEICULO_ITEM_OS TEXT,
                                                       F_KM_COLETADO_RESOLUCAO BIGINT,
                                                       F_DURACAO_RESOLUCAO_MS BIGINT,
                                                       F_FEEDBACK_RESOLUCAO TEXT,
                                                       F_DATA_HORA_RESOLVIDO_PROLOG TIMESTAMP WITH TIME ZONE,
                                                       F_DATA_HORA_INICIO_RESOLUCAO TIMESTAMP WITH TIME ZONE,
                                                       F_DATA_HORA_FIM_RESOLUCAO TIMESTAMP WITH TIME ZONE,
                                                       F_TOKEN_INTEGRACAO TEXT,
                                                       F_DATA_HORA_SINCRONIA_RESOLUCAO TIMESTAMP WITH TIME ZONE)
        RETURNS BIGINT
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        STATUS_ITEM_OS_PENDENTE       TEXT   := 'P';
        COD_ITEM_RESOLVIDO_PROLOG     BIGINT;
        COD_RETORNO_SUCESSO           BIGINT := 1;
        F_QTD_ROWS_ITENS_OS           BIGINT;
        F_QTD_ROWS_VINCULOS_ALTERADOS BIGINT;
    BEGIN
        -- Antes de processarmos a resolução de Itens de O.S., validamos todos os códigos de vínculo possíveis.
        -- Por segurança, verificamos se a integração está fechando os itens de o.s. que pertencem a empresa correta.
        IF (F_COD_UNIDADE_ITEM_OS NOT IN (SELECT CODIGO
                                          FROM PUBLIC.UNIDADE
                                          WHERE COD_EMPRESA = (SELECT TI.COD_EMPRESA
                                                               FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                               WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('[ERRO DE VÍNCULO] O token "%s" não está autorizado a inserir dados da unidade "%s"',
                                   F_TOKEN_INTEGRACAO,
                                   F_COD_UNIDADE_ITEM_OS));
        END IF;

        -- Validamos se o código do item fechado no Globus, está mapeado no ProLog.
        IF (SELECT EXISTS(SELECT COD_ITEM_OS_PROLOG
                          FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
                          WHERE COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS
                            AND COD_OS_GLOBUS = F_COD_OS_GLOBUS
                            AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS))
        THEN
            SELECT COD_ITEM_OS_PROLOG
            FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
            WHERE COD_OS_GLOBUS = F_COD_OS_GLOBUS
              AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS
              AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
            INTO COD_ITEM_RESOLVIDO_PROLOG;
        ELSE
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('[ERRO DE VÍNCULO] O item "%s" da O.S. "%s" não possuí vínculo no ProLog',
                                   F_COD_ITEM_RESOLVIDO_GLOBUS,
                                   F_COD_OS_GLOBUS));
        END IF;

        -- Validamos se o item mapeado está pendente no ProLog. Caso já está resolvido, apenas retorna sucesso.
        IF (SELECT COSID.STATUS_RESOLUCAO
            FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO COSIV
                     JOIN CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSID
                          ON COSIV.COD_ITEM_OS_PROLOG = COSID.CODIGO
            WHERE COD_OS_GLOBUS = F_COD_OS_GLOBUS
              AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS) != STATUS_ITEM_OS_PENDENTE
        THEN
            RETURN COD_RETORNO_SUCESSO;
        END IF;

        -- Validamos se o usuário está na base de dados do ProLog, podendo estar em qualquer unidade da empresa integrada.
        IF (SELECT NOT EXISTS(SELECT C.CODIGO
                              FROM PUBLIC.COLABORADOR C
                              WHERE C.CPF = F_CPF_COLABORADOR_RESOLUCAO
                                AND C.COD_EMPRESA = (SELECT U.COD_EMPRESA
                                                     FROM PUBLIC.UNIDADE U
                                                     WHERE U.CODIGO = F_COD_UNIDADE_ITEM_OS)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O CPF "%s" não encontra-se cadastrado no ProLog',
                                                      PUBLIC.FORMAT_CPF(F_CPF_COLABORADOR_RESOLUCAO)));
        END IF;

        -- Validamos se a placa é a mesma do item pendente mapeado no ProLog.
        IF ((SELECT PLACA_VEICULO_OS
             FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
             WHERE COD_OS_GLOBUS = F_COD_OS_GLOBUS
               AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
               AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS) != F_PLACA_VEICULO_ITEM_OS)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(
                            FORMAT('A placa "%s" não bate com a placa do item pendente "%s" do ProLog',
                                   F_PLACA_VEICULO_ITEM_OS,
                                   COD_ITEM_RESOLVIDO_PROLOG));
        END IF;

        -- Depois de validar podemos resolver o item.
        UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
        SET CPF_MECANICO               = F_CPF_COLABORADOR_RESOLUCAO,
            KM                         = F_KM_COLETADO_RESOLUCAO,
            STATUS_RESOLUCAO           = 'R',
            TEMPO_REALIZACAO           = F_DURACAO_RESOLUCAO_MS,
            DATA_HORA_CONSERTO         = F_DATA_HORA_RESOLVIDO_PROLOG,
            FEEDBACK_CONSERTO          = F_FEEDBACK_RESOLUCAO,
            DATA_HORA_INICIO_RESOLUCAO = F_DATA_HORA_INICIO_RESOLUCAO,
            DATA_HORA_FIM_RESOLUCAO    = F_DATA_HORA_FIM_RESOLUCAO
        WHERE CODIGO = COD_ITEM_RESOLVIDO_PROLOG;

        -- O ATRIBUTO 'ROW_COUNT' CONTERÁ A QUANTIDADE DE LINHAS QUE FORAM ATUALIZADAS PELO UPDATE ACIMA. A FUNCITON
        -- IRÁ RETORNAR ESSE ATRIBUTO PARA QUE POSSAMOS VALIDAR SE TODOS OS UPDATES ACONTECERAM COMO DEVERIAM.
        GET DIAGNOSTICS F_QTD_ROWS_ITENS_OS = ROW_COUNT;

        -- SE APÓS O UPDATE NENHUMA LINHA FOR ALTERADA, SIGNIFICA QUE O UPDATE NÃO EXECUTOU CORRETAMENTE.
        -- LANÇAMOS AQUI UMA EXCEÇÃO PARA RASTREAR ESSE ERRO.
        IF F_QTD_ROWS_ITENS_OS <= 0
        THEN
            RAISE EXCEPTION 'Não foi possível resolver o item do ProLog "%s"', COD_ITEM_RESOLVIDO_PROLOG;
        END IF;

        -- Vamos fechar a O.S. caso todos os itens dela já estejam resolvidos.
        UPDATE CHECKLIST_ORDEM_SERVICO_DATA
        SET STATUS               = 'F',
            DATA_HORA_FECHAMENTO = F_DATA_HORA_RESOLVIDO_PROLOG
        WHERE CODIGO = F_COD_OS_GLOBUS
          AND COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
          AND (SELECT COUNT(*)
               FROM PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS COSI
               WHERE COSI.COD_OS = F_COD_OS_GLOBUS
                 AND COSI.COD_UNIDADE = F_COD_UNIDADE_ITEM_OS
                 AND COSI.STATUS_RESOLUCAO = 'P') = 0;

        -- Para finalizar, atualizamos a tabela de vínculo marcando o item como resolvido.
        UPDATE PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO
        SET DATA_HORA_SINCRONIA_RESOLUCAO = F_DATA_HORA_SINCRONIA_RESOLUCAO
        WHERE COD_ITEM_OS_PROLOG = COD_ITEM_RESOLVIDO_PROLOG
          AND COD_ITEM_OS_GLOBUS = F_COD_ITEM_RESOLVIDO_GLOBUS;

        GET DIAGNOSTICS F_QTD_ROWS_VINCULOS_ALTERADOS = ROW_COUNT;

        -- VERIFICAMOS SE O INSERT NA TABELA DE MAPEAMENTO DE ITENS RESOLVIDOS NA INTEGRAÇÃO OCORREU COM ÊXITO.
        IF F_QTD_ROWS_VINCULOS_ALTERADOS <= 0
        THEN
            RAISE EXCEPTION
                'Não foi possível inserir o item do ProLog resolvido na tabela de mapeamento, item "%s"',
                COD_ITEM_RESOLVIDO_PROLOG;
        END IF;

        RETURN F_QTD_ROWS_ITENS_OS;
    END;
    $$;

    CREATE OR REPLACE FUNCTION PICCOLOTUR.FUNC_CHECK_GET_NEXT_COD_CHECKLIST_PARA_SINCRONIZAR()
        RETURNS TABLE
                (
                    COD_CHECKLIST BIGINT,
                    IS_LAST_COD   BOOLEAN
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        COD_CHECKLIST BIGINT;
        IS_LAST_COD   BOOLEAN;
    BEGIN
        --   1° - verifica se existe um checklist para sincronizar, se não, seta o de menor código como apto a
        --   sincronização.
        IF ((SELECT COD_CHECKLIST_PARA_SINCRONIZAR
             FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
             WHERE NEXT_TO_SYNC IS TRUE
               AND SINCRONIZADO IS FALSE
               AND PRECISA_SER_SINCRONIZADO IS TRUE) IS NULL)
        THEN
            UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
            SET NEXT_TO_SYNC = TRUE
            WHERE COD_CHECKLIST_PARA_SINCRONIZAR = (SELECT CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                    FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR CPPS
                                                    WHERE CPPS.SINCRONIZADO IS FALSE
                                                      AND CPPS.PRECISA_SER_SINCRONIZADO IS TRUE
                                                    ORDER BY CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                    LIMIT 1);
        END IF;

        --   2° - Verifica se o código marcado para sincronizar é o último código a ser sincronizado
        SELECT CPPS.NEXT_TO_SYNC
        FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR CPPS
        WHERE CPPS.PRECISA_SER_SINCRONIZADO
          AND CPPS.SINCRONIZADO IS FALSE
        ORDER BY CPPS.COD_CHECKLIST_PARA_SINCRONIZAR DESC
        LIMIT 1
        INTO IS_LAST_COD;

        --   3° - Pega o código que está marcado para tentar sincronizar
        SELECT COD_CHECKLIST_PARA_SINCRONIZAR
        FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
        WHERE NEXT_TO_SYNC = TRUE
        INTO COD_CHECKLIST;

        --   4° - Remove a marcação do checklist que estava marcado par sincronizar
        UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
        SET NEXT_TO_SYNC = FALSE
        WHERE COD_CHECKLIST_PARA_SINCRONIZAR = COD_CHECKLIST;

        --   5° - Marca o próximo código que precisa ser sincronizado, se for o último código, então seta o
        -- primeiro como o próximo a ser sincronizado
        IF IS_LAST_COD
        THEN
            UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
            SET NEXT_TO_SYNC = TRUE
            WHERE COD_CHECKLIST_PARA_SINCRONIZAR = (SELECT CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                    FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR CPPS
                                                    WHERE CPPS.SINCRONIZADO IS FALSE
                                                      AND CPPS.PRECISA_SER_SINCRONIZADO IS TRUE
                                                    ORDER BY CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                    LIMIT 1);
        ELSE
            UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
            SET NEXT_TO_SYNC = TRUE
            WHERE COD_CHECKLIST_PARA_SINCRONIZAR = (SELECT COD_CHECKLIST_PARA_SINCRONIZAR
                                                    FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
                                                    WHERE SINCRONIZADO IS FALSE
                                                      AND PRECISA_SER_SINCRONIZADO IS TRUE
                                                      AND NEXT_TO_SYNC IS FALSE
                                                      AND COD_CHECKLIST_PARA_SINCRONIZAR > COD_CHECKLIST
                                                    ORDER BY COD_CHECKLIST_PARA_SINCRONIZAR
                                                    LIMIT 1);
        END IF;

        --   6° - Retorna o código que será sincronizado
        RETURN QUERY
            SELECT COD_CHECKLIST, IS_LAST_COD;
    END;
    $$;

    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_INCREMENTA_QTD_APONTAMENTOS_ITEM(F_COD_ITEM_ORDEM_SERVICO BIGINT,
                                                                                  F_COD_CHECKLIST_REALIZADO BIGINT,
                                                                                  F_COD_ALTERNATIVA BIGINT,
                                                                                  F_STATUS_RESOLUCAO TEXT)
        RETURNS VOID
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        NOVA_QTD_APONTAMENTOS_ITEM INTEGER;
    BEGIN
        -- Atualiza quantidade de apontamentos do item.
        UPDATE CHECKLIST_ORDEM_SERVICO_ITENS
        SET QT_APONTAMENTOS = QT_APONTAMENTOS + 1
        WHERE CODIGO = F_COD_ITEM_ORDEM_SERVICO
          AND STATUS_RESOLUCAO = F_STATUS_RESOLUCAO RETURNING QT_APONTAMENTOS INTO NOVA_QTD_APONTAMENTOS_ITEM;

        -- Insere a alternativa que incrementou a quantidade de apontamentos na tabela.
        INSERT INTO CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS (COD_ITEM_ORDEM_SERVICO,
                                                                COD_CHECKLIST_REALIZADO,
                                                                COD_ALTERNATIVA,
                                                                NOVA_QTD_APONTAMENTOS)
        VALUES (F_COD_ITEM_ORDEM_SERVICO, F_COD_CHECKLIST_REALIZADO, F_COD_ALTERNATIVA, NOVA_QTD_APONTAMENTOS_ITEM);
    END;
    $$;


    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_INSERE_ITEM_OS(F_COD_UNIDADE BIGINT,
                                                                F_COD_OS BIGINT,
                                                                F_COD_PERGUNTA_PRIMEIRO_APONTAMENTO BIGINT,
                                                                F_COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO BIGINT,
                                                                F_STATUS_RESOLUCAO TEXT,
                                                                F_COD_CONTEXTO_PERGUNTA BIGINT,
                                                                F_COD_CONTEXTO_ALTERNATIVA BIGINT,
                                                                F_COD_CHECKLIST_REALIZADO BIGINT)
        RETURNS BIGINT
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        NOVA_QTD_APONTAMENTOS_ITEM INTEGER := 1;
        CODIGO_ITEM_OS             BIGINT;
    BEGIN
        -- Insere o item da O.S
        INSERT INTO CHECKLIST_ORDEM_SERVICO_ITENS(COD_UNIDADE,
                                                  COD_OS,
                                                  COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
                                                  COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                                                  STATUS_RESOLUCAO,
                                                  COD_CONTEXTO_PERGUNTA,
                                                  COD_CONTEXTO_ALTERNATIVA)
        VALUES (F_COD_UNIDADE,
                F_COD_OS,
                F_COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
                F_COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                F_STATUS_RESOLUCAO,
                F_COD_CONTEXTO_PERGUNTA,
                F_COD_CONTEXTO_ALTERNATIVA) RETURNING CODIGO INTO CODIGO_ITEM_OS;

        -- Insere a alternativa que incrementou a quantidade de apontamentos na tabela.
        INSERT INTO CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS (COD_ITEM_ORDEM_SERVICO,
                                                                COD_CHECKLIST_REALIZADO,
                                                                COD_ALTERNATIVA,
                                                                NOVA_QTD_APONTAMENTOS)
        VALUES (CODIGO_ITEM_OS,
                F_COD_CHECKLIST_REALIZADO,
                F_COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                NOVA_QTD_APONTAMENTOS_ITEM);

        RETURN CODIGO_ITEM_OS;
    END;
    $$;
end;
$fun$;

create or replace function suporte.func_veiculo_transfere_veiculo_entre_empresas(f_placa_veiculo character varying,
                                                                                 f_cod_empresa_origem bigint,
                                                                                 f_cod_unidade_origem bigint,
                                                                                 f_cod_empresa_destino bigint,
                                                                                 f_cod_unidade_destino bigint,
                                                                                 f_cod_modelo_veiculo_destino bigint,
                                                                                 f_cod_tipo_veiculo_destino bigint,
                                                                                 OUT veiculo_transferido text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    F_NOME_EMPRESA_DESTINO                           VARCHAR(255) := (SELECT E.NOME
                                                                      FROM EMPRESA E
                                                                      WHERE E.CODIGO = F_COD_EMPRESA_DESTINO);
    F_NOME_UNIDADE_DESTINO                           VARCHAR(255) := (SELECT U.NOME
                                                                      FROM UNIDADE U
                                                                      WHERE U.CODIGO = F_COD_UNIDADE_DESTINO);
    F_LISTA_COD_AFERICAO_PLACA                       BIGINT[];
    F_COD_AFERICAO_FOREACH                           BIGINT;
    F_LISTA_COD_PNEU_EM_AFERICAO_MANUTENCAO          BIGINT[];
    F_QTD_COD_AFERICAO_EM_AFERICAO_VALORES           BIGINT;
    F_QTD_COD_AFERICAO_DELETADOS_EM_AFERICAO_VALORES BIGINT;


BEGIN
    --VERIFICA SE EMPRESA ORIGEM POSSUI UNIDADE ORIGEM.
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_UNIDADE(F_COD_EMPRESA_ORIGEM, F_COD_UNIDADE_ORIGEM);

    --VERIFICA SE EMPRESA DESTINO POSSUI UNIDADE DESTINO.
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_UNIDADE(F_COD_EMPRESA_DESTINO, F_COD_UNIDADE_DESTINO);

    --VERIFICA SE EMPRESA ORIGEM/DESTINO SÃO DISTINTAS.
    PERFORM FUNC_GARANTE_EMPRESAS_DISTINTAS(F_COD_EMPRESA_ORIGEM, F_COD_EMPRESA_DESTINO);

    --VERIFICA SE VEICULO EXISTE
    PERFORM FUNC_GARANTE_VEICULO_EXISTE(F_COD_UNIDADE_ORIGEM, F_PLACA_VEICULO);

    --VERIFICA SE A PLACA POSSUI PNEUS.
    IF EXISTS(SELECT VP.COD_PNEU
              FROM VEICULO_PNEU VP
              WHERE VP.PLACA = F_PLACA_VEICULO
                AND VP.COD_UNIDADE = F_COD_UNIDADE_ORIGEM)
    THEN
        RAISE EXCEPTION 'ERRO! A PLACA: % POSSUI PNEUS VINCULADOS, FAVOR REMOVER OS PNEUS DO MESMO', F_PLACA_VEICULO;
    END IF;

    --VERIFICA SE EMPRESA DESTINO POSSUI TIPO DO VEÍCULO INFORMADO.
    IF NOT EXISTS(
            SELECT VT.CODIGO
            FROM VEICULO_TIPO VT
            WHERE VT.COD_EMPRESA = F_COD_EMPRESA_DESTINO
              AND VT.CODIGO = F_COD_TIPO_VEICULO_DESTINO)
    THEN
        RAISE EXCEPTION 'ERRO! O CÓDIGO TIPO: % NÃO EXISTE NA EMPRESA DESTINO: %', F_COD_TIPO_VEICULO_DESTINO,
            F_NOME_EMPRESA_DESTINO;
    END IF;

    --VERIFICA SE EMPRESA DESTINO POSSUI MODELO DO VEÍCULO INFORMADO.
    IF NOT EXISTS(SELECT MV.CODIGO
                  FROM MODELO_VEICULO MV
                  WHERE MV.COD_EMPRESA = F_COD_EMPRESA_DESTINO
                    AND MV.CODIGO = F_COD_MODELO_VEICULO_DESTINO)
    THEN
        RAISE EXCEPTION 'ERRO! O CÓDIGO MODELO: % NÃO EXISTE NA EMPRESA DESTINO: %', F_COD_MODELO_VEICULO_DESTINO,
            F_NOME_EMPRESA_DESTINO;
    END IF;

    --VERIFICA SE PLACA POSSUI AFERIÇÃO.
    IF EXISTS(SELECT A.CODIGO
              FROM AFERICAO A
              WHERE A.PLACA_VEICULO = F_PLACA_VEICULO)
    THEN
        --ENTÃO COLETAMOS TODOS OS CÓDIGOS DAS AFERIÇÕES QUE A PLACA POSSUI E ADICIONAMOS NO ARRAY.
        SELECT DISTINCT ARRAY_AGG(A.CODIGO)
        FROM AFERICAO A
        WHERE A.PLACA_VEICULO = F_PLACA_VEICULO
        INTO F_LISTA_COD_AFERICAO_PLACA;

        --LAÇO FOR PARA PERCORRER TODOS OS VALORES EM F_LISTA_COD_AFERICAO_PLACA.
        FOREACH F_COD_AFERICAO_FOREACH IN ARRAY F_LISTA_COD_AFERICAO_PLACA
            LOOP
                --PARA CADA VALOR EM: F_LISTA_COD_AFERICAO_PLACA
                IF EXISTS(SELECT AM.COD_AFERICAO
                          FROM AFERICAO_MANUTENCAO AM
                          WHERE AM.COD_AFERICAO = F_COD_AFERICAO_FOREACH
                            AND AM.DATA_HORA_RESOLUCAO IS NULL
                            AND AM.FECHADO_AUTOMATICAMENTE_INTEGRACAO IS FALSE
                            AND AM.FECHADO_AUTOMATICAMENTE_MOVIMENTACAO IS FALSE)
                THEN
                    --COLETA O(S) COD_PNEU CORRESPONDENTES AO COD_AFERICAO.
                    SELECT ARRAY_AGG(AM.COD_PNEU)
                    FROM AFERICAO_MANUTENCAO AM
                    WHERE AM.COD_AFERICAO = F_COD_AFERICAO_FOREACH
                      AND AM.DATA_HORA_RESOLUCAO IS NULL
                      AND AM.FECHADO_AUTOMATICAMENTE_INTEGRACAO IS FALSE
                      AND AM.FECHADO_AUTOMATICAMENTE_MOVIMENTACAO IS FALSE
                    INTO F_LISTA_COD_PNEU_EM_AFERICAO_MANUTENCAO;

                    --DELETA AFERIÇÃO EM AFERICAO_MANUTENCAO_DATA ATRAVÉS DO COD_AFERICAO E COD_PNEU.
                    UPDATE AFERICAO_MANUTENCAO_DATA
                    SET DELETADO            = TRUE,
                        DATA_HORA_DELETADO  = NOW(),
                        PG_USERNAME_DELECAO = SESSION_USER
                    WHERE COD_UNIDADE = F_COD_UNIDADE_ORIGEM
                      AND COD_AFERICAO = F_COD_AFERICAO_FOREACH
                      AND COD_PNEU = ANY (F_LISTA_COD_PNEU_EM_AFERICAO_MANUTENCAO);

                    --DELETA AFERICAO EM AFERICAO_VALORES_DATA ATRAVÉS DO COD_AFERICAO E COD_PNEU.
                    UPDATE AFERICAO_VALORES_DATA
                    SET DELETADO            = TRUE,
                        DATA_HORA_DELETADO  = NOW(),
                        PG_USERNAME_DELECAO = SESSION_USER
                    WHERE COD_UNIDADE = F_COD_UNIDADE_ORIGEM
                      AND COD_AFERICAO = F_COD_AFERICAO_FOREACH
                      AND COD_PNEU = ANY (F_LISTA_COD_PNEU_EM_AFERICAO_MANUTENCAO);
                END IF;
            END LOOP;

        --SE, E SOMENTE SE, A AFERIÇÃO POSSUIR TODOS OS VALORES EXCLUÍDOS, DEVE-SE EXCLUIR TODA A AFERIÇÃO.
        --SENÃO, A AFERIÇÃO CONTINUA EXISTINDO.
        FOREACH F_COD_AFERICAO_FOREACH IN ARRAY F_LISTA_COD_AFERICAO_PLACA
            LOOP
                F_QTD_COD_AFERICAO_EM_AFERICAO_VALORES = (SELECT COUNT(AVD.COD_AFERICAO)
                                                          FROM AFERICAO_VALORES_DATA AVD
                                                          WHERE AVD.COD_AFERICAO = F_COD_AFERICAO_FOREACH);

                F_QTD_COD_AFERICAO_DELETADOS_EM_AFERICAO_VALORES = (SELECT COUNT(AVD.COD_AFERICAO)
                                                                    FROM AFERICAO_VALORES_DATA AVD
                                                                    WHERE AVD.COD_AFERICAO = F_COD_AFERICAO_FOREACH
                                                                      AND AVD.DELETADO IS TRUE);

                --SE A QUANTIDADE DE UM COD_AFERICAO EM AFERICAO_VALORES_DATA FOR IGUAL A QUANTIDADE DE UM COD_AFERICAO
                --DELETADO EM AFERICAO_VALORES_DATA, DEVEMOS EXCLUIR A AFERIÇÃO, POIS, TODOS SEUS VALORES FORAM
                --DELETADOS.
                IF (F_QTD_COD_AFERICAO_EM_AFERICAO_VALORES =
                    F_QTD_COD_AFERICAO_DELETADOS_EM_AFERICAO_VALORES)
                THEN
                    UPDATE AFERICAO_DATA
                    SET DELETADO            = TRUE,
                        DATA_HORA_DELETADO  = NOW(),
                        PG_USERNAME_DELECAO = SESSION_USER
                    WHERE COD_UNIDADE = F_COD_UNIDADE_ORIGEM
                      AND CODIGO = F_COD_AFERICAO_FOREACH;
                END IF;
            END LOOP;
    END IF;

    --REALIZA TRANSFERÊNCIA.
    UPDATE VEICULO_DATA
    SET COD_EMPRESA = F_COD_EMPRESA_DESTINO,
        COD_UNIDADE = F_COD_UNIDADE_DESTINO,
        COD_TIPO    = F_COD_TIPO_VEICULO_DESTINO,
        COD_MODELO  = F_COD_MODELO_VEICULO_DESTINO
    WHERE COD_EMPRESA = F_COD_EMPRESA_ORIGEM
      AND COD_UNIDADE = F_COD_UNIDADE_ORIGEM
      AND PLACA = F_PLACA_VEICULO;

    --MENSAGEM DE SUCESSO.
    SELECT 'VEÍCULO TRANSFERIDO COM SUCESSO! O VEÍCULO COM PLACA: ' || F_PLACA_VEICULO ||
           ' FOI TRANSFERIDO PARA A EMPRESA ' || F_NOME_EMPRESA_DESTINO || ' JUNTO A UNIDADE ' ||
           F_NOME_UNIDADE_DESTINO || '.'
    INTO VEICULO_TRANSFERIDO;
END
$$;

create or replace function migration_checklist.func_migration_8_migra_functions_views() returns void
    language plpgsql
as
$fun$
begin
    --######################################################################################################################
--######################################################################################################################
--#################### MIGRATION DE IMPLEMENTAÇÃO DA NOVA ESTRUTURA DE CHECKLISTS NOS RELATÓRIOS #######################
--######################################################################################################################
--######################################################################################################################
-- PL-2230

    -- Agora a function é STABLE STRICT.
    CREATE OR REPLACE FUNCTION TZ_UNIDADE(F_COD_UNIDADE BIGINT) RETURNS TEXT
        LANGUAGE PLPGSQL
        STABLE STRICT
    AS
    $$
    DECLARE
        TZ TEXT;
    BEGIN
        SELECT TIMEZONE FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE INTO TZ;
        RETURN TZ;
    END;
    $$;

    -- https://dba.stackexchange.com/a/125155/151090
    -- show work_mem;
    -- SET LOCAL work_mem = '4MB';

    -- Agora a function é STABLE STRICT.
    CREATE OR REPLACE FUNCTION TZ_DATE(TIMESTAMP WITH TIME ZONE, TEXT) RETURNS DATE
        LANGUAGE PLPGSQL
        STABLE STRICT
    AS
    $$
    BEGIN
        RETURN ($1 AT TIME ZONE $2) :: DATE;
    END;
    $$;

    CREATE OR REPLACE FUNCTION FORMAT_TIMESTAMP(TS_TZ TIMESTAMP,
                                                TS_FORTMAT TEXT,
                                                VALUE_IF_NULL TEXT DEFAULT NULL)
        RETURNS TEXT
        IMMUTABLE
        LANGUAGE PLPGSQL
    AS
    $$
    BEGIN
        RETURN COALESCE(TO_CHAR(TS_TZ, TS_FORTMAT), VALUE_IF_NULL);
    END;
    $$;

    -- FUNC_CHECKLIST_RELATORIO_RESUMO_REALIZADOS - Aplica as alterações no relatório de resumo de checklist
    DROP FUNCTION FUNC_CHECKLIST_RELATORIO_RESUMO_REALIZADOS(F_COD_UNIDADES BIGINT[],
        F_PLACA_VEICULO TEXT,
        F_DATA_INICIAL DATE,
        F_DATA_FINAL DATE);
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_RELATORIO_RESUMO_REALIZADOS(F_COD_UNIDADES BIGINT[],
                                                                          F_PLACA_VEICULO TEXT,
                                                                          F_DATA_INICIAL DATE,
                                                                          F_DATA_FINAL DATE)
        RETURNS TABLE
                (
                    "UNIDADE"                     TEXT,
                    "MODELO CHECKLIST"            TEXT,
                    "CÓDIGO CHECKLIST"            BIGINT,
                    "DATA REALIZAÇÃO"             TEXT,
                    "DATA IMPORTADO"              TEXT,
                    "COLABORADOR"                 TEXT,
                    "CPF"                         TEXT,
                    "PLACA"                       TEXT,
                    "KM"                          BIGINT,
                    "TEMPO REALIZAÇÃO (SEGUNDOS)" BIGINT,
                    "TIPO"                        TEXT,
                    "TOTAL DE PERGUNTAS"          SMALLINT,
                    "TOTAL NOK"                   BIGINT,
                    "PRIORIDADE BAIXA"            BIGINT,
                    "PRIORIDADE ALTA"             BIGINT,
                    "PRIORIDADE CRÍTICA"          BIGINT
                )
        LANGUAGE SQL
    AS
    $$
    SELECT U.NOME                                                 AS NOME_UNIDADE,
           CM.NOME                                                AS NOME_MODELO,
           C.CODIGO                                               AS COD_CHECKLIST,
           FORMAT_TIMESTAMP(
                   C.DATA_HORA_REALIZACAO_TZ_APLICADO,
                   'DD/MM/YYYY HH24:MI')                          AS DATA_HORA_REALIZACAO,
           FORMAT_WITH_TZ(
                   C.DATA_HORA_IMPORTADO_PROLOG,
                   TZ_UNIDADE(C.COD_UNIDADE),
                   'DD/MM/YYYY HH24:MI',
                   '-')                                           AS DATA_HORA_IMPORTADO,
           CO.NOME                                                AS NOME_COLABORADOR,
           LPAD(CO.CPF :: TEXT, 11, '0')                          AS CPF_COLABORADOR,
           C.PLACA_VEICULO                                        AS PLACA_VEICULO,
           C.KM_VEICULO                                           AS KM_VEICULO,
           C.TEMPO_REALIZACAO / 1000                              AS TEMPO_REALIZACAO_SEGUNDOS,
           F_IF(C.TIPO = 'S', 'Saída' :: TEXT, 'Retorno' :: TEXT) AS TIPO_CHECKLIST,
           C.TOTAL_PERGUNTAS_OK + C.TOTAL_PERGUNTAS_NOK           AS TOTAL_PERGUNTAS,
           (SELECT COUNT(*)
            FROM CHECKLIST_RESPOSTAS_NOK CRN
            WHERE CRN.COD_CHECKLIST = C.CODIGO)                   AS TOTAL_NOK,
           (SELECT COUNT(*)
            FROM CHECKLIST_RESPOSTAS_NOK CRN
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON CRN.COD_ALTERNATIVA = CAP.CODIGO
            WHERE CRN.COD_CHECKLIST = C.CODIGO
              AND CAP.PRIORIDADE = 'BAIXA')                       AS TOTAL_BAIXA,
           (SELECT COUNT(*)
            FROM CHECKLIST_RESPOSTAS_NOK CRN
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON CRN.COD_ALTERNATIVA = CAP.CODIGO
            WHERE CRN.COD_CHECKLIST = C.CODIGO
              AND CAP.PRIORIDADE = 'ALTA')                        AS TOTAL_ALTA,
           (SELECT COUNT(*)
            FROM CHECKLIST_RESPOSTAS_NOK CRN
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON CRN.COD_ALTERNATIVA = CAP.CODIGO
            WHERE CRN.COD_CHECKLIST = C.CODIGO
              AND CAP.PRIORIDADE = 'CRITICA')                     AS TOTAL_CRITICA
    FROM CHECKLIST C
             JOIN CHECKLIST_PERGUNTAS CP
                  ON CP.cod_versao_checklist_modelo = C.cod_versao_checklist_modelo
             JOIN COLABORADOR CO
                  ON C.CPF_COLABORADOR = CO.CPF
             JOIN UNIDADE U
                  ON C.COD_UNIDADE = U.CODIGO
             JOIN CHECKLIST_MODELO CM ON CM.CODIGO = C.COD_CHECKLIST_MODELO
    WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
      AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
      AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
      AND (F_PLACA_VEICULO = '%' OR C.PLACA_VEICULO LIKE F_PLACA_VEICULO)
    GROUP BY C.CODIGO,
             CM.NOME,
             C.TOTAL_PERGUNTAS_OK,
             C.TOTAL_PERGUNTAS_NOK,
             U.CODIGO,
             CO.CPF,
             CO.NOME,
             CO.CPF,
             C.DATA_HORA,
             C.DATA_HORA_REALIZACAO_TZ_APLICADO,
             C.DATA_HORA_IMPORTADO_PROLOG,
             C.DATA_HORA_SINCRONIZACAO,
             C.COD_UNIDADE,
             C.PLACA_VEICULO,
             C.KM_VEICULO,
             C.TEMPO_REALIZACAO,
             C.TIPO
    ORDER BY U.NOME,
             C.DATA_HORA_SINCRONIZACAO DESC;
    $$;

    -- FUNC_CHECKLIST_OS_RELATORIO_ITENS_MAIOR_QUANTIDADE_NOK - Aplica as alterações no relatório de itens com maior
    -- qtd de nok.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_RELATORIO_ITENS_MAIOR_QUANTIDADE_NOK(F_COD_UNIDADES BIGINT[],
                                                                                      F_DATA_INICIAL DATE,
                                                                                      F_DATA_FINAL DATE)
        RETURNS TABLE
                (
                    UNIDADE               TEXT,
                    "MODELO CHECKLIST"    TEXT,
                    PERGUNTA              TEXT,
                    ALTERNATIVA           TEXT,
                    PRIORIDADE            TEXT,
                    "TOTAL MARCAÇÕES NOK" BIGINT,
                    "TOTAL REALIZAÇÕES"   BIGINT,
                    "PROPORÇÃO"           TEXT
                )
        LANGUAGE SQL
    AS
    $$
    SELECT Q.NOME_UNIDADE          AS NOME_UNIDADE,
           Q.NOME_MODELO_CHECKLIST AS NOME_MODELO_CHECKLIST,
           Q.PERGUNTA              AS PERGUNTA,
           Q.ALTERNATIVA           AS ALTERNATIVA,
           Q.PRIORIDADE            AS PRIORIDADE,
           Q.TOTAL_MARCACOES_NOK   AS TOTAL_MARCACOES_NOK,
           Q.TOTAL_REALIZACOES     AS TOTAL_REALIZACOES,
           Q.PROPORCAO_NUM || '%'  AS PROPORCAO
    FROM (SELECT U.NOME                                                         AS NOME_UNIDADE,
                 CM.NOME                                                        AS NOME_MODELO_CHECKLIST,
                 CP.PERGUNTA                                                    AS PERGUNTA,
                 CAP.ALTERNATIVA                                                AS ALTERNATIVA,
                 CAP.PRIORIDADE                                                 AS PRIORIDADE,
                 COUNT(CRN.CODIGO)                                              AS TOTAL_MARCACOES_NOK,
                 COUNT(DISTINCT C.CODIGO)                                       AS TOTAL_REALIZACOES,
                 TRUNC(((COUNT(CRN.CODIGO)
                     / COUNT(DISTINCT C.CODIGO) :: FLOAT) * 100) :: NUMERIC, 2) AS PROPORCAO_NUM
          FROM CHECKLIST C
                   -- O JOIN é feito pelo código do modelo e não da versão pois queremos saber as proporções de
                   -- respostas NOK em todas as versões de cada modelo.
                   JOIN CHECKLIST_PERGUNTAS CP
                        ON CP.COD_CHECKLIST_MODELO = C.COD_CHECKLIST_MODELO
                   JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                        ON CP.CODIGO = CAP.COD_PERGUNTA
                   LEFT JOIN CHECKLIST_RESPOSTAS_NOK CRN
                             ON C.CODIGO = CRN.COD_CHECKLIST AND CAP.CODIGO = CRN.COD_ALTERNATIVA
                   JOIN CHECKLIST_MODELO CM
                        ON CM.CODIGO = C.COD_CHECKLIST_MODELO
                   JOIN UNIDADE U ON C.COD_UNIDADE = U.CODIGO
          WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
            AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
            AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
          GROUP BY U.NOME, CAP.PRIORIDADE, CP.PERGUNTA, CAP.ALTERNATIVA, CM.NOME, C.COD_CHECKLIST_MODELO) Q
    ORDER BY Q.NOME_UNIDADE, Q.PROPORCAO_NUM DESC, Q.TOTAL_MARCACOES_NOK DESC, Q.PERGUNTA;
    $$;

    -- FUNC_CHECKLIST_RELATORIO_LISTAGEM_MODELOS_CHECKLIST - Aplica alterações no relatórios de listagem de modelos
    -- de check.
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_RELATORIO_LISTAGEM_MODELOS_CHECKLIST(F_COD_UNIDADES BIGINT[])
        RETURNS TABLE
                (
                    UNIDADE                 TEXT,
                    "CÓDIGO DO CHECKLIST"   TEXT,
                    "NOME DO CHECKLIST"     TEXT,
                    ATIVO                   TEXT,
                    "CÓDIGO DA PERGUNTA"    TEXT,
                    PERGUNTA                TEXT,
                    "CÓDIGO DA ALTERNATIVA" TEXT,
                    ALTERNATIVA             TEXT,
                    "TIPO DE RESPOSTA"      TEXT,
                    PRIORIDADE              TEXT
                )
        LANGUAGE SQL
    AS
    $$
    SELECT U.NOME                                              AS NOME_UNIDADE,
           CM.CODIGO::TEXT                                     AS COD_MODELO_CHECKLIST,
           CM.NOME                                             AS NOME_MODELO,
           F_IF(CM.STATUS_ATIVO, 'SIM' :: TEXT, 'NÃO')         AS ATIVO,
           CP.CODIGO::TEXT                                     AS COD_PERGUNTA,
           CP.PERGUNTA                                         AS PERGUNTA,
           CAP.CODIGO::TEXT                                    AS COD_ALTERNATIVA,
           CAP.ALTERNATIVA                                     AS ALTERNATIVA,
           F_IF(CP.SINGLE_CHOICE, 'ÚNICA' :: TEXT, 'MÚLTIPLA') AS TIPO_DE_RESPOSTA,
           CAP.PRIORIDADE                                      AS PRIORIDADE
    FROM CHECKLIST_PERGUNTAS CP
             JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                  ON CP.CODIGO = CAP.COD_PERGUNTA
             JOIN CHECKLIST_MODELO CM
                  ON CAP.COD_VERSAO_CHECKLIST_MODELO = CM.COD_VERSAO_ATUAL
             JOIN UNIDADE U
                  ON CM.COD_UNIDADE = U.CODIGO
    WHERE CM.COD_UNIDADE = ANY (F_COD_UNIDADES)
    ORDER BY U.NOME, CM.NOME, CP.PERGUNTA, CAP.ALTERNATIVA;
    $$;

    -- FUNC_CHECKLIST_RELATORIO_ESTRATIFICACAO_RESPOSTAS_NOK
    -- Aplica alterações no relatório de estratificação de respostas não ok
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_RELATORIO_ESTRATIFICACAO_RESPOSTAS_NOK(F_COD_UNIDADES BIGINT[],
                                                                                     F_PLACA_VEICULO CHARACTER VARYING,
                                                                                     F_DATA_INICIAL DATE,
                                                                                     F_DATA_FINAL DATE)
        RETURNS TABLE
                (
                    "UNIDADE"          TEXT,
                    "CODIGO CHECKLIST" BIGINT,
                    "DATA"             CHARACTER VARYING,
                    "PLACA"            CHARACTER VARYING,
                    "TIPO"             TEXT,
                    "KM"               BIGINT,
                    "NOME"             CHARACTER VARYING,
                    "PERGUNTA"         CHARACTER VARYING,
                    "ALTERNATIVA"      CHARACTER VARYING,
                    "RESPOSTA"         CHARACTER VARYING,
                    "PRIORIDADE"       CHARACTER VARYING,
                    "PRAZO EM HORAS"   INTEGER
                )
        LANGUAGE SQL
    AS
    $$
    SELECT U.NOME                                                                     AS NOME_UNIDADE,
           C.CODIGO                                                                   AS COD_CHECKLIST,
           FORMAT_TIMESTAMP(C.DATA_HORA_REALIZACAO_TZ_APLICADO, 'DD/MM/YYYY HH24:MI') AS DATA_HORA_CHECK,
           C.PLACA_VEICULO                                                            AS PLACA_VEICULO,
           CASE
               WHEN C.TIPO = 'S'
                   THEN 'Saída'
               ELSE 'Retorno' END                                                     AS TIPO_CHECKLIST,
           C.KM_VEICULO                                                               AS KM_VEICULO,
           CO.NOME                                                                    AS NOME_REALIZADOR_CHECK,
           CP.PERGUNTA                                                                AS DESCRICAO_PERGUNTA,
           CAP.ALTERNATIVA                                                            AS DESCRICAO_ALTERNATIVA,
           CRN.RESPOSTA_OUTROS                                                        AS RESPOSTA,
           CAP.PRIORIDADE                                                             AS PRIORIDADE,
           PRIO.PRAZO                                                                 AS PRAZO
    FROM CHECKLIST C
             JOIN VEICULO V
                  ON V.PLACA = C.PLACA_VEICULO
             JOIN CHECKLIST_PERGUNTAS CP
                  ON CP.COD_CHECKLIST_MODELO = C.COD_CHECKLIST_MODELO
             JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                  ON CAP.COD_PERGUNTA = CP.CODIGO
             JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE PRIO
                  ON PRIO.PRIORIDADE :: TEXT = CAP.PRIORIDADE :: TEXT
             JOIN CHECKLIST_RESPOSTAS_NOK CRN
                  ON C.CODIGO = CRN.COD_CHECKLIST
                      AND CRN.COD_ALTERNATIVA = CAP.CODIGO
             JOIN COLABORADOR CO
                  ON CO.CPF = C.CPF_COLABORADOR
             JOIN UNIDADE U
                  ON C.COD_UNIDADE = U.CODIGO
    WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
      AND C.PLACA_VEICULO LIKE F_PLACA_VEICULO
      AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
      AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
    ORDER BY U.NOME, C.DATA_HORA_SINCRONIZACAO DESC, C.CODIGO ASC
    $$;

    -- View já foi dropada no migration_checklist.func_migration_1_cria_estrutura_versionamento_modelo.
    CREATE OR REPLACE VIEW ESTRATIFICACAO_OS AS
    SELECT COS.CODIGO                                                       AS COD_OS,
           REALIZADOR.NOME                                                  AS NOME_REALIZADOR_CHECKLIST,
           C.PLACA_VEICULO,
           C.KM_VEICULO                                                     AS KM,
           C.DATA_HORA_REALIZACAO_TZ_APLICADO                               AS DATA_HORA,
           C.TIPO                                                           AS TIPO_CHECKLIST,
           CP.CODIGO                                                        AS COD_PERGUNTA,
           CP.CODIGO_CONTEXTO                                               AS COD_CONTEXTO_PERGUNTA,
           CP.ORDEM                                                         AS ORDEM_PERGUNTA,
           CP.PERGUNTA,
           CP.SINGLE_CHOICE,
           NULL :: UNKNOWN                                                  AS URL_IMAGEM,
           CAP.PRIORIDADE,
           CASE CAP.PRIORIDADE
               WHEN 'CRITICA' :: TEXT
                   THEN 1
               WHEN 'ALTA' :: TEXT
                   THEN 2
               WHEN 'BAIXA' :: TEXT
                   THEN 3
               ELSE NULL :: INTEGER
               END                                                          AS PRIORIDADE_ORDEM,
           CAP.CODIGO                                                       AS COD_ALTERNATIVA,
           CAP.CODIGO_CONTEXTO                                              AS COD_CONTEXTO_ALTERNATIVA,
           CAP.ALTERNATIVA,
           PRIO.PRAZO,
           CRN.RESPOSTA_OUTROS,
           V.COD_TIPO,
           COS.COD_UNIDADE,
           COS.STATUS                                                       AS STATUS_OS,
           COS.COD_CHECKLIST,
           TZ_UNIDADE(COS.COD_UNIDADE)                                      AS TIME_ZONE_UNIDADE,
           COSI.STATUS_RESOLUCAO                                            AS STATUS_ITEM,
           MECANICO.NOME                                                    AS NOME_MECANICO,
           COSI.CPF_MECANICO,
           COSI.TEMPO_REALIZACAO,
           COSI.DATA_HORA_CONSERTO AT TIME ZONE TZ_UNIDADE(COS.COD_UNIDADE) AS DATA_HORA_CONSERTO,
           COSI.DATA_HORA_INICIO_RESOLUCAO                                  AS DATA_HORA_INICIO_RESOLUCAO_UTC,
           COSI.DATA_HORA_FIM_RESOLUCAO                                     AS DATA_HORA_FIM_RESOLUCAO_UTC,
           COSI.KM                                                          AS KM_FECHAMENTO,
           COSI.QT_APONTAMENTOS,
           COSI.FEEDBACK_CONSERTO,
           COSI.CODIGO
    FROM CHECKLIST_DATA C
             JOIN COLABORADOR REALIZADOR
                  ON REALIZADOR.CPF = C.CPF_COLABORADOR
             JOIN VEICULO V
                  ON V.PLACA :: TEXT = C.PLACA_VEICULO :: TEXT
             JOIN CHECKLIST_ORDEM_SERVICO COS
                  ON C.CODIGO = COS.COD_CHECKLIST
             JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                  ON COS.CODIGO = COSI.COD_OS
                      AND COS.COD_UNIDADE = COSI.COD_UNIDADE
             JOIN CHECKLIST_PERGUNTAS CP
                  ON CP.COD_VERSAO_CHECKLIST_MODELO = C.COD_VERSAO_CHECKLIST_MODELO
                      AND COSI.COD_CONTEXTO_PERGUNTA = CP.CODIGO_CONTEXTO
             JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                  ON CAP.COD_PERGUNTA = CP.CODIGO
                      AND COSI.COD_CONTEXTO_ALTERNATIVA = CAP.CODIGO_CONTEXTO
             JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE PRIO
                  ON PRIO.PRIORIDADE :: TEXT = CAP.PRIORIDADE :: TEXT
             JOIN CHECKLIST_RESPOSTAS_NOK CRN
                  ON CRN.COD_CHECKLIST = C.CODIGO
                      AND CRN.COD_ALTERNATIVA = CAP.CODIGO
             LEFT JOIN COLABORADOR MECANICO ON MECANICO.CPF = COSI.CPF_MECANICO;

    -- Dropa e recria a FUNC_CHECKLIST_OS_RELATORIO_ESTRATIFICACAO_OS
    DROP FUNCTION FUNC_CHECKLIST_OS_RELATORIO_ESTRATIFICACAO_OS(BIGINT[], TEXT, TEXT, TEXT, DATE, DATE, DATE, DATE);
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_OS_RELATORIO_ESTRATIFICACAO_OS(F_COD_UNIDADES BIGINT[],
                                                                             F_PLACA_VEICULO TEXT,
                                                                             F_STATUS_OS TEXT,
                                                                             F_STATUS_ITEM TEXT,
                                                                             F_DATA_INICIAL_ABERTURA DATE,
                                                                             F_DATA_FINAL_ABERTURA DATE,
                                                                             F_DATA_INICIAL_RESOLUCAO DATE,
                                                                             F_DATA_FINAL_RESOLUCAO DATE)
        RETURNS TABLE
                (
                    UNIDADE                        TEXT,
                    "CÓDICO OS"                    BIGINT,
                    "ABERTURA OS"                  TEXT,
                    "DATA LIMITE CONSERTO"         TEXT,
                    "STATUS OS"                    TEXT,
                    "PLACA"                        TEXT,
                    "PERGUNTA"                     TEXT,
                    "ALTERNATIVA"                  TEXT,
                    "PRIORIDADE"                   TEXT,
                    "PRAZO EM HORAS"               INTEGER,
                    "DESCRIÇÃO"                    TEXT,
                    "STATUS ITEM"                  TEXT,
                    "DATA INÍCIO RESOLUÇÃO"        TEXT,
                    "DATA FIM RESOLUÇÃO"           TEXT,
                    "DATA RESOLIVDO PROLOG"        TEXT,
                    "MECÂNICO"                     TEXT,
                    "DESCRIÇÃO CONSERTO"           TEXT,
                    "TEMPO DE CONSERTO EM MINUTOS" BIGINT,
                    "KM ABERTURA"                  BIGINT,
                    "KM FECHAMENTO"                BIGINT,
                    "KM PERCORRIDO"                TEXT,
                    "MOTORISTA"                    TEXT,
                    "TIPO DO CHECKLIST"            TEXT
                )
        LANGUAGE SQL
    AS
    $$
    SELECT U.NOME                                                                             AS NOME_UNIDADE,
           EO.COD_OS                                                                          AS CODIGO_OS,
           FORMAT_TIMESTAMP(DATA_HORA, 'DD/MM/YYYY HH24:MI')                                  AS ABERTURA_OS,
           FORMAT_TIMESTAMP(DATA_HORA + (PRAZO || ' HOUR') :: INTERVAL, 'DD/MM/YYYY HH24:MI') AS DATA_LIMITE_CONSERTO,
           (CASE
                WHEN STATUS_OS = 'A'
                    THEN 'ABERTA'
                ELSE 'FECHADA' END)                                                           AS STATUS_OS,
           PLACA_VEICULO                                                                      AS PLACA,
           PERGUNTA                                                                           AS PERGUNTA,
           ALTERNATIVA                                                                        AS ALTERNATIVA,
           PRIORIDADE                                                                         AS PRIORIDADE,
           PRAZO                                                                              AS PRAZO_EM_HORAS,
           RESPOSTA_OUTROS                                                                    AS DESCRICAO,
           CASE
               WHEN STATUS_ITEM = 'P'
                   THEN 'PENDENTE'
               ELSE 'RESOLVIDO' END                                                           AS STATUS_ITEM,
           FORMAT_TIMESTAMP(
                   DATA_HORA_INICIO_RESOLUCAO_UTC AT TIME ZONE TIME_ZONE_UNIDADE,
                   'DD/MM/YYYY HH24:MI',
                   '-')                                                                       AS DATA_INICIO_RESOLUCAO,
           FORMAT_TIMESTAMP(
                   DATA_HORA_FIM_RESOLUCAO_UTC AT TIME ZONE TIME_ZONE_UNIDADE,
                   'DD/MM/YYYY HH24:MI', '-')                                                 AS DATA_FIM_RESOLUCAO,
           FORMAT_TIMESTAMP(DATA_HORA_CONSERTO, 'DD/MM/YYYY HH24:MI')                         AS DATA_RESOLVIDO_PROLOG,
           NOME_MECANICO                                                                      AS MECANICO,
           FEEDBACK_CONSERTO                                                                  AS DESCRICAO_CONSERTO,
           TEMPO_REALIZACAO / 1000 / 60                                                       AS TEMPO_CONSERTO_MINUTOS,
           KM                                                                                 AS KM_ABERTURA,
           KM_FECHAMENTO                                                                      AS KM_FECHAMENTO,
           COALESCE((KM_FECHAMENTO - KM) :: TEXT, '-')                                        AS KM_PERCORRIDO,
           NOME_REALIZADOR_CHECKLIST                                                          AS MOTORISTA,
           CASE
               WHEN TIPO_CHECKLIST = 'S'
                   THEN 'SAÍDA'
               ELSE 'RETORNO' END                                                             AS TIPO_CHECKLIST
    FROM ESTRATIFICACAO_OS EO
             JOIN UNIDADE U
                  ON EO.COD_UNIDADE = U.CODIGO
    WHERE EO.COD_UNIDADE = ANY (F_COD_UNIDADES)
      AND EO.PLACA_VEICULO LIKE F_PLACA_VEICULO
      AND EO.STATUS_OS LIKE F_STATUS_OS
      AND EO.STATUS_ITEM LIKE F_STATUS_ITEM
      AND CASE
        -- O usuário pode filtrar tanto por início e fim de abertura ou por início e fim de resolução ou, ainda,
        -- por ambos.
              WHEN (F_DATA_INICIAL_ABERTURA,
                    F_DATA_FINAL_ABERTURA,
                    F_DATA_INICIAL_RESOLUCAO,
                    F_DATA_FINAL_RESOLUCAO) IS NOT NULL
                  THEN (
                      EO.DATA_HORA :: DATE BETWEEN F_DATA_INICIAL_ABERTURA AND F_DATA_FINAL_ABERTURA
                      AND
                      EO.DATA_HORA_CONSERTO :: DATE BETWEEN F_DATA_INICIAL_RESOLUCAO AND F_DATA_FINAL_RESOLUCAO)
              WHEN (F_DATA_INICIAL_ABERTURA,
                    F_DATA_FINAL_ABERTURA) IS NOT NULL
                  THEN
                  EO.DATA_HORA :: DATE BETWEEN F_DATA_INICIAL_ABERTURA AND F_DATA_FINAL_ABERTURA
              WHEN (F_DATA_INICIAL_RESOLUCAO,
                    F_DATA_FINAL_RESOLUCAO) IS NOT NULL
                  THEN
                  EO.DATA_HORA_CONSERTO :: DATE BETWEEN F_DATA_INICIAL_RESOLUCAO AND F_DATA_FINAL_RESOLUCAO

        -- Se não entrar em nenhuma condição conhecida, retornamos FALSE para o relatório não retornar dado nenhum.
              ELSE FALSE END
    ORDER BY U.NOME, EO.COD_OS, EO.PRAZO;
    $$;
    --######################################################################################################################
    --######################################################################################################################

    --######################################################################################################################
    --######################################################################################################################
    -- Remove usos da CHECKLIST_RESPOSTAS e utiliza nova coluna DATA_HORA_REALIZACAO_TZ_APLICADO.
    DROP FUNCTION FUNC_CHECKLIST_GET_ALL_CHECKLISTS_REALIZADOS(F_COD_UNIDADE BIGINT,
        F_COD_EQUIPE BIGINT,
        F_COD_TIPO_VEICULO BIGINT,
        F_PLACA_VEICULO CHARACTER VARYING,
        F_DATA_INICIAL DATE,
        F_DATA_FINAL DATE,
        F_TIMEZONE TEXT,
        F_LIMIT INTEGER,
        F_OFFSET BIGINT);
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_GET_ALL_CHECKLISTS_REALIZADOS(F_COD_UNIDADE BIGINT,
                                                                            F_COD_EQUIPE BIGINT,
                                                                            F_COD_TIPO_VEICULO BIGINT,
                                                                            F_PLACA_VEICULO CHARACTER VARYING,
                                                                            F_DATA_INICIAL DATE,
                                                                            F_DATA_FINAL DATE,
                                                                            F_TIMEZONE TEXT,
                                                                            F_LIMIT INTEGER,
                                                                            F_OFFSET BIGINT)
        RETURNS TABLE
                (
                    COD_CHECKLIST                 BIGINT,
                    COD_CHECKLIST_MODELO          BIGINT,
                    COD_VERSAO_CHECKLIST_MODELO   BIGINT,
                    DATA_HORA_REALIZACAO          TIMESTAMP WITHOUT TIME ZONE,
                    DATA_HORA_IMPORTADO_PROLOG    TIMESTAMP WITHOUT TIME ZONE,
                    KM_VEICULO_MOMENTO_REALIZACAO BIGINT,
                    DURACAO_REALIZACAO_MILLIS     BIGINT,
                    CPF_COLABORADOR               BIGINT,
                    PLACA_VEICULO                 TEXT,
                    TIPO_CHECKLIST                CHAR,
                    NOME_COLABORADOR              TEXT,
                    TOTAL_ITENS_OK                SMALLINT,
                    TOTAL_ITENS_NOK               SMALLINT
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        F_HAS_EQUIPE           INTEGER := CASE WHEN F_COD_EQUIPE IS NULL THEN 1 ELSE 0 END;
        F_HAS_COD_TIPO_VEICULO INTEGER := CASE WHEN F_COD_TIPO_VEICULO IS NULL THEN 1 ELSE 0 END;
        F_HAS_PLACA_VEICULO    INTEGER := CASE WHEN F_PLACA_VEICULO IS NULL THEN 1 ELSE 0 END;
    BEGIN
        RETURN QUERY
            SELECT C.CODIGO                                             AS COD_CHECKLIST,
                   C.COD_CHECKLIST_MODELO                               AS COD_CHECKLIST_MODELO,
                   C.COD_VERSAO_CHECKLIST_MODELO                        AS COD_VERSAO_CHECKLIST_MODELO,
                   C.DATA_HORA AT TIME ZONE F_TIMEZONE                  AS DATA_HORA_REALIZACAO,
                   C.DATA_HORA_IMPORTADO_PROLOG AT TIME ZONE F_TIMEZONE AS DATA_HORA_IMPORTADO_PROLOG,
                   C.KM_VEICULO                                         AS KM_VEICULO_MOMENTO_REALIZACAO,
                   C.TEMPO_REALIZACAO                                   AS DURACAO_REALIZACAO_MILLIS,
                   C.CPF_COLABORADOR                                    AS CPF_COLABORADOR,
                   C.PLACA_VEICULO :: TEXT                              AS PLACA_VEICULO,
                   C.TIPO                                               AS TIPO_CHECKLIST,
                   CO.NOME :: TEXT                                      AS NOME_COLABORADOR,
                   C.TOTAL_PERGUNTAS_OK                                 AS TOTAL_ITENS_OK,
                   C.TOTAL_PERGUNTAS_NOK                                AS TOTAL_ITENS_NOK
            FROM CHECKLIST C
                     JOIN COLABORADOR CO
                          ON CO.CPF = C.CPF_COLABORADOR
                     JOIN EQUIPE E
                          ON E.CODIGO = CO.COD_EQUIPE
                     JOIN VEICULO V
                          ON V.PLACA = C.PLACA_VEICULO
            WHERE C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
              AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
              AND C.COD_UNIDADE = F_COD_UNIDADE
              AND (F_HAS_EQUIPE = 1 OR E.CODIGO = F_COD_EQUIPE)
              AND (F_HAS_COD_TIPO_VEICULO = 1 OR V.COD_TIPO = F_COD_TIPO_VEICULO)
              AND (F_HAS_PLACA_VEICULO = 1 OR C.PLACA_VEICULO = F_PLACA_VEICULO)
            ORDER BY DATA_HORA_SINCRONIZACAO DESC
            LIMIT F_LIMIT
                OFFSET F_OFFSET;
    END;
    $$;
    --######################################################################################################################
    --######################################################################################################################

    --######################################################################################################################
    --######################################################################################################################
    CREATE OR REPLACE FUNCTION FUNC_CHECKLIST_GET_FAROL_CHECKLIST(F_COD_UNIDADE BIGINT,
                                                                  F_DATA_INICIAL DATE,
                                                                  F_DATA_FINAL DATE,
                                                                  F_ITENS_CRITICOS_RETROATIVOS BOOLEAN)
        RETURNS TABLE
                (
                    DATA                               DATE,
                    PLACA                              CHARACTER VARYING,
                    COD_CHECKLIST_SAIDA                BIGINT,
                    DATA_HORA_ULTIMO_CHECKLIST_SAIDA   TIMESTAMP WITHOUT TIME ZONE,
                    COD_CHECKLIST_MODELO_SAIDA         BIGINT,
                    NOME_COLABORADOR_CHECKLIST_SAIDA   CHARACTER VARYING,
                    COD_CHECKLIST_RETORNO              BIGINT,
                    DATA_HORA_ULTIMO_CHECKLIST_RETORNO TIMESTAMP WITHOUT TIME ZONE,
                    COD_CHECKLIST_MODELO_RETORNO       BIGINT,
                    NOME_COLABORADOR_CHECKLIST_RETORNO CHARACTER VARYING,
                    CODIGO_PERGUNTA                    BIGINT,
                    DESCRICAO_PERGUNTA                 TEXT,
                    DESCRICAO_ALTERNATIVA              TEXT,
                    ALTERNATIVA_TIPO_OUTROS            BOOLEAN,
                    DESCRICAO_ALTERNATIVA_TIPO_OUTROS  TEXT,
                    CODIGO_ITEM_CRITICO                BIGINT,
                    DATA_HORA_APONTAMENTO_ITEM_CRITICO TIMESTAMP WITHOUT TIME ZONE
                )
        LANGUAGE PLPGSQL
    AS
    $$
    DECLARE
        CHECKLIST_TIPO_SAIDA         CHAR := 'S';
        CHECKLIST_TIPO_RETORNO       CHAR := 'R';
        CHECKLIST_PRIORIDADE_CRITICA TEXT := 'CRITICA';
        ORDEM_SERVICO_ABERTA         CHAR := 'A';
        ITEM_ORDEM_SERVICO_PENDENDTE CHAR := 'P';
    BEGIN
        RETURN QUERY
            WITH ULTIMOS_CHECKLISTS_VEICULOS AS (
                SELECT INNERTABLE.DATA,
                       INNERTABLE.PLACA,
                       INNERTABLE.COD_CHECKLIST_SAIDA,
                       INNERTABLE.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                       CS.COD_CHECKLIST_MODELO AS COD_CHECKLIST_MODELO_SAIDA,
                       COS.NOME                AS NOME_COLABORADOR_CHECKLIST_SAIDA,
                       INNERTABLE.COD_CHECKLIST_RETORNO,
                       INNERTABLE.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
                       CR.COD_CHECKLIST_MODELO AS COD_CHECKLIST_MODELO_RETORNO,
                       COR.NOME                AS NOME_COLABORADOR_CHECKLIST_RETORNO
                FROM (SELECT G.DAY :: DATE                                            AS DATA,
                             V.PLACA                                                  AS PLACA,
                             MAX(CASE
                                     WHEN C.TIPO = CHECKLIST_TIPO_SAIDA
                                         THEN C.CODIGO END)                           AS COD_CHECKLIST_SAIDA,
                             MAX(CASE
                                     WHEN C.TIPO = CHECKLIST_TIPO_SAIDA
                                         THEN C.DATA_HORA_REALIZACAO_TZ_APLICADO END) AS DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                             MAX(CASE
                                     WHEN C.TIPO = CHECKLIST_TIPO_RETORNO
                                         THEN C.CODIGO END)                           AS COD_CHECKLIST_RETORNO,
                             MAX(CASE
                                     WHEN C.TIPO = CHECKLIST_TIPO_RETORNO
                                         THEN C.DATA_HORA_REALIZACAO_TZ_APLICADO END) AS DATA_HORA_ULTIMO_CHECKLIST_RETORNO
                      FROM VEICULO V
                               CROSS JOIN GENERATE_SERIES(F_DATA_INICIAL, F_DATA_FINAL, '1 DAY') G(DAY)
                               LEFT JOIN CHECKLIST C
                                         ON C.PLACA_VEICULO = V.PLACA AND
                                            G.DAY :: DATE = (C.DATA_HORA_REALIZACAO_TZ_APLICADO) :: DATE
                      WHERE V.COD_UNIDADE = F_COD_UNIDADE
                        AND V.STATUS_ATIVO = TRUE
                      GROUP BY 1, 2
                      ORDER BY 1, 2) AS INNERTABLE
                         LEFT JOIN CHECKLIST CS ON CS.CODIGO = INNERTABLE.COD_CHECKLIST_SAIDA
                         LEFT JOIN CHECKLIST CR ON CR.CODIGO = INNERTABLE.COD_CHECKLIST_RETORNO
                         LEFT JOIN COLABORADOR COS ON COS.CPF = CS.CPF_COLABORADOR
                         LEFT JOIN COLABORADOR COR ON COR.CPF = CR.CPF_COLABORADOR
                ORDER BY INNERTABLE.DATA, INNERTABLE.PLACA
            ),

                 ITENS_CRITICOS_PENDENTES AS (
                     SELECT COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO AS COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                            COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO    AS COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
                            COSI.STATUS_RESOLUCAO                     AS STATUS_RESOLUCAO,
                            COSI.COD_OS                               AS COD_OS,
                            COSI.COD_UNIDADE                          AS COD_UNIDADE,
                            COSI.CODIGO                               AS CODIGO,
                            CAP.PRIORIDADE                            AS PRIORIDADE
                     FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                              JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                                   ON CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                              JOIN CHECKLIST_PERGUNTAS CP
                                   ON CP.CODIGO = CAP.COD_PERGUNTA
                     WHERE COSI.COD_UNIDADE = F_COD_UNIDADE
                       AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                       AND COSI.STATUS_RESOLUCAO = ITEM_ORDEM_SERVICO_PENDENDTE
                 )

            SELECT Q.DATA,
                   Q.PLACA,
                   Q.COD_CHECKLIST_SAIDA,
                   Q.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                   Q.COD_CHECKLIST_MODELO_SAIDA,
                   Q.NOME_COLABORADOR_CHECKLIST_SAIDA,
                   Q.COD_CHECKLIST_RETORNO,
                   Q.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
                   Q.COD_CHECKLIST_MODELO_RETORNO,
                   Q.NOME_COLABORADOR_CHECKLIST_RETORNO,
                   Q.CODIGO_PERGUNTA,
                   Q.DESCRICAO_PERGUNTA,
                   Q.DESCRICAO_ALTERNATIVA,
                   CASE
                       WHEN Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_SAIDA
                           OR Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO
                           THEN TRUE
                       ELSE FALSE
                       END AS ALTERNATIVA_TIPO_OUTROS,
                   CASE
                       WHEN Q.ITEM_CRITICO_DE_SAIDA_TIPO_OUTROS
                           THEN (SELECT CRN.RESPOSTA_OUTROS
                                 FROM CHECKLIST_RESPOSTAS_NOK CRN
                                 WHERE CRN.COD_CHECKLIST = Q.COD_CHECKLIST_SAIDA
                                   AND CRN.COD_ALTERNATIVA = Q.CODIGO_ALTERNATIVA)
                       WHEN Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO
                           THEN (SELECT CRN.RESPOSTA_OUTROS
                                 FROM CHECKLIST_RESPOSTAS_NOK CRN
                                 WHERE CRN.COD_CHECKLIST = Q.COD_CHECKLIST_RETORNO
                                   AND CRN.COD_ALTERNATIVA = Q.CODIGO_ALTERNATIVA)
                       ELSE NULL
                       END AS DESCRICAO_ALTERNATIVA_TIPO_OUTROS,
                   Q.CODIGO_ITEM_CRITICO,
                   Q.DATA_HORA_APONTAMENTO_ITEM_CRITICO
            FROM (SELECT UCV.DATA,
                         UCV.PLACA,
                         UCV.COD_CHECKLIST_SAIDA,
                         UCV.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                         UCV.COD_CHECKLIST_MODELO_SAIDA,
                         UCV.NOME_COLABORADOR_CHECKLIST_SAIDA,
                         UCV.COD_CHECKLIST_RETORNO,
                         UCV.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
                         UCV.COD_CHECKLIST_MODELO_RETORNO,
                         UCV.NOME_COLABORADOR_CHECKLIST_RETORNO,
                         CP.CODIGO       AS CODIGO_PERGUNTA,
                         CP.PERGUNTA     AS DESCRICAO_PERGUNTA,
                         CAP.ALTERNATIVA AS DESCRICAO_ALTERNATIVA,
                         CAP.CODIGO      AS CODIGO_ALTERNATIVA,
                         CASE
                             WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                                 AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                 AND CAP.ALTERNATIVA_TIPO_OUTROS = TRUE
                                 AND COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO)
                                 THEN TRUE
                             ELSE FALSE
                             END         AS ITEM_CRITICO_DE_SAIDA_TIPO_OUTROS,
                         CASE
                             WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                                 AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                 AND CAP.ALTERNATIVA_TIPO_OUTROS = TRUE)
                                 THEN TRUE
                             ELSE FALSE
                             END         AS ALTERNATIVA_TIPO_OUTROS_CHECKLIST_SAIDA,
                         CASE
                             WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_RETORNO
                                 AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                 AND CAP.ALTERNATIVA_TIPO_OUTROS = TRUE)
                                 THEN TRUE
                             ELSE FALSE
                             END         AS ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO,
                         CASE
                             WHEN CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                 THEN COSI.CODIGO
                             ELSE NULL
                             END         AS CODIGO_ITEM_CRITICO,
                         CASE
                             WHEN COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                                 AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                 THEN UCV.DATA_HORA_ULTIMO_CHECKLIST_SAIDA
                             WHEN COS.COD_CHECKLIST = UCV.COD_CHECKLIST_RETORNO
                                 AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                                 THEN UCV.DATA_HORA_ULTIMO_CHECKLIST_RETORNO
                             ELSE NULL
                             END         AS DATA_HORA_APONTAMENTO_ITEM_CRITICO
                  FROM ULTIMOS_CHECKLISTS_VEICULOS UCV
                           LEFT JOIN CHECKLIST_ORDEM_SERVICO COS
                                     ON COS.COD_CHECKLIST IN (UCV.COD_CHECKLIST_SAIDA, UCV.COD_CHECKLIST_RETORNO)
                                         AND COS.STATUS = ORDEM_SERVICO_ABERTA
                                         AND COS.CODIGO IS NOT NULL
                      -- Utilizamos o join com ITENS_CRITICOS_PENDENTES ao invés de CHECKLIST_ORDEM_SERVICO_ITENS pois desse modo
                      -- consideramos apenas os itens abertos críticos, que é o que importa para o farol.
                           LEFT JOIN ITENS_CRITICOS_PENDENTES COSI
                                     ON COS.CODIGO = COSI.COD_OS
                                         AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                                         AND COSI.STATUS_RESOLUCAO = ITEM_ORDEM_SERVICO_PENDENDTE
                                         AND COSI.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                           LEFT JOIN CHECKLIST_PERGUNTAS CP
                                     ON CP.CODIGO = COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO
                           LEFT JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                                     ON CAP.COD_PERGUNTA = CP.CODIGO
                                         AND CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                                         AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA) AS Q
            ORDER BY Q.DATA, Q.PLACA, Q.CODIGO_PERGUNTA;
    END;
    $$;
    --######################################################################################################################
    --######################################################################################################################
end;
$fun$;

create or replace function migration_checklist.func_checklist_cria_versao_modelo(f_cod_modelo bigint,
                                                                                 f_cod_primeiro_check_versao_modelo bigint,
                                                                                 f_data_hora_atual timestamp with time zone) returns bigint
    language plpgsql
as
$$
declare
    cod_pergunta_criado          bigint;
    cod_alternativa_criado       bigint;
    pergunta_modelo_checklist    checklist_perguntas_data%rowtype;
    alternativa_modelo_checklist checklist_alternativa_pergunta_data%rowtype;
    qtd_linhas_inseridas         bigint;
    qtd_linhas_atualizadas       bigint;
    novo_cod_versao_modelo       bigint := nextval(
            pg_get_serial_sequence('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
begin
    -- 1 -> Insere a versão.
    insert into checklist_modelo_versao(cod_versao_checklist_modelo,
                                        cod_versao_user_friendly,
                                        cod_checklist_modelo,
                                        data_hora_criacao_versao,
                                        cod_colaborador_criacao_versao)
    values (novo_cod_versao_modelo,
            (select coalesce(max(cmv.cod_versao_user_friendly) + 1, 1)
             from checklist_modelo_versao cmv
             where cmv.cod_checklist_modelo = f_cod_modelo),
            f_cod_modelo,
            f_data_hora_atual,
            null);

    get diagnostics qtd_linhas_inseridas = row_count;

    if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
    then
        raise exception 'Erro ao inserir versão do modelo';
    end if;
    --

    -- 2 -> Criamos as perguntas e alternativas, mesmo que seja a versão 1.
    -- insere as perguntas e alternativas.
    for pergunta_modelo_checklist in
        select cp.*
        from checklist_respostas cr
                 join checklist_perguntas_data cp on cp.codigo = cr.cod_pergunta
        where cr.cod_checklist = f_cod_primeiro_check_versao_modelo
        group by cr.cod_pergunta,
                 cp.cod_checklist_modelo,
                 cp.cod_unidade,
                 cp.ordem,
                 cp.pergunta,
                 cp.status_ativo,
                 cp.single_choice,
                 cp.cod_imagem,
                 cp.codigo,
                 cp.deletado,
                 cp.data_hora_deletado,
                 cp.codigo_contexto
        loop
            -- Pergunta.
            insert into checklist_perguntas_data (cod_checklist_modelo,
                                                  cod_unidade,
                                                  ordem,
                                                  pergunta,
                                                  status_ativo,
                                                  single_choice,
                                                  cod_imagem,
                                                  codigo_contexto,
                                                  cod_versao_checklist_modelo)
            values (pergunta_modelo_checklist.cod_checklist_modelo,
                    pergunta_modelo_checklist.cod_unidade,
                    pergunta_modelo_checklist.ordem,
                    pergunta_modelo_checklist.pergunta,
                    pergunta_modelo_checklist.status_ativo,
                    pergunta_modelo_checklist.single_choice,
                    pergunta_modelo_checklist.cod_imagem,
                    pergunta_modelo_checklist.codigo_contexto,
                    novo_cod_versao_modelo) returning codigo
                       into cod_pergunta_criado;

            insert into migration_checklist.check_perguntas_aux (cod_modelo,
                                                                 cod_modelo_versao,
                                                                 cod_pergunta_antigo,
                                                                 cod_pergunta_novo)
            values (f_cod_modelo, novo_cod_versao_modelo, pergunta_modelo_checklist.codigo, cod_pergunta_criado);

            get diagnostics qtd_linhas_inseridas = row_count;

            if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
            then
                raise exception 'Erro ao inserir pergunta aux';
            end if;

            -- Alternativa.
            for alternativa_modelo_checklist in
                select cap.*
                from checklist_respostas cr
                         join checklist_alternativa_pergunta_data cap on cap.codigo = cr.cod_alternativa
                where cr.cod_checklist = f_cod_primeiro_check_versao_modelo
                  and cr.cod_pergunta = pergunta_modelo_checklist.codigo
                loop
                    insert into checklist_alternativa_pergunta_data (cod_checklist_modelo,
                                                                     cod_unidade,
                                                                     alternativa,
                                                                     ordem,
                                                                     status_ativo,
                                                                     cod_pergunta,
                                                                     alternativa_tipo_outros,
                                                                     prioridade,
                                                                     deve_abrir_ordem_servico,
                                                                     codigo_contexto,
                                                                     cod_versao_checklist_modelo)
                    values (alternativa_modelo_checklist.cod_checklist_modelo,
                            alternativa_modelo_checklist.cod_unidade,
                            alternativa_modelo_checklist.alternativa,
                            alternativa_modelo_checklist.ordem,
                            alternativa_modelo_checklist.status_ativo,
                            alternativa_modelo_checklist.cod_pergunta,
                            alternativa_modelo_checklist.alternativa_tipo_outros,
                            alternativa_modelo_checklist.prioridade,
                            alternativa_modelo_checklist.deve_abrir_ordem_servico,
                            alternativa_modelo_checklist.codigo_contexto,
                            novo_cod_versao_modelo) returning codigo
                               into cod_alternativa_criado;

                    insert into migration_checklist.check_alternativas_aux (cod_modelo,
                                                                            cod_modelo_versao,
                                                                            cod_alternativa_antigo,
                                                                            cod_alternativa_novo)
                    values (f_cod_modelo,
                            novo_cod_versao_modelo,
                            alternativa_modelo_checklist.codigo,
                            cod_alternativa_criado);

                    get diagnostics qtd_linhas_inseridas = row_count;

                    if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
                    then
                        raise exception 'Erro ao inserir alternativa aux';
                    end if;

                end loop;
        end loop;
    --

    -- 3 -> Atualiza na tabela de mapeamento da migração para setar a versão criada.
    -- Isso vai fazer a versão ser setada em todos os CHECKLIST_DATA.
    update migration_checklist.migration_checklist_modelos
    set cod_checklist_modelo_versao = novo_cod_versao_modelo
    where cod_checklist_modelo = f_cod_modelo
      and cod_checklist_primeira_realizacao_modelo = f_cod_primeiro_check_versao_modelo;

    get diagnostics qtd_linhas_atualizadas = row_count;

    if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas <> 1
    then
        raise exception 'Erro ao setar versão na tabela migration_checklist_modelos %, %',
            f_cod_modelo,
            f_cod_primeiro_check_versao_modelo;
    end if;
    --

    return novo_cod_versao_modelo;
end
$$;

create or replace function migration_checklist.func_checklist_cria_modelo_ultima_versao(f_cod_modelo bigint, f_data_hora_atual timestamp with time zone) returns bigint
    language plpgsql
as
$$
declare
    qtd_linhas_inseridas   bigint;
    qtd_linhas_atualizadas bigint;
    novo_cod_versao_modelo bigint := nextval(
            pg_get_serial_sequence('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
begin
    -- 1 -> Insere a versão.
    insert into checklist_modelo_versao(cod_versao_checklist_modelo,
                                        cod_versao_user_friendly,
                                        cod_checklist_modelo,
                                        data_hora_criacao_versao,
                                        cod_colaborador_criacao_versao)
    values (novo_cod_versao_modelo,
            (select coalesce(max(cmv.cod_versao_user_friendly) + 1, 1)
             from checklist_modelo_versao cmv
             where cmv.cod_checklist_modelo = f_cod_modelo),
            f_cod_modelo,
            f_data_hora_atual,
            null);

    get diagnostics qtd_linhas_inseridas = row_count;

    if qtd_linhas_inseridas is null or qtd_linhas_inseridas <> 1
    then
        raise exception 'Erro ao inserir versão do modelo';
    end if;
    --

    -- 2 -> Atualiza modelo para setar versão atual.
    update checklist_modelo_data
    set cod_versao_atual = novo_cod_versao_modelo
    where codigo = f_cod_modelo
      and cod_versao_atual is null;

    get diagnostics qtd_linhas_atualizadas = row_count;

    if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas <> 1
    then
        raise exception 'Erro ao setar versão na tabela checklist_modelo_data, %, %, %',
            f_cod_modelo,
            novo_cod_versao_modelo,
            (select cod_versao_atual from checklist_modelo_data where codigo = f_cod_modelo);
    end if;


    update checklist_perguntas_data
    set cod_versao_checklist_modelo = novo_cod_versao_modelo
    where cod_checklist_modelo = f_cod_modelo
      and cod_versao_checklist_modelo is null;

    get diagnostics qtd_linhas_atualizadas = row_count;

    if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas < 1
    then
        raise exception 'Erro ao setar versão na tabela checklist_perguntas_data';
    end if;


    update checklist_alternativa_pergunta_data
    set cod_versao_checklist_modelo = novo_cod_versao_modelo
    where cod_checklist_modelo = f_cod_modelo
      and cod_versao_checklist_modelo is null;

    get diagnostics qtd_linhas_atualizadas = row_count;

    if qtd_linhas_atualizadas is null or qtd_linhas_atualizadas < 1
    then
        raise exception 'Erro ao setar versão na tabela checklist_alternativa_pergunta_data';
    end if;
    --

    return novo_cod_versao_modelo;
end
$$;

create or replace function public.func_checklist_encontra_versao_modelo(f_cod_modelo_checklist bigint, f_perguntas_alternativas jsonb) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_VERSAO_MODELO_CHECKLIST_PROCURADO BIGINT;
    F_ALTERNATIVA                         BIGINT;
BEGIN
    -- CRIA UM JSONB DAS ALTERNATIVAS EXTRAÍDAS DO JSON DO MODELO.
    WITH CHECKLIST AS (
        SELECT JSONB_ARRAY_ELEMENTS_TEXT(F_PERGUNTAS_ALTERNATIVAS)::JSONB -> 'codAlternativas' AS COD_ALTERNATIVAS
    ),
         DADOS_MODELO_WS AS (
             SELECT F_COD_MODELO_CHECKLIST                           AS COD_MODELO_CHECKLIST,
                    JSONB_ARRAY_ELEMENTS(CHECKLIST.COD_ALTERNATIVAS) AS COD_ALTERNATIVA
             FROM CHECKLIST
             ORDER BY 2
         )
    SELECT COD_ALTERNATIVA
    FROM DADOS_MODELO_WS WS
    INTO F_ALTERNATIVA;

    -- IDENTIFICA A VERSÃO DO MODELO ATRAVÉS DO CÓDIGO DE ALTERNATIVA E CÓDIGO DO MODELO.
    SELECT COD_VERSAO_CHECKLIST_MODELO
    FROM CHECKLIST_ALTERNATIVA_PERGUNTA_DATA
    WHERE CODIGO = F_ALTERNATIVA
      AND COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
    INTO COD_VERSAO_MODELO_CHECKLIST_PROCURADO;

    IF COD_VERSAO_MODELO_CHECKLIST_PROCURADO IS NOT NULL AND COD_VERSAO_MODELO_CHECKLIST_PROCURADO > 0
    THEN
        -- ENCONTRAMOS A VERSÃO DO MODELO NA BUSCA.
        RETURN COD_VERSAO_MODELO_CHECKLIST_PROCURADO;
    ELSE
        RAISE EXCEPTION 'Não foi possível encontrar a versão do modelo de checklist';
    END IF;
END;
$$;

create or replace function public.func_checklist_insert_checklist_infos(f_cod_unidade_checklist bigint,
                                                                        f_cod_modelo_checklist bigint,
                                                                        f_cod_versao_modelo_checklist bigint,
                                                                        f_data_hora_realizacao timestamp with time zone,
                                                                        f_cod_colaborador bigint, f_cod_veiculo bigint,
                                                                        f_placa_veiculo text,
                                                                        f_tipo_checklist character,
                                                                        f_km_coletado bigint, f_tempo_realizacao bigint,
                                                                        f_data_hora_sincronizacao timestamp with time zone,
                                                                        f_fonte_data_hora_realizacao text,
                                                                        f_versao_app_momento_realizacao integer,
                                                                        f_versao_app_momento_sincronizacao integer,
                                                                        f_device_id text, f_device_imei text,
                                                                        f_device_uptime_realizacao_millis bigint,
                                                                        f_device_uptime_sincronizacao_millis bigint,
                                                                        f_foi_offline boolean,
                                                                        f_total_perguntas_ok integer,
                                                                        f_total_perguntas_nok integer,
                                                                        f_total_alternativas_ok integer,
                                                                        f_total_alternativas_nok integer) returns bigint
    language plpgsql
as
$$
DECLARE
    -- Iremos atualizar o KM do Veículo somente para o caso em que o KM atual do veículo for menor que o KM coletado.
    DEVE_ATUALIZAR_KM_VEICULO BOOLEAN := (CASE
                                              WHEN (F_KM_COLETADO > (SELECT V.KM
                                                                     FROM VEICULO V
                                                                     WHERE V.CODIGO = F_COD_VEICULO))
                                                  THEN
                                                  TRUE
                                              ELSE FALSE END);
    COD_CHECKLIST_INSERIDO    BIGINT;
    QTD_LINHAS_ATUALIZADAS    BIGINT;
BEGIN

    INSERT INTO CHECKLIST(COD_UNIDADE,
                          COD_CHECKLIST_MODELO,
                          COD_VERSAO_CHECKLIST_MODELO,
                          DATA_HORA,
                          DATA_HORA_REALIZACAO_TZ_APLICADO,
                          CPF_COLABORADOR,
                          PLACA_VEICULO,
                          TIPO,
                          TEMPO_REALIZACAO,
                          KM_VEICULO,
                          DATA_HORA_SINCRONIZACAO,
                          FONTE_DATA_HORA_REALIZACAO,
                          VERSAO_APP_MOMENTO_REALIZACAO,
                          VERSAO_APP_MOMENTO_SINCRONIZACAO,
                          DEVICE_ID,
                          DEVICE_IMEI,
                          DEVICE_UPTIME_REALIZACAO_MILLIS,
                          DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
                          FOI_OFFLINE,
                          TOTAL_PERGUNTAS_OK,
                          TOTAL_PERGUNTAS_NOK,
                          TOTAL_ALTERNATIVAS_OK,
                          TOTAL_ALTERNATIVAS_NOK)
    VALUES (F_COD_UNIDADE_CHECKLIST,
            F_COD_MODELO_CHECKLIST,
            F_COD_VERSAO_MODELO_CHECKLIST,
            F_DATA_HORA_REALIZACAO,
            (F_DATA_HORA_REALIZACAO AT TIME ZONE TZ_UNIDADE(F_COD_UNIDADE_CHECKLIST)),
            (SELECT C.CPF FROM COLABORADOR C WHERE C.CODIGO = F_COD_COLABORADOR),
            F_PLACA_VEICULO,
            F_TIPO_CHECKLIST,
            F_TEMPO_REALIZACAO,
            F_KM_COLETADO,
            F_DATA_HORA_SINCRONIZACAO,
            F_FONTE_DATA_HORA_REALIZACAO,
            F_VERSAO_APP_MOMENTO_REALIZACAO,
            F_VERSAO_APP_MOMENTO_SINCRONIZACAO,
            F_DEVICE_ID,
            F_DEVICE_IMEI,
            F_DEVICE_UPTIME_REALIZACAO_MILLIS,
            F_DEVICE_UPTIME_SINCRONIZACAO_MILLIS,
            F_FOI_OFFLINE,
            F_TOTAL_PERGUNTAS_OK,
            F_TOTAL_PERGUNTAS_NOK,
            F_TOTAL_ALTERNATIVAS_OK,
            F_TOTAL_ALTERNATIVAS_NOK) RETURNING CODIGO INTO COD_CHECKLIST_INSERIDO;

    -- Verificamos se o insert funcionou.
    IF COD_CHECKLIST_INSERIDO <= 0
    THEN
        RAISE EXCEPTION 'Não foi possível inserir o checklist';
    END IF;

    IF DEVE_ATUALIZAR_KM_VEICULO
    THEN
        UPDATE VEICULO SET KM = F_KM_COLETADO WHERE CODIGO = F_COD_VEICULO;
    END IF;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    -- Se devemos atualizar o KM mas nenhuma linha foi alterada, então temos um erro.
    IF (DEVE_ATUALIZAR_KM_VEICULO AND QTD_LINHAS_ATUALIZADAS <= 0)
    THEN
        RAISE EXCEPTION 'Não foi possível atualizar o km do veículo';
    END IF;

    RETURN COD_CHECKLIST_INSERIDO;
END;
$$;

create or replace function public.func_checklist_insert_respostas_checklist(f_cod_unidade_checklist bigint,
                                                                            f_cod_modelo_checklist bigint,
                                                                            f_cod_versao_modelo_checklist bigint,
                                                                            f_cod_checklist bigint,
                                                                            f_cod_pergunta bigint,
                                                                            f_cod_alternativa bigint,
                                                                            f_resposta_outros text) returns bigint
    language plpgsql
as
$$
DECLARE
    QTD_LINHAS_INSERIDAS BIGINT;
BEGIN
    INSERT INTO CHECKLIST_RESPOSTAS_NOK(COD_UNIDADE,
                                        COD_CHECKLIST_MODELO,
                                        COD_VERSAO_CHECKLIST_MODELO,
                                        COD_CHECKLIST,
                                        COD_PERGUNTA,
                                        COD_ALTERNATIVA,
                                        RESPOSTA_OUTROS)
    VALUES (F_COD_UNIDADE_CHECKLIST,
            F_COD_MODELO_CHECKLIST,
            F_COD_VERSAO_MODELO_CHECKLIST,
            F_COD_CHECKLIST,
            F_COD_PERGUNTA,
            F_COD_ALTERNATIVA,
            F_RESPOSTA_OUTROS);

    GET DIAGNOSTICS QTD_LINHAS_INSERIDAS = ROW_COUNT;

    IF QTD_LINHAS_INSERIDAS <> 1
    THEN
        RAISE EXCEPTION 'Não foi possível inserir a(s) resposta(s)';
    END IF;

    RETURN QTD_LINHAS_INSERIDAS;
END;
$$;

create or replace function public.func_checklist_get_modelos_selecao_realizacao(f_cod_unidade bigint, f_cod_cargo bigint)
    returns TABLE
            (
                cod_modelo              bigint,
                cod_versao_atual_modelo bigint,
                cod_unidade_modelo      bigint,
                nome_modelo             text,
                cod_veiculo             bigint,
                placa_veiculo           text,
                km_atual_veiculo        bigint
            )
    language sql
as
$$
SELECT CM.CODIGO           AS COD_MODELO,
       CM.COD_VERSAO_ATUAL AS COD_VERSAO_ATUAL_MODELO,
       CM.COD_UNIDADE      AS COD_UNIDADE_MODELO,
       CM.NOME :: TEXT     AS NOME_MODELO,
       V.CODIGO            AS COD_VEICULO,
       V.PLACA :: TEXT     AS PLACA_VEICULO,
       V.KM                AS KM_ATUAL_VEICULO
FROM CHECKLIST_MODELO CM
         JOIN CHECKLIST_MODELO_FUNCAO CMF
              ON CMF.COD_CHECKLIST_MODELO = CM.CODIGO AND CM.COD_UNIDADE = CMF.COD_UNIDADE
         JOIN CHECKLIST_MODELO_VEICULO_TIPO CMVT
              ON CMVT.COD_MODELO = CM.CODIGO AND CMVT.COD_UNIDADE = CM.COD_UNIDADE
         JOIN VEICULO_TIPO VT
              ON VT.CODIGO = CMVT.COD_TIPO_VEICULO
         JOIN VEICULO V
              ON V.COD_TIPO = VT.CODIGO AND V.COD_UNIDADE = CM.COD_UNIDADE
WHERE CM.COD_UNIDADE = F_COD_UNIDADE
  AND CMF.COD_FUNCAO = F_COD_CARGO
  AND CM.STATUS_ATIVO = TRUE
  AND V.STATUS_ATIVO = TRUE
ORDER BY CM.CODIGO, V.PLACA
$$;

create or replace function public.func_checklist_get_modelo_realizacao(f_cod_modelo_checklist bigint, f_cod_veiculo_realizacao bigint)
    returns TABLE
            (
                cod_unidade_modelo_checklist bigint,
                cod_modelo_checklist         bigint,
                cod_versao_modelo_checklist  bigint,
                nome_modelo_checklist        text,
                cod_pergunta                 bigint,
                descricao_pergunta           text,
                cod_imagem                   bigint,
                url_imagem                   text,
                pergunta_ordem_exibicao      integer,
                single_choice                boolean,
                cod_alternativa              bigint,
                descricao_alternativa        text,
                tipo_outros                  boolean,
                alternativa_ordem_exibicao   integer,
                prioridade_alternativa       text,
                km_atual_veiculo_realizacao  bigint
            )
    language plpgsql
as
$$
DECLARE
    KM_ATUAL_VEICULO CONSTANT BIGINT := (SELECT V.KM
                                         FROM VEICULO V
                                         WHERE V.CODIGO = F_COD_VEICULO_REALIZACAO);
BEGIN
    IF KM_ATUAL_VEICULO IS NULL
    THEN
        RAISE EXCEPTION 'Erro ao buscar KM atual do veículo para realização do checklist!';
    END IF;

    RETURN QUERY
        SELECT CM.COD_UNIDADE              AS COD_UNIDADE_MODELO_CHECKLIST,
               CM.CODIGO                   AS COD_MODELO_CHECKLIST,
               CM.COD_VERSAO_ATUAL         AS COD_VERSAO_MODELO_CHECKLIST,
               CM.NOME :: TEXT             AS NOME_MODELO_CHECKLIST,
               CP.CODIGO                   AS COD_PERGUNTA,
               CP.PERGUNTA                 AS DESCRICAO_PERGUNTA,
               CP.COD_IMAGEM               AS COD_IMAGEM,
               CGI.URL_IMAGEM              AS URL_IMAGEM,
               CP.ORDEM                    AS PERGUNTA_ORDEM_EXIBICAO,
               CP.SINGLE_CHOICE            AS SINGLE_CHOICE,
               CAP.CODIGO                  AS COD_ALTERNATIVA,
               CAP.ALTERNATIVA             AS DESCRICAO_ALTERNATIVA,
               CAP.ALTERNATIVA_TIPO_OUTROS AS TIPO_OUTROS,
               CAP.ORDEM                   AS ALTERNATIVA_ORDEM_EXIBICAO,
               CAP.PRIORIDADE :: TEXT      AS PRIORIDADE_ALTERNATIVA,
               KM_ATUAL_VEICULO            AS KM_ATUAL_VEICULO_REALIZACAO
        FROM CHECKLIST_MODELO CM
                 JOIN CHECKLIST_PERGUNTAS CP
                      ON CM.CODIGO = CP.COD_CHECKLIST_MODELO AND
                         CM.COD_VERSAO_ATUAL = CP.COD_VERSAO_CHECKLIST_MODELO
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                      ON CP.CODIGO = CAP.COD_PERGUNTA AND CM.COD_VERSAO_ATUAL = CAP.COD_VERSAO_CHECKLIST_MODELO
            -- Precisamos que seja LEFT JOIN para o caso de perguntas sem imagem associada.
                 LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                           ON CP.COD_IMAGEM = CGI.COD_IMAGEM
        WHERE CM.CODIGO = F_COD_MODELO_CHECKLIST
          AND CM.STATUS_ATIVO
        ORDER BY COD_MODELO_CHECKLIST,
                 PERGUNTA_ORDEM_EXIBICAO,
                 COD_PERGUNTA,
                 ALTERNATIVA_ORDEM_EXIBICAO,
                 COD_ALTERNATIVA;
END ;
$$;

create or replace function public.func_checklist_get_by_codigo(f_cod_checklist bigint)
    returns TABLE
            (
                cod_checklist                 bigint,
                cod_checklist_modelo          bigint,
                cod_versao_checklist_modelo   bigint,
                data_hora_realizacao          timestamp without time zone,
                data_hora_importado_prolog    timestamp without time zone,
                km_veiculo_momento_realizacao bigint,
                duracao_realizacao_millis     bigint,
                cpf_colaborador               bigint,
                placa_veiculo                 text,
                tipo_checklist                character,
                nome_colaborador              text,
                cod_pergunta                  bigint,
                ordem_pergunta                integer,
                descricao_pergunta            text,
                pergunta_single_choice        boolean,
                cod_alternativa               bigint,
                prioridade_alternativa        text,
                ordem_alternativa             integer,
                descricao_alternativa         text,
                alternativa_tipo_outros       boolean,
                cod_imagem                    bigint,
                url_imagem                    text,
                alternativa_selecionada       boolean,
                resposta_outros               text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT C.CODIGO                                                            AS COD_CHECKLIST,
               C.COD_CHECKLIST_MODELO                                              AS COD_CHECKLIST_MODELO,
               C.COD_VERSAO_CHECKLIST_MODELO                                       AS COD_CHECKLIST_MODELO,
               C.DATA_HORA_REALIZACAO_TZ_APLICADO                                  AS DATA_HORA_REALIZACAO,
               C.DATA_HORA_IMPORTADO_PROLOG AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE) AS DATA_HORA_IMPORTADO_PROLOG,
               C.KM_VEICULO                                                        AS KM_VEICULO_MOMENTO_REALIZACAO,
               C.TEMPO_REALIZACAO                                                  AS DURACAO_REALIZACAO_MILLIS,
               C.CPF_COLABORADOR                                                   AS CPF_COLABORADOR,
               C.PLACA_VEICULO :: TEXT                                             AS PLACA_VEICULO,
               C.TIPO                                                              AS TIPO_CHECKLIST,
               CO.NOME :: TEXT                                                     AS NOME_COLABORADOR,
               CP.CODIGO                                                           AS COD_PERGUNTA,
               CP.ORDEM                                                            AS ORDEM_PERGUNTA,
               CP.PERGUNTA                                                         AS DESCRICAO_PERGUNTA,
               CP.SINGLE_CHOICE                                                    AS PERGUNTA_SINGLE_CHOICE,
               CAP.CODIGO                                                          AS COD_ALTERNATIVA,
               CAP.PRIORIDADE :: TEXT                                              AS PRIORIDADE_ALTERNATIVA,
               CAP.ORDEM                                                           AS ORDEM_ALTERNATIVA,
               CAP.ALTERNATIVA                                                     AS DESCRICAO_ALTERNATIVA,
               CAP.ALTERNATIVA_TIPO_OUTROS                                         AS ALTERNATIVA_TIPO_OUTROS,
               CGI.COD_IMAGEM                                                      AS COD_IMAGEM,
               CGI.URL_IMAGEM                                                      AS URL_IMAGEM,
               CRN.CODIGO IS NOT NULL                                              AS ALTERNATIVA_SELECIONADA,
               CRN.RESPOSTA_OUTROS                                                 AS RESPOSTA_OUTROS
        FROM CHECKLIST C
                 JOIN COLABORADOR CO
                      ON CO.CPF = C.CPF_COLABORADOR
                 JOIN CHECKLIST_PERGUNTAS CP
                      ON CP.COD_VERSAO_CHECKLIST_MODELO = C.COD_VERSAO_CHECKLIST_MODELO
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                      ON CAP.COD_PERGUNTA = CP.CODIGO
                 LEFT JOIN CHECKLIST_RESPOSTAS_NOK CRN
                           ON C.CODIGO = CRN.COD_CHECKLIST
                               AND CAP.CODIGO = CRN.COD_ALTERNATIVA
                 LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                           ON CP.COD_IMAGEM = CGI.COD_IMAGEM
        WHERE C.CODIGO = F_COD_CHECKLIST
        ORDER BY CP.CODIGO, CAP.CODIGO;
END ;
$$;

create or replace function public.func_checklist_os_alternativas_abertura_os(f_cod_modelo_checklist bigint,
                                                                             f_cod_versao_modelo_checklist bigint,
                                                                             f_placa_veiculo text)
    returns TABLE
            (
                cod_alternativa                    bigint,
                cod_contexto_pergunta              bigint,
                cod_contexto_alternativa           bigint,
                cod_item_ordem_servico             bigint,
                resposta_tipo_outros_abertura_item text,
                tem_item_os_pendente               boolean,
                deve_abrir_ordem_servico           boolean,
                alternativa_tipo_outros            boolean,
                qtd_apontamentos_item              integer,
                prioridade_alternativa             text
            )
    language plpgsql
as
$$
DECLARE
    STATUS_ITEM_PENDENTE TEXT = 'P';
BEGIN
    RETURN QUERY
        WITH ITENS_PENDENTES AS (
            SELECT COSI.CODIGO                               AS COD_ITEM_ORDEM_SERVICO,
                   COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO AS COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                   COSI.COD_CONTEXTO_ALTERNATIVA             AS COD_CONTEXTO_ALTERNATIVA,
                   COSI.QT_APONTAMENTOS                      AS QTD_APONTAMENTOS_ITEM,
                   COS.COD_CHECKLIST                         AS COD_CHECKLIST,
                   C.COD_CHECKLIST_MODELO                    AS COD_CHECKLIST_MODELO
            FROM CHECKLIST C
                     JOIN CHECKLIST_ORDEM_SERVICO COS
                          ON C.CODIGO = COS.COD_CHECKLIST
                     JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          ON COS.CODIGO = COSI.COD_OS
                              AND COS.COD_UNIDADE = COSI.COD_UNIDADE
            WHERE C.PLACA_VEICULO = F_PLACA_VEICULO
              AND C.COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST
              AND COSI.STATUS_RESOLUCAO = STATUS_ITEM_PENDENTE
        )
        SELECT CAP.CODIGO                                          AS COD_ALTERNATIVA,
               CP.CODIGO_CONTEXTO                                  AS COD_CONTEXTO_PERGUNTA,
               CAP.CODIGO_CONTEXTO                                 AS COD_CONTEXTO_ALTERNATIVA,
               IP.COD_ITEM_ORDEM_SERVICO                           AS COD_ITEM_ORDEM_SERVICO,
               CRN.RESPOSTA_OUTROS                                 AS RESPOSTA_TIPO_OUTROS_ABERTURA_ITEM,
               F_IF(IP.COD_ITEM_ORDEM_SERVICO ISNULL, FALSE, TRUE) AS TEM_ITEM_OS_PENDENTE,
               CAP.DEVE_ABRIR_ORDEM_SERVICO                        AS DEVE_ABRIR_ORDEM_SERVICO,
               CAP.ALTERNATIVA_TIPO_OUTROS                         AS ALTERNATIVA_TIPO_OUTROS,
               IP.QTD_APONTAMENTOS_ITEM                            AS QTD_APONTAMENTOS_ITEM,
               CAP.PRIORIDADE::TEXT                                AS PRIORIDADE_ALTERNATIVA
        FROM CHECKLIST_ALTERNATIVA_PERGUNTA_DATA CAP
                 JOIN CHECKLIST_PERGUNTAS_DATA CP
                      ON CAP.COD_PERGUNTA = CP.CODIGO
                 LEFT JOIN ITENS_PENDENTES IP
                           ON IP.COD_CONTEXTO_ALTERNATIVA = CAP.CODIGO_CONTEXTO
                 LEFT JOIN CHECKLIST_RESPOSTAS_NOK CRN
                           ON CRN.COD_ALTERNATIVA = IP.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                               AND CRN.COD_CHECKLIST = IP.COD_CHECKLIST
        WHERE CAP.COD_VERSAO_CHECKLIST_MODELO = F_COD_VERSAO_MODELO_CHECKLIST;
END ;
$$;

create or replace function public.func_checklist_insert_modelo_checklist_infos(f_cod_unidade_modelo bigint,
                                                                               f_nome_modelo text,
                                                                               f_status_ativo boolean,
                                                                               f_cod_cargos bigint[],
                                                                               f_cod_tipos_veiculos bigint[],
                                                                               f_data_hora_atual timestamp with time zone,
                                                                               f_token_colaborador text)
    returns TABLE
            (
                cod_modelo_checklist        bigint,
                cod_versao_modelo_checklist bigint
            )
    language plpgsql
as
$$
DECLARE
    ERROR_MESSAGE          TEXT   := 'Erro ao salvar modelo de checklist, tente novamente';
    QTD_LINHAS_INSERIDAS   BIGINT;
    COD_MODELO_INSERIDO    BIGINT;
    NOVO_COD_VERSAO_MODELO BIGINT := NEXTVAL(
            PG_GET_SERIAL_SEQUENCE('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
BEGIN
    -- Assim conseguimos inserir mantendo a referência circular entre modelo e versão.
    SET CONSTRAINTS ALL DEFERRED;

    -- 1 -> Insere o modelo.
    INSERT INTO CHECKLIST_MODELO(COD_UNIDADE,
                                 COD_VERSAO_ATUAL,
                                 NOME,
                                 STATUS_ATIVO)
    VALUES (F_COD_UNIDADE_MODELO,
            NOVO_COD_VERSAO_MODELO,
            F_NOME_MODELO,
            F_STATUS_ATIVO) RETURNING CODIGO INTO COD_MODELO_INSERIDO;


    IF COD_MODELO_INSERIDO IS NULL OR COD_MODELO_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;
    --

    -- 2 -> Insere a versão.
    INSERT INTO CHECKLIST_MODELO_VERSAO(COD_VERSAO_CHECKLIST_MODELO,
                                        COD_VERSAO_USER_FRIENDLY,
                                        COD_CHECKLIST_MODELO,
                                        DATA_HORA_CRIACAO_VERSAO,
                                        COD_COLABORADOR_CRIACAO_VERSAO)
    VALUES (NOVO_COD_VERSAO_MODELO,
            1,
            COD_MODELO_INSERIDO,
            F_DATA_HORA_ATUAL,
            (SELECT TA.COD_COLABORADOR FROM TOKEN_AUTENTICACAO TA WHERE TA.TOKEN = F_TOKEN_COLABORADOR));

    GET DIAGNOSTICS QTD_LINHAS_INSERIDAS = ROW_COUNT;

    IF QTD_LINHAS_INSERIDAS IS NULL OR QTD_LINHAS_INSERIDAS <> 1
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;
    --

    -- 3 -> Insere os tipos de veículos.
    INSERT INTO CHECKLIST_MODELO_VEICULO_TIPO(COD_UNIDADE, COD_MODELO, COD_TIPO_VEICULO)
    VALUES (F_COD_UNIDADE_MODELO, COD_MODELO_INSERIDO, UNNEST(F_COD_TIPOS_VEICULOS));
    --

    -- 4 -> Insere os cargos.
    INSERT INTO CHECKLIST_MODELO_FUNCAO(COD_UNIDADE, COD_CHECKLIST_MODELO, COD_FUNCAO)
    VALUES (F_COD_UNIDADE_MODELO, COD_MODELO_INSERIDO, UNNEST(F_COD_CARGOS));
    --

    RETURN QUERY
        SELECT COD_MODELO_INSERIDO              AS COD_MODELO_CHECKLIST,
               NOVO_COD_VERSAO_MODELO :: BIGINT AS COD_VERSAO_MODELO_CHECKLIST;
END;
$$;

create or replace function public.func_checklist_insert_nova_versao_modelo(f_cod_unidade_modelo bigint,
                                                                           f_cod_modelo bigint, f_nome_modelo text,
                                                                           f_status_ativo boolean,
                                                                           f_data_hora_atual timestamp with time zone,
                                                                           f_token_colaborador text)
    returns TABLE
            (
                cod_modelo_checklist        bigint,
                cod_versao_modelo_checklist bigint
            )
    language plpgsql
as
$$
DECLARE
    ERROR_MESSAGE          TEXT   := 'Erro ao atualizar modelo de checklist, tente novamente';
    QTD_LINHAS_ATUALIZADAS BIGINT;
    NOVO_COD_VERSAO_MODELO BIGINT := NEXTVAL(
            PG_GET_SERIAL_SEQUENCE('checklist_modelo_versao', 'cod_versao_checklist_modelo'));
BEGIN
    -- 1 -> Primeiro criamos uma nova versão.
    INSERT INTO CHECKLIST_MODELO_VERSAO(COD_VERSAO_CHECKLIST_MODELO,
                                        COD_VERSAO_USER_FRIENDLY,
                                        COD_CHECKLIST_MODELO,
                                        DATA_HORA_CRIACAO_VERSAO,
                                        COD_COLABORADOR_CRIACAO_VERSAO)
    VALUES (NOVO_COD_VERSAO_MODELO,
            (SELECT MAX(COD_VERSAO_USER_FRIENDLY) + 1
             FROM CHECKLIST_MODELO_VERSAO CMV
             WHERE CMV.COD_CHECKLIST_MODELO = F_COD_MODELO),
            F_COD_MODELO,
            F_DATA_HORA_ATUAL,
            (SELECT TA.COD_COLABORADOR
             FROM TOKEN_AUTENTICACAO TA
             WHERE TA.TOKEN = F_TOKEN_COLABORADOR));

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF QTD_LINHAS_ATUALIZADAS IS NULL
        OR QTD_LINHAS_ATUALIZADAS <> 1
        OR NOVO_COD_VERSAO_MODELO IS NULL
        OR NOVO_COD_VERSAO_MODELO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;

    -- 2 -> Agora atualizamos o modelo de checklist.
    UPDATE CHECKLIST_MODELO
    SET NOME             = F_NOME_MODELO,
        STATUS_ATIVO     = F_STATUS_ATIVO,
        COD_VERSAO_ATUAL = NOVO_COD_VERSAO_MODELO
    WHERE CODIGO = F_COD_MODELO
      AND COD_UNIDADE = F_COD_UNIDADE_MODELO;

    GET DIAGNOSTICS QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

    IF QTD_LINHAS_ATUALIZADAS IS NULL OR QTD_LINHAS_ATUALIZADAS <> 1
    THEN
        PERFORM THROW_GENERIC_ERROR(ERROR_MESSAGE);
    END IF;

    RETURN QUERY
        SELECT F_COD_MODELO           AS COD_MODELO_CHECKLIST,
               NOVO_COD_VERSAO_MODELO AS COD_VERSAO_MODELO_CHECKLIST;
END;
$$;

create or replace function public.func_checklist_update_modelo_checklist_infos(f_cod_unidade bigint,
                                                                               f_cod_modelo bigint, f_nome_modelo text,
                                                                               f_cod_cargos bigint[],
                                                                               f_cod_tipos_veiculos bigint[]) returns void
    language plpgsql
as
$$
DECLARE
    QTD_TIPOS_VEICULO_PARA_DELETAR BIGINT := (SELECT COUNT(*)
                                              FROM CHECKLIST_MODELO_VEICULO_TIPO
                                              WHERE COD_UNIDADE = F_COD_UNIDADE
                                                AND COD_MODELO = F_COD_MODELO);
    QTD_CARGOS_PARA_DELETAR        BIGINT := (SELECT COUNT(*)
                                              FROM CHECKLIST_MODELO_FUNCAO
                                              WHERE COD_UNIDADE = F_COD_UNIDADE
                                                AND COD_CHECKLIST_MODELO = F_COD_MODELO);
    QTD_LINHAS_IMPACTADAS          BIGINT;
BEGIN
    -- 1 -> Atualiza o modelo.
    UPDATE CHECKLIST_MODELO
    SET NOME = F_NOME_MODELO
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND CODIGO = F_COD_MODELO;

    GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

    IF QTD_LINHAS_IMPACTADAS IS NULL OR QTD_LINHAS_IMPACTADAS <> 1
    THEN
        RAISE EXCEPTION 'Erro ao atualizar o nome do modelo de checklist';
    END IF;
    --

    -- 2 -> Atualiza os tipos de veículos.
    DELETE FROM CHECKLIST_MODELO_VEICULO_TIPO WHERE COD_UNIDADE = F_COD_UNIDADE AND COD_MODELO = F_COD_MODELO;

    GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

    IF QTD_TIPOS_VEICULO_PARA_DELETAR = QTD_LINHAS_IMPACTADAS
    THEN
        INSERT INTO CHECKLIST_MODELO_VEICULO_TIPO(COD_UNIDADE, COD_MODELO, COD_TIPO_VEICULO)
        VALUES (F_COD_UNIDADE, F_COD_MODELO, UNNEST(F_COD_TIPOS_VEICULOS));

        GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

        IF QTD_LINHAS_IMPACTADAS IS NULL OR QTD_LINHAS_IMPACTADAS <> ARRAY_LENGTH(F_COD_TIPOS_VEICULOS, 1)
        THEN
            RAISE EXCEPTION 'Erro ao inserir tipos de veículo liberados no modelo de checklist %', F_COD_MODELO;
        END IF;
    ELSE
        RAISE EXCEPTION 'Não foi possível limpar as entradas da tabela CHECKLIST_MODELO_VEICULO_TIPO';
    END IF;
    --

    -- 3 -> Atualiza os cargos.
    DELETE FROM CHECKLIST_MODELO_FUNCAO WHERE COD_UNIDADE = F_COD_UNIDADE AND COD_CHECKLIST_MODELO = F_COD_MODELO;

    GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

    IF QTD_CARGOS_PARA_DELETAR = QTD_LINHAS_IMPACTADAS
    THEN
        INSERT INTO CHECKLIST_MODELO_FUNCAO(COD_UNIDADE, COD_CHECKLIST_MODELO, COD_FUNCAO)
        VALUES (F_COD_UNIDADE, F_COD_MODELO, UNNEST(F_COD_CARGOS));

        GET DIAGNOSTICS QTD_LINHAS_IMPACTADAS = ROW_COUNT;

        IF QTD_LINHAS_IMPACTADAS IS NULL OR QTD_LINHAS_IMPACTADAS <> ARRAY_LENGTH(F_COD_CARGOS, 1)
        THEN
            RAISE EXCEPTION 'Erro ao inserir cargos liberados no modelo de checklist %', F_COD_MODELO;
        END IF;
    ELSE
        RAISE EXCEPTION 'Não foi possível limpar as entradas da tabela CHECKLIST_MODELO_FUNCAO';
    END IF;
    --
END;
$$;

create or replace function public.func_checklist_analisa_mudancas_modelo(f_cod_modelo bigint,
                                                                         f_cod_versao_modelo bigint, f_nome_modelo text,
                                                                         f_cod_cargos bigint[],
                                                                         f_cod_tipos_veiculos bigint[],
                                                                         f_perguntas_alternativas_json jsonb)
    returns TABLE
            (
                codigo_item                   bigint,
                item_novo                     boolean,
                item_mudou_contexto           boolean,
                item_tipo_pergunta            boolean,
                algo_mudou_no_modelo          boolean,
                algo_mudou_no_contexto        boolean,
                deve_criar_nova_versao_modelo boolean
            )
    language plpgsql
as
$$
declare
    algo_mudou_no_modelo          boolean := false;
    algo_mudou_no_contexto        boolean := false;
    deve_criar_nova_versao_modelo boolean := false;
begin
    -- Verifica se o nome do modelo sofreu alteração, cria nova versão sem alterar contexto.
    if (select exists(
                       select soundex(f_nome_modelo)
                           except
                       select soundex(nome)
                       from checklist_modelo
                       where cod_versao_atual = f_cod_versao_modelo
                   ))
    then
        algo_mudou_no_modelo := true;
        deve_criar_nova_versao_modelo := true;
    end if;

    -- 1 -> Cria tabelas temporárias para nos ajudarem a trabalhar com os dados.
    create temp table if not exists perguntas
    (
        _id                     bigserial not null,
        codigo                  bigint,
        cod_imagem              bigint,
        descricao               text      not null,
        single_choice           boolean   not null,
        ordem_exibicao          integer   not null,
        pergunta_nova           boolean   not null,
        pergunta_mudou          boolean,
        pergunta_mudou_contexto boolean
    ) on commit delete rows;

    create temp table if not exists alternativas
    (
        _id                        bigserial not null,
        codigo                     bigint,
        descricao                  text      not null,
        prioridade                 text      not null,
        tipo_outros                boolean   not null,
        ordem_exibicao             integer   not null,
        deve_abrir_ordem_servico   boolean   not null,
        alternativa_nova           boolean   not null,
        alternativa_mudou          boolean,
        alternativa_mudou_contexto boolean
    ) on commit delete rows;
    --

    -- 2 -> Insere as perguntas.
    with cte as (
        select jsonb_array_elements(f_perguntas_alternativas_json) src
    )
    insert
    into perguntas (codigo, cod_imagem, descricao, single_choice, ordem_exibicao, pergunta_nova)
    select (src ->> 'codigo') :: bigint,
           (src ->> 'codImagem') :: bigint,
           (src ->> 'descricao'),
           (src ->> 'singleChoice') :: boolean,
           (src ->> 'ordemExibicao') :: integer,
           -- Se for uma pergunta sendo cadastrada, então ainda não tem código.
           (src ->> 'codigo') is null
    from cte;
    --


    -- 3 -> Insere as alternativas.
    with cte as (
        select jsonb_array_elements(jsonb_array_elements(f_perguntas_alternativas_json) -> 'alternativas') src
    )
    insert
    into alternativas (codigo, descricao, prioridade, tipo_outros, ordem_exibicao, deve_abrir_ordem_servico,
                       alternativa_nova)
    select (src ->> 'codigo') :: bigint,
           (src ->> 'descricao'),
           (src ->> 'prioridade'),
           (src ->> 'tipoOutros') :: boolean,
           (src ->> 'ordemExibicao') :: integer,
           (src ->> 'deveAbrirOrdemServico') :: boolean,
           -- Se for uma alternativa sendo cadastrada, então ainda não tem código.
           (src ->> 'codigo') is null
    from cte;
    --

    -- 4.1 -> Verifica se alguma pergunta foi deletada.
    if (select exists(select cp.codigo
                      from checklist_perguntas cp
                      where cp.cod_checklist_modelo = f_cod_modelo
                        and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
                          except
                      select codigo
                      from perguntas
                      where codigo is not null
                   ))
    then
        algo_mudou_no_contexto := true;
        algo_mudou_no_modelo := true;
        deve_criar_nova_versao_modelo := true;
    end if;

    -- 4.2 -> Verifica se alguma alternativa foi deletada.
    if (select exists(select cap.codigo
                      from checklist_alternativa_pergunta cap
                      where cap.cod_checklist_modelo = f_cod_modelo
                        and cap.cod_versao_checklist_modelo = f_cod_versao_modelo
                          except
                      select codigo
                      from alternativas
                      where codigo is not null
                   ))
    then
        algo_mudou_no_contexto := true;
        algo_mudou_no_modelo := true;
        deve_criar_nova_versao_modelo := true;
    end if;


    -- 4.3 -> Verifica se as perguntas mudaram com alteração de contexto.
    with perguntas_novas_ou_editadas as (
        select codigo,
               cod_imagem,
               -- Usamos o soundex para verificar se a descrição mudou e não o texto em si.
               soundex(descricao)
        from perguntas
            except
        select cp.codigo,
               cp.cod_imagem,
               soundex(cp.pergunta)
        from checklist_perguntas cp
        where cp.cod_checklist_modelo = f_cod_modelo
          and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
    )

    update perguntas p
    set pergunta_mudou_contexto = true
        -- CTE irá conter apenas as novas e/ou alteradas.
    from perguntas_novas_ou_editadas pne
         -- Só considera como alterada as perguntas que já existiam.
    where pne.codigo is not null
      and pne.codigo = p.codigo;

    if (select count(*) from perguntas where pergunta_mudou_contexto is true or pergunta_nova is true) > 0
    then
        algo_mudou_no_contexto := true;
        deve_criar_nova_versao_modelo := true;
    end if;
    --

    -- 4.4 -> Verifica se o tipo de escolha das perguntas mudou sem alteração de contexto.
    with perguntas_tipo_selecao_alterada as (
        select codigo,
               single_choice
        from perguntas
            except
        select cp.codigo,
               cp.single_choice
        from checklist_perguntas cp
        where cp.cod_checklist_modelo = f_cod_modelo
          and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
    )

    update perguntas p
    set pergunta_mudou = true
        -- CTE irá conter apenas as perguntas que mudaram o tipo de seleção.
    from perguntas_tipo_selecao_alterada pne
         -- Só considera como alterada as perguntas que já existiam.
    where pne.codigo is not null
      and pne.codigo = p.codigo;

    if (select count(*) from perguntas where pergunta_mudou is true) > 0 and deve_criar_nova_versao_modelo is false
    then
        algo_mudou_no_modelo := true;
        deve_criar_nova_versao_modelo := true;
    end if;
    --

    -- 4.5 -> Verifica se a ordem das perguntas mudou sem alteração de contexto.
    with perguntas_ordem_alterada as (
        select codigo,
               ordem_exibicao
        from perguntas
            except
        select cp.codigo,
               cp.ordem
        from checklist_perguntas cp
        where cp.cod_checklist_modelo = f_cod_modelo
          and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
    )

    update perguntas p
    set pergunta_mudou = true
        -- CTE irá conter apenas as perguntas que mudaram a ordem de exibição.
    from perguntas_ordem_alterada pne
         -- Só considera como alterada as perguntas que já existiam.
    where pne.codigo is not null
      and pne.codigo = p.codigo;

    if (select count(*) from perguntas where pergunta_mudou is true) > 0 and deve_criar_nova_versao_modelo is false
    then
        algo_mudou_no_modelo := true;
        deve_criar_nova_versao_modelo := true;
    end if;
    --

    -- 4.6 -> Verifica se as perguntas mudaram sem alteração de contexto.
    with perguntas_novas_ou_editadas as (
        select codigo,
               descricao
        from perguntas
            except
        select cp.codigo,
               cp.pergunta
        from checklist_perguntas cp
        where cp.cod_checklist_modelo = f_cod_modelo
          and cp.cod_versao_checklist_modelo = f_cod_versao_modelo
    )

    update perguntas p
    set pergunta_mudou = true
        -- CTE irá conter apenas as novas e/ou alteradas.
    from perguntas_novas_ou_editadas pne
         -- Só considera como alterada as perguntas que já existiam.
    where pne.codigo is not null
      and pne.codigo = p.codigo;

    if (select count(*) from perguntas where pergunta_mudou is true) > 0 AND deve_criar_nova_versao_modelo is false
    then
        algo_mudou_no_modelo := true;
    end if;
    --

    -- 5.1 -> Verifica se as alternativas mudaram com alteração de contexto.
    with alternativas_novas_ou_editadas as (
        select codigo,
               -- Usamos o soundex para verificar se a descrição mudou e não o texto em si.
               soundex(descricao),
               prioridade,
               tipo_outros,
               deve_abrir_ordem_servico
        from alternativas
            except
        select cap.codigo,
               soundex(cap.alternativa),
               cap.prioridade,
               cap.alternativa_tipo_outros,
               cap.deve_abrir_ordem_servico
        from checklist_alternativa_pergunta cap
        where cap.cod_checklist_modelo = f_cod_modelo
          and cap.cod_versao_checklist_modelo = f_cod_versao_modelo
    )

    update alternativas a
    set alternativa_mudou_contexto = true
        -- CTE irá conter apenas as novas e/ou alteradas.
    from alternativas_novas_ou_editadas ane
         -- Só considera como alterada as alternativas que já existiam.
    where ane.codigo is not null
      and a.codigo = ane.codigo;

    if (select count(*) from alternativas where alternativa_mudou_contexto is true or alternativa_nova is true) > 0
    then
        algo_mudou_no_contexto := true;
        deve_criar_nova_versao_modelo := true;
    end if;
    --

    -- 5.2 -> Verifica se as alternativas mudaram sem alteração de contexto.
    with alternativas_novas_ou_editadas as (
        select codigo,
               descricao,
               ordem_exibicao
        from alternativas
            except
        select cap.codigo,
               cap.alternativa,
               cap.ordem
        from checklist_alternativa_pergunta cap
        where cap.cod_checklist_modelo = f_cod_modelo
          and cap.cod_versao_checklist_modelo = f_cod_versao_modelo
    )

    update alternativas a
    set alternativa_mudou = true
        -- CTE irá conter apenas as novas e/ou alteradas.
    from alternativas_novas_ou_editadas ane
         -- Só considera como alterada as alternativas que já existiam.
    where ane.codigo is not null
      and a.codigo = ane.codigo;

    if (select count(*) from alternativas where alternativa_mudou is true) > 0 and
       deve_criar_nova_versao_modelo is false
    then
        algo_mudou_no_modelo := true;
        deve_criar_nova_versao_modelo := false;
    end if;
    --

    -- 6 -> Verifica se os cargos mudaram.
    if (select count(*)
        from (select codigo
              from unnest(f_cod_cargos) codigo
                  except
              select cmf.cod_funcao
              from checklist_modelo_funcao cmf
              where cmf.cod_checklist_modelo = f_cod_modelo) t) > 0
    then
        algo_mudou_no_modelo := true;
    end if;
    --

    -- 7 -> Verifica se os tipos de veículos mudaram.
    if (select count(*)
        from (select codigo
              from unnest(f_cod_tipos_veiculos) codigo
                  except
              select cmvt.cod_tipo_veiculo
              from checklist_modelo_veiculo_tipo cmvt
              where cmvt.cod_modelo = f_cod_modelo) t) > 0
    then
        algo_mudou_no_modelo := true;
    end if;
    --

    case
        -- A) Caso mais simples: nada mudou, não precisamos fazer nada.
        when algo_mudou_no_contexto is false and deve_criar_nova_versao_modelo is false and
             algo_mudou_no_modelo is false
            then
                return query
                    select null :: bigint  as codigo_item,
                           null :: boolean as item_novo,
                           null :: boolean as item_mudou_contexto,
                           null :: boolean as item_tipo_pergunta,
                           false           as algo_mudou_no_modelo,
                           false           as algo_mudou_no_contexto,
                           false           as deve_criar_nova_versao_modelo;

        -- B) Caso intermediário: algo mudou no modelo porém nada que justifique a criação de uma nova versão.
        when algo_mudou_no_modelo is true and deve_criar_nova_versao_modelo is false
            then
                return query
                    select null :: bigint  as codigo_item,
                           null :: boolean as item_novo,
                           null :: boolean as item_mudou_contexto,
                           null :: boolean as item_tipo_pergunta,
                           true            as algo_mudou_no_modelo,
                           false           as algo_mudou_no_contexto,
                           false           as deve_criar_nova_versao_modelo;

        -- C) Caso intermediário: algo mudou no modelo com a criação de uma nova versão e mantendo o código de contexto.
        when algo_mudou_no_modelo is true and deve_criar_nova_versao_modelo is true and
             algo_mudou_no_contexto is false
            then
                return query
                    select p.codigo                      as codigo_item,
                           p.pergunta_nova               as item_novo,
                           p.pergunta_mudou_contexto     as item_mudou_contexto,
                           true                          as item_tipo_pergunta,
                           true                          as algo_mudou_no_modelo,
                           false                         as algo_mudou_no_contexto,
                           deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                    from perguntas p
                    union all
                    select a.codigo                      as codigo_item,
                           a.alternativa_nova            as item_novo,
                           a.alternativa_mudou_contexto  as item_mudou_contexto,
                           false                         as item_tipo_pergunta,
                           true                          as algo_mudou_no_modelo,
                           false                         as algo_mudou_no_contexto,
                           deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                    from alternativas a;

        -- D) Caso mais complexo: algo mudou e iremos precisar criar nova versão. Nesse cenário temos que retornar
        -- todas as informações.
        when algo_mudou_no_contexto is true and deve_criar_nova_versao_modelo is true
            then
                return query
                    select p.codigo                      as codigo_item,
                           p.pergunta_nova               as item_novo,
                           p.pergunta_mudou_contexto     as item_mudou_contexto,
                           true                          as item_tipo_pergunta,
                           true                          as algo_mudou_no_modelo,
                           true                          as algo_mudou_no_contexto,
                           deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                    from perguntas p
                    union all
                    select a.codigo                      as codigo_item,
                           a.alternativa_nova            as item_novo,
                           a.alternativa_mudou_contexto  as item_mudou_contexto,
                           false                         as item_tipo_pergunta,
                           true                          as algo_mudou_no_modelo,
                           true                          as algo_mudou_no_contexto,
                           deve_criar_nova_versao_modelo as deve_criar_nova_versao_modelo
                    from alternativas a;
        else
            raise exception
                'Erro! Estado ilegal dos dados. algo_mudou_no_modelo = false AND deve_criar_nova_versao_modelo = true';
        end case;

    drop table alternativas;
    drop table perguntas;
END;
$$;

create or replace function public.func_checklist_get_perguntas_modelos_checklist(f_cod_unidade bigint, f_cod_modelo bigint, f_cod_versao_modelo bigint)
    returns TABLE
            (
                cod_pergunta             bigint,
                cod_contexto_pergunta    bigint,
                cod_imagem               bigint,
                url_imagem               text,
                pergunta                 text,
                ordem_pergunta           integer,
                single_choice            boolean,
                cod_alternativa          bigint,
                cod_contexto_alternativa bigint,
                alternativa              text,
                prioridade               text,
                ordem_alternativa        integer,
                deve_abrir_ordem_servico boolean,
                alternativa_tipo_outros  boolean
            )
    language sql
as
$$
SELECT CP.CODIGO                    AS COD_PERGUNTA,
       CP.CODIGO_CONTEXTO           AS COD_CONTEXTO_PERGUNTA,
       CGI.COD_IMAGEM               AS COD_IMAGEM,
       CGI.URL_IMAGEM               AS URL_IMAGEM,
       CP.PERGUNTA                  AS PERGUNTA,
       CP.ORDEM                     AS ORDEM_PERGUNTA,
       CP.SINGLE_CHOICE             AS SINGLE_CHOICE,
       CAP.CODIGO                   AS COD_ALTERNATIVA,
       CAP.CODIGO_CONTEXTO          AS COD_CONTEXTO_ALTERNATIVA,
       CAP.ALTERNATIVA              AS ALTERNATIVA,
       CAP.PRIORIDADE :: TEXT       AS PRIORIDADE,
       CAP.ORDEM                    AS ORDEM_ALTERNATIVA,
       CAP.DEVE_ABRIR_ORDEM_SERVICO AS DEVE_ABRIR_ORDEM_SERVICO,
       CAP.ALTERNATIVA_TIPO_OUTROS  AS ALTERNATIVA_TIPO_OUTROS
FROM CHECKLIST_PERGUNTAS CP
         JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
              ON CP.CODIGO = CAP.COD_PERGUNTA
                  AND CAP.COD_UNIDADE = CP.COD_UNIDADE
                  AND CAP.COD_CHECKLIST_MODELO = CP.COD_CHECKLIST_MODELO
                  AND CAP.COD_VERSAO_CHECKLIST_MODELO = CP.COD_VERSAO_CHECKLIST_MODELO
         LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                   ON CGI.COD_IMAGEM = CP.COD_IMAGEM
WHERE CP.COD_UNIDADE = F_COD_UNIDADE
  AND CP.COD_CHECKLIST_MODELO = F_COD_MODELO
  AND CP.COD_VERSAO_CHECKLIST_MODELO = F_COD_VERSAO_MODELO
ORDER BY CP.ORDEM, CP.PERGUNTA, CAP.ORDEM;
$$;


create or replace function public.func_checklist_relatorio_resumo_realizados(f_cod_unidades bigint[],
                                                                             f_placa_veiculo text, f_data_inicial date,
                                                                             f_data_final date)
    returns TABLE
            (
                "UNIDADE"                     text,
                "MODELO CHECKLIST"            text,
                "CÓDIGO CHECKLIST"            bigint,
                "DATA REALIZAÇÃO"             text,
                "DATA IMPORTADO"              text,
                "COLABORADOR"                 text,
                "CPF"                         text,
                "PLACA"                       text,
                "KM"                          bigint,
                "TEMPO REALIZAÇÃO (SEGUNDOS)" bigint,
                "TIPO"                        text,
                "TOTAL DE PERGUNTAS"          smallint,
                "TOTAL NOK"                   bigint,
                "PRIORIDADE BAIXA"            bigint,
                "PRIORIDADE ALTA"             bigint,
                "PRIORIDADE CRÍTICA"          bigint
            )
    language sql
as
$$
SELECT U.NOME                                                 AS NOME_UNIDADE,
       CM.NOME                                                AS NOME_MODELO,
       C.CODIGO                                               AS COD_CHECKLIST,
       FORMAT_TIMESTAMP(
               C.DATA_HORA_REALIZACAO_TZ_APLICADO,
               'DD/MM/YYYY HH24:MI')                          AS DATA_HORA_REALIZACAO,
       FORMAT_WITH_TZ(
               C.DATA_HORA_IMPORTADO_PROLOG,
               TZ_UNIDADE(C.COD_UNIDADE),
               'DD/MM/YYYY HH24:MI',
               '-')                                           AS DATA_HORA_IMPORTADO,
       CO.NOME                                                AS NOME_COLABORADOR,
       LPAD(CO.CPF :: TEXT, 11, '0')                          AS CPF_COLABORADOR,
       C.PLACA_VEICULO                                        AS PLACA_VEICULO,
       C.KM_VEICULO                                           AS KM_VEICULO,
       C.TEMPO_REALIZACAO / 1000                              AS TEMPO_REALIZACAO_SEGUNDOS,
       F_IF(C.TIPO = 'S', 'Saída' :: TEXT, 'Retorno' :: TEXT) AS TIPO_CHECKLIST,
       C.TOTAL_PERGUNTAS_OK + C.TOTAL_PERGUNTAS_NOK           AS TOTAL_PERGUNTAS,
       (SELECT COUNT(*)
        FROM CHECKLIST_RESPOSTAS_NOK CRN
        WHERE CRN.COD_CHECKLIST = C.CODIGO)                   AS TOTAL_NOK,
       (SELECT COUNT(*)
        FROM CHECKLIST_RESPOSTAS_NOK CRN
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                      ON CRN.COD_ALTERNATIVA = CAP.CODIGO
        WHERE CRN.COD_CHECKLIST = C.CODIGO
          AND CAP.PRIORIDADE = 'BAIXA')                       AS TOTAL_BAIXA,
       (SELECT COUNT(*)
        FROM CHECKLIST_RESPOSTAS_NOK CRN
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                      ON CRN.COD_ALTERNATIVA = CAP.CODIGO
        WHERE CRN.COD_CHECKLIST = C.CODIGO
          AND CAP.PRIORIDADE = 'ALTA')                        AS TOTAL_ALTA,
       (SELECT COUNT(*)
        FROM CHECKLIST_RESPOSTAS_NOK CRN
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                      ON CRN.COD_ALTERNATIVA = CAP.CODIGO
        WHERE CRN.COD_CHECKLIST = C.CODIGO
          AND CAP.PRIORIDADE = 'CRITICA')                     AS TOTAL_CRITICA
FROM CHECKLIST C
         JOIN CHECKLIST_PERGUNTAS CP
              ON CP.cod_versao_checklist_modelo = C.cod_versao_checklist_modelo
         JOIN COLABORADOR CO
              ON C.CPF_COLABORADOR = CO.CPF
         JOIN UNIDADE U
              ON C.COD_UNIDADE = U.CODIGO
         JOIN CHECKLIST_MODELO CM ON CM.CODIGO = C.COD_CHECKLIST_MODELO
WHERE C.COD_UNIDADE = ANY (F_COD_UNIDADES)
  AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
  AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
  AND (F_PLACA_VEICULO = '%' OR C.PLACA_VEICULO LIKE F_PLACA_VEICULO)
GROUP BY C.CODIGO,
         CM.NOME,
         C.TOTAL_PERGUNTAS_OK,
         C.TOTAL_PERGUNTAS_NOK,
         U.CODIGO,
         CO.CPF,
         CO.NOME,
         CO.CPF,
         C.DATA_HORA,
         C.DATA_HORA_REALIZACAO_TZ_APLICADO,
         C.DATA_HORA_IMPORTADO_PROLOG,
         C.DATA_HORA_SINCRONIZACAO,
         C.COD_UNIDADE,
         C.PLACA_VEICULO,
         C.KM_VEICULO,
         C.TEMPO_REALIZACAO,
         C.TIPO
ORDER BY U.NOME,
         C.DATA_HORA_SINCRONIZACAO DESC;
$$;

create or replace function public.func_checklist_os_relatorio_estratificacao_os(f_cod_unidades bigint[],
                                                                                f_placa_veiculo text, f_status_os text,
                                                                                f_status_item text,
                                                                                f_data_inicial_abertura date,
                                                                                f_data_final_abertura date,
                                                                                f_data_inicial_resolucao date,
                                                                                f_data_final_resolucao date)
    returns TABLE
            (
                unidade                        text,
                "CÓDICO OS"                    bigint,
                "ABERTURA OS"                  text,
                "DATA LIMITE CONSERTO"         text,
                "STATUS OS"                    text,
                "PLACA"                        text,
                "PERGUNTA"                     text,
                "ALTERNATIVA"                  text,
                "PRIORIDADE"                   text,
                "PRAZO EM HORAS"               integer,
                "DESCRIÇÃO"                    text,
                "STATUS ITEM"                  text,
                "DATA INÍCIO RESOLUÇÃO"        text,
                "DATA FIM RESOLUÇÃO"           text,
                "DATA RESOLIVDO PROLOG"        text,
                "MECÂNICO"                     text,
                "DESCRIÇÃO CONSERTO"           text,
                "TEMPO DE CONSERTO EM MINUTOS" bigint,
                "KM ABERTURA"                  bigint,
                "KM FECHAMENTO"                bigint,
                "KM PERCORRIDO"                text,
                "MOTORISTA"                    text,
                "TIPO DO CHECKLIST"            text
            )
    language sql
as
$$
SELECT U.NOME                                                                             AS NOME_UNIDADE,
       EO.COD_OS                                                                          AS CODIGO_OS,
       FORMAT_TIMESTAMP(DATA_HORA, 'DD/MM/YYYY HH24:MI')                                  AS ABERTURA_OS,
       FORMAT_TIMESTAMP(DATA_HORA + (PRAZO || ' HOUR') :: INTERVAL, 'DD/MM/YYYY HH24:MI') AS DATA_LIMITE_CONSERTO,
       (CASE
            WHEN STATUS_OS = 'A'
                THEN 'ABERTA'
            ELSE 'FECHADA' END)                                                           AS STATUS_OS,
       PLACA_VEICULO                                                                      AS PLACA,
       PERGUNTA                                                                           AS PERGUNTA,
       ALTERNATIVA                                                                        AS ALTERNATIVA,
       PRIORIDADE                                                                         AS PRIORIDADE,
       PRAZO                                                                              AS PRAZO_EM_HORAS,
       RESPOSTA_OUTROS                                                                    AS DESCRICAO,
       CASE
           WHEN STATUS_ITEM = 'P'
               THEN 'PENDENTE'
           ELSE 'RESOLVIDO' END                                                           AS STATUS_ITEM,
       FORMAT_TIMESTAMP(
               DATA_HORA_INICIO_RESOLUCAO_UTC AT TIME ZONE TIME_ZONE_UNIDADE,
               'DD/MM/YYYY HH24:MI',
               '-')                                                                       AS DATA_INICIO_RESOLUCAO,
       FORMAT_TIMESTAMP(
               DATA_HORA_FIM_RESOLUCAO_UTC AT TIME ZONE TIME_ZONE_UNIDADE,
               'DD/MM/YYYY HH24:MI', '-')                                                 AS DATA_FIM_RESOLUCAO,
       FORMAT_TIMESTAMP(DATA_HORA_CONSERTO, 'DD/MM/YYYY HH24:MI')                         AS DATA_RESOLVIDO_PROLOG,
       NOME_MECANICO                                                                      AS MECANICO,
       FEEDBACK_CONSERTO                                                                  AS DESCRICAO_CONSERTO,
       TEMPO_REALIZACAO / 1000 / 60                                                       AS TEMPO_CONSERTO_MINUTOS,
       KM                                                                                 AS KM_ABERTURA,
       KM_FECHAMENTO                                                                      AS KM_FECHAMENTO,
       COALESCE((KM_FECHAMENTO - KM) :: TEXT, '-')                                        AS KM_PERCORRIDO,
       NOME_REALIZADOR_CHECKLIST                                                          AS MOTORISTA,
       CASE
           WHEN TIPO_CHECKLIST = 'S'
               THEN 'SAÍDA'
           ELSE 'RETORNO' END                                                             AS TIPO_CHECKLIST
FROM ESTRATIFICACAO_OS EO
         JOIN UNIDADE U
              ON EO.COD_UNIDADE = U.CODIGO
WHERE EO.COD_UNIDADE = ANY (F_COD_UNIDADES)
  AND EO.PLACA_VEICULO LIKE F_PLACA_VEICULO
  AND EO.STATUS_OS LIKE F_STATUS_OS
  AND EO.STATUS_ITEM LIKE F_STATUS_ITEM
  AND CASE
    -- O usuário pode filtrar tanto por início e fim de abertura ou por início e fim de resolução ou, ainda,
    -- por ambos.
          WHEN (F_DATA_INICIAL_ABERTURA,
                F_DATA_FINAL_ABERTURA,
                F_DATA_INICIAL_RESOLUCAO,
                F_DATA_FINAL_RESOLUCAO) IS NOT NULL
              THEN (
                  EO.DATA_HORA :: DATE BETWEEN F_DATA_INICIAL_ABERTURA AND F_DATA_FINAL_ABERTURA
                  AND
                  EO.DATA_HORA_CONSERTO :: DATE BETWEEN F_DATA_INICIAL_RESOLUCAO AND F_DATA_FINAL_RESOLUCAO)
          WHEN (F_DATA_INICIAL_ABERTURA,
                F_DATA_FINAL_ABERTURA) IS NOT NULL
              THEN
              EO.DATA_HORA :: DATE BETWEEN F_DATA_INICIAL_ABERTURA AND F_DATA_FINAL_ABERTURA
          WHEN (F_DATA_INICIAL_RESOLUCAO,
                F_DATA_FINAL_RESOLUCAO) IS NOT NULL
              THEN
              EO.DATA_HORA_CONSERTO :: DATE BETWEEN F_DATA_INICIAL_RESOLUCAO AND F_DATA_FINAL_RESOLUCAO

    -- Se não entrar em nenhuma condição conhecida, retornamos FALSE para o relatório não retornar dado nenhum.
          ELSE FALSE END
ORDER BY U.NOME, EO.COD_OS, EO.PRAZO;
$$;

create or replace function public.func_checklist_get_all_checklists_realizados(f_cod_unidade bigint,
                                                                               f_cod_equipe bigint,
                                                                               f_cod_tipo_veiculo bigint,
                                                                               f_placa_veiculo character varying,
                                                                               f_data_inicial date, f_data_final date,
                                                                               f_timezone text, f_limit integer,
                                                                               f_offset bigint)
    returns TABLE
            (
                cod_checklist                 bigint,
                cod_checklist_modelo          bigint,
                cod_versao_checklist_modelo   bigint,
                data_hora_realizacao          timestamp without time zone,
                data_hora_importado_prolog    timestamp without time zone,
                km_veiculo_momento_realizacao bigint,
                duracao_realizacao_millis     bigint,
                cpf_colaborador               bigint,
                placa_veiculo                 text,
                tipo_checklist                character,
                nome_colaborador              text,
                total_itens_ok                smallint,
                total_itens_nok               smallint
            )
    language plpgsql
as
$$
DECLARE
    F_HAS_EQUIPE           INTEGER := CASE WHEN F_COD_EQUIPE IS NULL THEN 1 ELSE 0 END;
    F_HAS_COD_TIPO_VEICULO INTEGER := CASE WHEN F_COD_TIPO_VEICULO IS NULL THEN 1 ELSE 0 END;
    F_HAS_PLACA_VEICULO    INTEGER := CASE WHEN F_PLACA_VEICULO IS NULL THEN 1 ELSE 0 END;
BEGIN
    RETURN QUERY
        SELECT C.CODIGO                                             AS COD_CHECKLIST,
               C.COD_CHECKLIST_MODELO                               AS COD_CHECKLIST_MODELO,
               C.COD_VERSAO_CHECKLIST_MODELO                        AS COD_VERSAO_CHECKLIST_MODELO,
               C.DATA_HORA AT TIME ZONE F_TIMEZONE                  AS DATA_HORA_REALIZACAO,
               C.DATA_HORA_IMPORTADO_PROLOG AT TIME ZONE F_TIMEZONE AS DATA_HORA_IMPORTADO_PROLOG,
               C.KM_VEICULO                                         AS KM_VEICULO_MOMENTO_REALIZACAO,
               C.TEMPO_REALIZACAO                                   AS DURACAO_REALIZACAO_MILLIS,
               C.CPF_COLABORADOR                                    AS CPF_COLABORADOR,
               C.PLACA_VEICULO :: TEXT                              AS PLACA_VEICULO,
               C.TIPO                                               AS TIPO_CHECKLIST,
               CO.NOME :: TEXT                                      AS NOME_COLABORADOR,
               C.TOTAL_PERGUNTAS_OK                                 AS TOTAL_ITENS_OK,
               C.TOTAL_PERGUNTAS_NOK                                AS TOTAL_ITENS_NOK
        FROM CHECKLIST C
                 JOIN COLABORADOR CO
                      ON CO.CPF = C.CPF_COLABORADOR
                 JOIN EQUIPE E
                      ON E.CODIGO = CO.COD_EQUIPE
                 JOIN VEICULO V
                      ON V.PLACA = C.PLACA_VEICULO
        WHERE C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE >= F_DATA_INICIAL
          AND C.DATA_HORA_REALIZACAO_TZ_APLICADO :: DATE <= F_DATA_FINAL
          AND C.COD_UNIDADE = F_COD_UNIDADE
          AND (F_HAS_EQUIPE = 1 OR E.CODIGO = F_COD_EQUIPE)
          AND (F_HAS_COD_TIPO_VEICULO = 1 OR V.COD_TIPO = F_COD_TIPO_VEICULO)
          AND (F_HAS_PLACA_VEICULO = 1 OR C.PLACA_VEICULO = F_PLACA_VEICULO)
        ORDER BY DATA_HORA_SINCRONIZACAO DESC
        LIMIT F_LIMIT
            OFFSET F_OFFSET;
END;
$$;

create or replace function public.func_checklist_get_farol_checklist(f_cod_unidade bigint, f_data_inicial date,
                                                                     f_data_final date,
                                                                     f_itens_criticos_retroativos boolean)
    returns TABLE
            (
                data                               date,
                placa                              character varying,
                cod_checklist_saida                bigint,
                data_hora_ultimo_checklist_saida   timestamp without time zone,
                cod_checklist_modelo_saida         bigint,
                nome_colaborador_checklist_saida   character varying,
                cod_checklist_retorno              bigint,
                data_hora_ultimo_checklist_retorno timestamp without time zone,
                cod_checklist_modelo_retorno       bigint,
                nome_colaborador_checklist_retorno character varying,
                codigo_pergunta                    bigint,
                descricao_pergunta                 text,
                descricao_alternativa              text,
                alternativa_tipo_outros            boolean,
                descricao_alternativa_tipo_outros  text,
                codigo_item_critico                bigint,
                data_hora_apontamento_item_critico timestamp without time zone
            )
    language plpgsql
as
$$
DECLARE
    CHECKLIST_TIPO_SAIDA         CHAR := 'S';
    CHECKLIST_TIPO_RETORNO       CHAR := 'R';
    CHECKLIST_PRIORIDADE_CRITICA TEXT := 'CRITICA';
    ORDEM_SERVICO_ABERTA         CHAR := 'A';
    ITEM_ORDEM_SERVICO_PENDENDTE CHAR := 'P';
BEGIN
    RETURN QUERY
        WITH ULTIMOS_CHECKLISTS_VEICULOS AS (
            SELECT INNERTABLE.DATA,
                   INNERTABLE.PLACA,
                   INNERTABLE.COD_CHECKLIST_SAIDA,
                   INNERTABLE.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                   CS.COD_CHECKLIST_MODELO AS COD_CHECKLIST_MODELO_SAIDA,
                   COS.NOME                AS NOME_COLABORADOR_CHECKLIST_SAIDA,
                   INNERTABLE.COD_CHECKLIST_RETORNO,
                   INNERTABLE.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
                   CR.COD_CHECKLIST_MODELO AS COD_CHECKLIST_MODELO_RETORNO,
                   COR.NOME                AS NOME_COLABORADOR_CHECKLIST_RETORNO
            FROM (SELECT G.DAY :: DATE                                            AS DATA,
                         V.PLACA                                                  AS PLACA,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_SAIDA
                                     THEN C.CODIGO END)                           AS COD_CHECKLIST_SAIDA,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_SAIDA
                                     THEN C.DATA_HORA_REALIZACAO_TZ_APLICADO END) AS DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_RETORNO
                                     THEN C.CODIGO END)                           AS COD_CHECKLIST_RETORNO,
                         MAX(CASE
                                 WHEN C.TIPO = CHECKLIST_TIPO_RETORNO
                                     THEN C.DATA_HORA_REALIZACAO_TZ_APLICADO END) AS DATA_HORA_ULTIMO_CHECKLIST_RETORNO
                  FROM VEICULO V
                           CROSS JOIN GENERATE_SERIES(F_DATA_INICIAL, F_DATA_FINAL, '1 DAY') G(DAY)
                           LEFT JOIN CHECKLIST C
                                     ON C.PLACA_VEICULO = V.PLACA AND
                                        G.DAY :: DATE = (C.DATA_HORA_REALIZACAO_TZ_APLICADO) :: DATE
                  WHERE V.COD_UNIDADE = F_COD_UNIDADE
                    AND V.STATUS_ATIVO = TRUE
                  GROUP BY 1, 2
                  ORDER BY 1, 2) AS INNERTABLE
                     LEFT JOIN CHECKLIST CS ON CS.CODIGO = INNERTABLE.COD_CHECKLIST_SAIDA
                     LEFT JOIN CHECKLIST CR ON CR.CODIGO = INNERTABLE.COD_CHECKLIST_RETORNO
                     LEFT JOIN COLABORADOR COS ON COS.CPF = CS.CPF_COLABORADOR
                     LEFT JOIN COLABORADOR COR ON COR.CPF = CR.CPF_COLABORADOR
            ORDER BY INNERTABLE.DATA, INNERTABLE.PLACA
        ),

             ITENS_CRITICOS_PENDENTES AS (
                 SELECT COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO AS COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                        COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO    AS COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
                        COSI.STATUS_RESOLUCAO                     AS STATUS_RESOLUCAO,
                        COSI.COD_OS                               AS COD_OS,
                        COSI.COD_UNIDADE                          AS COD_UNIDADE,
                        COSI.CODIGO                               AS CODIGO,
                        CAP.PRIORIDADE                            AS PRIORIDADE
                 FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                          JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                               ON CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                          JOIN CHECKLIST_PERGUNTAS CP
                               ON CP.CODIGO = CAP.COD_PERGUNTA
                 WHERE COSI.COD_UNIDADE = F_COD_UNIDADE
                   AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                   AND COSI.STATUS_RESOLUCAO = ITEM_ORDEM_SERVICO_PENDENDTE
             )

        SELECT Q.DATA,
               Q.PLACA,
               Q.COD_CHECKLIST_SAIDA,
               Q.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
               Q.COD_CHECKLIST_MODELO_SAIDA,
               Q.NOME_COLABORADOR_CHECKLIST_SAIDA,
               Q.COD_CHECKLIST_RETORNO,
               Q.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
               Q.COD_CHECKLIST_MODELO_RETORNO,
               Q.NOME_COLABORADOR_CHECKLIST_RETORNO,
               Q.CODIGO_PERGUNTA,
               Q.DESCRICAO_PERGUNTA,
               Q.DESCRICAO_ALTERNATIVA,
               CASE
                   WHEN Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_SAIDA
                       OR Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO
                       THEN TRUE
                   ELSE FALSE
                   END AS ALTERNATIVA_TIPO_OUTROS,
               CASE
                   WHEN Q.ITEM_CRITICO_DE_SAIDA_TIPO_OUTROS
                       THEN (SELECT CRN.RESPOSTA_OUTROS
                             FROM CHECKLIST_RESPOSTAS_NOK CRN
                             WHERE CRN.COD_CHECKLIST = Q.COD_CHECKLIST_SAIDA
                               AND CRN.COD_ALTERNATIVA = Q.CODIGO_ALTERNATIVA)
                   WHEN Q.ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO
                       THEN (SELECT CRN.RESPOSTA_OUTROS
                             FROM CHECKLIST_RESPOSTAS_NOK CRN
                             WHERE CRN.COD_CHECKLIST = Q.COD_CHECKLIST_RETORNO
                               AND CRN.COD_ALTERNATIVA = Q.CODIGO_ALTERNATIVA)
                   ELSE NULL
                   END AS DESCRICAO_ALTERNATIVA_TIPO_OUTROS,
               Q.CODIGO_ITEM_CRITICO,
               Q.DATA_HORA_APONTAMENTO_ITEM_CRITICO
        FROM (SELECT UCV.DATA,
                     UCV.PLACA,
                     UCV.COD_CHECKLIST_SAIDA,
                     UCV.DATA_HORA_ULTIMO_CHECKLIST_SAIDA,
                     UCV.COD_CHECKLIST_MODELO_SAIDA,
                     UCV.NOME_COLABORADOR_CHECKLIST_SAIDA,
                     UCV.COD_CHECKLIST_RETORNO,
                     UCV.DATA_HORA_ULTIMO_CHECKLIST_RETORNO,
                     UCV.COD_CHECKLIST_MODELO_RETORNO,
                     UCV.NOME_COLABORADOR_CHECKLIST_RETORNO,
                     CP.CODIGO       AS CODIGO_PERGUNTA,
                     CP.PERGUNTA     AS DESCRICAO_PERGUNTA,
                     CAP.ALTERNATIVA AS DESCRICAO_ALTERNATIVA,
                     CAP.CODIGO      AS CODIGO_ALTERNATIVA,
                     CASE
                         WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                             AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                             AND CAP.ALTERNATIVA_TIPO_OUTROS = TRUE
                             AND COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAP.CODIGO)
                             THEN TRUE
                         ELSE FALSE
                         END         AS ITEM_CRITICO_DE_SAIDA_TIPO_OUTROS,
                     CASE
                         WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                             AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                             AND CAP.ALTERNATIVA_TIPO_OUTROS = TRUE)
                             THEN TRUE
                         ELSE FALSE
                         END         AS ALTERNATIVA_TIPO_OUTROS_CHECKLIST_SAIDA,
                     CASE
                         WHEN (COS.COD_CHECKLIST = UCV.COD_CHECKLIST_RETORNO
                             AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                             AND CAP.ALTERNATIVA_TIPO_OUTROS = TRUE)
                             THEN TRUE
                         ELSE FALSE
                         END         AS ALTERNATIVA_TIPO_OUTROS_CHECKLIST_RETORNO,
                     CASE
                         WHEN CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                             THEN COSI.CODIGO
                         ELSE NULL
                         END         AS CODIGO_ITEM_CRITICO,
                     CASE
                         WHEN COS.COD_CHECKLIST = UCV.COD_CHECKLIST_SAIDA
                             AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                             THEN UCV.DATA_HORA_ULTIMO_CHECKLIST_SAIDA
                         WHEN COS.COD_CHECKLIST = UCV.COD_CHECKLIST_RETORNO
                             AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                             THEN UCV.DATA_HORA_ULTIMO_CHECKLIST_RETORNO
                         ELSE NULL
                         END         AS DATA_HORA_APONTAMENTO_ITEM_CRITICO
              FROM ULTIMOS_CHECKLISTS_VEICULOS UCV
                       LEFT JOIN CHECKLIST_ORDEM_SERVICO COS
                                 ON COS.COD_CHECKLIST IN (UCV.COD_CHECKLIST_SAIDA, UCV.COD_CHECKLIST_RETORNO)
                                     AND COS.STATUS = ORDEM_SERVICO_ABERTA
                                     AND COS.CODIGO IS NOT NULL
                  -- Utilizamos o join com ITENS_CRITICOS_PENDENTES ao invés de CHECKLIST_ORDEM_SERVICO_ITENS pois desse modo
                  -- consideramos apenas os itens abertos críticos, que é o que importa para o farol.
                       LEFT JOIN ITENS_CRITICOS_PENDENTES COSI
                                 ON COS.CODIGO = COSI.COD_OS
                                     AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                                     AND COSI.STATUS_RESOLUCAO = ITEM_ORDEM_SERVICO_PENDENDTE
                                     AND COSI.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA
                       LEFT JOIN CHECKLIST_PERGUNTAS CP
                                 ON CP.CODIGO = COSI.COD_PERGUNTA_PRIMEIRO_APONTAMENTO
                       LEFT JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                                 ON CAP.COD_PERGUNTA = CP.CODIGO
                                     AND CAP.CODIGO = COSI.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO
                                     AND CAP.PRIORIDADE = CHECKLIST_PRIORIDADE_CRITICA) AS Q
        ORDER BY Q.DATA, Q.PLACA, Q.CODIGO_PERGUNTA;
END;
$$;

create or replace function public.func_checklist_offline_get_modelos_disponiveis(f_cod_unidade bigint)
    returns TABLE
            (
                cod_unidade_modelo_checklist      bigint,
                cod_modelo_checklist              bigint,
                cod_versao_atual_modelo_checklist bigint,
                nome_modelo_checklist             text,
                cod_pergunta                      bigint,
                cod_contexto_pergunta             bigint,
                descricao_pergunta                text,
                cod_imagem                        bigint,
                url_imagem                        text,
                pergunta_ordem_exibicao           integer,
                single_choice                     boolean,
                cod_alternativa                   bigint,
                cod_contexto_alternativa          bigint,
                descricao_alternativa             text,
                tipo_outros                       boolean,
                alternativa_ordem_exibicao        integer,
                prioridade_alternativa            text,
                cod_cargo                         bigint,
                cod_tipo_veiculo                  bigint
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        WITH CHECKLIST_MODELO_ATIVO AS (
            SELECT CM.COD_UNIDADE              AS COD_UNIDADE_MODELO_CHECKLIST,
                   CM.CODIGO                   AS COD_MODELO_CHECKLIST,
                   CM.COD_VERSAO_ATUAL         AS COD_VERSAO_MODELO_CHECKLIST,
                   CM.NOME :: TEXT             AS NOME_MODELO_CHECKLIST,
                   CP.CODIGO                   AS COD_PERGUNTA,
                   CP.CODIGO_CONTEXTO          AS COD_CONTEXTO_PERGUNTA,
                   CP.PERGUNTA                 AS DESCRICAO_PERGUNTA,
                   CP.COD_IMAGEM               AS COD_IMAGEM,
                   CGI.URL_IMAGEM              AS URL_IMAGEM,
                   CP.ORDEM                    AS PERGUNTA_ORDEM_EXIBICAO,
                   CP.SINGLE_CHOICE            AS SINGLE_CHOICE,
                   CAP.CODIGO                  AS COD_ALTERNATIVA,
                   CAP.CODIGO_CONTEXTO         AS COD_CONTEXTO_ALTERNATIVA,
                   CAP.ALTERNATIVA             AS DESCRICAO_ALTERNATIVA,
                   CAP.ALTERNATIVA_TIPO_OUTROS AS TIPO_OUTROS,
                   CAP.ORDEM                   AS ALTERNATIVA_ORDEM_EXIBICAO,
                   CAP.PRIORIDADE :: TEXT      AS PRIORIDADE_ALTERNATIVA,
                   NULL :: BIGINT              AS COD_CARGO,
                   NULL :: BIGINT              AS COD_TIPO_VEICULO
            FROM CHECKLIST_MODELO CM
                     JOIN CHECKLIST_PERGUNTAS CP
                          ON CM.CODIGO = CP.COD_CHECKLIST_MODELO
                              AND CM.COD_VERSAO_ATUAL = CP.COD_VERSAO_CHECKLIST_MODELO
                     JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                          ON CP.CODIGO = CAP.COD_PERGUNTA
                -- Precisamos que seja LEFT JOIN para o caso de perguntas sem imagem associada.
                     LEFT JOIN CHECKLIST_GALERIA_IMAGENS CGI
                               ON CP.COD_IMAGEM = CGI.COD_IMAGEM
            WHERE CM.COD_UNIDADE = F_COD_UNIDADE
              AND CM.STATUS_ATIVO
        ),

             CHECKLIST_MODELO_CARGO AS (
                 SELECT NULL :: BIGINT           AS COD_UNIDADE_MODELO_CHECKLIST,
                        CMF.COD_CHECKLIST_MODELO AS COD_MODELO_CHECKLIST,
                        NULL :: BIGINT           AS COD_VERSAO_MODELO_CHECKLIST,
                        NULL :: TEXT             AS NOME_MODELO_CHECKLIST,
                        NULL :: BIGINT           AS COD_PERGUNTA,
                        NULL :: BIGINT           AS COD_CONTEXTO_PERGUNTA,
                        NULL :: TEXT             AS DESCRICAO_PERGUNTA,
                        NULL :: BIGINT           AS COD_IMAGEM,
                        NULL :: TEXT             AS URL_IMAGEM,
                        NULL :: INTEGER          AS PERGUNTA_ORDEM_EXIBICAO,
                        NULL :: BOOLEAN          AS SINGLE_CHOICE,
                        NULL :: BIGINT           AS COD_ALTERNATIVA,
                        NULL :: BIGINT           AS COD_CONTEXTO_ALTERNATIVA,
                        NULL :: TEXT             AS DESCRICAO_ALTERNATIVA,
                        NULL :: BOOLEAN          AS TIPO_OUTROS,
                        NULL :: INTEGER          AS ALTERNATIVA_ORDEM_EXIBICAO,
                        NULL :: TEXT             AS PRIORIDADE_ALTERNATIVA,
                        CMF.COD_FUNCAO           AS COD_CARGO,
                        NULL :: BIGINT           AS COD_TIPO_VEICULO
                 FROM CHECKLIST_MODELO_FUNCAO CMF
                 WHERE CMF.COD_CHECKLIST_MODELO IN (SELECT CODIGO
                                                    FROM CHECKLIST_MODELO CM
                                                    WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                                                      AND CM.STATUS_ATIVO = TRUE)
             ),

             CHECKLIST_MODELO_TIPO_VEICULO AS (
                 SELECT NULL :: BIGINT        AS COD_UNIDADE_MODELO_CHECKLIST,
                        CMVT.COD_MODELO       AS COD_MODELO_CHECKLIST,
                        NULL :: BIGINT        AS COD_VERSAO_MODELO_CHECKLIST,
                        NULL :: TEXT          AS NOME_MODELO_CHECKLIST,
                        NULL :: BIGINT        AS COD_PERGUNTA,
                        NULL :: BIGINT        AS COD_CONTEXTO_PERGUNTA,
                        NULL :: TEXT          AS DESCRICAO_PERGUNTA,
                        NULL :: BIGINT        AS COD_IMAGEM,
                        NULL :: TEXT          AS URL_IMAGEM,
                        NULL :: INTEGER       AS PERGUNTA_ORDEM_EXIBICAO,
                        NULL :: BOOLEAN       AS SINGLE_CHOICE,
                        NULL :: BIGINT        AS COD_ALTERNATIVA,
                        NULL :: BIGINT        AS COD_CONTEXTO_ALTERNATIVA,
                        NULL :: TEXT          AS DESCRICAO_ALTERNATIVA,
                        NULL :: BOOLEAN       AS TIPO_OUTROS,
                        NULL :: INTEGER       AS ALTERNATIVA_ORDEM_EXIBICAO,
                        NULL :: TEXT          AS PRIORIDADE_ALTERNATIVA,
                        NULL :: BIGINT        AS COD_CARGO,
                        CMVT.COD_TIPO_VEICULO AS COD_TIPO_VEICULO
                 FROM CHECKLIST_MODELO_VEICULO_TIPO CMVT
                 WHERE CMVT.COD_MODELO IN (SELECT CODIGO
                                           FROM CHECKLIST_MODELO CM
                                           WHERE CM.COD_UNIDADE = F_COD_UNIDADE
                                             AND CM.STATUS_ATIVO = TRUE)
             ),

             CHECKLISTS_FILTRADOS AS (
                 SELECT *
                 FROM CHECKLIST_MODELO_ATIVO
                 UNION ALL
                 SELECT *
                 FROM CHECKLIST_MODELO_CARGO
                 UNION ALL
                 SELECT *
                 FROM CHECKLIST_MODELO_TIPO_VEICULO
             )

        SELECT CF.COD_UNIDADE_MODELO_CHECKLIST AS COD_UNIDADE_MODELO_CHECKLIST,
               CF.COD_MODELO_CHECKLIST         AS COD_MODELO_CHECKLIST,
               CF.COD_VERSAO_MODELO_CHECKLIST  AS COD_VERSAO_MODELO_CHECKLIST,
               CF.NOME_MODELO_CHECKLIST        AS NOME_MODELO_CHECKLIST,
               CF.COD_PERGUNTA                 AS COD_PERGUNTA,
               CF.COD_CONTEXTO_PERGUNTA        AS COD_CONTEXTO_PERGUNTA,
               CF.DESCRICAO_PERGUNTA           AS DESCRICAO_PERGUNTA,
               CF.COD_IMAGEM                   AS COD_IMAGEM,
               CF.URL_IMAGEM                   AS URL_IMAGEM,
               CF.PERGUNTA_ORDEM_EXIBICAO      AS PERGUNTA_ORDEM_EXIBICAO,
               CF.SINGLE_CHOICE                AS SINGLE_CHOICE,
               CF.COD_ALTERNATIVA              AS COD_ALTERNATIVA,
               CF.COD_CONTEXTO_ALTERNATIVA     AS COD_CONTEXTO_ALTERNATIVA,
               CF.DESCRICAO_ALTERNATIVA        AS DESCRICAO_ALTERNATIVA,
               CF.TIPO_OUTROS                  AS TIPO_OUTROS,
               CF.ALTERNATIVA_ORDEM_EXIBICAO   AS ALTERNATIVA_ORDEM_EXIBICAO,
               CF.PRIORIDADE_ALTERNATIVA       AS PRIORIDADE_ALTERNATIVA,
               CF.COD_CARGO                    AS COD_CARGO,
               CF.COD_TIPO_VEICULO             AS COD_TIPO_VEICULO
        FROM CHECKLISTS_FILTRADOS CF
        ORDER BY CF.COD_MODELO_CHECKLIST,
                 CF.PERGUNTA_ORDEM_EXIBICAO,
                 CF.COD_PERGUNTA,
                 CF.ALTERNATIVA_ORDEM_EXIBICAO,
                 CF.COD_ALTERNATIVA,
                 CF.COD_CARGO,
                 CF.COD_TIPO_VEICULO;
END;
$$;

create or replace function piccolotur.func_check_os_insere_item_os_aberta(f_cod_os_globus bigint,
                                                                          f_cod_unidade_os bigint,
                                                                          f_cod_checklist bigint,
                                                                          f_cod_item_os_globus bigint,
                                                                          f_cod_contexto_pergunta_checklist bigint,
                                                                          f_cod_contexto_alternativa_checklist bigint,
                                                                          f_data_hora_sincronizacao_pendencia timestamp with time zone,
                                                                          f_token_integracao text) returns bigint
    language plpgsql
as
$$
DECLARE
    STATUS_OS_ABERTA        TEXT   := 'A';
    STATUS_ITEM_OS_PENDENTE TEXT   := 'P';
    CODIGO_PERGUNTA         BIGINT := (SELECT CP.CODIGO
                                       FROM CHECKLIST_PERGUNTAS CP
                                       WHERE CP.CODIGO_CONTEXTO = F_COD_CONTEXTO_PERGUNTA_CHECKLIST
                                         AND CP.COD_VERSAO_CHECKLIST_MODELO =
                                             (SELECT C.COD_VERSAO_CHECKLIST_MODELO
                                              FROM CHECKLIST C
                                              WHERE C.CODIGO = F_COD_CHECKLIST));
    CODIGO_ALTERNATIVA      BIGINT := (SELECT CAP.CODIGO
                                       FROM CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                                       WHERE CAP.CODIGO_CONTEXTO = F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST
                                         AND CAP.COD_PERGUNTA = CODIGO_PERGUNTA
                                         AND CAP.COD_VERSAO_CHECKLIST_MODELO = (SELECT C.COD_VERSAO_CHECKLIST_MODELO
                                                                                FROM CHECKLIST C
                                                                                WHERE C.CODIGO = F_COD_CHECKLIST));
    COD_ITEM_OS_PROLOG      BIGINT;
BEGIN
    -- Antes de processarmos a abertura da O.S e inserção de Itens, validamos todos os códigos de vínculo.
    -- Validamos se o código da unidade da O.S bate com a empresa do Token
    IF ((SELECT U.COD_EMPRESA FROM PUBLIC.UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE_OS)
        <>
        (SELECT TI.COD_EMPRESA
         FROM INTEGRACAO.TOKEN_INTEGRACAO TI
         WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE VÍNCULO] O token "%s" não está autorizado a inserir dados da unidade "%s"',
                               F_TOKEN_INTEGRACAO,
                               F_COD_UNIDADE_OS));
    END IF;

    -- Validamos se o Item da Ordem de Serviço já existe no ProLog.
    -- Nesse caso, não podemos incrementar a quantidade de apontamentos pois, o incremento é feito em JAVA, quando
    -- enviamos os itens NOK para o Globus. Em teoria, deveria chegar para o ProLog apenas novos itens de OS.
--     IF (SELECT EXISTS(SELECT *
--                       FROM PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO COSIV
--                       WHERE COSIV.COD_UNIDADE = F_COD_UNIDADE_OS
--                         AND COSIV.COD_OS_GLOBUS = F_COD_OS_GLOBUS
--                         AND COSIV.COD_ITEM_OS_GLOBUS = F_COD_ITEM_OS_GLOBUS
--                         AND COSIV.COD_ITEM_OS_PROLOG))
--     THEN
--         PERFORM PUBLIC.THROW_GENERIC_ERROR(
--                         FORMAT('[ERRO DE STATUS] O serviço "%s" já está existe na O.S "%s" do ProLog',
--                                F_COD_ITEM_OS_GLOBUS,
--                                F_COD_OS_GLOBUS));
--     END IF;

    -- Validamos se o código do checklist existe.
    IF (SELECT NOT EXISTS(
            SELECT C.CODIGO
            FROM PUBLIC.CHECKLIST C
            WHERE C.CODIGO = F_COD_CHECKLIST
              AND C.COD_UNIDADE = F_COD_UNIDADE_OS))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE VÍNCULO] O checklist "%s" não encontra-se na base de dados do ProLog',
                               F_COD_CHECKLIST));
    END IF;

    -- Validamos se a pergunta existe e está mesmo vinculada ao checklist realizado.
    IF (SELECT NOT EXISTS(
            SELECT CRN.COD_PERGUNTA
            FROM PUBLIC.CHECKLIST_RESPOSTAS_NOK CRN
            WHERE CRN.COD_CHECKLIST = F_COD_CHECKLIST
              AND CRN.COD_PERGUNTA = CODIGO_PERGUNTA))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE VÍNCULO] A pergunta "%s" não possui vínculo com o checklist "%s"',
                               F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
                               F_COD_CHECKLIST));
    END IF;

    -- Validamos se a alternativa existe e pertence a pergunta do checklist realizado.
    IF (SELECT NOT EXISTS(
            SELECT CRN.COD_ALTERNATIVA
            FROM PUBLIC.CHECKLIST_RESPOSTAS_NOK CRN
            WHERE CRN.COD_CHECKLIST = F_COD_CHECKLIST
              AND CRN.COD_PERGUNTA = CODIGO_PERGUNTA
              AND CRN.COD_ALTERNATIVA = CODIGO_ALTERNATIVA))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('[ERRO DE VÍNCULO] A alternativa "%s" não possui vínculo com a pergunta "%s"',
                               F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST,
                               F_COD_CONTEXTO_PERGUNTA_CHECKLIST));
    END IF;

    -- Validamos se o Item da O.S pertencem a um checklist que de fato foi enviado para o Globus.
    IF (NOT (SELECT EXISTS(
                            SELECT *
                            FROM PICCOLOTUR.CHECKLIST_ITEM_NOK_ENVIADO_GLOBUS CINEG
                            WHERE CINEG.COD_CHECKLIST = F_COD_CHECKLIST
                              AND CINEG.COD_CONTEXTO_PERGUNTA = F_COD_CONTEXTO_PERGUNTA_CHECKLIST
                              AND CINEG.COD_CONTEXTO_ALTERNATIVA = F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT(
                                '[ERRO DE VÍNCULO] Não existe vínculo entre o cod_checklist "%s", cod_pergunta "%s" e cod_alternativa "%s"',
                                F_COD_CHECKLIST,
                                F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
                                F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST));
    END IF;

    -- Se chegou nesse estágio, já validamos todos os cenários do item, devemos então inserir.
    -- Se a Ordem de Serviço não existe, então criamos ela.
    IF (SELECT NOT EXISTS(
            SELECT COS.CODIGO
            FROM PUBLIC.CHECKLIST_ORDEM_SERVICO COS
            WHERE COS.CODIGO = F_COD_OS_GLOBUS
              AND COS.COD_UNIDADE = F_COD_UNIDADE_OS))
    THEN
        INSERT INTO PUBLIC.CHECKLIST_ORDEM_SERVICO(CODIGO,
                                                   COD_UNIDADE,
                                                   COD_CHECKLIST,
                                                   STATUS)
        VALUES (F_COD_OS_GLOBUS, F_COD_UNIDADE_OS, F_COD_CHECKLIST, STATUS_OS_ABERTA);
    ELSE
        -- Caso a OS estiver fechada, iremos reabrir para inserir o novo item.
        -- Se estiver aberta, iremos apenas adicionar o item nela.
        UPDATE PUBLIC.CHECKLIST_ORDEM_SERVICO
        SET STATUS               = STATUS_OS_ABERTA,
            DATA_HORA_FECHAMENTO = NULL
        WHERE CODIGO = F_COD_OS_GLOBUS
          AND COD_UNIDADE = F_COD_UNIDADE_OS;
    END IF;

    -- Não precisamos validar novamente se o item já existe no banco de dados, apenas inserimos.
    INSERT INTO PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS(COD_UNIDADE,
                                                     COD_OS,
                                                     STATUS_RESOLUCAO,
                                                     COD_CONTEXTO_PERGUNTA,
                                                     COD_CONTEXTO_ALTERNATIVA,
                                                     COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
                                                     COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO)
    VALUES (F_COD_UNIDADE_OS,
            F_COD_OS_GLOBUS,
            STATUS_ITEM_OS_PENDENTE,
            F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
            F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST,
            CODIGO_PERGUNTA,
            CODIGO_ALTERNATIVA) RETURNING CODIGO INTO COD_ITEM_OS_PROLOG;

    -- Não chegará nesse ponto um 'item', 'checklist' ou 'alternativa' que não existam, então podemos inserir os
    -- dados com segurança. Também, não chegará aqui um item que não deveremos inserir ou que devemos aumentar a
    -- quantidade de apontamentos, nesse estágio o item SEMPRE tera 'NOVA_QTD_APONTAMENTOS' = 1 (primeiro apontamento).
    INSERT INTO PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS(COD_ITEM_ORDEM_SERVICO,
                                                                  COD_CHECKLIST_REALIZADO,
                                                                  COD_ALTERNATIVA,
                                                                  NOVA_QTD_APONTAMENTOS)
    VALUES (COD_ITEM_OS_PROLOG, F_COD_CHECKLIST, CODIGO_ALTERNATIVA, 1);

    -- Após salvar o item, criamos o vínculo dele na tabela DE-PARA.
    INSERT INTO PICCOLOTUR.CHECKLIST_ORDEM_SERVICO_ITEM_VINCULO(COD_UNIDADE,
                                                                COD_OS_GLOBUS,
                                                                COD_ITEM_OS_GLOBUS,
                                                                COD_ITEM_OS_PROLOG,
                                                                PLACA_VEICULO_OS,
                                                                COD_CHECKLIST_OS_PROLOG,
                                                                COD_CONTEXTO_PERGUNTA_OS_PROLOG,
                                                                COD_CONTEXTO_ALTERNATIVA_OS_PROLOG,
                                                                DATA_HORA_SINCRONIA_PENDENCIA)
    VALUES (F_COD_UNIDADE_OS,
            F_COD_OS_GLOBUS,
            F_COD_ITEM_OS_GLOBUS,
            COD_ITEM_OS_PROLOG,
            (SELECT C.PLACA_VEICULO FROM PUBLIC.CHECKLIST C WHERE C.CODIGO = F_COD_CHECKLIST),
            F_COD_CHECKLIST,
            F_COD_CONTEXTO_PERGUNTA_CHECKLIST,
            F_COD_CONTEXTO_ALTERNATIVA_CHECKLIST,
            F_DATA_HORA_SINCRONIZACAO_PENDENCIA);

    RETURN COD_ITEM_OS_PROLOG;
END;
$$;

create or replace function public.func_checklist_os_incrementa_qtd_apontamentos_item(f_cod_item_ordem_servico bigint,
                                                                                     f_cod_checklist_realizado bigint,
                                                                                     f_cod_alternativa bigint,
                                                                                     f_status_resolucao text) returns void
    language plpgsql
as
$$
DECLARE
    NOVA_QTD_APONTAMENTOS_ITEM INTEGER;
BEGIN
    -- Atualiza quantidade de apontamentos do item.
    UPDATE CHECKLIST_ORDEM_SERVICO_ITENS
    SET QT_APONTAMENTOS = QT_APONTAMENTOS + 1
    WHERE CODIGO = F_COD_ITEM_ORDEM_SERVICO
      AND STATUS_RESOLUCAO = F_STATUS_RESOLUCAO RETURNING QT_APONTAMENTOS INTO NOVA_QTD_APONTAMENTOS_ITEM;

    -- Insere a alternativa que incrementou a quantidade de apontamentos na tabela.
    INSERT INTO CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS (COD_ITEM_ORDEM_SERVICO,
                                                            COD_CHECKLIST_REALIZADO,
                                                            COD_ALTERNATIVA,
                                                            NOVA_QTD_APONTAMENTOS)
    VALUES (F_COD_ITEM_ORDEM_SERVICO, F_COD_CHECKLIST_REALIZADO, F_COD_ALTERNATIVA, NOVA_QTD_APONTAMENTOS_ITEM);
END;
$$;

create or replace function public.func_checklist_os_insere_item_os(f_cod_unidade bigint, f_cod_os bigint,
                                                                   f_cod_pergunta_primeiro_apontamento bigint,
                                                                   f_cod_alternativa_primeiro_apontamento bigint,
                                                                   f_status_resolucao text,
                                                                   f_cod_contexto_pergunta bigint,
                                                                   f_cod_contexto_alternativa bigint,
                                                                   f_cod_checklist_realizado bigint) returns bigint
    language plpgsql
as
$$
DECLARE
    NOVA_QTD_APONTAMENTOS_ITEM INTEGER := 1;
    CODIGO_ITEM_OS             BIGINT;
BEGIN
    -- Insere o item da O.S
    INSERT INTO CHECKLIST_ORDEM_SERVICO_ITENS(COD_UNIDADE,
                                              COD_OS,
                                              COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
                                              COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
                                              STATUS_RESOLUCAO,
                                              COD_CONTEXTO_PERGUNTA,
                                              COD_CONTEXTO_ALTERNATIVA)
    VALUES (F_COD_UNIDADE,
            F_COD_OS,
            F_COD_PERGUNTA_PRIMEIRO_APONTAMENTO,
            F_COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
            F_STATUS_RESOLUCAO,
            F_COD_CONTEXTO_PERGUNTA,
            F_COD_CONTEXTO_ALTERNATIVA) RETURNING CODIGO INTO CODIGO_ITEM_OS;

    -- Insere a alternativa que incrementou a quantidade de apontamentos na tabela.
    INSERT INTO CHECKLIST_ORDEM_SERVICO_ITENS_APONTAMENTOS (COD_ITEM_ORDEM_SERVICO,
                                                            COD_CHECKLIST_REALIZADO,
                                                            COD_ALTERNATIVA,
                                                            NOVA_QTD_APONTAMENTOS)
    VALUES (CODIGO_ITEM_OS,
            F_COD_CHECKLIST_REALIZADO,
            F_COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO,
            NOVA_QTD_APONTAMENTOS_ITEM);

    RETURN CODIGO_ITEM_OS;
END;
$$;

create or replace function public.func_checklist_get_realizados_by_colaborador(f_cpf_colaborador bigint,
                                                                               f_data_inicial date, f_data_final date,
                                                                               f_timezone text, f_limit integer,
                                                                               f_offset bigint)
    returns TABLE
            (
                cod_checklist                 bigint,
                cod_checklist_modelo          bigint,
                cod_versao_checklist_modelo   bigint,
                data_hora_realizacao          timestamp without time zone,
                data_hora_importado_prolog    timestamp without time zone,
                km_veiculo_momento_realizacao bigint,
                duracao_realizacao_millis     bigint,
                cpf_colaborador               bigint,
                placa_veiculo                 text,
                tipo_checklist                character,
                nome_colaborador              text,
                total_itens_ok                smallint,
                total_itens_nok               smallint
            )
    language plpgsql
as
$$
DECLARE
    F_HAS_DATA_INICIAL INTEGER := CASE WHEN F_DATA_INICIAL IS NULL THEN 1 ELSE 0 END;
    F_HAS_DATA_FINAL   INTEGER := CASE WHEN F_DATA_FINAL IS NULL THEN 1 ELSE 0 END;
BEGIN
    RETURN QUERY
        SELECT C.CODIGO                                             AS COD_CHECKLIST,
               C.COD_CHECKLIST_MODELO                               AS COD_CHECKLIST_MODELO,
               C.COD_VERSAO_CHECKLIST_MODELO                        AS COD_VERSAO_CHECKLIST_MODELO,
               C.DATA_HORA AT TIME ZONE F_TIMEZONE                  AS DATA_HORA_REALIZACAO,
               C.DATA_HORA_IMPORTADO_PROLOG AT TIME ZONE F_TIMEZONE AS DATA_HORA_IMPORTADO_PROLOG,
               C.KM_VEICULO                                         AS KM_VEICULO_MOMENTO_REALIZACAO,
               C.TEMPO_REALIZACAO                                   AS DURACAO_REALIZACAO_MILLIS,
               C.CPF_COLABORADOR                                    AS CPF_COLABORADOR,
               C.PLACA_VEICULO :: TEXT                              AS PLACA_VEICULO,
               C.TIPO                                               AS TIPO_CHECKLIST,
               CO.NOME :: TEXT                                      AS NOME_COLABORADOR,
               C.TOTAL_PERGUNTAS_OK                                 AS TOTAL_ITENS_OK,
               C.TOTAL_PERGUNTAS_NOK                                AS TOTAL_ITENS_NOK
        FROM CHECKLIST C
                 JOIN COLABORADOR CO
                      ON CO.CPF = C.CPF_COLABORADOR
        WHERE C.CPF_COLABORADOR = F_CPF_COLABORADOR
          AND (F_HAS_DATA_INICIAL = 1 OR (C.DATA_HORA AT TIME ZONE F_TIMEZONE) :: DATE >= F_DATA_INICIAL)
          AND (F_HAS_DATA_FINAL = 1 OR (C.DATA_HORA AT TIME ZONE F_TIMEZONE) :: DATE <= F_DATA_FINAL)
        ORDER BY C.DATA_HORA DESC
        LIMIT F_LIMIT
            OFFSET F_OFFSET;
END;
$$;

create or replace function suporte.func_veiculo_altera_tipo_veiculo(f_placa_veiculo text,
                                                                    f_cod_veiculo_tipo_novo bigint,
                                                                    f_cod_unidade bigint,
                                                                    OUT aviso_tipo_veiculo_alterado text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_DIAGRAMA_NOVO BIGINT := (SELECT VT.COD_DIAGRAMA
                                   FROM VEICULO_TIPO VT
                                   WHERE VT.CODIGO = F_COD_VEICULO_TIPO_NOVO);
    F_COD_EMPRESA       BIGINT := (SELECT U.COD_EMPRESA
                                   FROM UNIDADE U
                                   WHERE U.CODIGO = F_COD_UNIDADE);

BEGIN
    -- Garante que unidade/empresa existem
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    -- Garante que veiculo existe e pertence a unidade
    PERFORM FUNC_GARANTE_VEICULO_EXISTE(F_COD_UNIDADE, F_PLACA_VEICULO);

    -- Verifica se veículo não está deletado (a function FUNC_GARANTE_VEICULO_EXISTE, utiliza a veiculo_data, portanto
    -- também trás veículos deletados em sua consulta)
    IF EXISTS(SELECT VD.PLACA FROM VEICULO_DATA VD WHERE VD.PLACA = F_PLACA_VEICULO AND VD.DELETADO = TRUE)
    THEN
        RAISE EXCEPTION
            'O veículo consta como deletado, placa: %, código da unidade: %.' , F_PLACA_VEICULO,
            (SELECT VD.COD_UNIDADE FROM VEICULO_DATA VD WHERE VD.PLACA = F_PLACA_VEICULO);
    END IF;

    -- Garante que tipo_veiculo_novo pertence a empresa
    IF NOT EXISTS(SELECT VT.CODIGO
                  FROM VEICULO_TIPO VT
                  WHERE VT.CODIGO = F_COD_VEICULO_TIPO_NOVO
                    AND VT.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION
            'O tipo de veículo de código: % Não pertence à empresa: %',
            F_COD_VEICULO_TIPO_NOVO,
            F_COD_EMPRESA;
    END IF;

    -- Verifica se o tipo_veiculo_novo é o atual
    IF EXISTS(SELECT V.CODIGO FROM VEICULO V WHERE V.PLACA = F_PLACA_VEICULO AND V.COD_TIPO = F_COD_VEICULO_TIPO_NOVO)
    THEN
        RAISE EXCEPTION
            'O tipo de veículo atual da placa % é igual ao informado. Código tipo de veículo: %',
            F_PLACA_VEICULO,
            F_COD_VEICULO_TIPO_NOVO;
    END IF;

    -- Verifica se placa tem pneus aplicados
    IF EXISTS(SELECT VP.PLACA FROM VEICULO_PNEU VP WHERE VP.PLACA = F_PLACA_VEICULO)
    THEN
        -- Se existirem pneus, verifica se os pneus que estão aplicados possuem as mesmas posições do novo tipo
        IF ((SELECT ARRAY_AGG(VP.POSICAO)
             FROM VEICULO_PNEU VP
             WHERE VP.PLACA = F_PLACA_VEICULO) <@
            (SELECT ARRAY_AGG(VDPP.POSICAO_PROLOG :: INTEGER)
             FROM VEICULO_DIAGRAMA_POSICAO_PROLOG VDPP
             WHERE COD_DIAGRAMA = F_COD_DIAGRAMA_NOVO) = FALSE)
        THEN
            RAISE EXCEPTION
                'Existem pneus aplicados em posições que não fazem parte do tipo de veículo de código: %',
                F_COD_VEICULO_TIPO_NOVO;
        END IF;
    END IF;

    -- Realiza a mudança de tipo
    UPDATE VEICULO_DATA
    SET COD_TIPO = F_COD_VEICULO_TIPO_NOVO
    WHERE PLACA = F_PLACA_VEICULO
      AND COD_UNIDADE = F_COD_UNIDADE;

    --MENSAGEM DE SUCESSO.
    SELECT 'Tipo do veículo alterado! Placa: ' || F_PLACA_VEICULO ||
           ', Código da unidade: ' || F_COD_UNIDADE ||
           ', Tipo: ' || (SELECT VT.NOME FROM VEICULO_TIPO VT WHERE VT.CODIGO = F_COD_VEICULO_TIPO_NOVO) ||
           ', Código do tipo: ' || F_COD_VEICULO_TIPO_NOVO || '.'
    INTO AVISO_TIPO_VEICULO_ALTERADO;
END;

$$;

create or replace function integracao.func_pneu_deleta_servicos_movimentacao_pneu(f_cod_pneu_prolog bigint, f_data_hora_delecao timestamp with time zone) returns void
    language plpgsql
as
$$
DECLARE
    -- Códigos dos serviços que estão pendentes e deverão ser deletados.
    COD_SERVICOS_PARA_DELETAR CONSTANT BIGINT[] := ARRAY(SELECT PSRD.CODIGO
                                                         FROM PUBLIC.PNEU_SERVICO_REALIZADO_DATA PSRD
                                                         WHERE PSRD.DELETADO = FALSE
                                                           AND PSRD.COD_PNEU = F_COD_PNEU_PROLOG);
BEGIN
    -- Deleta lógicamente incrementos de vida para o pneu.
    UPDATE PUBLIC.PNEU_SERVICO_REALIZADO_INCREMENTA_VIDA_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = F_DATA_HORA_DELECAO,
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE DELETADO = FALSE
      AND COD_SERVICO_REALIZADO = ANY (COD_SERVICOS_PARA_DELETAR);

    -- Deleta lógicamente vínculo entre serviço e recapadora que realizou o servico, para o pneu.
    UPDATE PUBLIC.MOVIMENTACAO_PNEU_SERVICO_REALIZADO_RECAPADORA_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = F_DATA_HORA_DELECAO,
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_SERVICO_REALIZADO_MOVIMENTACAO = ANY (COD_SERVICOS_PARA_DELETAR);

    -- Deleta lógicamente vinculo entre serviço e movimentação de origem do serviço, para o pneu.
    UPDATE PUBLIC.MOVIMENTACAO_PNEU_SERVICO_REALIZADO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = F_DATA_HORA_DELECAO,
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_SERVICO_REALIZADO = ANY (COD_SERVICOS_PARA_DELETAR);

    -- Deleta lógicamente os serviços realizados no pneu.
    UPDATE PUBLIC.PNEU_SERVICO_REALIZADO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = F_DATA_HORA_DELECAO,
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = ANY (COD_SERVICOS_PARA_DELETAR);

    -- Deleta lógicamente os serviços de cadastro realizados no pneu.
    UPDATE PUBLIC.PNEU_SERVICO_CADASTRO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = F_DATA_HORA_DELECAO,
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_PNEU = F_COD_PNEU_PROLOG;
END;
$$;

create or replace function integracao.func_pneu_fecha_servico_pneu_automaticamente(f_cod_pneu_prolog bigint,
                                                                                   f_data_hora_resolucao timestamp with time zone) returns void
    language plpgsql
as
$$
BEGIN
    UPDATE PUBLIC.AFERICAO_MANUTENCAO
    SET KM_MOMENTO_CONSERTO                  = 0, -- Zero pois no fechamento automatico não há o input de KM
        DATA_HORA_RESOLUCAO                  = F_DATA_HORA_RESOLUCAO,
        FECHADO_AUTOMATICAMENTE_MOVIMENTACAO = FALSE,
        FECHADO_AUTOMATICAMENTE_INTEGRACAO   = TRUE
    WHERE COD_PNEU = F_COD_PNEU_PROLOG
      AND DATA_HORA_RESOLUCAO IS NULL;
END;
$$;

create or replace function integracao.func_pneu_sobrescreve_pneu_cadastrado(f_cod_pneu_prolog bigint,
                                                                            f_cod_unidade_pneu bigint,
                                                                            f_cod_modelo_pneu bigint,
                                                                            f_cod_dimensao_pneu bigint,
                                                                            f_pressao_correta_pneu double precision,
                                                                            f_vida_atual_pneu integer,
                                                                            f_vida_total_pneu integer,
                                                                            f_dot_pneu character varying,
                                                                            f_valor_pneu numeric,
                                                                            f_pneu_novo_nunca_rodado boolean,
                                                                            f_cod_modelo_banda_pneu bigint,
                                                                            f_valor_banda_pneu numeric,
                                                                            f_data_hora_pneu_cadastro timestamp with time zone) returns void
    language plpgsql
as
$$
DECLARE
    PNEU_PRIMEIRA_VIDA CONSTANT BIGINT := 1;
    COD_UNIDADE_ATUAL_PNEU      BIGINT;
    VIDA_ATUAL_PNEU             BIGINT;
BEGIN
    SELECT P.COD_UNIDADE, P.VIDA_ATUAL
    FROM PNEU P
    WHERE P.CODIGO = F_COD_PNEU_PROLOG
    INTO COD_UNIDADE_ATUAL_PNEU, VIDA_ATUAL_PNEU;

    -- Devemos remover o vínculo do pneu com qualquer placa. Se o pneu não está aplicado, nada vai acontecer.
    DELETE FROM VEICULO_PNEU VP WHERE VP.COD_PNEU = F_COD_PNEU_PROLOG;

    -- Devemos tratar os serviços abertos para o pneu (setar fechado_integracao), apenas se a unidade mudar.
    IF (COD_UNIDADE_ATUAL_PNEU <> F_COD_UNIDADE_PNEU)
    THEN
        PERFORM INTEGRACAO.FUNC_PNEU_FECHA_SERVICO_PNEU_AUTOMATICAMENTE(F_COD_PNEU_PROLOG,
                                                                        F_DATA_HORA_PNEU_CADASTRO);
    END IF;

    -- Devemos deletar os serviços realizados para o pneu (recapagens, consertos). Apenas se não for a mesma vida.
    IF (VIDA_ATUAL_PNEU <> F_VIDA_ATUAL_PNEU)
    THEN
        -- Deleta todos os serviços do pneu.
        PERFORM INTEGRACAO.FUNC_PNEU_DELETA_SERVICOS_MOVIMENTACAO_PNEU(F_COD_PNEU_PROLOG,
                                                                       F_DATA_HORA_PNEU_CADASTRO);

        -- Apenas cadastramos um serviço de nova vida caso o pneu não esteja na primeira vida.
        IF (F_VIDA_ATUAL_PNEU > PNEU_PRIMEIRA_VIDA)
        THEN
            -- Como deletamos todos os serviços e o pneu não está na primeira vida, cadastramos o serviço referente a
            -- vida atual do pneu.
            PERFORM INTEGRACAO.FUNC_PNEU_REALIZA_INCREMENTO_VIDA_CADASTRO(F_COD_UNIDADE_PNEU,
                                                                          F_COD_PNEU_PROLOG,
                                                                          F_COD_MODELO_BANDA_PNEU,
                                                                          F_VALOR_BANDA_PNEU,
                                                                          F_VIDA_ATUAL_PNEU);
        END IF;
    ELSE
        -- Se as vidas são iguais, apenas iremos atualizar as informações da banda e custo no serviço já realizado.
        PERFORM PUBLIC.FUNC_PNEUS_UPDATE_BANDA_PNEU(F_COD_PNEU_PROLOG, F_COD_MODELO_BANDA_PNEU, F_VALOR_BANDA_PNEU);
    END IF;

    -- Devemos mudar o status do pneu para ESTOQUE e atualizar as informações do pneu.
    UPDATE PUBLIC.PNEU
    SET STATUS                 = 'ESTOQUE',
        COD_UNIDADE            = F_COD_UNIDADE_PNEU,
        COD_MODELO             = F_COD_MODELO_PNEU,
        COD_DIMENSAO           = F_COD_DIMENSAO_PNEU,
        PRESSAO_RECOMENDADA    = F_PRESSAO_CORRETA_PNEU,
        VIDA_ATUAL             = F_VIDA_ATUAL_PNEU,
        VIDA_TOTAL             = F_VIDA_TOTAL_PNEU,
        DOT                    = F_DOT_PNEU,
        VALOR                  = F_VALOR_PNEU,
        PNEU_NOVO_NUNCA_RODADO = F_PNEU_NOVO_NUNCA_RODADO,
        COD_MODELO_BANDA       = F_IF(F_COD_MODELO_BANDA_PNEU IS NULL, NULL, F_COD_MODELO_BANDA_PNEU)
    WHERE CODIGO = F_COD_PNEU_PROLOG;
END;
$$;

create or replace function integracao.func_pneu_insere_pneu_prolog(f_cod_pneu_sistema_integrado bigint,
                                                                   f_codigo_pneu_cliente character varying,
                                                                   f_cod_unidade_pneu bigint, f_cod_modelo_pneu bigint,
                                                                   f_cod_dimensao_pneu bigint,
                                                                   f_pressao_correta_pneu double precision,
                                                                   f_vida_atual_pneu integer, f_vida_total_pneu integer,
                                                                   f_dot_pneu character varying, f_valor_pneu numeric,
                                                                   f_pneu_novo_nunca_rodado boolean,
                                                                   f_cod_modelo_banda_pneu bigint,
                                                                   f_valor_banda_pneu numeric,
                                                                   f_data_hora_pneu_cadastro timestamp with time zone,
                                                                   f_token_integracao character varying,
                                                                   f_deve_sobrescrever_pneu boolean DEFAULT false) returns bigint
    language plpgsql
as
$$
DECLARE
    PNEU_PRIMEIRA_VIDA CONSTANT  BIGINT  := 1;
    PNEU_STATUS_ESTOQUE CONSTANT TEXT    := 'ESTOQUE';
    PNEU_POSSUI_BANDA CONSTANT   BOOLEAN := F_IF(F_VIDA_ATUAL_PNEU > PNEU_PRIMEIRA_VIDA, TRUE, FALSE);
    COD_EMPRESA_PNEU CONSTANT    BIGINT  := (SELECT TI.COD_EMPRESA
                                             FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                             WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    PNEU_ESTA_NO_PROLOG CONSTANT BOOLEAN := (SELECT EXISTS(SELECT P.CODIGO
                                                           FROM PUBLIC.PNEU P
                                                           WHERE P.CODIGO_CLIENTE = F_CODIGO_PNEU_CLIENTE
                                                             AND P.COD_EMPRESA = COD_EMPRESA_PNEU));
    COD_PNEU_PROLOG              BIGINT;
    F_QTD_ROWS_AFETADAS          BIGINT;
BEGIN
    -- Validamos se a Empresa existe.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_PNEU,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    -- Validamos se a Unidade repassada existe.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE_PNEU,
                                        FORMAT('A Unidade %s repassada não existe no Sistema ProLog',
                                               F_COD_UNIDADE_PNEU));

    -- Validamos se a Unidade pertence a Empresa do token repassado.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(COD_EMPRESA_PNEU,
                                                F_COD_UNIDADE_PNEU,
                                                FORMAT('A Unidade %s não está configurada para esta empresa',
                                                       F_COD_UNIDADE_PNEU));

    -- Validamos se o modelo do pneu está mapeado.
    IF (SELECT NOT EXISTS(SELECT MP.CODIGO
                          FROM PUBLIC.MODELO_PNEU MP
                          WHERE MP.COD_EMPRESA = COD_EMPRESA_PNEU
                            AND MP.CODIGO = F_COD_MODELO_PNEU))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O modelo do pneu %s não está mapeado no Sistema ProLog',
                                                  F_COD_MODELO_PNEU));
    END IF;

    -- Validamos se a dimensão do pneu está mapeada.
    IF (SELECT NOT EXISTS(SELECT DP.CODIGO
                          FROM PUBLIC.DIMENSAO_PNEU DP
                          WHERE DP.CODIGO = F_COD_DIMENSAO_PNEU))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('A dimensão de código %s do pneu não está mapeada no Sistema ProLog',
                                                  F_COD_DIMENSAO_PNEU));
    END IF;

    -- Validamos se a pressão recomendada é válida.
    IF (F_PRESSAO_CORRETA_PNEU < 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('A pressão recomendada para o pneu não pode ser um número negativo');
    END IF;

    -- Validamos se a vida atual é correta.
    IF (F_VIDA_ATUAL_PNEU < PNEU_PRIMEIRA_VIDA)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('A vida atual do pneu deve ser no mínimo 1 (caso novo)');
    END IF;

    -- Validamos se a vida total é válida.
    IF (F_VIDA_TOTAL_PNEU < F_VIDA_ATUAL_PNEU)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('A vida total do pneu não pode ser menor que a vida atual');
    END IF;

    -- Validamos se o valor do pneu é um valor válido.
    IF (F_VALOR_PNEU < 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor do pneu não pode ser um número negativo');
    END IF;

    -- Validamos se o código do modelo de banda é válido. Apenas validamos se o pneu possuir banda.
    IF (PNEU_POSSUI_BANDA AND F_COD_MODELO_BANDA_PNEU IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT(
                'O pneu %s não está na primeira vida, deve ser informado um modelo de banda',
                F_COD_PNEU_SISTEMA_INTEGRADO));
    END IF;

    -- Validamos se o código do modelo da banda é válido. Apenas validamos se o pneu possuir banda.
    IF (PNEU_POSSUI_BANDA AND (SELECT NOT EXISTS(SELECT MB.CODIGO
                                                 FROM PUBLIC.MODELO_BANDA MB
                                                 WHERE MB.COD_EMPRESA = COD_EMPRESA_PNEU
                                                   AND MB.CODIGO = F_COD_MODELO_BANDA_PNEU)))
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O modelo da banda %s do pneu não está mapeado no Sistema ProLog',
                                                  F_COD_MODELO_BANDA_PNEU));
    END IF;

    -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
    IF (PNEU_POSSUI_BANDA AND F_VALOR_BANDA_PNEU IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        'O pneu não está na primeira vida, deve ser informado o valor da banda aplicada');
    END IF;

    -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
    IF (PNEU_POSSUI_BANDA AND F_VALOR_BANDA_PNEU < 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da banda do pneu não pode ser um número negativo');
    END IF;

    -- Validamos se o código do sistema integrado já está mapeado na tabela, apenas se não estiver devemos sobrescrever.
    -- Pode acontecer o caso onde o pneu está na base do ProLog e é rodado a sobrecarga. Neste cenário o pneu deve
    -- apenas ter as informações sobrescritas e a tabela de vínculo atualizada.
    IF (SELECT EXISTS(SELECT PC.COD_PNEU_CADASTRO_PROLOG
                      FROM INTEGRACAO.PNEU_CADASTRADO PC
                      WHERE PC.COD_PNEU_SISTEMA_INTEGRADO = F_COD_PNEU_SISTEMA_INTEGRADO
                        AND PC.COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU) AND NOT F_DEVE_SOBRESCREVER_PNEU)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O pneu de código interno %s já está cadastrado no Sistema ProLog',
                                                  F_COD_PNEU_SISTEMA_INTEGRADO));
    END IF;

    -- Já validamos se o pneu existe no ProLog através código do sistema integrado, então sobrescrevemos as
    -- informações dele ou, caso não deva sobrescrever, inserimos no base. Validamos também se o pneu já está na base
    -- do ProLog, caso ele não esteja, deveremos inserir e não sobrescrever.
    IF (PNEU_ESTA_NO_PROLOG AND F_DEVE_SOBRESCREVER_PNEU)
    THEN
        -- Pegamos o código do pneu que iremos sobrescrever.
        SELECT P.CODIGO
        FROM PUBLIC.PNEU P
        WHERE P.CODIGO_CLIENTE = F_CODIGO_PNEU_CLIENTE
          AND P.COD_EMPRESA = COD_EMPRESA_PNEU
        INTO COD_PNEU_PROLOG;

        -- Sebrescrevemos os dados do pneu.
        PERFORM INTEGRACAO.FUNC_PNEU_SOBRESCREVE_PNEU_CADASTRADO(COD_PNEU_PROLOG,
                                                                 F_COD_UNIDADE_PNEU,
                                                                 F_COD_MODELO_PNEU,
                                                                 F_COD_DIMENSAO_PNEU,
                                                                 F_PRESSAO_CORRETA_PNEU,
                                                                 F_VIDA_ATUAL_PNEU,
                                                                 F_VIDA_TOTAL_PNEU,
                                                                 F_DOT_PNEU,
                                                                 F_VALOR_PNEU,
                                                                 F_PNEU_NOVO_NUNCA_RODADO,
                                                                 F_COD_MODELO_BANDA_PNEU,
                                                                 F_VALOR_BANDA_PNEU,
                                                                 F_DATA_HORA_PNEU_CADASTRO);
    ELSEIF (NOT PNEU_ESTA_NO_PROLOG)
    THEN
        -- Deveremos inserir os dados na base.
        INSERT INTO PUBLIC.PNEU(COD_EMPRESA,
                                COD_UNIDADE_CADASTRO,
                                COD_UNIDADE,
                                CODIGO_CLIENTE,
                                COD_MODELO,
                                COD_DIMENSAO,
                                PRESSAO_RECOMENDADA,
                                PRESSAO_ATUAL,
                                ALTURA_SULCO_INTERNO,
                                ALTURA_SULCO_CENTRAL_INTERNO,
                                ALTURA_SULCO_CENTRAL_EXTERNO,
                                ALTURA_SULCO_EXTERNO,
                                STATUS,
                                VIDA_ATUAL,
                                VIDA_TOTAL,
                                DOT,
                                VALOR,
                                COD_MODELO_BANDA,
                                PNEU_NOVO_NUNCA_RODADO,
                                DATA_HORA_CADASTRO)
        VALUES (COD_EMPRESA_PNEU,
                F_COD_UNIDADE_PNEU,
                F_COD_UNIDADE_PNEU,
                F_CODIGO_PNEU_CLIENTE,
                F_COD_MODELO_PNEU,
                F_COD_DIMENSAO_PNEU,
                F_PRESSAO_CORRETA_PNEU,
                0, -- PRESSAO_ATUAL
                NULL, -- ALTURA_SULCO_INTERNO
                NULL, -- ALTURA_SULCO_CENTRAL_INTERNO
                NULL, -- ALTURA_SULCO_CENTRAL_EXTERNO
                NULL, -- ALTURA_SULCO_EXTERNO
                PNEU_STATUS_ESTOQUE,
                F_VIDA_ATUAL_PNEU,
                F_VIDA_TOTAL_PNEU,
                F_DOT_PNEU,
                F_VALOR_PNEU,
                F_IF(PNEU_POSSUI_BANDA, F_COD_MODELO_BANDA_PNEU, NULL),
                F_IF(PNEU_POSSUI_BANDA, FALSE, F_PNEU_NOVO_NUNCA_RODADO), -- Forçamos FALSE caso o pneu já possua uma banda aplicada.
                F_DATA_HORA_PNEU_CADASTRO) RETURNING CODIGO INTO COD_PNEU_PROLOG;

        -- Precisamos criar um serviço de incremento de vida para o pneu cadastrado já possuíndo uma banda.
        IF (PNEU_POSSUI_BANDA)
        THEN
            PERFORM INTEGRACAO.FUNC_PNEU_REALIZA_INCREMENTO_VIDA_CADASTRO(F_COD_UNIDADE_PNEU,
                                                                          COD_PNEU_PROLOG,
                                                                          F_COD_MODELO_BANDA_PNEU,
                                                                          F_VALOR_BANDA_PNEU,
                                                                          F_VIDA_ATUAL_PNEU);
        END IF;
    ELSE
        -- Pneu está no ProLog e não deve sobrescrever.
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('O pneu %s já está cadastrado no Sistema ProLog', F_CODIGO_PNEU_CLIENTE));
    END IF;

    IF (F_DEVE_SOBRESCREVER_PNEU)
    THEN
        -- Se houve uma sobrescrita de dados, então tentamos inserir, caso a constraint estourar,
        -- apenas atualizamos os dados. Tentamos inserir antes, pois, em cenários onde o pneu já encontra-se no ProLog,
        -- não temos nenhuma entrada para ele na tabela de mapeamento.
        INSERT INTO INTEGRACAO.PNEU_CADASTRADO(COD_PNEU_CADASTRO_PROLOG,
                                               COD_PNEU_SISTEMA_INTEGRADO,
                                               COD_EMPRESA_CADASTRO,
                                               COD_UNIDADE_CADASTRO,
                                               COD_CLIENTE_PNEU_CADASTRO,
                                               TOKEN_AUTENTICACAO_CADASTRO,
                                               DATA_HORA_CADASTRO_PROLOG)
        VALUES (COD_PNEU_PROLOG,
                F_COD_PNEU_SISTEMA_INTEGRADO,
                COD_EMPRESA_PNEU,
                F_COD_UNIDADE_PNEU,
                F_CODIGO_PNEU_CLIENTE,
                F_TOKEN_INTEGRACAO,
                F_DATA_HORA_PNEU_CADASTRO)
        ON CONFLICT ON CONSTRAINT UNIQUE_PNEU_CADASTRADO_EMPRESA_INTEGRACAO
            DO UPDATE SET COD_PNEU_SISTEMA_INTEGRADO  = F_COD_PNEU_SISTEMA_INTEGRADO,
                          COD_UNIDADE_CADASTRO        = F_COD_UNIDADE_PNEU,
                          TOKEN_AUTENTICACAO_CADASTRO = F_TOKEN_INTEGRACAO,
                          DATA_HORA_ULTIMA_EDICAO     = F_DATA_HORA_PNEU_CADASTRO;
    ELSE
        -- Se não houve sobrescrita de dados, significa que devemos apenas inserir os dados na tabela de mapeamento e
        -- deixar um erro estourar caso pneu já exista.
        INSERT INTO INTEGRACAO.PNEU_CADASTRADO(COD_PNEU_CADASTRO_PROLOG,
                                               COD_PNEU_SISTEMA_INTEGRADO,
                                               COD_EMPRESA_CADASTRO,
                                               COD_UNIDADE_CADASTRO,
                                               COD_CLIENTE_PNEU_CADASTRO,
                                               TOKEN_AUTENTICACAO_CADASTRO,
                                               DATA_HORA_CADASTRO_PROLOG)
        VALUES (COD_PNEU_PROLOG,
                F_COD_PNEU_SISTEMA_INTEGRADO,
                COD_EMPRESA_PNEU,
                F_COD_UNIDADE_PNEU,
                F_CODIGO_PNEU_CLIENTE,
                F_TOKEN_INTEGRACAO,
                F_DATA_HORA_PNEU_CADASTRO);
    END IF;

    GET DIAGNOSTICS F_QTD_ROWS_AFETADAS = ROW_COUNT;

    -- Verificamos se a inserção na tabela de mapeamento ocorreu com sucesso.
    IF (F_QTD_ROWS_AFETADAS <= 0)
    THEN
        RAISE EXCEPTION
            'Não foi possível inserir o pneu "%" na tabela de mapeamento', F_CODIGO_PNEU_CLIENTE;
    END IF;

    RETURN COD_PNEU_PROLOG;
END;
$$;

create or replace function integracao.func_empresa_get_config_sobrescreve_pneus(f_cod_empresa bigint) returns boolean
    language sql
as
$$
SELECT F_IF(SOBRESCREVE_PNEUS IS NULL, FALSE, SOBRESCREVE_PNEUS) AS SOBRESCREVE_PNEUS
FROM INTEGRACAO.EMPRESA_CONFIG_CARGA_INICIAL
WHERE COD_EMPRESA = F_COD_EMPRESA;
$$;

create or replace function integracao.func_empresa_get_config_sobrescreve_veiculos(f_cod_empresa bigint) returns boolean
    language sql
as
$$
SELECT F_IF(SOBRESCREVE_VEICULOS IS NULL, FALSE, SOBRESCREVE_VEICULOS) AS SOBRESCREVE_VEICULOS
FROM INTEGRACAO.EMPRESA_CONFIG_CARGA_INICIAL
WHERE COD_EMPRESA = F_COD_EMPRESA;
$$;

create or replace function integracao.func_pneu_remove_vinculo_pneu_placa_posicao_by_placa(f_placa_veiculo text) returns void
    language plpgsql
as
$$
DECLARE
    COD_PNEUS_PARA_ATUALIZAR BIGINT[] := (SELECT ARRAY_AGG(COD_PNEU)
                                          FROM PUBLIC.VEICULO_PNEU
                                          WHERE PLACA = F_PLACA_VEICULO);
BEGIN
    DELETE
    FROM PUBLIC.VEICULO_PNEU
    WHERE PLACA = F_PLACA_VEICULO;

    UPDATE PUBLIC.PNEU
    SET STATUS = 'ESTOQUE'
    WHERE CODIGO = ANY (COD_PNEUS_PARA_ATUALIZAR);
END;
$$;

create or replace function integracao.func_veiculo_deleta_servicos_abertos_placa(f_placa_veiculo bigint, f_cod_unidade bigint) returns void
    language plpgsql
as
$$
DECLARE
    COD_SERVICOS_PARA_DELETAR CONSTANT   BIGINT[] := (SELECT ARRAY_AGG(COSI.CODIGO)
                                                      FROM CHECKLIST_ORDEM_SERVICO COS
                                                               JOIN CHECKLIST C ON COS.COD_CHECKLIST = C.CODIGO
                                                               JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                                                    ON COS.CODIGO = COSI.COD_OS
                                                                        AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                                                      WHERE C.PLACA_VEICULO = F_PLACA_VEICULO
                                                        AND COSI.STATUS_RESOLUCAO = 'P'
                                                        AND COSI.COD_UNIDADE = F_COD_UNIDADE);
    -- Usamos o 'DISTINCT' para não repetir o 'cod_os' no array gerado.
    COD_ORDENS_SERVICO_ANALISAR CONSTANT BIGINT[] := (SELECT ARRAY_AGG(DISTINCT COD_OS)
                                                      FROM CHECKLIST_ORDEM_SERVICO_ITENS
                                                      WHERE CODIGO IN (COD_SERVICOS_PARA_DELETAR));
BEGIN
    -- Aqui deletamos os ITENS que estão pendentes de resolução na placa informada.
    UPDATE PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO IN (COD_SERVICOS_PARA_DELETAR);

    -- Após deletarmos os itens, varremos as OSs para saber se alguma das OSs que tiveram seus itens deletados estão
    -- vazias, se estiverem vazias (count() = 0) então deletamos também.
    -- The secret key:
    -- O segredo para esse update funcionar está em utilizar a view 'checklist_ordem_servico_itens' e não filtrar
    -- por status dos itens, pois assim saberemos se após deletar lógicamente os itens na query anterior, a OS se
    -- mantem com algum item dentro dela, seja pendente ou resolvido. Caso tiver, não devemos deletar.
    UPDATE PUBLIC.CHECKLIST_ORDEM_SERVICO_DATA COSD
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COSD.COD_UNIDADE = F_COD_UNIDADE
      AND NOT DELETADO -- Se já está deletada, não nos interessa.
      AND COSD.CODIGO IN (COD_ORDENS_SERVICO_ANALISAR)
      AND ((SELECT COUNT(COSI.CODIGO)
            FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
            WHERE COSI.COD_OS = COSD.CODIGO
              AND COSI.COD_UNIDADE = F_COD_UNIDADE) = 0);

    -- Pode acontecer um cenário onde a OS tenha 2 itens, um resolvido e um pendente. Neste cenário a OS está aberta,
    -- ao deletar o item pendente, devemos fechar a OS e inserir a data de fechamento como a data do último item
    -- resolvido.
    -- The secret key:
    -- O segredo aqui esta em usar a view 'checklist_ordem_servico' para realizar o update, pois ela já não trará as
    -- OSs que foram deletados na query acima. Bastando verificar se a OS não tem nenhum item pendente, para esses
    -- casos buscamos a maior 'data_hora_conserto' e usamos ela para fechar a OS.
    UPDATE PUBLIC.CHECKLIST_ORDEM_SERVICO AS COS
    SET STATUS               = 'F',
        DATA_HORA_FECHAMENTO = (SELECT MAX(COSI.DATA_HORA_CONSERTO)
                                FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                WHERE COSI.COD_OS = COS.CODIGO
                                  AND COSI.COD_UNIDADE = COS.COD_UNIDADE)
    WHERE COS.COD_UNIDADE = F_COD_UNIDADE
      AND COS.CODIGO IN (COD_ORDENS_SERVICO_ANALISAR)
      AND COS.STATUS = 'A'
      AND ((SELECT COUNT(COSI.CODIGO)
            FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
            WHERE COSI.COD_OS = COS.CODIGO
              AND COSI.COD_UNIDADE = F_COD_UNIDADE
              AND COSI.STATUS_RESOLUCAO = 'P') = 0);
END;
$$;

create or replace function integracao.func_veiculo_sobrescreve_veiculo_cadastrado(f_placa_veiculo text,
                                                                                  f_cod_unidade_veiculo bigint,
                                                                                  f_km_atual_veiculo bigint,
                                                                                  f_cod_tipo_veiculo bigint,
                                                                                  f_cod_modelo_veiculo bigint) returns void
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_VEICULO CONSTANT       BIGINT := (SELECT COD_EMPRESA
                                                  FROM UNIDADE
                                                  WHERE CODIGO = F_COD_UNIDADE_VEICULO);
    COD_UNIDADE_ATUAL_VEICULO CONSTANT BIGINT := (SELECT COD_UNIDADE
                                                  FROM PUBLIC.VEICULO
                                                  WHERE PLACA = F_PLACA_VEICULO
                                                    AND COD_EMPRESA = COD_EMPRESA_VEICULO);
BEGIN
    -- Devemos tratar os serviços abertos para o veículo (setar fechado_integracao), apenas se a unidade mudar.
    IF (COD_UNIDADE_ATUAL_VEICULO <> F_COD_UNIDADE_VEICULO)
    THEN
        PERFORM INTEGRACAO.FUNC_VEICULO_DELETA_SERVICOS_ABERTOS_PLACA(F_PLACA_VEICULO,
                                                                      F_COD_UNIDADE_VEICULO);
    END IF;

    UPDATE PUBLIC.VEICULO
    SET COD_UNIDADE = F_COD_UNIDADE_VEICULO,
        KM          = F_KM_ATUAL_VEICULO,
        COD_TIPO    = F_COD_TIPO_VEICULO,
        COD_MODELO  = F_COD_MODELO_VEICULO
    WHERE PLACA = F_PLACA_VEICULO
      AND COD_EMPRESA = COD_EMPRESA_VEICULO;
END;
$$;

create or replace function integracao.func_veiculo_deleta_servicos_abertos_placa(f_placa_veiculo text, f_cod_unidade bigint) returns void
    language plpgsql
as
$$
DECLARE
    COD_SERVICOS_PARA_DELETAR CONSTANT   BIGINT[] := (SELECT ARRAY_AGG(COSI.CODIGO)
                                                      FROM CHECKLIST_ORDEM_SERVICO COS
                                                               JOIN CHECKLIST C ON COS.COD_CHECKLIST = C.CODIGO
                                                               JOIN CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                                                    ON COS.CODIGO = COSI.COD_OS
                                                                        AND COS.COD_UNIDADE = COSI.COD_UNIDADE
                                                      WHERE C.PLACA_VEICULO = F_PLACA_VEICULO
                                                        AND COSI.STATUS_RESOLUCAO = 'P'
                                                        AND COSI.COD_UNIDADE = F_COD_UNIDADE);
    -- Usamos o 'DISTINCT' para não repetir o 'cod_os' no array gerado.
    COD_ORDENS_SERVICO_ANALISAR CONSTANT BIGINT[] := (SELECT ARRAY_AGG(DISTINCT COD_OS)
                                                      FROM CHECKLIST_ORDEM_SERVICO_ITENS
                                                      WHERE CODIGO = ANY (COD_SERVICOS_PARA_DELETAR));
BEGIN
    -- Aqui deletamos os ITENS que estão pendentes de resolução na placa informada.
    UPDATE PUBLIC.CHECKLIST_ORDEM_SERVICO_ITENS_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE CODIGO = ANY (COD_SERVICOS_PARA_DELETAR);
    -- Após deletarmos os itens, varremos as OSs para saber se alguma das OSs que tiveram seus itens deletados estão
    -- vazias, se estiverem vazias (count() = 0) então deletamos também.
    -- The secret key:
    -- O segredo para esse update funcionar está em utilizar a view 'checklist_ordem_servico_itens' e não filtrar
    -- por status dos itens, pois assim saberemos se após deletar lógicamente os itens na query anterior, a OS se
    -- mantem com algum item dentro dela, seja pendente ou resolvido. Caso tiver, não devemos deletar.
    UPDATE PUBLIC.CHECKLIST_ORDEM_SERVICO_DATA COSD
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COSD.COD_UNIDADE = F_COD_UNIDADE
      AND NOT DELETADO -- Se já está deletada, não nos interessa.
      AND COSD.CODIGO = ANY (COD_ORDENS_SERVICO_ANALISAR)
      AND ((SELECT COUNT(COSI.CODIGO)
            FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
            WHERE COSI.COD_OS = COSD.CODIGO
              AND COSI.COD_UNIDADE = F_COD_UNIDADE) = 0);
    -- Pode acontecer um cenário onde a OS tenha 2 itens, um resolvido e um pendente. Neste cenário a OS está aberta,
    -- ao deletar o item pendente, devemos fechar a OS e inserir a data de fechamento como a data do último item
    -- resolvido.
    -- The secret key:
    -- O segredo aqui esta em usar a view 'checklist_ordem_servico' para realizar o update, pois ela já não trará as
    -- OSs que foram deletados na query acima. Bastando verificar se a OS não tem nenhum item pendente, para esses
    -- casos buscamos a maior 'data_hora_conserto' e usamos ela para fechar a OS.
    UPDATE PUBLIC.CHECKLIST_ORDEM_SERVICO AS COS
    SET STATUS               = 'F',
        DATA_HORA_FECHAMENTO = (SELECT MAX(COSI.DATA_HORA_CONSERTO)
                                FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
                                WHERE COSI.COD_OS = COS.CODIGO
                                  AND COSI.COD_UNIDADE = COS.COD_UNIDADE)
    WHERE COS.COD_UNIDADE = F_COD_UNIDADE
      AND COS.CODIGO = ANY (COD_ORDENS_SERVICO_ANALISAR)
      AND COS.STATUS = 'A'
      AND ((SELECT COUNT(COSI.CODIGO)
            FROM CHECKLIST_ORDEM_SERVICO_ITENS COSI
            WHERE COSI.COD_OS = COS.CODIGO
              AND COSI.COD_UNIDADE = F_COD_UNIDADE
              AND COSI.STATUS_RESOLUCAO = 'P') = 0);
END;
$$;

create or replace function integracao.func_integracao_busca_itens_os_empresa(f_cod_ultimo_item_pendente_sincronizado bigint,
                                                                             f_token_integracao text)
    returns TABLE
            (
                placa_veiculo                      text,
                km_abertura_servico                bigint,
                cod_ordem_servico                  bigint,
                cod_unidade_ordem_servico          bigint,
                status_ordem_servico               text,
                data_hora_abertura_servico         timestamp without time zone,
                cod_item_ordem_servico             bigint,
                cod_unidade_item_ordem_servico     bigint,
                data_hora_primeiro_apontamento     timestamp without time zone,
                status_item_ordem_servico          text,
                prazo_resolucao_item_horas         integer,
                qtd_apontamentos                   integer,
                cod_checklist_primeiro_apontamento bigint,
                cod_contexto_pergunta              bigint,
                descricao_pergunta                 text,
                cod_contexto_alternativa           bigint,
                descricao_alternativa              text,
                is_tipo_outros                     boolean,
                descricao_tipo_outros              text,
                prioridade_alternativa             text
            )
    language plpgsql
as
$$
DECLARE
    F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE TEXT := 'P';
BEGIN
    RETURN QUERY
        SELECT CD.PLACA_VEICULO::TEXT                               AS PLACA_VEICULO,
               CD.KM_VEICULO                                        AS KM_ABERTURA_SERVICO,
               COSD.CODIGO                                          AS COD_ORDEM_SERVICO,
               COSD.COD_UNIDADE                                     AS COD_UNIDADE_ORDEM_SERVICO,
               COSD.STATUS::TEXT                                    AS STATUS_ORDEM_SERVICO,
               CD.DATA_HORA AT TIME ZONE TZ_UNIDADE(CD.COD_UNIDADE) AS DATA_HORA_ABERTURA_SERVICO,
               COSID.CODIGO                                         AS COD_ITEM_ORDEM_SERVICO,
               COSID.COD_UNIDADE                                    AS COD_UNIDADE_ITEM_ORDEM_SERVICO,
               CD.DATA_HORA AT TIME ZONE TZ_UNIDADE(CD.COD_UNIDADE) AS DATA_HORA_PRIMEIRO_APONTAMENTO,
               COSID.STATUS_RESOLUCAO::TEXT                         AS STATUS_ITEM_ORDEM_SERVICO,
               CAP.PRAZO                                            AS PRAZO_RESOLUCAO_ITEM_HORAS,
               COSID.QT_APONTAMENTOS                                AS QTD_APONTAMENTOS,
               CD.CODIGO                                            AS COD_CHECKLIST_PRIMEIRO_APONTAMENTO,
               COSID.COD_CONTEXTO_PERGUNTA                          AS COD_CONTEXTO_PERGUNTA,
               CPD.PERGUNTA                                         AS DESCRICAO_PERGUNTA,
               COSID.COD_CONTEXTO_ALTERNATIVA                       AS COD_CONTEXTO_ALTERNATIVA,
               CAPD.ALTERNATIVA                                     AS DESCRICAO_ALTERNATIVA,
               CAPD.ALTERNATIVA_TIPO_OUTROS                         AS IS_TIPO_OUTROS,
               CASE
                   WHEN CAPD.ALTERNATIVA_TIPO_OUTROS
                       THEN
                       (SELECT CRN.RESPOSTA_OUTROS
                        FROM CHECKLIST_RESPOSTAS_NOK CRN
                        WHERE CRN.COD_CHECKLIST = CD.CODIGO
                          AND CRN.COD_ALTERNATIVA = CAPD.CODIGO)
                   ELSE
                       NULL
                   END                                              AS DESCRICAO_TIPO_OUTROS,
               CAPD.PRIORIDADE::TEXT                                AS PRIORIDADE_ALTERNATIVA
        FROM CHECKLIST_ORDEM_SERVICO_ITENS_DATA COSID
                 JOIN CHECKLIST_ORDEM_SERVICO_DATA COSD
                      ON COSID.COD_OS = COSD.CODIGO AND COSID.COD_UNIDADE = COSD.COD_UNIDADE
                 JOIN CHECKLIST_DATA CD ON COSD.COD_CHECKLIST = CD.CODIGO
                 JOIN CHECKLIST_PERGUNTAS_DATA CPD ON COSID.COD_PERGUNTA_PRIMEIRO_APONTAMENTO = CPD.CODIGO
                 JOIN CHECKLIST_ALTERNATIVA_PERGUNTA_DATA CAPD
                      ON COSID.COD_ALTERNATIVA_PRIMEIRO_APONTAMENTO = CAPD.CODIGO
                 JOIN CHECKLIST_ALTERNATIVA_PRIORIDADE CAP ON CAPD.PRIORIDADE = CAP.PRIORIDADE
        WHERE COSID.COD_UNIDADE IN (SELECT U.CODIGO
                                    FROM UNIDADE U
                                    WHERE U.COD_EMPRESA = (SELECT TI.COD_EMPRESA
                                                           FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                                           WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO))
          AND COSID.STATUS_RESOLUCAO = F_STATUS_ITEM_ORDEM_SERVICO_PENDENTE
          AND COSID.CODIGO > F_COD_ULTIMO_ITEM_PENDENTE_SINCRONIZADO
        ORDER BY COSID.CODIGO;
END;
$$;

create or replace function public.func_garante_cod_colaborador_existe(f_cod_colaborador bigint) returns void
    language plpgsql
as
$$
BEGIN
    -- VERIFICA SE O COLABORADOR EXISTE
    IF NOT EXISTS(SELECT C.CPF
                  FROM COLABORADOR C
                  WHERE C.CODIGO = F_COD_COLABORADOR)
    THEN
        RAISE EXCEPTION 'O colaborador com CÓDIGO: % não está cadastrado.', F_COD_COLABORADOR;
    END IF;
END;
$$;

create or replace function public.func_garante_integridade_empresa_cod_colaborador(f_cod_empresa bigint, f_cod_colaborador bigint) returns void
    language plpgsql
as
$$
BEGIN
    -- Verifica se colaborador existe.
    PERFORM FUNC_GARANTE_COD_COLABORADOR_EXISTE(F_COD_COLABORADOR);

    -- Verifica se empresa existe.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

    -- Verifica se o colaborador pertence à empresa.
    IF NOT EXISTS(SELECT C.CPF
                  FROM COLABORADOR C
                  WHERE C.CODIGO = F_COD_COLABORADOR
                    AND C.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        RAISE EXCEPTION 'O colaborador com o código: %, nome: %, não pertence a empresa: % - %!',
            F_COD_COLABORADOR,
                (SELECT C.NOME FROM COLABORADOR C WHERE C.CODIGO = F_COD_COLABORADOR),
            F_COD_EMPRESA,
                (SELECT E.NOME FROM EMPRESA E WHERE E.CODIGO = F_COD_EMPRESA);
    END IF;
END;
$$;

create or replace function suporte.func_checklist_copia_modelo_checklist(f_cod_modelo_checklist_copiado bigint,
                                                                         f_cod_unidade_destino_modelo_checklist bigint,
                                                                         f_cod_colaborador_solicitante_copia bigint,
                                                                         f_copiar_cargos_liberados boolean DEFAULT true,
                                                                         f_copiar_tipos_veiculos_liberados boolean DEFAULT true,
                                                                         OUT cod_modelo_checklist_inserido bigint,
                                                                         OUT aviso_modelo_inserido text) returns record
    security definer
    language plpgsql
as
$$
DECLARE
    COD_UNIDADE_MODELO_CHECKLIST_COPIADO  BIGINT;
    COD_PERGUNTA_CRIADO                   BIGINT;
    F_COD_EMPRESA                         BIGINT := (SELECT COD_EMPRESA
                                                     FROM UNIDADE
                                                     WHERE CODIGO = F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST);
    PERGUNTA_MODELO_CHECKLIST_COPIADO     CHECKLIST_PERGUNTAS_DATA%ROWTYPE;
    MODELO_VEICULO_TIPO_CHECKLIST_COPIADO CHECKLIST_MODELO_VEICULO_TIPO%ROWTYPE;
    NOME_MODELO_CHECKLIST_COPIADO         TEXT;
    COD_VERSAO_MODELO_CHECKLIST_COPIADO   BIGINT := (SELECT COD_VERSAO_ATUAL
                                                     FROM CHECKLIST_MODELO
                                                     WHERE CODIGO = F_COD_MODELO_CHECKLIST_COPIADO);
    STATUS_MODELO_CHECKLIST_COPIADO       BOOLEAN;
    NOVO_COD_VERSAO_MODELO                BIGINT;
BEGIN
    -- VERIFICA SE COLABORADOR PERTENCE À EMPRESA.
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_COD_COLABORADOR(F_COD_EMPRESA, F_COD_COLABORADOR_SOLICITANTE_COPIA);

    -- VERIFICA SE O MODELO DE CHECKLIST EXISTE.
    IF NOT EXISTS(SELECT CODIGO
                  FROM CHECKLIST_MODELO
                  WHERE CODIGO = F_COD_MODELO_CHECKLIST_COPIADO)
    THEN
        RAISE EXCEPTION 'Modelo de checklist de código % não existe!', F_COD_MODELO_CHECKLIST_COPIADO;
    END IF;

    -- VERIFICA SE A UNIDADE DE CÓDIGO INFORMADO EXISTE.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST);

    -- VERIFICA SE ESTAMOS COPIANDO O MODELO DE CHECKLIST ENTRE UNIDADES DA MESMA EMPRESA.
    SELECT COD_UNIDADE
    FROM CHECKLIST_MODELO CM
    WHERE CM.CODIGO = F_COD_MODELO_CHECKLIST_COPIADO
    INTO COD_UNIDADE_MODELO_CHECKLIST_COPIADO;
    IF (F_COD_EMPRESA !=
        (SELECT U.COD_EMPRESA
         FROM UNIDADE U
         WHERE U.CODIGO = COD_UNIDADE_MODELO_CHECKLIST_COPIADO))
    THEN
        RAISE EXCEPTION 'Só é possível copiar modelos de checklists entre unidades da mesma empresa para garantirmos
            o vínculo correto de imagens da galeria.';
    END IF;

    -- Busca o nome e status do modelo copiado.
    SELECT CONCAT(CC.NOME, ' (cópia)'), CC.STATUS_ATIVO
    FROM CHECKLIST_MODELO CC
    WHERE CC.CODIGO = F_COD_MODELO_CHECKLIST_COPIADO
    INTO NOME_MODELO_CHECKLIST_COPIADO, STATUS_MODELO_CHECKLIST_COPIADO;

    -- Busca o novo código de versão do modelo de checklist
    NOVO_COD_VERSAO_MODELO := NEXTVAL(
            PG_GET_SERIAL_SEQUENCE('checklist_modelo_versao', 'cod_versao_checklist_modelo'));

    -- Assim conseguimos inserir mantendo a referência circular entre modelo e versão.
    SET CONSTRAINTS ALL DEFERRED;

    -- INSERE O MODELO DE CHECKLIST.
    INSERT INTO CHECKLIST_MODELO (COD_UNIDADE, COD_VERSAO_ATUAL, NOME, STATUS_ATIVO)
    VALUES (F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
            NOVO_COD_VERSAO_MODELO,
            NOME_MODELO_CHECKLIST_COPIADO,
            STATUS_MODELO_CHECKLIST_COPIADO) RETURNING CODIGO
               INTO COD_MODELO_CHECKLIST_INSERIDO;

    -- VERIFICAMOS SE O INSERT FUNCIONOU.
    IF COD_MODELO_CHECKLIST_INSERIDO IS NULL OR COD_MODELO_CHECKLIST_INSERIDO <= 0
    THEN
        RAISE EXCEPTION 'Não foi possível copiar o modelo de checklist';
    END IF;

    -- INSERE A VERSÃO
    INSERT INTO CHECKLIST_MODELO_VERSAO(COD_VERSAO_CHECKLIST_MODELO,
                                        COD_VERSAO_USER_FRIENDLY,
                                        COD_CHECKLIST_MODELO,
                                        DATA_HORA_CRIACAO_VERSAO,
                                        COD_COLABORADOR_CRIACAO_VERSAO)
    VALUES (NOVO_COD_VERSAO_MODELO,
            1,
            COD_MODELO_CHECKLIST_INSERIDO,
            NOW(),
            F_COD_COLABORADOR_SOLICITANTE_COPIA);

    SELECT CONCAT('Modelo inserido com sucesso, código: ', COD_MODELO_CHECKLIST_INSERIDO)
    INTO AVISO_MODELO_INSERIDO;

    IF F_COPIAR_CARGOS_LIBERADOS
    THEN
        -- INSERE OS CARGOS LIBERADOS.
        INSERT INTO CHECKLIST_MODELO_FUNCAO (COD_CHECKLIST_MODELO, COD_UNIDADE, COD_FUNCAO)
            (SELECT COD_MODELO_CHECKLIST_INSERIDO,
                    F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
                    CMF.COD_FUNCAO
             FROM CHECKLIST_MODELO_FUNCAO CMF
             WHERE CMF.COD_CHECKLIST_MODELO = F_COD_MODELO_CHECKLIST_COPIADO);
    END IF;

    IF F_COPIAR_TIPOS_VEICULOS_LIBERADOS
    THEN
        -- COPIA OS TIPOS DE VEÍCULO VINCULADOS.
        FOR MODELO_VEICULO_TIPO_CHECKLIST_COPIADO IN
            SELECT CMVT.COD_UNIDADE,
                   CMVT.COD_MODELO,
                   CMVT.COD_TIPO_VEICULO
            FROM CHECKLIST_MODELO_VEICULO_TIPO CMVT
            WHERE CMVT.COD_MODELO = F_COD_MODELO_CHECKLIST_COPIADO
            LOOP
                -- INSERE OS TIPOS DE VEÍCULOS VINCULADOS.
                INSERT INTO CHECKLIST_MODELO_VEICULO_TIPO (cod_unidade, cod_modelo, cod_tipo_veiculo)
                VALUES (F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
                        COD_MODELO_CHECKLIST_INSERIDO,
                        MODELO_VEICULO_TIPO_CHECKLIST_COPIADO.COD_TIPO_VEICULO);
            END LOOP;
    END IF;

    -- INSERE AS PERGUNTAS E ALTERNATIVAS.
    FOR PERGUNTA_MODELO_CHECKLIST_COPIADO IN
        SELECT CP.COD_CHECKLIST_MODELO,
               CP.COD_UNIDADE,
               CP.ORDEM,
               CP.PERGUNTA,
               CP.SINGLE_CHOICE,
               CP.COD_IMAGEM,
               CP.CODIGO
        FROM CHECKLIST_PERGUNTAS CP
        WHERE CP.COD_VERSAO_CHECKLIST_MODELO = COD_VERSAO_MODELO_CHECKLIST_COPIADO
        LOOP
            -- PERGUNTA.
            INSERT INTO CHECKLIST_PERGUNTAS (COD_CHECKLIST_MODELO,
                                             COD_UNIDADE,
                                             ORDEM,
                                             PERGUNTA,
                                             SINGLE_CHOICE,
                                             COD_IMAGEM,
                                             COD_VERSAO_CHECKLIST_MODELO)
            VALUES (COD_MODELO_CHECKLIST_INSERIDO,
                    F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
                    PERGUNTA_MODELO_CHECKLIST_COPIADO.ORDEM,
                    PERGUNTA_MODELO_CHECKLIST_COPIADO.PERGUNTA,
                    PERGUNTA_MODELO_CHECKLIST_COPIADO.SINGLE_CHOICE,
                    PERGUNTA_MODELO_CHECKLIST_COPIADO.COD_IMAGEM,
                    NOVO_COD_VERSAO_MODELO) RETURNING CODIGO
                       INTO COD_PERGUNTA_CRIADO;
            -- ALTERNATIVA.
            INSERT INTO CHECKLIST_ALTERNATIVA_PERGUNTA (COD_CHECKLIST_MODELO,
                                                        COD_UNIDADE,
                                                        ALTERNATIVA,
                                                        ORDEM,
                                                        COD_PERGUNTA,
                                                        ALTERNATIVA_TIPO_OUTROS,
                                                        PRIORIDADE,
                                                        COD_VERSAO_CHECKLIST_MODELO)
                (SELECT COD_MODELO_CHECKLIST_INSERIDO,
                        F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
                        CAP.ALTERNATIVA,
                        CAP.ORDEM,
                        COD_PERGUNTA_CRIADO,
                        CAP.ALTERNATIVA_TIPO_OUTROS,
                        CAP.PRIORIDADE,
                        NOVO_COD_VERSAO_MODELO
                 FROM CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                 WHERE CAP.COD_VERSAO_CHECKLIST_MODELO = COD_VERSAO_MODELO_CHECKLIST_COPIADO
                   AND CAP.COD_PERGUNTA = PERGUNTA_MODELO_CHECKLIST_COPIADO.CODIGO);
        END LOOP;
END;
$$;

create or replace function suporte.func_checklist_copia_modelo_checklist_entre_empresas(f_cod_modelo_checklist_copiado bigint,
                                                                                        f_cod_unidade_destino_modelo_checklist bigint,
                                                                                        f_cod_colaborador_solicitante_copia bigint,
                                                                                        f_cod_cargos_checklist bigint[] DEFAULT NULL::bigint[],
                                                                                        f_cod_tipos_veiculos_checklist bigint[] DEFAULT NULL::bigint[],
                                                                                        OUT cod_modelo_checklist_inserido bigint,
                                                                                        OUT aviso_modelo_inserido text) returns record
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST BIGINT := (SELECT U.COD_EMPRESA
                                                      FROM UNIDADE U
                                                      WHERE U.CODIGO = F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST);
    COD_UNIDADE_MODELO_CHECKLIST_COPIADO   BIGINT;
    COD_PERGUNTA_CRIADO                    BIGINT;
    NOVO_COD_VERSAO_MODELO                 BIGINT;
    COD_VERSAO_MODELO_CHECKLIST_COPIADO    BIGINT := (SELECT COD_VERSAO_ATUAL
                                                      FROM CHECKLIST_MODELO
                                                      WHERE CODIGO = F_COD_MODELO_CHECKLIST_COPIADO);
    PERGUNTA_MODELO_CHECKLIST_COPIADO      CHECKLIST_PERGUNTAS_DATA%ROWTYPE;
BEGIN
    -- VERIFICA SE COLABORADOR PERTENCE À EMPRESA DESTINO.
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_COD_COLABORADOR(F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST,
                                                             F_COD_COLABORADOR_SOLICITANTE_COPIA);

    -- VERIFICA SE O MODELO DE CHECKLIST EXISTE.
    IF NOT EXISTS(SELECT CM.CODIGO
                  FROM CHECKLIST_MODELO CM
                  WHERE CM.CODIGO = F_COD_MODELO_CHECKLIST_COPIADO)
    THEN
        RAISE EXCEPTION 'Modelo de checklist de código % não existe!', F_COD_MODELO_CHECKLIST_COPIADO;
    END IF;

    -- VERIFICA SE A UNIDADE DE CÓDIGO INFORMADO EXISTE.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST);

    -- VERIFICA SE ESTAMOS COPIANDO O MODELO DE CHECKLIST ENTRE UNIDADES DE EMPRESAS DIFERENTES.
    SELECT CM.COD_UNIDADE
    FROM CHECKLIST_MODELO CM
    WHERE CM.CODIGO = F_COD_MODELO_CHECKLIST_COPIADO
    INTO COD_UNIDADE_MODELO_CHECKLIST_COPIADO;
    IF (F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST =
        (SELECT U.COD_EMPRESA
         FROM UNIDADE U
         WHERE U.CODIGO = COD_UNIDADE_MODELO_CHECKLIST_COPIADO))
    THEN
        RAISE EXCEPTION 'Essa function deve ser utilizada para copiar modelos de checklists entre empresas diferentes.
                        Utilize a function: FUNC_CHECKLIST_COPIA_MODELO_CHECKLIST, para copiar checklists entre unidades
             da mesma empresa.';
    END IF;

    IF F_COD_CARGOS_CHECKLIST IS NOT NULL
    THEN
        -- VERIFICA SE TODOS OS CARGOS EXISTEM.
        IF (SELECT EXISTS(SELECT COD_CARGO
                          FROM UNNEST(F_COD_CARGOS_CHECKLIST) AS COD_CARGO
                                   LEFT JOIN FUNCAO F ON F.CODIGO = COD_CARGO
                          WHERE F.CODIGO IS NULL))
        THEN
            RAISE EXCEPTION 'O(s) cargo(s) % não existe(m) no ProLog', (SELECT ARRAY_AGG(COD_CARGO)
                                                                        FROM UNNEST(F_COD_CARGOS_CHECKLIST)
                                                                                 AS COD_CARGO
                                                                                 LEFT JOIN FUNCAO F
                                                                                           ON F.CODIGO = COD_CARGO
                                                                        WHERE F.CODIGO IS NULL);
        END IF;

        -- VERIFICA SE TODOS OS CARGOS PERTENCEM A EMPRESA DE DESTINO.
        IF (SELECT EXISTS(SELECT COD_CARGO
                          FROM UNNEST(F_COD_CARGOS_CHECKLIST) AS COD_CARGO
                                   LEFT JOIN FUNCAO F ON F.CODIGO = COD_CARGO
                          WHERE F.COD_EMPRESA <> F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST))
        THEN
            RAISE EXCEPTION 'O(s) cargo(s) % não pertence(m) a empresa para a qual você está tentando copiar o
                modelo checklit, empresa: %',
                (SELECT ARRAY_AGG(COD_CARGO)
                 FROM UNNEST(F_COD_CARGOS_CHECKLIST) AS COD_CARGO
                          LEFT JOIN FUNCAO F ON F.CODIGO = COD_CARGO
                 WHERE F.COD_EMPRESA <> F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST),
                (SELECT E.NOME
                 FROM EMPRESA E
                 WHERE E.CODIGO = F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST);
        END IF;
    END IF;

    IF F_COD_TIPOS_VEICULOS_CHECKLIST IS NOT NULL
    THEN
        -- VERIFICA SE TODOS OS TIPOS DE VEÍCULO EXISTEM.
        IF (SELECT EXISTS(SELECT COD_TIPO_VEICULO
                          FROM UNNEST(F_COD_TIPOS_VEICULOS_CHECKLIST) AS COD_TIPO_VEICULO
                                   LEFT JOIN VEICULO_TIPO VT
                                             ON VT.CODIGO = COD_TIPO_VEICULO
                          WHERE VT.CODIGO IS NULL))
        THEN
            RAISE EXCEPTION 'O(s) tipo(s) de veículo % não existe(m) no ProLog', (SELECT ARRAY_AGG(COD_TIPO_VEICULO)
                                                                                  FROM UNNEST(F_COD_TIPOS_VEICULOS_CHECKLIST)
                                                                                           AS COD_TIPO_VEICULO
                                                                                           LEFT JOIN VEICULO_TIPO VT
                                                                                                     ON VT.CODIGO = COD_TIPO_VEICULO
                                                                                  WHERE VT.CODIGO IS NULL);
        END IF;

        -- VERIFICA SE TODOS OS TIPOS DE VEÍCULO PERTENCEM A EMPRESA DE DESTINO.
        IF (SELECT EXISTS(SELECT COD_TIPO_VEICULO
                          FROM UNNEST(F_COD_TIPOS_VEICULOS_CHECKLIST) AS COD_TIPO_VEICULO
                                   LEFT JOIN VEICULO_TIPO VT
                                             ON VT.CODIGO = COD_TIPO_VEICULO
                          WHERE VT.COD_EMPRESA <> F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST))
        THEN
            RAISE EXCEPTION 'O(s) tipo(s) de veículo % não pertence(m) a empresa para a qual você está tentando
                copiar o modelo checklit, empresa: %',
                (SELECT ARRAY_AGG(COD_TIPO_VEICULO)
                 FROM UNNEST(F_COD_TIPOS_VEICULOS_CHECKLIST) AS COD_TIPO_VEICULO
                          LEFT JOIN VEICULO_TIPO VT
                                    ON VT.CODIGO = COD_TIPO_VEICULO
                 WHERE VT.COD_EMPRESA <> F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST),
                (SELECT E.NOME
                 FROM EMPRESA E
                 WHERE E.CODIGO = F_COD_EMPRESA_DESTINO_MODELO_CHECKLIST);
        END IF;
    END IF;

    -- Busca o novo código de versão do modelo de checklist.
    NOVO_COD_VERSAO_MODELO := NEXTVAL(
            PG_GET_SERIAL_SEQUENCE('checklist_modelo_versao', 'cod_versao_checklist_modelo'));

    -- Assim conseguimos inserir mantendo a referência circular entre modelo e versão.
    SET CONSTRAINTS ALL DEFERRED;

    -- INSERE O MODELO DE CHECKLIST.
    INSERT INTO CHECKLIST_MODELO (COD_UNIDADE, COD_VERSAO_ATUAL, NOME, STATUS_ATIVO)
    SELECT F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
           NOVO_COD_VERSAO_MODELO,
           CONCAT(CC.NOME, ' (cópia)'),
           CC.STATUS_ATIVO
    FROM CHECKLIST_MODELO CC
    WHERE CC.CODIGO = F_COD_MODELO_CHECKLIST_COPIADO RETURNING CODIGO
        INTO COD_MODELO_CHECKLIST_INSERIDO;

    -- VERIFICAMOS SE O INSERT FUNCIONOU.
    IF COD_MODELO_CHECKLIST_INSERIDO IS NULL OR COD_MODELO_CHECKLIST_INSERIDO <= 0
    THEN
        RAISE EXCEPTION 'Não foi possível copiar o modelo de checklist';
    END IF;

    -- INSERE A VERSÃO.
    INSERT INTO CHECKLIST_MODELO_VERSAO(COD_VERSAO_CHECKLIST_MODELO,
                                        COD_VERSAO_USER_FRIENDLY,
                                        COD_CHECKLIST_MODELO,
                                        DATA_HORA_CRIACAO_VERSAO,
                                        COD_COLABORADOR_CRIACAO_VERSAO)
    VALUES (NOVO_COD_VERSAO_MODELO,
            1,
            COD_MODELO_CHECKLIST_INSERIDO,
            NOW(),
            F_COD_COLABORADOR_SOLICITANTE_COPIA);

    SELECT CONCAT('Modelo inserido com sucesso, código: ', COD_MODELO_CHECKLIST_INSERIDO)
    INTO AVISO_MODELO_INSERIDO;

    IF F_COD_CARGOS_CHECKLIST IS NOT NULL
    THEN
        -- INSERE CARGOS QUE PODEM REALIZAR O MODELO DE CHECKLIST
        INSERT INTO CHECKLIST_MODELO_FUNCAO (COD_CHECKLIST_MODELO, COD_UNIDADE, COD_FUNCAO)
        SELECT COD_MODELO_CHECKLIST_INSERIDO          COD_CHECKLIST_MODELO,
               F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST COD_UNIDADE,
               CODIGO_FUNCAO
        FROM UNNEST(F_COD_CARGOS_CHECKLIST) CODIGO_FUNCAO;
    END IF;

    IF F_COD_TIPOS_VEICULOS_CHECKLIST IS NOT NULL
    THEN
        -- INSERE TIPOS DE VEÍCULOS LIBERADOS PARA O MODELO DE CHECKLIST
        INSERT INTO CHECKLIST_MODELO_VEICULO_TIPO (COD_MODELO, COD_UNIDADE, COD_TIPO_VEICULO)
        SELECT COD_MODELO_CHECKLIST_INSERIDO          COD_CHECKLIST_MODELO,
               F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST COD_UNIDADE,
               CODIGO_TIPO_VEICULO
        FROM UNNEST(F_COD_TIPOS_VEICULOS_CHECKLIST) CODIGO_TIPO_VEICULO;
    END IF;

    -- INSERE AS PERGUNTAS E ALTERNATIVAS.
    FOR PERGUNTA_MODELO_CHECKLIST_COPIADO IN
        SELECT CP.COD_CHECKLIST_MODELO,
               CP.COD_UNIDADE,
               CP.ORDEM,
               CP.PERGUNTA,
               CP.SINGLE_CHOICE,
               CP.COD_IMAGEM,
               CP.CODIGO
        FROM CHECKLIST_PERGUNTAS CP
        WHERE CP.COD_VERSAO_CHECKLIST_MODELO = COD_VERSAO_MODELO_CHECKLIST_COPIADO
        LOOP
            -- PERGUNTA.
            INSERT INTO CHECKLIST_PERGUNTAS (COD_CHECKLIST_MODELO,
                                             COD_UNIDADE,
                                             ORDEM,
                                             PERGUNTA,
                                             SINGLE_CHOICE,
                                             COD_IMAGEM,
                                             COD_VERSAO_CHECKLIST_MODELO)
            VALUES (COD_MODELO_CHECKLIST_INSERIDO,
                    F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
                    PERGUNTA_MODELO_CHECKLIST_COPIADO.ORDEM,
                    PERGUNTA_MODELO_CHECKLIST_COPIADO.PERGUNTA,
                    PERGUNTA_MODELO_CHECKLIST_COPIADO.SINGLE_CHOICE,
                       -- Só copiamos o código da imagem se a imagem vinculada for da galeria pública do Prolog.
                    F_IF((SELECT EXISTS(SELECT CGI.COD_IMAGEM
                                        FROM CHECKLIST_GALERIA_IMAGENS CGI
                                        WHERE CGI.COD_IMAGEM = PERGUNTA_MODELO_CHECKLIST_COPIADO.COD_IMAGEM
                                          AND CGI.COD_EMPRESA IS NULL)),
                         PERGUNTA_MODELO_CHECKLIST_COPIADO.COD_IMAGEM,
                         NULL),
                    NOVO_COD_VERSAO_MODELO) RETURNING CODIGO
                       INTO COD_PERGUNTA_CRIADO;
            -- ALTERNATIVA.
            INSERT INTO CHECKLIST_ALTERNATIVA_PERGUNTA (COD_CHECKLIST_MODELO,
                                                        COD_UNIDADE,
                                                        ALTERNATIVA,
                                                        ORDEM,
                                                        COD_PERGUNTA,
                                                        ALTERNATIVA_TIPO_OUTROS,
                                                        PRIORIDADE,
                                                        COD_VERSAO_CHECKLIST_MODELO)
                (SELECT COD_MODELO_CHECKLIST_INSERIDO,
                        F_COD_UNIDADE_DESTINO_MODELO_CHECKLIST,
                        CAP.ALTERNATIVA,
                        CAP.ORDEM,
                        COD_PERGUNTA_CRIADO,
                        CAP.ALTERNATIVA_TIPO_OUTROS,
                        CAP.PRIORIDADE,
                        NOVO_COD_VERSAO_MODELO
                 FROM CHECKLIST_ALTERNATIVA_PERGUNTA CAP
                 WHERE CAP.COD_VERSAO_CHECKLIST_MODELO = COD_VERSAO_MODELO_CHECKLIST_COPIADO
                   AND CAP.COD_PERGUNTA = PERGUNTA_MODELO_CHECKLIST_COPIADO.CODIGO);
        END LOOP;
END
$$;

create or replace function public.func_afericao_insert_afericao(f_cod_unidade bigint,
                                                                f_data_hora timestamp with time zone,
                                                                f_cpf_aferidor bigint, f_tempo_realizacao bigint,
                                                                f_tipo_medicao_coletada character varying,
                                                                f_tipo_processo_coleta character varying,
                                                                f_placa_veiculo character varying,
                                                                f_km_veiculo bigint) returns bigint
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_TIPO_VEICULO      BIGINT := (SELECT V.COD_TIPO
                                       FROM VEICULO_DATA V
                                       WHERE V.PLACA = F_PLACA_VEICULO);
    F_COD_DIAGRAMA_VEICULO  BIGINT := (SELECT VT.COD_DIAGRAMA
                                       FROM VEICULO_TIPO VT
                                       WHERE VT.CODIGO = F_COD_TIPO_VEICULO);
    F_COD_AFERICAO_INSERIDA BIGINT;
BEGIN
    --REALIZA INSERÇÃO DA AFERIÇÃO
    INSERT INTO AFERICAO_DATA(DATA_HORA, PLACA_VEICULO, CPF_AFERIDOR, KM_VEICULO, TEMPO_REALIZACAO,
                              TIPO_MEDICAO_COLETADA, COD_UNIDADE, TIPO_PROCESSO_COLETA, DELETADO, DATA_HORA_DELETADO,
                              PG_USERNAME_DELECAO, COD_DIAGRAMA)
    VALUES (F_DATA_HORA, F_PLACA_VEICULO, F_CPF_AFERIDOR, F_KM_VEICULO, F_TEMPO_REALIZACAO, F_TIPO_MEDICAO_COLETADA,
            F_COD_UNIDADE, F_TIPO_PROCESSO_COLETA, FALSE, NULL, NULL,
            F_COD_DIAGRAMA_VEICULO) RETURNING CODIGO INTO F_COD_AFERICAO_INSERIDA;

    RETURN F_COD_AFERICAO_INSERIDA;
END
$$;

create or replace function public.func_movimentacao_insert_movimentacao_veiculo_origem(f_cod_pneu bigint,
                                                                                       f_cod_unidade bigint,
                                                                                       f_tipo_origem character varying,
                                                                                       f_cod_movimentacao bigint,
                                                                                       f_placa_veiculo character varying,
                                                                                       f_km_atual bigint,
                                                                                       f_posicao_prolog integer) returns void
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_TIPO_VEICULO           BIGINT       := (SELECT V.COD_TIPO
                                                  FROM VEICULO_DATA V
                                                  WHERE V.PLACA = F_PLACA_VEICULO);
    F_COD_DIAGRAMA_VEICULO       BIGINT       := (SELECT VT.COD_DIAGRAMA
                                                  FROM VEICULO_TIPO VT
                                                  WHERE VT.CODIGO = F_COD_TIPO_VEICULO);
    F_TIPO_ORIGEM_ATUAL          VARCHAR(255) := (SELECT P.STATUS
                                                  FROM PNEU P
                                                  WHERE P.CODIGO = F_COD_PNEU
                                                    AND P.COD_UNIDADE = F_COD_UNIDADE
                                                    AND F_TIPO_ORIGEM IN (SELECT P.STATUS
                                                                          FROM PNEU P
                                                                          WHERE P.CODIGO = F_COD_PNEU
                                                                            AND P.COD_UNIDADE = F_COD_UNIDADE));
    F_COD_MOVIMENTACAO_REALIZADA BIGINT;
BEGIN
    --REALIZA INSERÇÃO DA MOVIMENTAÇÃO ORIGEM
    INSERT INTO MOVIMENTACAO_ORIGEM(COD_MOVIMENTACAO,
                                    TIPO_ORIGEM,
                                    PLACA,
                                    KM_VEICULO,
                                    POSICAO_PNEU_ORIGEM,
                                    COD_DIAGRAMA)
    VALUES (F_COD_MOVIMENTACAO,
            F_TIPO_ORIGEM_ATUAL,
            F_PLACA_VEICULO,
            F_KM_ATUAL,
            F_POSICAO_PROLOG,
            F_COD_DIAGRAMA_VEICULO) RETURNING COD_MOVIMENTACAO INTO F_COD_MOVIMENTACAO_REALIZADA;

    IF (F_COD_MOVIMENTACAO_REALIZADA <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR('Erro ao inserir a origem veiculo da movimentação');
    END IF;
END
$$;

create or replace function public.func_movimentacao_insert_movimentacao_veiculo_destino(f_cod_movimentacao bigint,
                                                                                        f_tipo_destino character varying,
                                                                                        f_placa_veiculo character varying,
                                                                                        f_km_atual bigint,
                                                                                        f_posicao_prolog bigint) returns void
    security definer
    language plpgsql
as
$$
DECLARE
    F_COD_TIPO_VEICULO           BIGINT := (SELECT V.COD_TIPO
                                            FROM VEICULO_DATA V
                                            WHERE V.PLACA = F_PLACA_VEICULO);
    F_COD_DIAGRAMA_VEICULO       BIGINT := (SELECT VT.COD_DIAGRAMA
                                            FROM VEICULO_TIPO VT
                                            WHERE VT.CODIGO = F_COD_TIPO_VEICULO);
    F_COD_MOVIMENTACAO_REALIZADA BIGINT;
BEGIN
    --REALIZA INSERÇÃO DA MOVIMENTAÇÃO DESTINO.
    INSERT INTO MOVIMENTACAO_DESTINO(COD_MOVIMENTACAO,
                                     TIPO_DESTINO,
                                     PLACA,
                                     KM_VEICULO,
                                     POSICAO_PNEU_DESTINO,
                                     COD_MOTIVO_DESCARTE,
                                     URL_IMAGEM_DESCARTE_1,
                                     URL_IMAGEM_DESCARTE_2,
                                     URL_IMAGEM_DESCARTE_3,
                                     COD_RECAPADORA_DESTINO,
                                     COD_COLETA,
                                     COD_DIAGRAMA)
    VALUES (F_COD_MOVIMENTACAO,
            F_TIPO_DESTINO,
            F_PLACA_VEICULO,
            F_KM_ATUAL,
            F_POSICAO_PROLOG,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            NULL,
            F_COD_DIAGRAMA_VEICULO) RETURNING COD_MOVIMENTACAO INTO F_COD_MOVIMENTACAO_REALIZADA;

    IF (F_COD_MOVIMENTACAO_REALIZADA <= 0)
    THEN
        PERFORM THROW_GENERIC_ERROR('Erro ao inserir o destino veiculo da movimentação');
    END IF;
END
$$;

create or replace function messaging.func_push_salva_token_colaborador(f_cod_colaborador bigint,
                                                                       f_token_colaborador_logado text,
                                                                       f_aplicacao_referencia_token messaging.aplicacao_referencia_token_type,
                                                                       f_token_push_firebase text,
                                                                       f_data_hora_atual timestamp with time zone) returns void
    language plpgsql
as
$$
BEGIN
    INSERT INTO MESSAGING.PUSH_COLABORADOR_TOKEN (COD_COLABORADOR,
                                                  TOKEN_COLABORADOR_LOGADO,
                                                  APLICACAO_REFERENCIA_TOKEN,
                                                  TOKEN_PUSH_FIREBASE,
                                                  DATA_HORA_CADASTRO)
    VALUES (F_COD_COLABORADOR,
            F_TOKEN_COLABORADOR_LOGADO,
            F_APLICACAO_REFERENCIA_TOKEN,
            F_TOKEN_PUSH_FIREBASE,
            F_DATA_HORA_ATUAL)
    ON CONFLICT ON CONSTRAINT UNIQUE_TOKEN
        DO UPDATE SET COD_COLABORADOR          = F_COD_COLABORADOR,
                      TOKEN_COLABORADOR_LOGADO = F_TOKEN_COLABORADOR_LOGADO,
                      DATA_HORA_CADASTRO       = F_DATA_HORA_ATUAL;

    IF NOT FOUND
    THEN
        RAISE EXCEPTION 'Erro ao salvar token de push para o colaborador.
            cod_colaborador: %s - aplicacao_referencia_token: %s - token_push: %s',
            F_COD_COLABORADOR,
            F_APLICACAO_REFERENCIA_TOKEN,
            F_TOKEN_PUSH_FIREBASE;
    END IF;
END;
$$;

create or replace function messaging.func_push_salva_log(f_data_hora_atual timestamp with time zone,
                                                         f_push_message_scope text, f_push_message_sent jsonb,
                                                         f_message_type messaging.push_message_type,
                                                         f_plataform_destination messaging.push_plataform_destination,
                                                         f_request_response_firebase jsonb,
                                                         f_fatal_send_exception text) returns void
    language plpgsql
as
$$
BEGIN
    INSERT INTO MESSAGING.PUSH_LOG (DATA_HORA_LOG,
                                    PUSH_MESSAGE_SCOPE,
                                    PUSH_MESSAGE_SENT,
                                    MESSAGE_TYPE,
                                    PLATAFORM_DESTINATION,
                                    REQUEST_RESPONSE_FIREBASE,
                                    FATAL_SEND_EXCEPTION)
    VALUES (F_DATA_HORA_ATUAL,
            F_PUSH_MESSAGE_SCOPE,
            F_PUSH_MESSAGE_SENT,
            F_MESSAGE_TYPE,
            F_PLATAFORM_DESTINATION,
            F_REQUEST_RESPONSE_FIREBASE,
            F_FATAL_SEND_EXCEPTION);

    IF NOT FOUND
    THEN
        RAISE EXCEPTION 'Erro ao salvar ao salvar log da mensagem: %s', F_PUSH_MESSAGE_SENT;
    END IF;
END;
$$;

create or replace function public.func_socorro_rota_abertura_get_colaboradores_notificacao(f_cod_unidade bigint)
    returns TABLE
            (
                cod_colaborador     bigint,
                token_push_firebase text
            )
    language plpgsql
as
$$
DECLARE
    PERMISSAO_TRATAR_SOCORRO CONSTANT BIGINT := 146;
BEGIN
    RETURN QUERY
        SELECT C.CODIGO                AS COD_COLABORADOR,
               PCT.TOKEN_PUSH_FIREBASE AS TOKEN_PUSH_FIREBASE
        FROM COLABORADOR C
                 JOIN CARGO_FUNCAO_PROLOG_V11 CFP ON C.COD_UNIDADE = CFP.COD_UNIDADE
            AND C.COD_FUNCAO = CFP.COD_FUNCAO_COLABORADOR
                 JOIN FUNCAO F ON F.CODIGO = C.COD_FUNCAO AND
                                  F.CODIGO = CFP.COD_FUNCAO_COLABORADOR AND C.COD_EMPRESA = F.COD_EMPRESA
                 JOIN MESSAGING.PUSH_COLABORADOR_TOKEN PCT ON C.CODIGO = PCT.COD_COLABORADOR
        WHERE C.COD_UNIDADE = F_COD_UNIDADE
          AND CFP.COD_FUNCAO_PROLOG = PERMISSAO_TRATAR_SOCORRO
          -- Filtra apenas por aplicativos do Prolog.
          AND PCT.APLICACAO_REFERENCIA_TOKEN IN ('PROLOG_ANDROID_DEBUG', 'PROLOG_ANDROID_PROD')
          AND C.STATUS_ATIVO = TRUE;
END;
$$;

create or replace function public.tg_func_socorro_verifica_descricao_problema() returns trigger
    language plpgsql
as
$$
DECLARE
    OBRIGA_DESCRICAO BOOLEAN := (SELECT OBRIGA_DESCRICAO
                                 FROM SOCORRO_ROTA_OPCAO_PROBLEMA
                                 WHERE CODIGO = NEW.COD_PROBLEMA_SOCORRO_ROTA);
BEGIN
    IF OBRIGA_DESCRICAO AND (NEW.DESCRICAO_PROBLEMA IS NULL OR LENGTH(NEW.DESCRICAO_PROBLEMA) = 0)
    THEN
        PERFORM THROW_GENERIC_ERROR('Essa opção de problema exige uma descrição');
    END IF;
    RETURN NEW;
END;
$$;

create trigger tg_socorro_verifica_descricao_problema
    before insert
    on public.socorro_rota_abertura
    for each row
execute procedure public.tg_func_socorro_verifica_descricao_problema();

create or replace function public.func_socorro_rota_abertura(f_cod_unidade bigint, f_cod_colaborador_abertura bigint,
                                                             f_cod_veiculo_problema bigint,
                                                             f_km_veiculo_abertura bigint,
                                                             f_cod_problema_socorro_rota bigint,
                                                             f_descricao_problema text,
                                                             f_data_hora_abertura timestamp with time zone,
                                                             f_url_foto_1_abertura text, f_url_foto_2_abertura text,
                                                             f_url_foto_3_abertura text, f_latitude_abertura text,
                                                             f_longitude_abertura text,
                                                             f_precisao_localizacao_abertura_metros numeric,
                                                             f_endereco_automatico text, f_ponto_referencia text,
                                                             f_versao_app_momento_abertura bigint,
                                                             f_device_id_abertura text, f_device_imei_abertura text,
                                                             f_device_uptime_millis_abertura bigint,
                                                             f_android_api_version_abertura integer,
                                                             f_marca_device_abertura text,
                                                             f_modelo_device_abertura text) returns bigint
    language plpgsql
as
$$
DECLARE
    F_COD_SOCORRO_INSERIDO          BIGINT;
    F_COD_SOCORRO_ABERTURA_INSERIDO BIGINT;
    F_COD_EMPRESA                   BIGINT := (SELECT COD_EMPRESA
                                               FROM UNIDADE
                                               WHERE CODIGO = F_COD_UNIDADE);
BEGIN
    -- Verifica se a funcionalidade está liberada para a empresa
    PERFORM FUNC_SOCORRO_ROTA_EMPRESA_LIBERADA(F_COD_EMPRESA);

    -- Insere na tabela pai
    INSERT INTO SOCORRO_ROTA (COD_UNIDADE, STATUS_ATUAL)
    VALUES (F_COD_UNIDADE, 'ABERTO') RETURNING CODIGO INTO F_COD_SOCORRO_INSERIDO;

    -- Exibe erro se não puder inserir
    IF F_COD_SOCORRO_INSERIDO IS NULL OR F_COD_SOCORRO_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível realizar a abertura desse socorro em rota, tente novamente');
    END IF;

    -- Insere na tabela de abertura
    INSERT INTO SOCORRO_ROTA_ABERTURA (COD_SOCORRO_ROTA,
                                       COD_COLABORADOR_ABERTURA,
                                       COD_VEICULO_PROBLEMA,
                                       KM_VEICULO_ABERTURA,
                                       COD_PROBLEMA_SOCORRO_ROTA,
                                       DESCRICAO_PROBLEMA,
                                       DATA_HORA_ABERTURA,
                                       URL_FOTO_1_ABERTURA,
                                       URL_FOTO_2_ABERTURA,
                                       URL_FOTO_3_ABERTURA,
                                       LATITUDE_ABERTURA,
                                       LONGITUDE_ABERTURA,
                                       PRECISAO_LOCALIZACAO_ABERTURA_METROS,
                                       ENDERECO_AUTOMATICO,
                                       PONTO_REFERENCIA,
                                       VERSAO_APP_MOMENTO_ABERTURA,
                                       DEVICE_ID_ABERTURA,
                                       DEVICE_IMEI_ABERTURA,
                                       DEVICE_UPTIME_MILLIS_ABERTURA,
                                       ANDROID_API_VERSION_ABERTURA,
                                       MARCA_DEVICE_ABERTURA,
                                       MODELO_DEVICE_ABERTURA)
    VALUES (F_COD_SOCORRO_INSERIDO,
            F_COD_COLABORADOR_ABERTURA,
            F_COD_VEICULO_PROBLEMA,
            F_KM_VEICULO_ABERTURA,
            F_COD_PROBLEMA_SOCORRO_ROTA,
            F_DESCRICAO_PROBLEMA,
            F_DATA_HORA_ABERTURA,
            F_URL_FOTO_1_ABERTURA,
            F_URL_FOTO_2_ABERTURA,
            F_URL_FOTO_3_ABERTURA,
            F_LATITUDE_ABERTURA,
            F_LONGITUDE_ABERTURA,
            F_PRECISAO_LOCALIZACAO_ABERTURA_METROS,
            F_ENDERECO_AUTOMATICO,
            F_PONTO_REFERENCIA,
            F_VERSAO_APP_MOMENTO_ABERTURA,
            F_DEVICE_ID_ABERTURA,
            F_DEVICE_IMEI_ABERTURA,
            F_DEVICE_UPTIME_MILLIS_ABERTURA,
            F_ANDROID_API_VERSION_ABERTURA,
            F_MARCA_DEVICE_ABERTURA,
            F_MODELO_DEVICE_ABERTURA) RETURNING CODIGO INTO F_COD_SOCORRO_ABERTURA_INSERIDO;

    -- Exibe erro se não puder inserir
    IF F_COD_SOCORRO_ABERTURA_INSERIDO IS NULL OR F_COD_SOCORRO_ABERTURA_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível realizar a abertura desse socorro em rota, tente novamente');
    END IF;

    -- Atualiza o KM no veículo, caso:
    -- Não esteja deletado
    -- O KM coletado na abertura seja maior que o atual do veículo
    UPDATE VEICULO SET KM = F_KM_VEICULO_ABERTURA WHERE CODIGO = F_COD_VEICULO_PROBLEMA AND KM < F_KM_VEICULO_ABERTURA;

    -- Retorna o código do socorro
    RETURN F_COD_SOCORRO_INSERIDO;
END;
$$;

create or replace function public.func_socorro_rota_invalidacao(f_cod_socorro_rota bigint,
                                                                f_cod_colaborador_invalidacao bigint,
                                                                f_motivo_invalidacao text,
                                                                f_data_hora_invalidacao timestamp with time zone,
                                                                f_url_foto_1_invalidacao text,
                                                                f_url_foto_2_invalidacao text,
                                                                f_url_foto_3_invalidacao text,
                                                                f_latitude_invalidacao text,
                                                                f_longitude_invalidacao text,
                                                                f_precisao_localizacao_invalidacao_metros numeric,
                                                                f_endereco_automatico text,
                                                                f_versao_app_momento_invalidacao bigint,
                                                                f_device_id_invalidacao text,
                                                                f_device_imei_invalidacao text,
                                                                f_device_uptime_millis_invalidacao bigint,
                                                                f_android_api_version_invalidacao integer,
                                                                f_marca_device_invalidacao text,
                                                                f_modelo_device_invalidacao text) returns bigint
    language plpgsql
as
$$
DECLARE
    F_PERMISSAO_TRATAR_SOCORRO                BOOLEAN;
    F_PERMISSAO_ABERTURA_SOCORRO              BOOLEAN;
    F_STATUS_SOCORRO                          SOCORRO_ROTA_STATUS_TYPE;
    F_COD_SOCORRO_INVALIDACAO_INSERIDO        BIGINT;
    F_QTD_LINHAS_ATUALIZADAS                  BIGINT;
    F_COD_COLABORADOR_ABERTURA CONSTANT       BIGINT  := (SELECT COD_COLABORADOR_ABERTURA
                                                          FROM SOCORRO_ROTA_ABERTURA
                                                          WHERE COD_SOCORRO_ROTA = F_COD_SOCORRO_ROTA);
    F_COD_COLABORADOR_ATENDIMENTO CONSTANT    BIGINT  := (SELECT COD_COLABORADOR_ATENDIMENTO
                                                          FROM SOCORRO_ROTA_ATENDIMENTO
                                                          WHERE COD_SOCORRO_ROTA = F_COD_SOCORRO_ROTA);
    F_COD_PERMISSAO_TRATAR_SOCORRO CONSTANT   INTEGER := 146;
    F_COD_PERMISSAO_ABERTURA_SOCORRO CONSTANT INTEGER := 145;
BEGIN
    -- Verifica se o socorro em rota existe.
    IF F_COD_COLABORADOR_ABERTURA IS NULL
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível localizar o socorro em rota.');
    END IF;

    -- Verifica se o socorro em rota foi atendido por quem está invalidando.
    IF F_COD_COLABORADOR_ATENDIMENTO IS NOT NULL AND F_COD_COLABORADOR_ATENDIMENTO != F_COD_COLABORADOR_INVALIDACAO
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não é possível invalidar um socorro que foi atendido por outro colaborador.');
    END IF;

    F_PERMISSAO_TRATAR_SOCORRO := (SELECT *
                                   FROM FUNC_COLABORADOR_VERIFICA_POSSUI_FUNCAO_PROLOG(
                                                F_COD_COLABORADOR_INVALIDACAO, F_COD_PERMISSAO_TRATAR_SOCORRO));
    F_PERMISSAO_ABERTURA_SOCORRO := (SELECT *
                                     FROM FUNC_COLABORADOR_VERIFICA_POSSUI_FUNCAO_PROLOG(
                                                  F_COD_COLABORADOR_INVALIDACAO, F_COD_PERMISSAO_ABERTURA_SOCORRO));
    F_STATUS_SOCORRO := (SELECT STATUS_ATUAL
                         FROM SOCORRO_ROTA
                         WHERE CODIGO = F_COD_SOCORRO_ROTA);

    -- Caso tenha a permissão de tratar socorros, impede a invalidação caso os status sejam INVALIDO e FINALZADO.
    IF F_PERMISSAO_TRATAR_SOCORRO
    THEN
        IF F_STATUS_SOCORRO = 'INVALIDO'
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível invalidar o socorro, pois ele já foi invalidado.');
        END IF;
        IF F_STATUS_SOCORRO = 'FINALIZADO'
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível invalidar o socorro, pois ele já foi finalizado.');
        END IF;
        -- Caso tenha a permissão de abertura, impede a invalidação de socorros de outros colaboradores e também
        -- de socorros que não estão mais em aberto.
    ELSEIF F_PERMISSAO_ABERTURA_SOCORRO
    THEN
        IF F_COD_COLABORADOR_ABERTURA <> F_COD_COLABORADOR_INVALIDACAO
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Você não tem permissão para invalidar pedidos de socorro de outros colaboradores.');
        END IF;
        IF F_STATUS_SOCORRO <> 'ABERTO'
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível invalidar o socorro, pois ele não está mais em aberto.');
        END IF;
    ELSE
        PERFORM THROW_GENERIC_ERROR(
                        'Você não ter permissão para invalidar o socorro.');
    END IF;

    INSERT INTO SOCORRO_ROTA_INVALIDACAO (COD_SOCORRO_ROTA,
                                          COD_COLABORADOR_INVALIDACAO,
                                          MOTIVO_INVALIDACAO,
                                          DATA_HORA_INVALIDACAO,
                                          URL_FOTO_1_INVALIDACAO,
                                          URL_FOTO_2_INVALIDACAO,
                                          URL_FOTO_3_INVALIDACAO,
                                          LATITUDE_INVALIDACAO,
                                          LONGITUDE_INVALIDACAO,
                                          PRECISAO_LOCALIZACAO_INVALIDACAO_METROS,
                                          ENDERECO_AUTOMATICO,
                                          VERSAO_APP_MOMENTO_INVALIDACAO,
                                          DEVICE_ID_INVALIDACAO,
                                          DEVICE_IMEI_INVALIDACAO,
                                          DEVICE_UPTIME_MILLIS_INVALIDACAO,
                                          ANDROID_API_VERSION_INVALIDACAO,
                                          MARCA_DEVICE_INVALIDACAO,
                                          MODELO_DEVICE_INVALIDACAO)
    VALUES (F_COD_SOCORRO_ROTA,
            F_COD_COLABORADOR_INVALIDACAO,
            F_MOTIVO_INVALIDACAO,
            F_DATA_HORA_INVALIDACAO,
            F_URL_FOTO_1_INVALIDACAO,
            F_URL_FOTO_2_INVALIDACAO,
            F_URL_FOTO_3_INVALIDACAO,
            F_LATITUDE_INVALIDACAO,
            F_LONGITUDE_INVALIDACAO,
            F_PRECISAO_LOCALIZACAO_INVALIDACAO_METROS,
            F_ENDERECO_AUTOMATICO,
            F_VERSAO_APP_MOMENTO_INVALIDACAO,
            F_DEVICE_ID_INVALIDACAO,
            F_DEVICE_IMEI_INVALIDACAO,
            F_DEVICE_UPTIME_MILLIS_INVALIDACAO,
            F_ANDROID_API_VERSION_INVALIDACAO,
            F_MARCA_DEVICE_INVALIDACAO,
            F_MODELO_DEVICE_INVALIDACAO) RETURNING CODIGO INTO F_COD_SOCORRO_INVALIDACAO_INSERIDO;

    IF F_COD_SOCORRO_INVALIDACAO_INSERIDO IS NOT NULL AND F_COD_SOCORRO_INVALIDACAO_INSERIDO > 0
    THEN
        UPDATE SOCORRO_ROTA SET STATUS_ATUAL = 'INVALIDO' WHERE CODIGO = F_COD_SOCORRO_ROTA;
        GET DIAGNOSTICS F_QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

        IF F_QTD_LINHAS_ATUALIZADAS IS NULL OR F_QTD_LINHAS_ATUALIZADAS <= 0
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível realizar a invalidação desse socorro em rota, tente novamente.');
        END IF;
    ELSE
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível realizar a invalidação desse socorro em rota, tente novamente.');
    END IF;

    RETURN F_COD_SOCORRO_INVALIDACAO_INSERIDO;
END;
$$;

create or replace function public.func_socorro_rota_atendimento(f_cod_socorro_rota bigint,
                                                                f_cod_colaborador_atendimento bigint,
                                                                f_observacao_atendimento text,
                                                                f_data_hora_atendimento timestamp with time zone,
                                                                f_latitude_atendimento text,
                                                                f_longitude_atendimento text,
                                                                f_precisao_localizacao_atendimento_metros numeric,
                                                                f_endereco_automatico text,
                                                                f_versao_app_momento_atendimento bigint,
                                                                f_device_id_atendimento text,
                                                                f_device_imei_atendimento text,
                                                                f_device_uptime_millis_atendimento bigint,
                                                                f_android_api_version_atendimento integer,
                                                                f_marca_device_atendimento text,
                                                                f_modelo_device_atendimento text) returns bigint
    language plpgsql
as
$$
DECLARE
    F_STATUS_SOCORRO                   SOCORRO_ROTA_STATUS_TYPE := (SELECT SR.STATUS_ATUAL
                                                                    FROM SOCORRO_ROTA SR
                                                                    WHERE SR.CODIGO = F_COD_SOCORRO_ROTA);
    F_COD_COLABORADOR_ABERTURA         BIGINT                   := (SELECT SRA.COD_COLABORADOR_ABERTURA
                                                                    FROM SOCORRO_ROTA_ABERTURA SRA
                                                                    WHERE SRA.COD_SOCORRO_ROTA = F_COD_SOCORRO_ROTA);
    F_COD_SOCORRO_ATENDIMENTO_INSERIDO BIGINT;
    F_QTD_LINHAS_ATUALIZADAS           BIGINT;
BEGIN
    -- Verifica se o socorro em rota existe
    IF F_COD_COLABORADOR_ABERTURA IS NULL
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível localizar o socorro em rota.');
    END IF;

    IF F_STATUS_SOCORRO = 'EM_ATENDIMENTO'
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível atender o socorro, pois ele já foi atendido.');
    END IF;
    IF F_STATUS_SOCORRO = 'INVALIDO'
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível atender o socorro, pois ele já foi invalidado.');
    END IF;
    IF F_STATUS_SOCORRO = 'FINALIZADO'
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível atender o socorro, pois ele já foi finalizado.');
    END IF;

    INSERT INTO SOCORRO_ROTA_ATENDIMENTO (COD_SOCORRO_ROTA,
                                          COD_COLABORADOR_ATENDIMENTO,
                                          OBSERVACAO_ATENDIMENTO,
                                          DATA_HORA_ATENDIMENTO,
                                          LATITUDE_ATENDIMENTO,
                                          LONGITUDE_ATENDIMENTO,
                                          PRECISAO_LOCALIZACAO_ATENDIMENTO_METROS,
                                          ENDERECO_AUTOMATICO,
                                          VERSAO_APP_MOMENTO_ATENDIMENTO,
                                          DEVICE_ID_ATENDIMENTO,
                                          DEVICE_IMEI_ATENDIMENTO,
                                          DEVICE_UPTIME_MILLIS_ATENDIMENTO,
                                          ANDROID_API_VERSION_ATENDIMENTO,
                                          MARCA_DEVICE_ATENDIMENTO,
                                          MODELO_DEVICE_ATENDIMENTO)
    VALUES (F_COD_SOCORRO_ROTA,
            F_COD_COLABORADOR_ATENDIMENTO,
            F_OBSERVACAO_ATENDIMENTO,
            F_DATA_HORA_ATENDIMENTO,
            F_LATITUDE_ATENDIMENTO,
            F_LONGITUDE_ATENDIMENTO,
            F_PRECISAO_LOCALIZACAO_ATENDIMENTO_METROS,
            F_ENDERECO_AUTOMATICO,
            F_VERSAO_APP_MOMENTO_ATENDIMENTO,
            F_DEVICE_ID_ATENDIMENTO,
            F_DEVICE_IMEI_ATENDIMENTO,
            F_DEVICE_UPTIME_MILLIS_ATENDIMENTO,
            F_ANDROID_API_VERSION_ATENDIMENTO,
            F_MARCA_DEVICE_ATENDIMENTO,
            F_MODELO_DEVICE_ATENDIMENTO) RETURNING CODIGO INTO F_COD_SOCORRO_ATENDIMENTO_INSERIDO;

    IF F_COD_SOCORRO_ATENDIMENTO_INSERIDO > 0
    THEN
        UPDATE SOCORRO_ROTA SET STATUS_ATUAL = 'EM_ATENDIMENTO' WHERE CODIGO = F_COD_SOCORRO_ROTA;
        GET DIAGNOSTICS F_QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

        IF F_QTD_LINHAS_ATUALIZADAS <= 0
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível realizar o atendimento desse socorro em rota, tente novamente.');
        END IF;
    ELSE
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível realizar a atendimento desse socorro em rota, tente novamente.');
    END IF;

    RETURN F_COD_SOCORRO_ATENDIMENTO_INSERIDO;
END;
$$;

create or replace function public.func_socorro_rota_finalizacao(f_cod_socorro_rota bigint,
                                                                f_cod_colaborador_finalizacao bigint,
                                                                f_motivo_finalizacao text,
                                                                f_data_hora_finalizacao timestamp with time zone,
                                                                f_url_foto_1_finalizacao text,
                                                                f_url_foto_2_finalizacao text,
                                                                f_url_foto_3_finalizacao text,
                                                                f_latitude_finalizacao text,
                                                                f_longitude_finalizacao text,
                                                                f_precisao_localizacao_finalizacao_metros numeric,
                                                                f_endereco_automatico text,
                                                                f_versao_app_momento_finalizacao bigint,
                                                                f_device_id_finalizacao text,
                                                                f_device_imei_finalizacao text,
                                                                f_device_uptime_millis_finalizacao bigint,
                                                                f_android_api_version_finalizacao integer,
                                                                f_marca_device_finalizacao text,
                                                                f_modelo_device_finalizacao text) returns bigint
    language plpgsql
as
$$
DECLARE
    F_STATUS_SOCORRO                   SOCORRO_ROTA_STATUS_TYPE := (SELECT SR.STATUS_ATUAL
                                                                    FROM SOCORRO_ROTA SR
                                                                    WHERE SR.CODIGO = F_COD_SOCORRO_ROTA);
    F_COD_COLABORADOR_ABERTURA         BIGINT                   := (SELECT SRA.COD_COLABORADOR_ABERTURA
                                                                    FROM SOCORRO_ROTA_ABERTURA SRA
                                                                    WHERE SRA.COD_SOCORRO_ROTA = F_COD_SOCORRO_ROTA);
    F_COD_COLABORADOR_ATENDIMENTO      BIGINT                   := (SELECT COD_COLABORADOR_ATENDIMENTO
                                                                    FROM SOCORRO_ROTA_ATENDIMENTO
                                                                    WHERE COD_SOCORRO_ROTA = F_COD_SOCORRO_ROTA);
    F_COD_SOCORRO_FINALIZACAO_INSERIDO BIGINT;
    F_QTD_LINHAS_ATUALIZADAS           BIGINT;
BEGIN
    -- Verifica se o socorro em rota existe
    IF F_COD_COLABORADOR_ABERTURA IS NULL
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível localizar o socorro em rota.');
    END IF;

    -- Verifica se o socorro em rota foi atendido por quem está finalizando
    IF F_COD_COLABORADOR_ATENDIMENTO != F_COD_COLABORADOR_FINALIZACAO
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não é possível finalizar um socorro que foi atendido por outro colaborador.');
    END IF;

    IF F_STATUS_SOCORRO = 'ABERTO'
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível finalizar o socorro, pois ele ainda não foi atendido.');
    END IF;
    IF F_STATUS_SOCORRO = 'INVALIDO'
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível finalizar o socorro, pois ele já foi invalidado.');
    END IF;
    IF F_STATUS_SOCORRO = 'FINALIZADO'
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível finalizar o socorro, pois ele já foi finalizado.');
    END IF;

    INSERT INTO SOCORRO_ROTA_FINALIZACAO (COD_SOCORRO_ROTA,
                                          COD_COLABORADOR_FINALIZACAO,
                                          OBSERVACAO_FINALIZACAO,
                                          DATA_HORA_FINALIZACAO,
                                          URL_FOTO_1_FINALIZACAO,
                                          URL_FOTO_2_FINALIZACAO,
                                          URL_FOTO_3_FINALIZACAO,
                                          LATITUDE_FINALIZACAO,
                                          LONGITUDE_FINALIZACAO,
                                          PRECISAO_LOCALIZACAO_FINALIZACAO_METROS,
                                          ENDERECO_AUTOMATICO,
                                          VERSAO_APP_MOMENTO_FINALIZACAO,
                                          DEVICE_ID_FINALIZACAO,
                                          DEVICE_IMEI_FINALIZACAO,
                                          DEVICE_UPTIME_MILLIS_FINALIZACAO,
                                          ANDROID_API_VERSION_FINALIZACAO,
                                          MARCA_DEVICE_FINALIZACAO,
                                          MODELO_DEVICE_FINALIZACAO)
    VALUES (F_COD_SOCORRO_ROTA,
            F_COD_COLABORADOR_FINALIZACAO,
            F_MOTIVO_FINALIZACAO,
            F_DATA_HORA_FINALIZACAO,
            F_URL_FOTO_1_FINALIZACAO,
            F_URL_FOTO_2_FINALIZACAO,
            F_URL_FOTO_3_FINALIZACAO,
            F_LATITUDE_FINALIZACAO,
            F_LONGITUDE_FINALIZACAO,
            F_PRECISAO_LOCALIZACAO_FINALIZACAO_METROS,
            F_ENDERECO_AUTOMATICO,
            F_VERSAO_APP_MOMENTO_FINALIZACAO,
            F_DEVICE_ID_FINALIZACAO,
            F_DEVICE_IMEI_FINALIZACAO,
            F_DEVICE_UPTIME_MILLIS_FINALIZACAO,
            F_ANDROID_API_VERSION_FINALIZACAO,
            F_MARCA_DEVICE_FINALIZACAO,
            F_MODELO_DEVICE_FINALIZACAO) RETURNING CODIGO INTO F_COD_SOCORRO_FINALIZACAO_INSERIDO;

    IF F_COD_SOCORRO_FINALIZACAO_INSERIDO > 0
    THEN
        UPDATE SOCORRO_ROTA SET STATUS_ATUAL = 'FINALIZADO' WHERE CODIGO = F_COD_SOCORRO_ROTA;
        GET DIAGNOSTICS F_QTD_LINHAS_ATUALIZADAS = ROW_COUNT;

        IF F_QTD_LINHAS_ATUALIZADAS <= 0
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível realizar a invalidação desse socorro em rota, tente novamente.');
        END IF;
    ELSE
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível realizar a invalidação desse socorro em rota, tente novamente.');
    END IF;

    RETURN F_COD_SOCORRO_FINALIZACAO_INSERIDO;
END;
$$;

create or replace function public.func_socorro_rota_visualizacao(f_cod_socorro_rota bigint)
    returns TABLE
            (
                cod_socorro_rota                    bigint,
                status_socorro_rota                 socorro_rota_status_type,
                placa_veiculo_abertura              text,
                cod_colaborador_abertura            bigint,
                nome_responsavel_abertura           text,
                km_veiculo_coletado_abertura        bigint,
                descricao_opcao_problema_abertura   text,
                descricao_fornecida_abertura        text,
                ponto_referencia_fornecido_abertura text,
                data_hora_abertura                  timestamp without time zone,
                latitude_abertura                   text,
                longitude_abertura                  text,
                endereco_automatico_abertura        text,
                marca_aparelho_abertura             text,
                modelo_aparelho_abertura            text,
                imei_aparelho_abertura              text,
                url_foto_1_abertura                 text,
                url_foto_2_abertura                 text,
                url_foto_3_abertura                 text,
                cod_colaborador_atendimento         bigint,
                nome_responsavel_atendimento        text,
                observacao_atendimento              text,
                data_hora_atendimento               timestamp without time zone,
                latitude_atendimento                text,
                longitude_atendimento               text,
                endereco_automatico_atendimento     text,
                marca_aparelho_atendimento          text,
                modelo_aparelho_atendimento         text,
                imei_aparelho_atendimento           text,
                cod_colaborador_invalidacao         bigint,
                nome_responsavel_invalidacao        text,
                motivo_invalidacao                  text,
                data_hora_invalidacao               timestamp without time zone,
                latitude_invalidacao                text,
                longitude_invalidacao               text,
                endereco_automatico_invalidacao     text,
                marca_aparelho_invalidacao          text,
                modelo_aparelho_invalidacao         text,
                imei_aparelho_invalidacao           text,
                url_foto_1_invalidacao              text,
                url_foto_2_invalidacao              text,
                url_foto_3_invalidacao              text,
                cod_colaborador_finalizacao         bigint,
                nome_responsavel_finalizacao        text,
                observacao_finalizacao              text,
                data_hora_finalizacao               timestamp without time zone,
                latitude_finalizacao                text,
                longitude_finalizacao               text,
                endereco_automatico_finalizacao     text,
                marca_aparelho_finalizacao          text,
                modelo_aparelho_finalizacao         text,
                imei_aparelho_finalizacao           text,
                url_foto_1_finalizacao              text,
                url_foto_2_finalizacao              text,
                url_foto_3_finalizacao              text
            )
    language plpgsql
as
$$
DECLARE
    -- Busca o código da empresa com base no código da unidade do socorro em rota
    F_COD_EMPRESA BIGINT := (SELECT COD_EMPRESA
                             FROM UNIDADE
                             WHERE CODIGO =
                                   (SELECT COD_UNIDADE FROM SOCORRO_ROTA WHERE COD_SOCORRO_ROTA = F_COD_SOCORRO_ROTA));
BEGIN
    -- Verifica se a funcionalidade está liberada para a empresa
    PERFORM FUNC_SOCORRO_ROTA_EMPRESA_LIBERADA(F_COD_EMPRESA);

    RETURN QUERY
        SELECT SR.CODIGO                                                          AS COD_SOCORRO_ROTA,
               SR.STATUS_ATUAL :: SOCORRO_ROTA_STATUS_TYPE                        AS STATUS_SOCORRO_ROTA,
               V.PLACA :: TEXT                                                    AS PLACA_VEICULO_ABERTURA,
               SRAB.COD_COLABORADOR_ABERTURA                                      AS COD_COLABORADOR_ABERTURA,
               CDAB.NOME :: TEXT                                                  AS NOME_RESPONSAVEL_ABERTURA,
               SRAB.KM_VEICULO_ABERTURA                                           AS KM_VEICULO_COLETADO_ABERTURA,
               SROP.DESCRICAO :: TEXT                                             AS DESCRICAO_OPCAO_PROBLEMA_ABERTURA,
               SRAB.DESCRICAO_PROBLEMA :: TEXT                                    AS DESCRICAO_FORNECIDA_ABERTURA,
               SRAB.PONTO_REFERENCIA :: TEXT                                      AS PONTO_REFERENCIA_FORNECIDO_ABERTURA,
               SRAB.DATA_HORA_ABERTURA AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)    AS DATA_HORA_ABERTURA,
               SRAB.LATITUDE_ABERTURA :: TEXT                                     AS LATITUDE_ABERTURA,
               SRAB.LONGITUDE_ABERTURA :: TEXT                                    AS LONGITUDE_ABERTURA,
               SRAB.ENDERECO_AUTOMATICO :: TEXT                                   AS ENDERECO_AUTOMATICO_ABERTURA,
               SRAB.MARCA_DEVICE_ABERTURA :: TEXT                                 AS MARCA_APARELHO_ABERTURA,
               SRAB.MODELO_DEVICE_ABERTURA :: TEXT                                AS MODELO_APARELHO_ABERTURA,
               SRAB.DEVICE_IMEI_ABERTURA :: TEXT                                  AS IMEI_APARELHO_ABERTURA,
               SRAB.URL_FOTO_1_ABERTURA :: TEXT                                   AS URL_FOTO_1_ABERTURA,
               SRAB.URL_FOTO_2_ABERTURA :: TEXT                                   AS URL_FOTO_2_ABERTURA,
               SRAB.URL_FOTO_3_ABERTURA :: TEXT                                   AS URL_FOTO_3_ABERTURA,
               SRAT.COD_COLABORADOR_ATENDIMENTO                                   AS COD_COLABORADOR_ATENDIMENTO,
               CDAT.NOME :: TEXT                                                  AS NOME_RESPONSAVEL_ATENDIMENTO,
               SRAT.OBSERVACAO_ATENDIMENTO :: TEXT                                AS OBSERVACAO_ATENDIMENTO,
               SRAT.DATA_HORA_ATENDIMENTO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE) AS DATA_HORA_ATENDIMENTO,
               SRAT.LATITUDE_ATENDIMENTO :: TEXT                                  AS LATITUDE_ATENDIMENTO,
               SRAT.LONGITUDE_ATENDIMENTO :: TEXT                                 AS LONGITUDE_ATENDIMENTO,
               SRAT.ENDERECO_AUTOMATICO :: TEXT                                   AS ENDERECO_AUTOMATICO_ATENDIMENTO,
               SRAT.MARCA_DEVICE_ATENDIMENTO :: TEXT                              AS MARCA_APARELHO_ATENDIMENTO,
               SRAT.MODELO_DEVICE_ATENDIMENTO :: TEXT                             AS MODELO_APARELHO_ATENDIMENTO,
               SRAT.DEVICE_IMEI_ATENDIMENTO :: TEXT                               AS IMEI_APARELHO_ATENDIMENTO,
               SRI.COD_COLABORADOR_INVALIDACAO                                    AS COD_COLABORADOR_INVALIDACAO,
               CDI.NOME :: TEXT                                                   AS NOME_RESPONSAVEL_INVALIDACAO,
               SRI.MOTIVO_INVALIDACAO :: TEXT                                     AS MOTIVO_INVALIDACAO,
               SRI.DATA_HORA_INVALIDACAO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)  AS DATA_HORA_INVALIDACAO,
               SRI.LATITUDE_INVALIDACAO :: TEXT                                   AS LATITUDE_INVALIDACAO,
               SRI.LONGITUDE_INVALIDACAO :: TEXT                                  AS LONGITUDE_INVALIDACAO,
               SRI.ENDERECO_AUTOMATICO :: TEXT                                    AS ENDERECO_AUTOMATICO_INVALIDACAO,
               SRI.MARCA_DEVICE_INVALIDACAO :: TEXT                               AS MARCA_APARELHO_INVALIDACAO,
               SRI.MODELO_DEVICE_INVALIDACAO :: TEXT                              AS MODELO_APARELHO_INVALIDACAO,
               SRI.DEVICE_IMEI_INVALIDACAO :: TEXT                                AS IMEI_APARELHO_INVALIDACAO,
               SRI.URL_FOTO_1_INVALIDACAO :: TEXT                                 AS URL_FOTO_1_INVALIDACAO,
               SRI.URL_FOTO_2_INVALIDACAO :: TEXT                                 AS URL_FOTO_2_INVALIDACAO,
               SRI.URL_FOTO_3_INVALIDACAO :: TEXT                                 AS URL_FOTO_3_INVALIDACAO,
               SRF.COD_COLABORADOR_FINALIZACAO                                    AS COD_COLABORADOR_FINALIZACAO,
               CDF.NOME :: TEXT                                                   AS NOME_RESPONSAVEL_FINALIZACAO,
               SRF.OBSERVACAO_FINALIZACAO :: TEXT                                 AS OBSERVACAO_FINALIZACAO,
               SRF.DATA_HORA_FINALIZACAO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)  AS DATA_HORA_FINALIZACAO,
               SRF.LATITUDE_FINALIZACAO :: TEXT                                   AS LATITUDE_FINALIZACAO,
               SRF.LONGITUDE_FINALIZACAO :: TEXT                                  AS LONGITUDE_FINALIZACAO,
               SRF.ENDERECO_AUTOMATICO :: TEXT                                    AS ENDERECO_AUTOMATICO_FINALIZACAO,
               SRF.MARCA_DEVICE_FINALIZACAO :: TEXT                               AS MARCA_APARELHO_FINALIZACAO,
               SRF.MODELO_DEVICE_FINALIZACAO :: TEXT                              AS MODELO_APARELHO_FINALIZACAO,
               SRF.DEVICE_IMEI_FINALIZACAO :: TEXT                                AS IMEI_APARELHO_FINALIZACAO,
               SRF.URL_FOTO_1_FINALIZACAO :: TEXT                                 AS URL_FOTO_1_FINALIZACAO,
               SRF.URL_FOTO_2_FINALIZACAO :: TEXT                                 AS URL_FOTO_2_FINALIZACAO,
               SRF.URL_FOTO_3_FINALIZACAO :: TEXT                                 AS URL_FOTO_3_FINALIZACAO
        FROM SOCORRO_ROTA SR
                 JOIN SOCORRO_ROTA_ABERTURA SRAB ON SR.CODIGO = SRAB.COD_SOCORRO_ROTA
                 JOIN VEICULO_DATA V ON V.CODIGO = SRAB.COD_VEICULO_PROBLEMA
                 JOIN COLABORADOR_DATA CDAB ON CDAB.CODIGO = SRAB.COD_COLABORADOR_ABERTURA
                 JOIN SOCORRO_ROTA_OPCAO_PROBLEMA SROP ON SROP.CODIGO = SRAB.COD_PROBLEMA_SOCORRO_ROTA
                 LEFT JOIN SOCORRO_ROTA_ATENDIMENTO SRAT
                           ON SR.STATUS_ATUAL::TEXT = ANY (ARRAY ['EM_ATENDIMENTO', 'INVALIDO', 'FINALIZADO']) AND
                              SR.CODIGO = SRAT.COD_SOCORRO_ROTA
                 LEFT JOIN COLABORADOR_DATA CDAT
                           ON SR.STATUS_ATUAL::TEXT = ANY (ARRAY ['EM_ATENDIMENTO', 'INVALIDO', 'FINALIZADO']) AND
                              CDAT.CODIGO = SRAT.COD_COLABORADOR_ATENDIMENTO
                 LEFT JOIN SOCORRO_ROTA_INVALIDACAO SRI
                           ON SR.STATUS_ATUAL = 'INVALIDO' AND SR.CODIGO = SRI.COD_SOCORRO_ROTA
                 LEFT JOIN COLABORADOR_DATA CDI
                           ON SR.STATUS_ATUAL = 'INVALIDO' AND CDI.CODIGO = SRI.COD_COLABORADOR_INVALIDACAO
                 LEFT JOIN SOCORRO_ROTA_FINALIZACAO SRF
                           ON SR.STATUS_ATUAL = 'FINALIZADO' AND SR.CODIGO = SRF.COD_SOCORRO_ROTA
                 LEFT JOIN COLABORADOR_DATA CDF
                           ON SR.STATUS_ATUAL = 'FINALIZADO' AND CDF.CODIGO = SRF.COD_COLABORADOR_FINALIZACAO
        WHERE SR.CODIGO = F_COD_SOCORRO_ROTA;
    IF NOT FOUND
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível encontrar esse socorro');
    END IF;
END;
$$;

create or replace function public.func_socorro_rota_opcoes_problemas_listagem(f_cod_empresa bigint)
    returns TABLE
            (
                cod_opcao_problema bigint,
                descricao          citext,
                obriga_descricao   boolean,
                status_ativo       boolean
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT SROP.CODIGO,
               SROP.DESCRICAO,
               SROP.OBRIGA_DESCRICAO,
               SROP.STATUS_ATIVO
        FROM SOCORRO_ROTA_OPCAO_PROBLEMA SROP
        WHERE SROP.COD_EMPRESA = F_COD_EMPRESA
        ORDER BY SROP.STATUS_ATIVO DESC, SROP.DESCRICAO ASC;
END;
$$;

create or replace function public.func_socorro_rota_insert_opcoes_problemas(f_cod_empresa bigint, f_descricao text,
                                                                            f_obriga_descricao boolean,
                                                                            f_cod_colaborador bigint,
                                                                            f_data_hora timestamp with time zone) returns bigint
    language plpgsql
as
$$
DECLARE
    F_COD_OPCAO_PROBLEMA_INSERIDO BIGINT;
BEGIN
    IF EXISTS(SELECT SROP.CODIGO
              FROM SOCORRO_ROTA_OPCAO_PROBLEMA SROP
              WHERE UNACCENT(TRIM(SROP.DESCRICAO)) ILIKE UNACCENT(TRIM(F_DESCRICAO))
                AND SROP.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        FORMAT(E'Já existe uma descrição \'%s\' cadastrada nesta empresa', F_DESCRICAO));
    END IF;

    INSERT INTO SOCORRO_ROTA_OPCAO_PROBLEMA (COD_EMPRESA, DESCRICAO, OBRIGA_DESCRICAO,
                                             COD_COLABORADOR_ULTIMA_ATUALIZACAO, DATA_HORA_ULTIMA_ATUALIZACAO)
    VALUES (F_COD_EMPRESA, F_DESCRICAO, F_OBRIGA_DESCRICAO, F_COD_COLABORADOR,
            F_DATA_HORA) RETURNING CODIGO INTO F_COD_OPCAO_PROBLEMA_INSERIDO;

    IF F_COD_OPCAO_PROBLEMA_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível inserir a opção de problema, tente novamente');
    END IF;

    RETURN F_COD_OPCAO_PROBLEMA_INSERIDO;
END;
$$;

create or replace function public.func_socorro_rota_update_opcoes_problemas(f_cod_opcao_problema bigint,
                                                                            f_cod_empresa bigint, f_descricao text,
                                                                            f_obriga_descricao boolean,
                                                                            f_cod_colaborador bigint,
                                                                            f_data_hora timestamp with time zone) returns boolean
    language plpgsql
as
$$
DECLARE
    -- Todos os campos a seguir devem ser buscados no registro anterior, antes da alteração
    -- Estes campos serão adicionados na tabela de histórico
    F_OLD_DESCRICAO                          TEXT;
    F_OLD_OBRIGA_DESCRICAO                   BOOLEAN;
    F_OLD_STATUS_ATIVO                       BOOLEAN;
    F_OLD_DATA_HORA_ALTERACAO                TIMESTAMP WITH TIME ZONE;
    F_OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO BIGINT;
    F_COD_HISTORICO_ALTERACAO                BIGINT;
BEGIN
    IF EXISTS(SELECT SROP.CODIGO
              FROM SOCORRO_ROTA_OPCAO_PROBLEMA SROP
              WHERE UNACCENT(TRIM(SROP.DESCRICAO)) ILIKE UNACCENT(TRIM(F_DESCRICAO))
                AND SROP.CODIGO != F_COD_OPCAO_PROBLEMA
                AND SROP.STATUS_ATIVO
                AND SROP.COD_EMPRESA = F_COD_EMPRESA)
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        FORMAT(E'Já existe uma descrição \'%s\' cadastrada na empresa', F_DESCRICAO));
    END IF;

    SELECT DESCRICAO, OBRIGA_DESCRICAO, DATA_HORA_ULTIMA_ATUALIZACAO, COD_COLABORADOR_ULTIMA_ATUALIZACAO, STATUS_ATIVO
    FROM SOCORRO_ROTA_OPCAO_PROBLEMA
    WHERE CODIGO = F_COD_OPCAO_PROBLEMA
    INTO F_OLD_DESCRICAO, F_OLD_OBRIGA_DESCRICAO, F_OLD_DATA_HORA_ALTERACAO, F_OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO,
        F_OLD_STATUS_ATIVO;

    IF F_OLD_DESCRICAO IS NULL
    THEN
        PERFORM THROW_GENERIC_ERROR('Não foi possível encontrar a opção de problema.');
    END IF;

    UPDATE SOCORRO_ROTA_OPCAO_PROBLEMA
    SET DESCRICAO                          = F_DESCRICAO,
        OBRIGA_DESCRICAO                   = F_OBRIGA_DESCRICAO,
        COD_COLABORADOR_ULTIMA_ATUALIZACAO = F_COD_COLABORADOR,
        DATA_HORA_ULTIMA_ATUALIZACAO       = F_DATA_HORA
    WHERE CODIGO = F_COD_OPCAO_PROBLEMA;

    -- FOUND será true se alguma linha foi modificada pela query executada.
    IF NOT FOUND THEN
        PERFORM THROW_GENERIC_ERROR('Não foi possível editar a opção de problema.');
    END IF;

    INSERT INTO SOCORRO_ROTA_OPCAO_PROBLEMA_HISTORICO (COD_PROBLEMA_SOCORRO_ROTA,
                                                       COD_COLABORADOR_ALTERACAO,
                                                       DATA_HORA_ALTERACAO,
                                                       COD_EMPRESA,
                                                       DESCRICAO,
                                                       OBRIGA_DESCRICAO,
                                                       STATUS_ATIVO)
    VALUES (F_COD_OPCAO_PROBLEMA,
            F_OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO,
            F_OLD_DATA_HORA_ALTERACAO,
            F_COD_EMPRESA,
            F_OLD_DESCRICAO,
            F_OLD_OBRIGA_DESCRICAO,
            F_OLD_STATUS_ATIVO) RETURNING CODIGO INTO F_COD_HISTORICO_ALTERACAO;

    IF NOT FOUND OR F_COD_HISTORICO_ALTERACAO IS NULL OR F_COD_HISTORICO_ALTERACAO <= 0 THEN
        PERFORM THROW_GENERIC_ERROR('Não foi possível criar um histórico para a edição de problema, ' ||
                                    'contate nosso suporte.');
    END IF;

    RETURN TRUE;
END;
$$;

create or replace function public.func_socorro_rota_opcao_problema_item(f_cod_opcao_problema bigint)
    returns TABLE
            (
                cod_opcao_problema                  bigint,
                descricao                           text,
                obriga_descricao                    boolean,
                status_ativo                        boolean,
                nome_colaborador_ultima_atualizacao text,
                data_hora_ultima_atualizacao        text
            )
    language plpgsql
as
$$
BEGIN
    RETURN QUERY
        SELECT SROP.CODIGO,
               SROP.DESCRICAO :: TEXT,
               SROP.OBRIGA_DESCRICAO,
               SROP.STATUS_ATIVO,
               (SELECT CD.NOME
                FROM COLABORADOR_DATA CD
                WHERE CD.CODIGO = SROP.COD_COLABORADOR_ULTIMA_ATUALIZACAO)::TEXT,
               TO_CHAR((SROP.DATA_HORA_ULTIMA_ATUALIZACAO), 'DD/MM/YYYY HH24:MI')
        FROM SOCORRO_ROTA_OPCAO_PROBLEMA SROP
        WHERE SROP.CODIGO = F_COD_OPCAO_PROBLEMA;

    IF NOT FOUND
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível encontrar a opção de problema');
    END IF;
END;
$$;

create or replace function public.func_socorro_rota_update_status_opcao_problema(f_cod_empresa bigint,
                                                                                 f_cod_colaborador bigint,
                                                                                 f_cod_opcao_problema bigint,
                                                                                 f_status_ativo boolean) returns void
    security definer
    language plpgsql
as
$$
DECLARE
    F_CPF_COLABORADOR                        BIGINT := (SELECT CD.CPF
                                                        FROM COLABORADOR_DATA CD
                                                        WHERE CD.CODIGO = F_COD_COLABORADOR);
    -- Todos os campos a seguir devem ser buscados no registro anterior, antes da alteração
    -- Estes campos serão adicionados na tabela de histórico.
    F_OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO BIGINT;
    F_OLD_DATA_HORA_ALTERACAO                TIMESTAMP WITH TIME ZONE;
    F_OLD_DESCRICAO                          TEXT;
    F_OLD_OBRIGA_DESCRICAO                   BOOLEAN;
    F_OLD_STATUS_ATIVO                       BOOLEAN;
    F_COD_HISTORICO_ALTERACAO                BIGINT;

BEGIN
    -- VERIFICA SE EMPRESA EXISTE.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(F_COD_EMPRESA);

    -- VERIFICA SE COLABORADOR PERTENCE À EMPRESA
    PERFORM FUNC_GARANTE_INTEGRIDADE_EMPRESA_COLABORADOR(F_COD_EMPRESA, F_CPF_COLABORADOR);

    -- Busca registro para histórico.
    SELECT SROP.COD_COLABORADOR_ULTIMA_ATUALIZACAO,
           SROP.DATA_HORA_ULTIMA_ATUALIZACAO,
           SROP.DESCRICAO,
           SROP.OBRIGA_DESCRICAO,
           SROP.STATUS_ATIVO
    FROM SOCORRO_ROTA_OPCAO_PROBLEMA SROP
    WHERE SROP.COD_EMPRESA = F_COD_EMPRESA
      AND SROP.CODIGO = F_COD_OPCAO_PROBLEMA
    INTO F_OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO,
        F_OLD_DATA_HORA_ALTERACAO,
        F_OLD_DESCRICAO,
        F_OLD_OBRIGA_DESCRICAO,
        F_OLD_STATUS_ATIVO;

    IF F_OLD_DESCRICAO IS NULL
    THEN
        PERFORM THROW_GENERIC_ERROR('Não foi possível encontrar a opção de problema.');
    END IF;

    -- Se estamos ativando uma opcao de problema e existe outra na mesma empresa, de mesma descrição e já ativa, é
    -- lançado erro.
    IF F_STATUS_ATIVO AND (SELECT EXISTS(SELECT SROP.CODIGO
                                         FROM SOCORRO_ROTA_OPCAO_PROBLEMA SROP
                                         WHERE SROP.COD_EMPRESA = F_COD_EMPRESA
                                           AND UNACCENT(TRIM(SROP.DESCRICAO)) ILIKE UNACCENT(TRIM(F_OLD_DESCRICAO))
                                           AND SROP.STATUS_ATIVO = TRUE))
    THEN
        PERFORM THROW_GENERIC_ERROR('Erro! Já existe uma opção de problema ativa com esse nome.');
    END IF;

    UPDATE SOCORRO_ROTA_OPCAO_PROBLEMA
    SET STATUS_ATIVO                       = F_STATUS_ATIVO,
        COD_COLABORADOR_ULTIMA_ATUALIZACAO = F_COD_COLABORADOR,
        DATA_HORA_ULTIMA_ATUALIZACAO       = NOW()
    WHERE COD_EMPRESA = F_COD_EMPRESA
      AND CODIGO = F_COD_OPCAO_PROBLEMA;

    IF NOT FOUND
    THEN
        RAISE EXCEPTION 'Erro ao atualizar o status da opção de problema % para %', F_OLD_DESCRICAO, F_STATUS_ATIVO;
    END IF;

    INSERT INTO SOCORRO_ROTA_OPCAO_PROBLEMA_HISTORICO (COD_PROBLEMA_SOCORRO_ROTA,
                                                       COD_COLABORADOR_ALTERACAO,
                                                       DATA_HORA_ALTERACAO,
                                                       COD_EMPRESA,
                                                       DESCRICAO,
                                                       OBRIGA_DESCRICAO,
                                                       STATUS_ATIVO)
    VALUES (F_COD_OPCAO_PROBLEMA,
            F_OLD_COD_COLABORADOR_ULTIMA_ATUALIZACAO,
            F_OLD_DATA_HORA_ALTERACAO,
            F_COD_EMPRESA,
            F_OLD_DESCRICAO,
            F_OLD_OBRIGA_DESCRICAO,
            F_STATUS_ATIVO) RETURNING CODIGO INTO F_COD_HISTORICO_ALTERACAO;

    IF NOT FOUND OR F_COD_HISTORICO_ALTERACAO IS NULL OR F_COD_HISTORICO_ALTERACAO <= 0 THEN
        PERFORM THROW_GENERIC_ERROR('Não foi possível criar um histórico para a mudança de status de opção de' ||
                                    ' problema, contate nosso suporte.');
    END IF;
END;
$$;

create or replace function public.func_colaborador_insert_colaborador(f_cpf bigint, f_matricula_ambev integer,
                                                                      f_matricula_trans integer, f_data_nascimento date,
                                                                      f_data_admissao date, f_nome character varying,
                                                                      f_cod_setor bigint, f_cod_funcao integer,
                                                                      f_cod_unidade integer, f_cod_permissao bigint,
                                                                      f_cod_empresa bigint, f_cod_equipe bigint,
                                                                      f_pis character varying,
                                                                      f_sigla_iso2 character varying,
                                                                      f_prefixo_pais integer, f_telefone text,
                                                                      f_email email, f_cod_unidade_cadastro integer,
                                                                      f_token text) returns bigint
    language plpgsql
as
$$
DECLARE
    F_COD_COLABORADOR_UPDATE CONSTANT BIGINT := (SELECT COD_COLABORADOR
                                                 FROM TOKEN_AUTENTICACAO
                                                 WHERE TOKEN = F_TOKEN);
    F_COD_COLABORADOR_INSERIDO        BIGINT;
    F_COD_TELEFONE_INSERIDO           BIGINT;
    F_COD_EMAIL_INSERIDO              BIGINT;
BEGIN
    INSERT INTO COLABORADOR (CPF,
                             MATRICULA_AMBEV,
                             MATRICULA_TRANS,
                             DATA_NASCIMENTO,
                             DATA_ADMISSAO,
                             NOME,
                             COD_SETOR,
                             COD_FUNCAO,
                             COD_UNIDADE,
                             COD_PERMISSAO,
                             COD_EMPRESA,
                             COD_EQUIPE,
                             PIS,
                             COD_UNIDADE_CADASTRO)
    VALUES (F_CPF,
            F_MATRICULA_AMBEV,
            F_MATRICULA_TRANS,
            F_DATA_NASCIMENTO,
            F_DATA_ADMISSAO,
            F_NOME,
            F_COD_SETOR,
            F_COD_FUNCAO,
            F_COD_UNIDADE,
            F_COD_PERMISSAO,
            F_COD_EMPRESA,
            F_COD_EQUIPE,
            F_PIS,
            F_COD_UNIDADE_CADASTRO) RETURNING CODIGO
               INTO F_COD_COLABORADOR_INSERIDO;

    -- Verificamos se o insert de colaborador funcionou.
    IF F_COD_COLABORADOR_INSERIDO IS NULL OR F_COD_COLABORADOR_INSERIDO <= 0
    THEN
        PERFORM THROW_GENERIC_ERROR(
                        'Não foi possível inserir o colaborador, tente novamente');
    END IF;

    IF F_PREFIXO_PAIS IS NOT NULL AND F_TELEFONE IS NOT NULL
    THEN
        INSERT INTO COLABORADOR_TELEFONE (SIGLA_ISO2,
                                          PREFIXO_PAIS,
                                          COD_COLABORADOR,
                                          NUMERO_TELEFONE,
                                          COD_COLABORADOR_ULTIMA_ATUALIZACAO)
        VALUES (F_SIGLA_ISO2,
                F_PREFIXO_PAIS,
                F_COD_COLABORADOR_INSERIDO,
                F_TELEFONE,
                F_COD_COLABORADOR_UPDATE) RETURNING CODIGO
                   INTO F_COD_TELEFONE_INSERIDO;

        -- Verificamos se o insert do telefone do colaborador funcionou.
        IF F_COD_TELEFONE_INSERIDO IS NULL OR F_COD_TELEFONE_INSERIDO <= 0
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível inserir o colaborador devido a problemas no telefone, tente novamente');
        END IF;
    END IF;

    IF F_EMAIL IS NOT NULL
    THEN
        INSERT INTO COLABORADOR_EMAIL (COD_COLABORADOR,
                                       EMAIL,
                                       COD_COLABORADOR_ULTIMA_ATUALIZACAO)
        VALUES (F_COD_COLABORADOR_INSERIDO,
                F_EMAIL,
                F_COD_COLABORADOR_UPDATE) RETURNING CODIGO
                   INTO F_COD_EMAIL_INSERIDO;

        -- Verificamos se o insert do email funcionou.
        IF F_COD_EMAIL_INSERIDO IS NULL OR F_COD_EMAIL_INSERIDO <= 0
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível inserir o colaborador devido a problemas no e-mail, tente novamente');
        END IF;
    END IF;

    RETURN F_COD_COLABORADOR_INSERIDO;
END;
$$;

create or replace function public.func_colaborador_update_colaborador(f_cod_colaborador bigint, f_cpf bigint,
                                                                      f_matricula_ambev integer,
                                                                      f_matricula_trans integer, f_data_nascimento date,
                                                                      f_data_admissao date, f_nome character varying,
                                                                      f_cod_setor bigint, f_cod_funcao integer,
                                                                      f_cod_unidade integer, f_cod_permissao bigint,
                                                                      f_cod_empresa bigint, f_cod_equipe bigint,
                                                                      f_pis character varying,
                                                                      f_sigla_iso2 character varying,
                                                                      f_prefixo_pais integer, f_telefone text,
                                                                      f_email email, f_token text) returns bigint
    language plpgsql
as
$$
DECLARE
    F_COD_COLABORADOR_UPDATE CONSTANT BIGINT := (SELECT COD_COLABORADOR
                                                 FROM TOKEN_AUTENTICACAO
                                                 WHERE TOKEN = F_TOKEN);
BEGIN
    UPDATE COLABORADOR
    SET CPF             = F_CPF,
        MATRICULA_AMBEV = F_MATRICULA_AMBEV,
        MATRICULA_TRANS = F_MATRICULA_TRANS,
        DATA_NASCIMENTO = F_DATA_NASCIMENTO,
        DATA_ADMISSAO   = F_DATA_ADMISSAO,
        NOME            = F_NOME,
        COD_SETOR       = F_COD_SETOR,
        COD_FUNCAO      = F_COD_FUNCAO,
        COD_UNIDADE     = F_COD_UNIDADE,
        COD_PERMISSAO   = F_COD_PERMISSAO,
        COD_EMPRESA     = F_COD_EMPRESA,
        COD_EQUIPE      = F_COD_EQUIPE,
        PIS             = F_PIS
    WHERE CODIGO = F_COD_COLABORADOR;

    -- Validamos se houve alguma atualização dos valores.
    IF NOT FOUND
    THEN
        PERFORM THROW_GENERIC_ERROR('Erro ao atualizar os dados do colaborador, tente novamente');
    END IF;

    -- Será permitido somente 1 email e telefone por colaborador no lançamento inicial.
    -- Deletamos email e telefone vinculados ao colaborador
    DELETE FROM COLABORADOR_EMAIL WHERE COD_COLABORADOR = F_COD_COLABORADOR;
    DELETE FROM COLABORADOR_TELEFONE WHERE COD_COLABORADOR = F_COD_COLABORADOR;

    IF F_PREFIXO_PAIS IS NOT NULL AND F_TELEFONE IS NOT NULL
    THEN
        INSERT INTO COLABORADOR_TELEFONE (SIGLA_ISO2,
                                          PREFIXO_PAIS,
                                          COD_COLABORADOR,
                                          NUMERO_TELEFONE,
                                          COD_COLABORADOR_ULTIMA_ATUALIZACAO)
        VALUES (F_SIGLA_ISO2,
                F_PREFIXO_PAIS,
                F_COD_COLABORADOR,
                F_TELEFONE,
                F_COD_COLABORADOR_UPDATE);

        -- Verificamos se o insert do telefone do colaborador funcionou.
        IF NOT FOUND
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível atualizar o colaborador devido a problemas no telefone, tente novamente');
        END IF;
    END IF;

    IF F_EMAIL IS NOT NULL
    THEN
        INSERT INTO COLABORADOR_EMAIL (COD_COLABORADOR,
                                       EMAIL,
                                       COD_COLABORADOR_ULTIMA_ATUALIZACAO)
        VALUES (F_COD_COLABORADOR,
                F_EMAIL,
                F_COD_COLABORADOR_UPDATE);

        -- Verificamos se o insert do email funcionou.
        IF NOT FOUND
        THEN
            PERFORM THROW_GENERIC_ERROR(
                            'Não foi possível atualizar o colaborador devido a problemas no e-mail, tente novamente');
        END IF;
    END IF;

    RETURN F_COD_COLABORADOR;
END;
$$;

create or replace function public.func_colaborador_get_all_by_empresa(f_cod_empresa bigint, f_status_ativos boolean)
    returns TABLE
            (
                codigo             bigint,
                cpf                bigint,
                pis                character varying,
                matricula_ambev    integer,
                matricula_trans    integer,
                data_nascimento    date,
                data_admissao      date,
                data_demissao      date,
                status_ativo       boolean,
                nome_colaborador   text,
                nome_empresa       text,
                cod_empresa        bigint,
                logo_thumbnail_url text,
                nome_regional      text,
                cod_regional       bigint,
                nome_unidade       text,
                cod_unidade        bigint,
                nome_equipe        text,
                cod_equipe         bigint,
                nome_setor         text,
                cod_setor          bigint,
                cod_funcao         bigint,
                nome_funcao        text,
                permissao          bigint,
                tz_unidade         text,
                sigla_iso2         text,
                prefixo_pais       integer,
                numero_telefone    text,
                email              text
            )
    language sql
as
$$
SELECT C.CODIGO,
       C.CPF,
       C.PIS,
       C.MATRICULA_AMBEV,
       C.MATRICULA_TRANS,
       C.DATA_NASCIMENTO,
       C.DATA_ADMISSAO,
       C.DATA_DEMISSAO,
       C.STATUS_ATIVO,
       INITCAP(C.NOME) AS NOME_COLABORADOR,
       EM.NOME         AS NOME_EMPRESA,
       EM.CODIGO       AS COD_EMPRESA,
       EM.LOGO_THUMBNAIL_URL,
       R.REGIAO        AS NOME_REGIONAL,
       R.CODIGO        AS COD_REGIONAL,
       U.NOME          AS NOME_UNIDADE,
       U.CODIGO        AS COD_UNIDADE,
       EQ.NOME         AS NOME_EQUIPE,
       EQ.CODIGO       AS COD_EQUIPE,
       S.NOME          AS NOME_SETOR,
       S.CODIGO        AS COD_SETOR,
       F.CODIGO        AS COD_FUNCAO,
       F.NOME          AS NOME_FUNCAO,
       C.COD_PERMISSAO AS PERMISSAO,
       U.TIMEZONE      AS TZ_UNIDADE,
       CT.SIGLA_ISO2 :: TEXT,
       CT.PREFIXO_PAIS,
       CT.NUMERO_TELEFONE,
       CE.EMAIL
FROM COLABORADOR C
         JOIN FUNCAO F ON C.COD_FUNCAO = F.CODIGO
         JOIN EQUIPE EQ ON EQ.CODIGO = C.COD_EQUIPE
         JOIN UNIDADE U ON U.CODIGO = C.COD_UNIDADE
         JOIN EMPRESA EM ON EM.CODIGO = C.COD_EMPRESA AND EM.CODIGO = U.COD_EMPRESA
         JOIN REGIONAL R ON R.CODIGO = U.COD_REGIONAL
         JOIN SETOR S ON S.CODIGO = C.COD_SETOR AND C.COD_UNIDADE = S.COD_UNIDADE
         LEFT JOIN COLABORADOR_TELEFONE CT ON C.CODIGO = CT.COD_COLABORADOR
         LEFT JOIN COLABORADOR_EMAIL CE ON C.CODIGO = CE.COD_COLABORADOR
WHERE C.COD_EMPRESA = F_COD_EMPRESA
  AND CASE
          WHEN F_STATUS_ATIVOS IS NULL
              THEN 1 = 1
          ELSE C.STATUS_ATIVO = F_STATUS_ATIVOS
    END
ORDER BY C.NOME ASC
$$;

create or replace function public.func_colaborador_get_all_by_unidade(f_cod_unidade bigint, f_status_ativos boolean)
    returns TABLE
            (
                codigo             bigint,
                cpf                bigint,
                pis                character varying,
                matricula_ambev    integer,
                matricula_trans    integer,
                data_nascimento    date,
                data_admissao      date,
                data_demissao      date,
                status_ativo       boolean,
                nome_colaborador   text,
                nome_empresa       text,
                cod_empresa        bigint,
                logo_thumbnail_url text,
                nome_regional      text,
                cod_regional       bigint,
                nome_unidade       text,
                cod_unidade        bigint,
                nome_equipe        text,
                cod_equipe         bigint,
                nome_setor         text,
                cod_setor          bigint,
                cod_funcao         bigint,
                nome_funcao        text,
                permissao          bigint,
                tz_unidade         text,
                sigla_iso2         text,
                prefixo_pais       integer,
                numero_telefone    text,
                email              text
            )
    language sql
as
$$
SELECT C.CODIGO,
       C.CPF,
       C.PIS,
       C.MATRICULA_AMBEV,
       C.MATRICULA_TRANS,
       C.DATA_NASCIMENTO,
       C.DATA_ADMISSAO,
       C.DATA_DEMISSAO,
       C.STATUS_ATIVO,
       INITCAP(C.NOME) AS NOME_COLABORADOR,
       EM.NOME         AS NOME_EMPRESA,
       EM.CODIGO       AS COD_EMPRESA,
       EM.LOGO_THUMBNAIL_URL,
       R.REGIAO        AS NOME_REGIONAL,
       R.CODIGO        AS COD_REGIONAL,
       U.NOME          AS NOME_UNIDADE,
       U.CODIGO        AS COD_UNIDADE,
       EQ.NOME         AS NOME_EQUIPE,
       EQ.CODIGO       AS COD_EQUIPE,
       S.NOME          AS NOME_SETOR,
       S.CODIGO        AS COD_SETOR,
       F.CODIGO        AS COD_FUNCAO,
       F.NOME          AS NOME_FUNCAO,
       C.COD_PERMISSAO AS PERMISSAO,
       U.TIMEZONE      AS TZ_UNIDADE,
       CT.SIGLA_ISO2 :: TEXT,
       CT.PREFIXO_PAIS,
       CT.NUMERO_TELEFONE,
       CE.EMAIL
FROM COLABORADOR C
         JOIN FUNCAO F ON C.COD_FUNCAO = F.CODIGO
         JOIN EQUIPE EQ ON EQ.CODIGO = C.COD_EQUIPE
         JOIN UNIDADE U ON U.CODIGO = C.COD_UNIDADE
         JOIN EMPRESA EM ON EM.CODIGO = C.COD_EMPRESA AND EM.CODIGO = U.COD_EMPRESA
         JOIN REGIONAL R ON R.CODIGO = U.COD_REGIONAL
         JOIN SETOR S ON S.CODIGO = C.COD_SETOR AND C.COD_UNIDADE = S.COD_UNIDADE
         LEFT JOIN COLABORADOR_TELEFONE CT ON C.CODIGO = CT.COD_COLABORADOR
         LEFT JOIN COLABORADOR_EMAIL CE ON C.CODIGO = CE.COD_COLABORADOR
WHERE C.COD_UNIDADE = F_COD_UNIDADE
  AND CASE
          WHEN F_STATUS_ATIVOS IS NULL
              THEN 1 = 1
          ELSE C.STATUS_ATIVO = F_STATUS_ATIVOS
    END
ORDER BY C.NOME ASC
$$;

create or replace function public.func_socorro_rota_empresa_liberada(f_cod_empresa bigint) returns void
    language plpgsql
as
$$
DECLARE
    -- Liberado para Fadel (1), Avilan (2 e 54), Testes (3) e Athivalog (7).
    F_COD_EMPRESAS_LIBERADAS BIGINT[] := (SELECT ARRAY_AGG(COD_EMPRESA)
                                          FROM SOCORRO_ROTA_EMPRESA_LIBERADA);
BEGIN
    -- Por enquanto apenas a fadel está utilizando esta funcionalidade.
    -- TODO: Criar estrutura própria para realizar essa verificação
    IF NOT F_COD_EMPRESA = ANY (F_COD_EMPRESAS_LIBERADAS) THEN
        PERFORM THROW_GENERIC_ERROR(
                        'A funcionalidade de Socorro em Rota não está liberada para a sua empresa, entre em contato com conexao@zalf.com.br para contratar!');
    END IF;
END;
$$;

create or replace function integracao.func_geral_busca_unidades_bloqueadas_integracao(f_user_token text)
    returns TABLE
            (
                cod_unidade_bloqueada bigint
            )
    language sql
as
$$
SELECT EUIB.COD_UNIDADE_BLOQUEADA
FROM INTEGRACAO.EMPRESA_UNIDADES_INTEGRACAO_BLOQUEADA EUIB
WHERE EUIB.COD_EMPRESA = (SELECT COD_EMPRESA
                          FROM TOKEN_AUTENTICACAO TA
                                   JOIN COLABORADOR C ON C.CODIGO = TA.COD_COLABORADOR
                          WHERE TA.TOKEN = F_USER_TOKEN)
$$;

create or replace function public.func_socorro_rota_listagem(f_cod_unidades bigint[], f_data_inicial date,
                                                             f_data_final date, f_token text)
    returns TABLE
            (
                cod_socorro_rota                          bigint,
                unidade                                   text,
                placa_veiculo                             text,
                veiculo_deletado                          boolean,
                nome_responsavel_abertura_socorro         text,
                colaborador_deletado                      boolean,
                descricao_fornecida_abertura_socorro      text,
                descricao_opcao_problema_abertura_socorro text,
                data_hora_abertura_socorro                timestamp without time zone,
                endereco_automatico_abertura_socorro      text,
                url_foto_1_abertura                       text,
                url_foto_2_abertura                       text,
                url_foto_3_abertura                       text,
                status_atual_socorro_rota                 socorro_rota_status_type
            )
    language plpgsql
as
$$
DECLARE
    -- Permissões para ver todos os socorros em rota
    -- 146 - TRATAR_SOCORRO
    -- 147 - VISUALIZAR_SOCORROS_E_RELATORIOS
    F_PERMISSOES_VISUALIZAR_TODOS INTEGER[] := ARRAY [146,147];
    F_VER_TODOS                   BOOLEAN   := (SELECT POSSUI_PERMISSSAO
                                                FROM FUNC_COLABORADOR_VERIFICA_PERMISSOES_TOKEN(F_TOKEN,
                                                                                                F_PERMISSOES_VISUALIZAR_TODOS,
                                                                                                FALSE,
                                                                                                TRUE));
    F_COD_COLABORADOR             BIGINT    := (SELECT COD_COLABORADOR
                                                FROM TOKEN_AUTENTICACAO
                                                WHERE TOKEN = F_TOKEN);
    -- Busca o código de empresa com base na primeira unidade do array recebido
    F_COD_EMPRESA                 BIGINT    := (SELECT COD_EMPRESA
                                                FROM UNIDADE
                                                WHERE CODIGO = (SELECT (F_COD_UNIDADES)[1]));
BEGIN
    -- Verifica se a funcionalidade está liberada para a empresa
    PERFORM FUNC_SOCORRO_ROTA_EMPRESA_LIBERADA(F_COD_EMPRESA);

    RETURN QUERY
        SELECT SR.CODIGO                                                      AS COD_SOCORRO_ROTA,
               U.NOME :: TEXT                                                 AS UNIDADE,
               VD.PLACA :: TEXT                                               AS PLACA_VEICULO,
               VD.DELETADO                                                    AS VEICULO_DELETADO,
               CD.NOME :: TEXT                                                AS NOME_RESPONSAVEL,
               CD.DELETADO                                                    AS COLABORADOR_DELETADO,
               SRA.DESCRICAO_PROBLEMA                                         AS DESCRICAO_FORNECIDA,
               SROP.DESCRICAO :: TEXT                                         AS DESCRICAO_OPCAO_PROBLEMA,
               SRA.DATA_HORA_ABERTURA AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE) AS DATA_HORA_ABERTURA,
               SRA.ENDERECO_AUTOMATICO                                        AS ENDERECO_AUTOMATICO_ABERTURA,
               SRA.URL_FOTO_1_ABERTURA :: TEXT                                AS URL_FOTO_1_ABERTURA,
               SRA.URL_FOTO_2_ABERTURA :: TEXT                                AS URL_FOTO_2_ABERTURA,
               SRA.URL_FOTO_3_ABERTURA :: TEXT                                AS URL_FOTO_3_ABERTURA,
               SR.STATUS_ATUAL :: SOCORRO_ROTA_STATUS_TYPE                    AS STATUS_ATUAL_SOCORRO
        FROM SOCORRO_ROTA SR
                 JOIN UNIDADE U ON U.CODIGO = SR.COD_UNIDADE
                 JOIN SOCORRO_ROTA_ABERTURA SRA ON SRA.COD_SOCORRO_ROTA = SR.CODIGO
                 JOIN VEICULO_DATA VD ON SRA.COD_VEICULO_PROBLEMA = VD.CODIGO
                 JOIN COLABORADOR_DATA CD ON SRA.COD_COLABORADOR_ABERTURA = CD.CODIGO
                 JOIN SOCORRO_ROTA_OPCAO_PROBLEMA SROP ON SROP.CODIGO = SRA.COD_PROBLEMA_SOCORRO_ROTA
        WHERE SR.COD_UNIDADE = ANY (F_COD_UNIDADES)
          -- Aplica o filtro por colaborador apenas se não tiver permissão para ver todos
          AND F_IF(F_VER_TODOS, TRUE, SRA.COD_COLABORADOR_ABERTURA = F_COD_COLABORADOR)
          AND (SRA.DATA_HORA_ABERTURA AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)) :: DATE
            BETWEEN F_DATA_INICIAL AND F_DATA_FINAL
        ORDER BY SRA.DATA_HORA_ABERTURA DESC;
END;
$$;

create or replace function public.func_converte_interval_hhmmss(f_interval interval) returns text
    language plpgsql
as
$$
DECLARE
    DATA_FORMATADA text;
BEGIN
    SELECT CONCAT(
                   TRUNC(EXTRACT(EPOCH FROM (F_INTERVAL)) / 3600),
                   ':',
                   TO_CHAR(TO_TIMESTAMP(
                                   EXTRACT(EPOCH FROM (F_INTERVAL))
                               ), 'MI:SS')
               )
    INTO DATA_FORMATADA;
    RETURN DATA_FORMATADA;
END;
$$;

create or replace function public.func_socorro_rota_atendimento_get_colaboradores_notificacao(f_cod_socorro_rota bigint)
    returns TABLE
            (
                cod_colaborador     bigint,
                token_push_firebase text
            )
    language plpgsql
as
$$
DECLARE
    -- Só iremos notificar se o colaborador tiver alguma permissão que permita à ele visualizar o socorro através da
    -- notificação. As permissões do array são: solicitar, tratar e visualizar socorros.
    PERMISSAO_PERMISSOES_NECESSARIAS CONSTANT BIGINT[] := ARRAY [145, 146, 147];
BEGIN
    RETURN QUERY
        SELECT C.CODIGO                AS COD_COLABORADOR,
               PCT.TOKEN_PUSH_FIREBASE AS TOKEN_PUSH_FIREBASE
        FROM COLABORADOR C
                 JOIN SOCORRO_ROTA_ABERTURA SRA ON C.CODIGO = SRA.COD_COLABORADOR_ABERTURA
                 JOIN CARGO_FUNCAO_PROLOG_V11 CFP ON C.COD_UNIDADE = CFP.COD_UNIDADE
            AND C.COD_FUNCAO = CFP.COD_FUNCAO_COLABORADOR
                 JOIN FUNCAO F ON F.CODIGO = C.COD_FUNCAO AND
                                  F.CODIGO = CFP.COD_FUNCAO_COLABORADOR AND C.COD_EMPRESA = F.COD_EMPRESA
                 JOIN MESSAGING.PUSH_COLABORADOR_TOKEN PCT ON C.CODIGO = PCT.COD_COLABORADOR
        WHERE SRA.COD_SOCORRO_ROTA = F_COD_SOCORRO_ROTA
          AND CFP.COD_FUNCAO_PROLOG = ANY (PERMISSAO_PERMISSOES_NECESSARIAS)
          -- Filtra apenas por aplicativos do Prolog.
          AND PCT.APLICACAO_REFERENCIA_TOKEN IN ('PROLOG_ANDROID_DEBUG', 'PROLOG_ANDROID_PROD')
          AND C.STATUS_ATIVO = TRUE;
END;
$$;

create or replace function public.func_colaborador_get_unidades_acesso(f_cod_colaborador bigint, f_equipe_obrigatoria boolean DEFAULT true)
    returns TABLE
            (
                codigo_empresa  bigint,
                nome_empresa    text,
                codigo_regional bigint,
                nome_regional   text,
                codigo_unidade  bigint,
                nome_unidade    text,
                codigo_equipe   bigint,
                nome_equipe     text
            )
    language plpgsql
as
$$
DECLARE
    F_COD_PERMISSAO SMALLINT;
    F_COD_EMPRESA   BIGINT;
    F_COD_REGIONAL  BIGINT;
    F_COD_UNIDADE   BIGINT;
    F_COD_EQUIPE    BIGINT;
BEGIN
    SELECT INTO F_COD_PERMISSAO, F_COD_EMPRESA, F_COD_REGIONAL, F_COD_UNIDADE, F_COD_EQUIPE C.COD_PERMISSAO,
                                                                                            C.COD_EMPRESA,
                                                                                            R.CODIGO,
                                                                                            C.COD_UNIDADE,
                                                                                            C.COD_EQUIPE
    FROM COLABORADOR C
             JOIN UNIDADE U ON C.COD_UNIDADE = U.CODIGO
             JOIN REGIONAL R ON U.COD_REGIONAL = R.CODIGO
    WHERE C.CODIGO = F_COD_COLABORADOR;
    IF F_EQUIPE_OBRIGATORIA
    THEN
        RETURN QUERY
            SELECT EMP.CODIGO       AS COD_EMPRESA,
                   EMP.NOME :: TEXT AS NOME_EMPRESA,
                   R.CODIGO         AS COD_REGIONAL,
                   R.REGIAO :: TEXT AS NOME_REGIONAL,
                   U.CODIGO         AS COD_UNIDADE,
                   U.NOME :: TEXT   AS NOME_UNIDADE,
                   EQ.CODIGO        AS COD_EQUIPE,
                   EQ.NOME :: TEXT  AS NOME_EQUIPE
            FROM UNIDADE U
                     JOIN REGIONAL R
                          ON R.CODIGO = U.COD_REGIONAL
                     JOIN EMPRESA EMP
                          ON EMP.CODIGO = U.COD_EMPRESA
                     JOIN EQUIPE EQ
                          ON U.CODIGO = EQ.COD_UNIDADE
            WHERE EMP.CODIGO = F_COD_EMPRESA
              AND F_IF(F_COD_PERMISSAO <= 2, R.CODIGO = F_COD_REGIONAL, TRUE)
              AND F_IF(F_COD_PERMISSAO <= 1, U.CODIGO = F_COD_UNIDADE, TRUE)
              AND F_IF(F_COD_PERMISSAO = 0, EQ.CODIGO = F_COD_EQUIPE, TRUE)
            ORDER BY EMP.CODIGO ASC, R.CODIGO ASC, U.CODIGO ASC, EQ.CODIGO ASC;
    ELSE
        RETURN QUERY
            SELECT EMP.CODIGO       AS COD_EMPRESA,
                   EMP.NOME :: TEXT AS NOME_EMPRESA,
                   R.CODIGO         AS COD_REGIONAL,
                   R.REGIAO :: TEXT AS NOME_REGIONAL,
                   U.CODIGO         AS COD_UNIDADE,
                   U.NOME :: TEXT   AS NOME_UNIDADE,
                   EQ.CODIGO        AS COD_EQUIPE,
                   EQ.NOME :: TEXT  AS NOME_EQUIPE
            FROM UNIDADE U
                     JOIN REGIONAL R
                          ON R.CODIGO = U.COD_REGIONAL
                     JOIN EMPRESA EMP
                          ON EMP.CODIGO = U.COD_EMPRESA
                     LEFT JOIN EQUIPE EQ
                               ON U.CODIGO = EQ.COD_UNIDADE
            WHERE EMP.CODIGO = F_COD_EMPRESA
              AND F_IF(F_COD_PERMISSAO <= 2, R.CODIGO = F_COD_REGIONAL, TRUE)
              AND F_IF(F_COD_PERMISSAO <= 1, U.CODIGO = F_COD_UNIDADE, TRUE)
              AND F_IF(F_COD_PERMISSAO = 0, EQ.CODIGO = F_COD_EQUIPE, TRUE)
            ORDER BY EMP.CODIGO ASC, R.CODIGO ASC, U.CODIGO ASC, EQ.CODIGO ASC;
    END IF;
END;
$$;

create or replace function public.func_pneu_atualiza_status_pneu_prolog(f_cod_pneu_sistema_integrado bigint,
                                                                        f_codigo_pneu_cliente character varying,
                                                                        f_cod_unidade_pneu bigint,
                                                                        f_cpf_colaborador_alteracao_status character varying,
                                                                        f_data_hora_alteracao_status timestamp without time zone,
                                                                        f_status_pneu character varying,
                                                                        f_trocou_de_banda boolean,
                                                                        f_cod_novo_modelo_banda_pneu bigint,
                                                                        f_valor_nova_banda_pneu numeric,
                                                                        f_placa_veiculo_pneu_aplicado character varying,
                                                                        f_posicao_veiculo_pneu_aplicado integer,
                                                                        f_token_integracao character varying) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_PNEU            BIGINT  := (SELECT TI.COD_EMPRESA
                                            FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                            WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_VEICULO_PROLOG          BIGINT  := (SELECT V.CODIGO
                                            FROM PUBLIC.VEICULO V
                                            WHERE V.PLACA = F_PLACA_VEICULO_PNEU_APLICADO
                                              AND V.COD_UNIDADE IN (SELECT U.CODIGO
                                                                    FROM PUBLIC.UNIDADE U
                                                                    WHERE U.COD_EMPRESA = COD_EMPRESA_PNEU));
    IS_POSICAO_ESTEPE           BOOLEAN := F_IF(F_POSICAO_VEICULO_PNEU_APLICADO >= 900
                                                    AND F_POSICAO_VEICULO_PNEU_APLICADO <= 908, TRUE, FALSE);
    COD_PNEU_PROLOG             BIGINT  := (SELECT PC.COD_PNEU_CADASTRO_PROLOG
                                            FROM INTEGRACAO.PNEU_CADASTRADO PC
                                            WHERE PC.COD_PNEU_SISTEMA_INTEGRADO = F_COD_PNEU_SISTEMA_INTEGRADO
                                              AND PC.COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU);
    VIDA_ATUAL_PNEU             INTEGER := (SELECT P.VIDA_ATUAL
                                            FROM PUBLIC.PNEU P
                                            WHERE P.CODIGO = COD_PNEU_PROLOG);
    PROXIMA_VIDA_PNEU           INTEGER := VIDA_ATUAL_PNEU + 1;
    STATUS_APLICADO_VEICULO     TEXT    := 'EM_USO';
    COD_SERVICO_INCREMENTA_VIDA BIGINT;
    F_QTD_ROWS_ALTERADAS        BIGINT;
BEGIN
    -- Validamos se a Empresa é válida.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_PNEU,
                                        FORMAT('O token %s não é de uma Empresa válida', F_TOKEN_INTEGRACAO));

    -- Validamos se a Unidade repassada existe.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE_PNEU,
                                        FORMAT('A Unidade %s repassada não existe no Sistema ProLog',
                                               F_COD_UNIDADE_PNEU));

    -- Validamos se a Unidade pertence a Empresa do token repassado.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(COD_EMPRESA_PNEU,
                                                F_COD_UNIDADE_PNEU,
                                                FORMAT('A Unidade %s não está configurada para esta empresa',
                                                       F_COD_UNIDADE_PNEU));

    -- Validamos se o código do pneu no sistema integrado está mapeado na tabela interna do ProLog.
    IF (COD_PNEU_PROLOG IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O pneu de código interno %s não está mapeado no Sistema ProLog',
                                                  F_COD_PNEU_SISTEMA_INTEGRADO));
    END IF;

    -- Deletamos o vinculo do pneu com a placa. Caso o pneu não estava vinculado, nada irá acontecer.
    DELETE FROM VEICULO_PNEU VP WHERE VP.COD_PNEU = COD_PNEU_PROLOG;

    -- Atualiza o pneu para o status em que ele deve estar.
    UPDATE PUBLIC.PNEU
    SET STATUS      = F_STATUS_PNEU,
        COD_UNIDADE = F_COD_UNIDADE_PNEU
    WHERE CODIGO = COD_PNEU_PROLOG;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- Validamos se o status do pneu foi atualizado com sucesso
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('Não foi possível atualizar as informações do pneu %s para o status %s',
                               F_CODIGO_PNEU_CLIENTE,
                               F_STATUS_PNEU));
    END IF;

    -- Precisamos vincular o pneu ao veículo apenas se o status for aplicado.
    IF (F_STATUS_PNEU = STATUS_APLICADO_VEICULO)
    THEN
        -- Transferimos o pneu para a unidade do veículo, caso ele já não esteja.
        IF ((SELECT P.COD_UNIDADE FROM PUBLIC.PNEU P WHERE P.CODIGO = COD_PNEU_PROLOG) <> F_COD_UNIDADE_PNEU)
        THEN
            UPDATE PUBLIC.PNEU
            SET COD_UNIDADE = (SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG)
            WHERE CODIGO = COD_PNEU_PROLOG;

            SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG INTO F_COD_UNIDADE_PNEU;
        END IF;

        PERFORM INTEGRACAO.FUNC_PNEU_VINCULA_PNEU_POSICAO_PLACA(COD_VEICULO_PROLOG,
                                                                F_PLACA_VEICULO_PNEU_APLICADO,
                                                                COD_PNEU_PROLOG,
                                                                F_CODIGO_PNEU_CLIENTE,
                                                                F_COD_UNIDADE_PNEU,
                                                                F_POSICAO_VEICULO_PNEU_APLICADO,
                                                                IS_POSICAO_ESTEPE);
    END IF;

    IF (F_TROCOU_DE_BANDA)
    THEN
        -- Validamos se o código do modelo de banda é válido. Apenas validamos se o pneu possuir banda.
        IF (F_COD_NOVO_MODELO_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O código do modelo da banda deve ser informado');
        END IF;

        -- Validamos se o código do modelo da banda é válido. Apenas validamos se o pneu possuir banda.
        IF ((SELECT NOT EXISTS(SELECT MB.CODIGO
                               FROM PUBLIC.MODELO_BANDA MB
                               WHERE MB.COD_EMPRESA = COD_EMPRESA_PNEU
                                 AND MB.CODIGO = F_COD_NOVO_MODELO_BANDA_PNEU)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O modelo da banda do pneu %s não está mapeado no Sistema ProLog',
                                                      F_COD_NOVO_MODELO_BANDA_PNEU));
        END IF;

        -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
        IF (F_VALOR_NOVA_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da banda do pneu deve ser informado');
        END IF;

        -- Validamos se o valor da banda é um valor válido. Apenas validamos se o pneu possuir banda.
        IF (F_VALOR_NOVA_BANDA_PNEU < 0)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O valor da banda do pneu não pode ser um número negativo');
        END IF;

        -- Busca serviço que incrementa a vida do pneu dentro da empresa em questão.
        SELECT *
        FROM PUBLIC.FUNC_PNEU_GET_SERVICO_INCREMENTA_VIDA_PNEU_EMPRESA(COD_EMPRESA_PNEU)
        INTO COD_SERVICO_INCREMENTA_VIDA;

        IF (COD_SERVICO_INCREMENTA_VIDA IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('Erro ao vincular banda ao pneu');
        END IF;

        -- Incrementa a vida do pneu simulando um processo de movimentação.
        PERFORM INTEGRACAO.FUNC_PNEU_REALIZA_INCREMENTO_VIDA_MOVIMENTACAO(F_COD_UNIDADE_PNEU,
                                                                          COD_PNEU_PROLOG,
                                                                          F_COD_NOVO_MODELO_BANDA_PNEU,
                                                                          F_VALOR_NOVA_BANDA_PNEU,
                                                                          PROXIMA_VIDA_PNEU,
                                                                          COD_SERVICO_INCREMENTA_VIDA);

        -- Após incrementar a vida e criar o serviço, atualizamos o pneu para ficar com a banda e a vida correta.
        PERFORM PUBLIC.FUNC_PNEUS_INCREMENTA_VIDA_PNEU(COD_PNEU_PROLOG, F_COD_NOVO_MODELO_BANDA_PNEU);
    END IF;

    -- Qualquer alteração de status do pneu deve verificar se o pneu tem serviços aberto e fechá-los.
    PERFORM INTEGRACAO.FUNC_PNEU_FECHA_SERVICO_PNEU_AUTOMATICAMENTE(COD_PNEU_PROLOG,
                                                                    F_DATA_HORA_ALTERACAO_STATUS);

    RETURN COD_PNEU_PROLOG;
END;
$$;

create or replace function public.func_pneu_atualiza_status_pneu_prolog(f_cod_pneu_sistema_integrado bigint,
                                                                        f_codigo_pneu_cliente character varying,
                                                                        f_cod_unidade_pneu bigint,
                                                                        f_cpf_colaborador_alteracao_status character varying,
                                                                        f_data_hora_alteracao_status timestamp with time zone,
                                                                        f_status_pneu character varying,
                                                                        f_trocou_de_banda boolean,
                                                                        f_cod_novo_modelo_banda_pneu bigint,
                                                                        f_valor_nova_banda_pneu numeric,
                                                                        f_placa_veiculo_pneu_aplicado character varying,
                                                                        f_posicao_veiculo_pneu_aplicado integer,
                                                                        f_token_integracao character varying) returns bigint
    language plpgsql
as
$$
DECLARE
    COD_EMPRESA_PNEU            BIGINT  := (SELECT TI.COD_EMPRESA
                                            FROM INTEGRACAO.TOKEN_INTEGRACAO TI
                                            WHERE TI.TOKEN_INTEGRACAO = F_TOKEN_INTEGRACAO);
    COD_VEICULO_PROLOG          BIGINT  := (SELECT V.CODIGO
                                            FROM PUBLIC.VEICULO V
                                            WHERE V.PLACA = F_PLACA_VEICULO_PNEU_APLICADO
                                              AND V.COD_UNIDADE IN (SELECT U.CODIGO
                                                                    FROM PUBLIC.UNIDADE U
                                                                    WHERE U.COD_EMPRESA = COD_EMPRESA_PNEU));
    IS_POSICAO_ESTEPE           BOOLEAN := F_IF(F_POSICAO_VEICULO_PNEU_APLICADO >= 900
                                                    AND F_POSICAO_VEICULO_PNEU_APLICADO <= 908, TRUE, FALSE);
    COD_PNEU_PROLOG             BIGINT  := (SELECT PC.COD_PNEU_CADASTRO_PROLOG
                                            FROM INTEGRACAO.PNEU_CADASTRADO PC
                                            WHERE PC.COD_PNEU_SISTEMA_INTEGRADO = F_COD_PNEU_SISTEMA_INTEGRADO
                                              AND PC.COD_EMPRESA_CADASTRO = COD_EMPRESA_PNEU);
    VIDA_ATUAL_PNEU             INTEGER := (SELECT P.VIDA_ATUAL
                                            FROM PUBLIC.PNEU P
                                            WHERE P.CODIGO = COD_PNEU_PROLOG);
    PROXIMA_VIDA_PNEU           INTEGER := VIDA_ATUAL_PNEU + 1;
    STATUS_APLICADO_VEICULO     TEXT    := 'EM_USO';
    COD_SERVICO_INCREMENTA_VIDA BIGINT;
    F_QTD_ROWS_ALTERADAS        BIGINT;
BEGIN
    -- VALIDAMOS SE A EMPRESA É VÁLIDA.
    PERFORM FUNC_GARANTE_EMPRESA_EXISTE(COD_EMPRESA_PNEU,
                                        FORMAT('O TOKEN %S NÃO É DE UMA EMPRESA VÁLIDA', F_TOKEN_INTEGRACAO));

    -- VALIDAMOS SE A UNIDADE REPASSADA EXISTE.
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE_PNEU,
                                        FORMAT('A UNIDADE %S REPASSADA NÃO EXISTE NO SISTEMA PROLOG',
                                               F_COD_UNIDADE_PNEU));

    -- VALIDAMOS SE A UNIDADE PERTENCE A EMPRESA DO TOKEN REPASSADO.
    PERFORM FUNC_GARANTE_EMPRESA_POSSUI_UNIDADE(COD_EMPRESA_PNEU,
                                                F_COD_UNIDADE_PNEU,
                                                FORMAT('A UNIDADE %S NÃO ESTÁ CONFIGURADA PARA ESTA EMPRESA',
                                                       F_COD_UNIDADE_PNEU));

    -- VALIDAMOS SE O CÓDIGO DO PNEU NO SISTEMA INTEGRADO ESTÁ MAPEADO NA TABELA INTERNA DO PROLOG.
    IF (COD_PNEU_PROLOG IS NULL)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O PNEU DE CÓDIGO INTERNO %S NÃO ESTÁ MAPEADO NO SISTEMA PROLOG',
                                                  F_COD_PNEU_SISTEMA_INTEGRADO));
    END IF;

    -- DELETAMOS O VINCULO DO PNEU COM A PLACA. CASO O PNEU NÃO ESTAVA VINCULADO, NADA IRÁ ACONTECER.
    DELETE FROM VEICULO_PNEU VP WHERE VP.COD_PNEU = COD_PNEU_PROLOG;

    -- ATUALIZA O PNEU PARA O STATUS EM QUE ELE DEVE ESTAR.
    UPDATE PUBLIC.PNEU
    SET STATUS      = F_STATUS_PNEU,
        COD_UNIDADE = F_COD_UNIDADE_PNEU
    WHERE CODIGO = COD_PNEU_PROLOG;

    GET DIAGNOSTICS F_QTD_ROWS_ALTERADAS = ROW_COUNT;

    -- VALIDAMOS SE O STATUS DO PNEU FOI ATUALIZADO COM SUCESSO
    IF (F_QTD_ROWS_ALTERADAS <= 0)
    THEN
        PERFORM PUBLIC.THROW_GENERIC_ERROR(
                        FORMAT('NÃO FOI POSSÍVEL ATUALIZAR AS INFORMAÇÕES DO PNEU %S PARA O STATUS %S',
                               F_CODIGO_PNEU_CLIENTE,
                               F_STATUS_PNEU));
    END IF;

    -- PRECISAMOS VINCULAR O PNEU AO VEÍCULO APENAS SE O STATUS FOR APLICADO.
    IF (F_STATUS_PNEU = STATUS_APLICADO_VEICULO)
    THEN
        -- TRANSFERIMOS O PNEU PARA A UNIDADE DO VEÍCULO, CASO ELE JÁ NÃO ESTEJA.
        IF ((SELECT P.COD_UNIDADE FROM PUBLIC.PNEU P WHERE P.CODIGO = COD_PNEU_PROLOG) <> F_COD_UNIDADE_PNEU)
        THEN
            UPDATE PUBLIC.PNEU
            SET COD_UNIDADE = (SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG)
            WHERE CODIGO = COD_PNEU_PROLOG;

            SELECT V.COD_UNIDADE FROM PUBLIC.VEICULO V WHERE V.CODIGO = COD_VEICULO_PROLOG INTO F_COD_UNIDADE_PNEU;
        END IF;

        PERFORM INTEGRACAO.FUNC_PNEU_VINCULA_PNEU_POSICAO_PLACA(COD_VEICULO_PROLOG,
                                                                F_PLACA_VEICULO_PNEU_APLICADO,
                                                                COD_PNEU_PROLOG,
                                                                F_CODIGO_PNEU_CLIENTE,
                                                                F_COD_UNIDADE_PNEU,
                                                                F_POSICAO_VEICULO_PNEU_APLICADO,
                                                                IS_POSICAO_ESTEPE);
    END IF;

    IF (F_TROCOU_DE_BANDA)
    THEN
        -- VALIDAMOS SE O CÓDIGO DO MODELO DE BANDA É VÁLIDO. APENAS VALIDAMOS SE O PNEU POSSUIR BANDA.
        IF (F_COD_NOVO_MODELO_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O CÓDIGO DO MODELO DA BANDA DEVE SER INFORMADO');
        END IF;

        -- VALIDAMOS SE O CÓDIGO DO MODELO DA BANDA É VÁLIDO. APENAS VALIDAMOS SE O PNEU POSSUIR BANDA.
        IF ((SELECT NOT EXISTS(SELECT MB.CODIGO
                               FROM PUBLIC.MODELO_BANDA MB
                               WHERE MB.COD_EMPRESA = COD_EMPRESA_PNEU
                                 AND MB.CODIGO = F_COD_NOVO_MODELO_BANDA_PNEU)))
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR(FORMAT('O MODELO DA BANDA DO PNEU %S NÃO ESTÁ MAPEADO NO SISTEMA PROLOG',
                                                      F_COD_NOVO_MODELO_BANDA_PNEU));
        END IF;

        -- VALIDAMOS SE O VALOR DA BANDA É UM VALOR VÁLIDO. APENAS VALIDAMOS SE O PNEU POSSUIR BANDA.
        IF (F_VALOR_NOVA_BANDA_PNEU IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O VALOR DA BANDA DO PNEU DEVE SER INFORMADO');
        END IF;

        -- VALIDAMOS SE O VALOR DA BANDA É UM VALOR VÁLIDO. APENAS VALIDAMOS SE O PNEU POSSUIR BANDA.
        IF (F_VALOR_NOVA_BANDA_PNEU < 0)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('O VALOR DA BANDA DO PNEU NÃO PODE SER UM NÚMERO NEGATIVO');
        END IF;

        -- BUSCA SERVIÇO QUE INCREMENTA A VIDA DO PNEU DENTRO DA EMPRESA EM QUESTÃO.
        SELECT *
        FROM PUBLIC.FUNC_PNEU_GET_SERVICO_INCREMENTA_VIDA_PNEU_EMPRESA(COD_EMPRESA_PNEU)
        INTO COD_SERVICO_INCREMENTA_VIDA;

        IF (COD_SERVICO_INCREMENTA_VIDA IS NULL)
        THEN
            PERFORM PUBLIC.THROW_GENERIC_ERROR('ERRO AO VINCULAR BANDA AO PNEU');
        END IF;

        -- INCREMENTA A VIDA DO PNEU SIMULANDO UM PROCESSO DE MOVIMENTAÇÃO.
        PERFORM INTEGRACAO.FUNC_PNEU_REALIZA_INCREMENTO_VIDA_MOVIMENTACAO(F_COD_UNIDADE_PNEU,
                                                                          COD_PNEU_PROLOG,
                                                                          F_COD_NOVO_MODELO_BANDA_PNEU,
                                                                          F_VALOR_NOVA_BANDA_PNEU,
                                                                          PROXIMA_VIDA_PNEU,
                                                                          COD_SERVICO_INCREMENTA_VIDA);

        -- APÓS INCREMENTAR A VIDA E CRIAR O SERVIÇO, ATUALIZAMOS O PNEU PARA FICAR COM A BANDA E A VIDA CORRETA.
        PERFORM PUBLIC.FUNC_PNEUS_INCREMENTA_VIDA_PNEU(COD_PNEU_PROLOG, F_COD_NOVO_MODELO_BANDA_PNEU);
    END IF;

    -- QUALQUER ALTERAÇÃO DE STATUS DO PNEU DEVE VERIFICAR SE O PNEU TEM SERVIÇOS ABERTO E FECHÁ-LOS.
    PERFORM INTEGRACAO.FUNC_PNEU_FECHA_SERVICO_PNEU_AUTOMATICAMENTE(COD_PNEU_PROLOG,
                                                                    F_DATA_HORA_ALTERACAO_STATUS);

    RETURN COD_PNEU_PROLOG;
END;
$$;

create or replace function piccolotur.func_check_os_insere_checklist_pendente_sincronia(f_cod_checklist bigint) returns void
    language plpgsql
as
$$
begin
    insert into piccolotur.checklist_pendente_para_sincronizar (cod_checklist_para_sincronizar, data_hora_realizado)
    values (f_cod_checklist,
            (select data_hora from checklist where codigo = f_cod_checklist));

    if not found
    then
        -- Não queremos que esse erro seja mapeado para o usuário ou para a integração.
        raise exception '%', (format('Não foi possível inserir o checklist (%s) na tabela de pendentes para envio',
                                     f_cod_checklist));
    end if;
end;
$$;

create or replace function piccolotur.func_check_os_marca_checklist_nao_precisa_sincronizar(f_cod_checklist bigint,
                                                                                            f_data_hora_atualizacao timestamp with time zone) returns void
    language plpgsql
as
$$
begin
    update piccolotur.checklist_pendente_para_sincronizar
    set precisa_ser_sincronizado     = false,
        data_hora_ultima_atualizacao = f_data_hora_atualizacao
    where cod_checklist_para_sincronizar = f_cod_checklist;

    if not found
    then
        -- Não queremos que esse erro seja mapeado para o usuário ou para a integração.
        raise exception '%', (format('Não foi possível marcar o checklist (%s) para não ser sincronizado',
                                     f_cod_checklist));
    end if;
end;
$$;

create or replace function piccolotur.func_check_os_marca_checklist_como_sincronizado(f_cod_checklist bigint,
                                                                                      f_data_hora_atualizacao timestamp with time zone) returns void
    language plpgsql
as
$$
begin
    update piccolotur.checklist_pendente_para_sincronizar
    set sincronizado                 = true,
        data_hora_ultima_atualizacao = f_data_hora_atualizacao
    where cod_checklist_para_sincronizar = f_cod_checklist;

    if not found
    then
        -- Não queremos que esse erro seja mapeado para o usuário ou para a integração.
        raise exception '%', (format('Não foi possível marcar o checklist (%s) como sincronizado', f_cod_checklist));
    end if;
end;
$$;

create or replace function piccolotur.func_check_os_insere_erro_sincronia_checklist(f_cod_checklist bigint,
                                                                                    f_error_message text,
                                                                                    f_stacktrace text,
                                                                                    f_data_hora_atualizacao timestamp with time zone) returns void
    language plpgsql
as
$$
declare
    nova_quantidade_tentativas integer;
begin
    update piccolotur.checklist_pendente_para_sincronizar
    set mensagem_erro_ao_sincronizar = f_error_message,
        data_hora_ultima_atualizacao = f_data_hora_atualizacao,
        qtd_tentativas               = qtd_tentativas + 1
    where cod_checklist_para_sincronizar = f_cod_checklist returning qtd_tentativas into nova_quantidade_tentativas;

    insert into piccolotur.checklist_erros_sincronia(cod_checklist_para_sincronizar,
                                                     nova_qtd_tentativas,
                                                     error_stacktrace,
                                                     data_hora_erro)
    values (f_cod_checklist, nova_quantidade_tentativas, f_stacktrace, f_data_hora_atualizacao);

    if not found
    then
        -- Não queremos que esse erro seja mapeado para o usuário ou para a integração.
        raise exception '%', (format('Não foi possível salvar a error_message ao tentar sincronizar o checklist (%s)',
                                     f_cod_checklist));
    end if;
end;
$$;

create or replace function piccolotur.func_check_os_busca_checklist_itens_nok(f_cod_checklist_prolog bigint)
    returns TABLE
            (
                cod_unidade_checklist        bigint,
                cod_modelo_checklist         bigint,
                cod_versao_modelo_checklist  bigint,
                cpf_colaborador_realizacao   text,
                placa_veiculo_checklist      text,
                km_coletado_checklist        bigint,
                tipo_checklist               text,
                data_hora_realizacao         timestamp without time zone,
                total_alternativas_nok       integer,
                cod_contexto_pergunta_nok    bigint,
                descricao_pergunta_nok       text,
                cod_alternativa_nok          bigint,
                cod_contexto_alternativa_nok bigint,
                descricao_alternativa_nok    text,
                prioridade_alternativa_nok   text
            )
    language sql
as
$$
SELECT C.COD_UNIDADE                                                           AS COD_UNIDADE_CHECKLIST,
       C.COD_CHECKLIST_MODELO                                                  AS COD_MODELO_CHECKLIST,
       C.COD_VERSAO_CHECKLIST_MODELO                                           AS COD_VERSAO_MODELO_CHECKLIST,
       LPAD(C.CPF_COLABORADOR::TEXT, 11, '0')                                  AS CPF_COLABORADOR_REALIZACAO,
       C.PLACA_VEICULO::TEXT                                                   AS PLACA_VEICULO_CHECKLIST,
       C.KM_VEICULO                                                            AS KM_COLETADO_CHECKLIST,
       F_IF(C.TIPO::TEXT = 'S'::TEXT, 'SAIDA'::TEXT, 'RETORNO'::TEXT)          AS TIPO_CHECKLIST,
       C.DATA_HORA AT TIME ZONE TZ_UNIDADE(C.COD_UNIDADE)                      AS DATA_HORA_REALIZACAO,
       C.TOTAL_ALTERNATIVAS_NOK::INTEGER                                       AS TOTAL_ALTERNATIVAS_NOK,
       CP.CODIGO_CONTEXTO                                                      AS COD_CONTEXTO_PERGUNTA_NOK,
       CP.PERGUNTA                                                             AS DESCRICAO_PERGUNTA_NOK,
       CAP.CODIGO                                                              AS COD_ALTERNATIVA_NOK,
       CAP.CODIGO_CONTEXTO                                                     AS COD_CONTEXTO_ALTERNATIVA_NOK,
       F_IF(CAP.ALTERNATIVA_TIPO_OUTROS, CRN.RESPOSTA_OUTROS, CAP.ALTERNATIVA) AS DESCRICAO_ALTERNATIVA_NOK,
       CAP.PRIORIDADE                                                          AS PRIORIDADE_ALTERNATIVA_NOK
FROM CHECKLIST C
         -- Usamos LEFT JOIN para os cenários onde o check não possuir nenhum item NOK, devemos retornar as infos do
         -- checklist mesmo assim.
         LEFT JOIN CHECKLIST_RESPOSTAS_NOK CRN ON C.CODIGO = CRN.COD_CHECKLIST
         LEFT JOIN CHECKLIST_PERGUNTAS CP ON CRN.COD_PERGUNTA = CP.CODIGO
    AND C.COD_VERSAO_CHECKLIST_MODELO = CP.COD_VERSAO_CHECKLIST_MODELO
         LEFT JOIN CHECKLIST_ALTERNATIVA_PERGUNTA CAP ON CRN.COD_ALTERNATIVA = CAP.CODIGO
    AND C.COD_VERSAO_CHECKLIST_MODELO = CAP.COD_VERSAO_CHECKLIST_MODELO
WHERE C.CODIGO = F_COD_CHECKLIST_PROLOG;
$$;

create or replace function piccolotur.func_check_os_get_next_cod_checklist_para_sincronizar()
    returns TABLE
            (
                cod_checklist bigint,
                is_last_cod   boolean
            )
    language plpgsql
as
$$
DECLARE
    COD_CHECKLIST BIGINT;
    IS_LAST_COD   BOOLEAN;
BEGIN
    --   1° - verifica se existe um checklist para sincronizar, se não, seta o de menor código como apto a
    --   sincronização.
    IF ((SELECT COD_CHECKLIST_PARA_SINCRONIZAR
         FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
         WHERE NEXT_TO_SYNC IS TRUE
           AND SINCRONIZADO IS FALSE
           AND PRECISA_SER_SINCRONIZADO IS TRUE
         LIMIT 1) IS NULL)
    THEN
        UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
        SET NEXT_TO_SYNC = TRUE
        WHERE COD_CHECKLIST_PARA_SINCRONIZAR = (SELECT CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR CPPS
                                                WHERE CPPS.SINCRONIZADO IS FALSE
                                                  AND CPPS.PRECISA_SER_SINCRONIZADO IS TRUE
                                                ORDER BY CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                LIMIT 1);
    END IF;

    --   2° - Verifica se o código marcado para sincronizar é o último código a ser sincronizado
    SELECT CPPS.NEXT_TO_SYNC
    FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR CPPS
    WHERE CPPS.PRECISA_SER_SINCRONIZADO
      AND CPPS.SINCRONIZADO IS FALSE
    ORDER BY CPPS.COD_CHECKLIST_PARA_SINCRONIZAR DESC
    LIMIT 1
    INTO IS_LAST_COD;

    --   3° - Pega o código que está marcado para tentar sincronizar. Utilizamos limit 1 para evitar que mais de um
    --   código seja setado.
    SELECT COD_CHECKLIST_PARA_SINCRONIZAR
    FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
    WHERE NEXT_TO_SYNC = TRUE
    ORDER BY COD_CHECKLIST_PARA_SINCRONIZAR DESC
    LIMIT 1
    INTO COD_CHECKLIST;

    --   4° - Remove a marcação do checklist que estava marcado par sincronizar
    UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
    SET NEXT_TO_SYNC = FALSE
    WHERE COD_CHECKLIST_PARA_SINCRONIZAR = COD_CHECKLIST;

    --   5° - Marca o próximo código que precisa ser sincronizado, se for o último código, então seta o
    -- primeiro como o próximo a ser sincronizado
    IF IS_LAST_COD
    THEN
        UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
        SET NEXT_TO_SYNC = TRUE
        WHERE COD_CHECKLIST_PARA_SINCRONIZAR = (SELECT CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR CPPS
                                                WHERE CPPS.SINCRONIZADO IS FALSE
                                                  AND CPPS.PRECISA_SER_SINCRONIZADO IS TRUE
                                                ORDER BY CPPS.COD_CHECKLIST_PARA_SINCRONIZAR
                                                LIMIT 1);
    ELSE
        UPDATE PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
        SET NEXT_TO_SYNC = TRUE
        WHERE COD_CHECKLIST_PARA_SINCRONIZAR = (SELECT COD_CHECKLIST_PARA_SINCRONIZAR
                                                FROM PICCOLOTUR.CHECKLIST_PENDENTE_PARA_SINCRONIZAR
                                                WHERE SINCRONIZADO IS FALSE
                                                  AND PRECISA_SER_SINCRONIZADO IS TRUE
                                                  AND NEXT_TO_SYNC IS FALSE
                                                  AND COD_CHECKLIST_PARA_SINCRONIZAR > COD_CHECKLIST
                                                ORDER BY COD_CHECKLIST_PARA_SINCRONIZAR
                                                LIMIT 1);
    END IF;

    --   6° - Retorna o código que será sincronizado
    RETURN QUERY
        SELECT COD_CHECKLIST, IS_LAST_COD;
END;
$$;

create or replace function piccolotur.func_geral_liga_desliga_integracao_piccolotur(f_ligar_integracao boolean) returns void
    security definer
    language plpgsql
as
$$
begin
    if (f_ligar_integracao)
    then
        -- Ligamos a integração, apenas se já não estiver ligada.
        if (select not exists(select cod_empresa from integracao.token_integracao where cod_empresa = 11))
        then
            insert into integracao.token_integracao (cod_empresa, token_integracao)
            values (11, 'kffdm2ba5ai3lsk79kqur9rb3mq7hv59qa8pr0sho4mcr56clck');
            insert into integracao.empresa_integracao_sistema (cod_empresa, chave_sistema, recurso_integrado)
            values (11, 'GLOBUS_PICCOLOTUR', 'CHECKLIST');
            insert into integracao.empresa_integracao_sistema (cod_empresa, chave_sistema, recurso_integrado)
            values (11, 'GLOBUS_PICCOLOTUR', 'CHECKLIST_MODELO');
        end if;
    else
        -- Se não é LIGAR, então de desligamos, mas apenas se ela já não estiver desligada.
        if (select exists(select cod_empresa from integracao.token_integracao where cod_empresa = 11))
        then
            delete from integracao.token_integracao where cod_empresa = 11;
            delete from integracao.empresa_integracao_sistema where cod_empresa = 11;
        end if;
    end if;
end;
$$;

create or replace function public.func_afericao_relatorio_cronograma_afericoes_placas(f_cod_unidades bigint[],
                                                                                      f_data_hora_atual_utc timestamp with time zone,
                                                                                      f_data_hora_geracao_relatorio timestamp with time zone)
    returns TABLE
            (
                unidade                              text,
                placa                                text,
                "QTD PNEUS APLICADOS"                text,
                "MODELO VEÍCULO"                     text,
                "TIPO VEÍCULO"                       text,
                "STATUS SULCO"                       text,
                "STATUS PRESSÃO"                     text,
                "DATA VENCIMENTO SULCO"              text,
                "DATA VENCIMENTO PRESSÃO"            text,
                "DIAS VENCIMENTO SULCO"              text,
                "DIAS VENCIMENTO PRESSÃO"            text,
                "DIAS DESDE ÚLTIMA AFERIÇÃO SULCO"   text,
                "DATA/HORA ÚLTIMA AFERIÇÃO SULCO"    text,
                "DIAS DESDE ÚLTIMA AFERIÇÃO PRESSÃO" text,
                "DATA/HORA ÚLTIMA AFERIÇÃO PRESSÃO"  text,
                "DATA/HORA GERAÇÃO RELATÓRIO"        text
            )
    language plpgsql
as
$$
DECLARE
BEGIN
    RETURN QUERY
        WITH DADOS AS (SELECT U.NOME :: TEXT                                                           AS NOME_UNIDADE,
                              V.PLACA :: TEXT                                                          AS PLACA_VEICULO,
                              (SELECT COUNT(VP.COD_PNEU)
                               FROM VEICULO_PNEU VP
                               WHERE VP.PLACA = V.PLACA
                               GROUP BY VP.PLACA) :: TEXT                                              AS QTD_PNEUS_APLICADOS,
                              MV.NOME :: TEXT                                                          AS NOME_MODELO_VEICULO,
                              VT.NOME :: TEXT                                                          AS NOME_TIPO_VEICULO,
                              TO_CHAR(SULCO.DATA_HORA_ULTIMA_AFERICAO_SULCO, 'DD/MM/YYYY HH24:MI')     AS DATA_HORA_ULTIMA_AFERICAO_SULCO,
                              TO_CHAR(PRESSAO.DATA_HORA_ULTIMA_AFERICAO_PRESSAO,
                                      'DD/MM/YYYY HH24:MI')                                            AS DATA_HORA_ULTIMA_AFERICAO_PRESSAO,
                              TO_CHAR(SULCO.DATA_ULTIMA_AFERICAO_SULCO + (PRU.PERIODO_AFERICAO_SULCO ||
                                                                          ' DAYS') :: INTERVAL,
                                      'DD/MM/YYYY')                                                    AS DATA_VENCIMENTO_SULCO,
                              TO_CHAR(PRESSAO.DATA_ULTIMA_AFERICAO_PRESSAO + (PRU.PERIODO_AFERICAO_PRESSAO ||
                                                                              ' DAYS') :: INTERVAL,
                                      'DD/MM/YYYY')                                                    AS DATA_VENCIMENTO_PRESSAO,
                              (PRU.PERIODO_AFERICAO_SULCO -
                               SULCO.DIAS) :: TEXT                                                     AS DIAS_VENCIMENTO_SULCO,
                              (PRU.PERIODO_AFERICAO_PRESSAO - PRESSAO.DIAS) :: TEXT
                                                                                                       AS DIAS_VENCIMENTO_PRESSAO,
                              SULCO.DIAS :: TEXT                                                       AS DIAS_DESDE_ULTIMA_AFERICAO_SULCO,
                              PRESSAO.DIAS :: TEXT                                                     AS DIAS_DESDE_ULTIMA_AFERICAO_PRESSAO,
                              F_IF(CONFIG.PODE_AFERIR_SULCO OR CONFIG.PODE_AFERIR_SULCO_PRESSAO, TRUE,
                                   FALSE)                                                              AS PODE_AFERIR_SULCO,
                              F_IF(CONFIG.PODE_AFERIR_PRESSAO OR CONFIG.PODE_AFERIR_SULCO_PRESSAO, TRUE,
                                   FALSE)                                                              AS PODE_AFERIR_PRESSAO,
                              F_IF(SULCO.DIAS IS NULL, TRUE,
                                   FALSE)                                                              AS SULCO_NUNCA_AFERIDO,
                              F_IF(PRESSAO.DIAS IS NULL, TRUE,
                                   FALSE)                                                              AS PRESSAO_NUNCA_AFERIDA,
                              F_IF(SULCO.DIAS > PRU.PERIODO_AFERICAO_SULCO, TRUE,
                                   FALSE)                                                              AS AFERICAO_SULCO_VENCIDA,
                              F_IF(PRESSAO.DIAS > PRU.PERIODO_AFERICAO_PRESSAO, TRUE,
                                   FALSE)                                                              AS AFERICAO_PRESSAO_VENCIDA
                       FROM VEICULO V
                                JOIN MODELO_VEICULO MV
                                     ON MV.CODIGO = V.COD_MODELO
                                JOIN VEICULO_TIPO VT
                                     ON VT.CODIGO = V.COD_TIPO
                                JOIN FUNC_AFERICAO_GET_CONFIG_TIPO_AFERICAO_VEICULO(V.COD_UNIDADE) CONFIG
                                     ON CONFIG.COD_TIPO_VEICULO = V.COD_TIPO
                                LEFT JOIN
                            (SELECT A.PLACA_VEICULO                                               AS PLACA_INTERVALO,
                                    MAX(A.DATA_HORA AT TIME ZONE
                                        TZ_UNIDADE(A.COD_UNIDADE)) :: DATE                        AS DATA_ULTIMA_AFERICAO_PRESSAO,
                                    MAX(A.DATA_HORA AT TIME ZONE
                                        TZ_UNIDADE(A.COD_UNIDADE))                                AS DATA_HORA_ULTIMA_AFERICAO_PRESSAO,
                                    -- TODO: TENHO DÚVIDAS SOBRE ESSA SUBTRAÇÃO AQUI :thinking_face:
                                    EXTRACT(DAYS FROM (F_DATA_HORA_ATUAL_UTC) - MAX(A.DATA_HORA)) AS DIAS
                             FROM AFERICAO A
                             WHERE A.TIPO_MEDICAO_COLETADA = 'PRESSAO'
                                OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO'
                             GROUP BY A.PLACA_VEICULO) AS PRESSAO ON PRESSAO.PLACA_INTERVALO = V.PLACA
                                LEFT JOIN
                            (SELECT A.PLACA_VEICULO                                             AS PLACA_INTERVALO,
                                    MAX(A.DATA_HORA AT TIME ZONE
                                        TZ_UNIDADE(A.COD_UNIDADE)) :: DATE                      AS DATA_ULTIMA_AFERICAO_SULCO,
                                    MAX(A.DATA_HORA AT TIME ZONE
                                        TZ_UNIDADE(A.COD_UNIDADE))                              AS DATA_HORA_ULTIMA_AFERICAO_SULCO,
                                    -- TODO: TENHO DÚVIDAS SOBRE ESSA SUBTRAÇÃO AQUI :thinking_face:
                                    EXTRACT(DAYS FROM F_DATA_HORA_ATUAL_UTC - MAX(A.DATA_HORA)) AS DIAS
                             FROM AFERICAO A
                             WHERE A.TIPO_MEDICAO_COLETADA = 'SULCO'
                                OR A.TIPO_MEDICAO_COLETADA = 'SULCO_PRESSAO'
                             GROUP BY A.PLACA_VEICULO) AS SULCO ON SULCO.PLACA_INTERVALO = V.PLACA
                                JOIN PNEU_RESTRICAO_UNIDADE PRU
                                     ON PRU.COD_UNIDADE = V.COD_UNIDADE
                                JOIN UNIDADE U
                                     ON U.CODIGO = V.COD_UNIDADE
                       WHERE V.STATUS_ATIVO = TRUE
                         AND V.COD_UNIDADE = ANY (F_COD_UNIDADES)
                       ORDER BY U.CODIGO ASC, V.PLACA ASC)

             -- TODOS OS COALESCE FICAM AQUI.
        SELECT D.NOME_UNIDADE                                               AS NOME_UNIDADE,
               D.PLACA_VEICULO                                              AS PLACA_VEICULO,
               COALESCE(D.QTD_PNEUS_APLICADOS, '-')                         AS QTD_PNEUS_APLICADOS,
               D.NOME_MODELO_VEICULO                                        AS NOME_MODELO_VEICULO,
               D.NOME_TIPO_VEICULO                                          AS NOME_TIPO_VEICULO,
               CASE
                   WHEN D.SULCO_NUNCA_AFERIDO
                       THEN 'SULCO NUNCA AFERIDO'
                   WHEN NOT D.PODE_AFERIR_SULCO
                       THEN 'BLOQUEADO AFERIÇÃO'
                   WHEN D.AFERICAO_SULCO_VENCIDA
                       THEN 'VENCIDO'
                   ELSE 'NO PRAZO'
                   END                                                      AS STATUS_SULCO,
               CASE
                   WHEN D.PRESSAO_NUNCA_AFERIDA
                       THEN 'PRESSÃO NUNCA AFERIDA'
                   WHEN NOT D.PODE_AFERIR_PRESSAO
                       THEN 'BLOQUEADO AFERIÇÃO'
                   WHEN D.AFERICAO_PRESSAO_VENCIDA
                       THEN 'VENCIDO'
                   ELSE 'NO PRAZO'
                   END                                                      AS STATUS_PRESSAO,
               F_IF(NOT D.PODE_AFERIR_SULCO OR D.SULCO_NUNCA_AFERIDO,
                    '-',
                    D.DATA_VENCIMENTO_SULCO)                                AS DATA_VENCIMENTO_SULCO,
               F_IF(NOT D.PODE_AFERIR_PRESSAO OR D.PRESSAO_NUNCA_AFERIDA,
                    '-',
                    D.DATA_VENCIMENTO_PRESSAO)                              AS DATA_VENCIMENTO_PRESSAO,
               F_IF(NOT D.PODE_AFERIR_SULCO OR D.SULCO_NUNCA_AFERIDO,
                    '-',
                    D.DIAS_VENCIMENTO_SULCO)                                AS DIAS_VENCIMENTO_SULCO,
               F_IF(NOT D.PODE_AFERIR_PRESSAO OR D.PRESSAO_NUNCA_AFERIDA,
                    '-',
                    D.DIAS_VENCIMENTO_PRESSAO)                              AS DIAS_VENCIMENTO_PRESSAO,
               F_IF(NOT D.PODE_AFERIR_SULCO OR D.SULCO_NUNCA_AFERIDO,
                    '-',
                    D.DIAS_DESDE_ULTIMA_AFERICAO_SULCO)                     AS DIAS_DESDE_ULTIMA_AFERICAO_SULCO,
               D.DATA_HORA_ULTIMA_AFERICAO_SULCO                            AS DATA_HORA_ULTIMA_AFERICAO_SULCO,
               F_IF(NOT D.PODE_AFERIR_PRESSAO OR D.PRESSAO_NUNCA_AFERIDA,
                    '-',
                    D.DIAS_DESDE_ULTIMA_AFERICAO_PRESSAO)                   AS DIAS_DESDE_ULTIMA_AFERICAO_PRESSAO,
               D.DATA_HORA_ULTIMA_AFERICAO_PRESSAO                          AS DATA_HORA_ULTIMA_AFERICAO_PRESSAO,
               TO_CHAR(F_DATA_HORA_GERACAO_RELATORIO, 'DD/MM/YYYY HH24:MI') AS DATA_HORA_GERACAO_RELATORIO
        FROM DADOS D;
END;
$$;

create or replace function suporte.func_veiculo_deleta_veiculo(f_cod_unidade bigint, f_placa character varying,
                                                               OUT dependencias_deletadas text) returns text
    security definer
    language plpgsql
as
$$
DECLARE
    CODIGO_LOOP                   BIGINT;
    LISTA_COD_AFERICAO_PLACA      BIGINT[];
    LISTA_COD_CHECK_PLACA         BIGINT[];
    LISTA_COD_PROLOG_DELETADO_COS BIGINT[];
    NOME_EMPRESA                  VARCHAR(255) := (SELECT E.NOME
                                                   FROM EMPRESA E
                                                   WHERE E.CODIGO =
                                                         (SELECT U.COD_EMPRESA
                                                          FROM UNIDADE U
                                                          WHERE U.CODIGO = F_COD_UNIDADE));
    NOME_UNIDADE                  VARCHAR(255) := (SELECT U.NOME
                                                   FROM UNIDADE U
                                                   WHERE U.CODIGO = F_COD_UNIDADE);
BEGIN
    -- VERIFICA SE UNIDADE EXISTE;
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    -- VERIFICA SE VEÍCULO EXISTE.
    PERFORM FUNC_GARANTE_VEICULO_EXISTE(F_COD_UNIDADE, F_PLACA);

    -- VERIFICA SE VEÍCULO POSSUI PNEU APLICADOS.
    IF EXISTS(SELECT VP.COD_PNEU FROM VEICULO_PNEU VP WHERE VP.PLACA = F_PLACA AND VP.COD_UNIDADE = F_COD_UNIDADE)
    THEN
        RAISE EXCEPTION 'Erro! A Placa: % possui pneus aplicados. Favor removê-los', F_PLACA;
    END IF;

    -- VERIFICA SE PLACA POSSUI AFERIÇÃO.
    IF EXISTS(SELECT A.CODIGO FROM AFERICAO_DATA A WHERE A.PLACA_VEICULO = F_PLACA)
    THEN
        -- COLETAMOS TODOS OS COD_AFERICAO QUE A PLACA POSSUI.
        SELECT ARRAY_AGG(A.CODIGO)
        FROM AFERICAO_DATA A
        WHERE A.PLACA_VEICULO = F_PLACA
        INTO LISTA_COD_AFERICAO_PLACA;

        -- DELETAMOS AFERIÇÃO EM AFERICAO_MANUTENCAO_DATA.
        UPDATE AFERICAO_MANUTENCAO_DATA
        SET DELETADO            = TRUE,
            DATA_HORA_DELETADO  = NOW(),
            PG_USERNAME_DELECAO = SESSION_USER
        WHERE DELETADO = FALSE
          AND COD_AFERICAO = ANY (LISTA_COD_AFERICAO_PLACA);

        -- DELETAMOS AFERIÇÃO EM AFERICAO_VALORES_DATA.
        UPDATE AFERICAO_VALORES_DATA
        SET DELETADO            = TRUE,
            DATA_HORA_DELETADO  = NOW(),
            PG_USERNAME_DELECAO = SESSION_USER
        WHERE DELETADO = FALSE
          AND COD_AFERICAO = ANY (LISTA_COD_AFERICAO_PLACA);

        -- DELETAMOS AFERIÇÃO.
        UPDATE AFERICAO_DATA
        SET DELETADO            = TRUE,
            DATA_HORA_DELETADO  = NOW(),
            PG_USERNAME_DELECAO = SESSION_USER
        WHERE DELETADO = FALSE
          AND CODIGO = ANY (LISTA_COD_AFERICAO_PLACA);
    END IF;

    -- VERIFICA SE PLACA POSSUI CHECKLIST.
    IF EXISTS(SELECT C.PLACA_VEICULO FROM CHECKLIST_DATA C WHERE C.PLACA_VEICULO = F_PLACA)
    THEN
        -- BUSCA TODOS OS CÓDIGO DO CHECKLIST DA PLACA.
        SELECT ARRAY_AGG(C.CODIGO)
        FROM CHECKLIST_DATA C
        WHERE C.PLACA_VEICULO = F_PLACA
        INTO LISTA_COD_CHECK_PLACA;

        -- DELETA COD_CHECK EM COS.
        UPDATE CHECKLIST_ORDEM_SERVICO_DATA
        SET DELETADO            = TRUE,
            DATA_HORA_DELETADO  = NOW(),
            PG_USERNAME_DELECAO = SESSION_USER
        WHERE DELETADO = FALSE
          AND COD_CHECKLIST = ANY (LISTA_COD_CHECK_PLACA);

        -- BUSCO OS CODIGO PROLOG DELETADOS EM COS.
        SELECT ARRAY_AGG(CODIGO_PROLOG)
        FROM CHECKLIST_ORDEM_SERVICO_DATA
        WHERE COD_CHECKLIST = ANY (LISTA_COD_CHECK_PLACA)
          AND COD_UNIDADE = F_COD_UNIDADE
          AND DELETADO IS TRUE
        INTO LISTA_COD_PROLOG_DELETADO_COS;

        -- PARA CADA CÓDIGO PROLOG DELETADO EM COS, DELETAMOS O REFERENTE NA COSI.
        FOREACH CODIGO_LOOP IN ARRAY LISTA_COD_PROLOG_DELETADO_COS
            LOOP
                -- DELETA EM COSI AQUELES QUE FORAM DELETADOS NA COS.
                UPDATE CHECKLIST_ORDEM_SERVICO_ITENS_DATA
                SET DELETADO            = TRUE,
                    DATA_HORA_DELETADO  = NOW(),
                    PG_USERNAME_DELECAO = SESSION_USER
                WHERE DELETADO = FALSE
                  AND (COD_OS, COD_UNIDADE) = (SELECT COS.CODIGO, COS.COD_UNIDADE
                                               FROM CHECKLIST_ORDEM_SERVICO_DATA COS
                                               WHERE COS.CODIGO_PROLOG = CODIGO_LOOP);
            END LOOP;

        -- DELETA TODOS CHECKLIST DA PLACA.
        UPDATE CHECKLIST_DATA
        SET DELETADO            = TRUE,
            DATA_HORA_DELETADO  = NOW(),
            PG_USERNAME_DELECAO = SESSION_USER
        WHERE PLACA_VEICULO = F_PLACA
          AND DELETADO = FALSE
          AND CODIGO = ANY (LISTA_COD_CHECK_PLACA);
    END IF;

    -- REALIZA DELEÇÃO DA PLACA.
    UPDATE VEICULO_DATA
    SET DELETADO            = TRUE,
        DATA_HORA_DELETADO  = NOW(),
        PG_USERNAME_DELECAO = SESSION_USER
    WHERE COD_UNIDADE = F_COD_UNIDADE
      AND PLACA = F_PLACA
      AND DELETADO = FALSE;

    -- MENSAGEM DE SUCESSO.
    SELECT 'Veículo deletado junto com suas dependências. Veículo: '
               || F_PLACA
               || ', Empresa: '
               || NOME_EMPRESA
               || ', Unidade: '
               || NOME_UNIDADE
    INTO DEPENDENCIAS_DELETADAS;
END;
$$;

create or replace function public.func_socorro_rota_relatorio_dados_gerais(f_cod_unidades bigint[], f_data_inicial date,
                                                                           f_data_final date,
                                                                           f_status_socorro_rota character varying[])
    returns TABLE
            (
                "UNIDADE"                                      text,
                "DISTÂNCIA ENTRE UNIDADE E ABERTURA"           text,
                "CÓDIGO SOCORRO ROTA"                          text,
                "STATUS SOCORRO ROTA"                          text,
                "PLACA VEÍCULO ABERTURA"                       text,
                "CÓDIGO COLABORADOR ABERTURA"                  text,
                "NOME RESPONSÁVEL ABERTURA"                    text,
                "KM VEÍCULO COLETADO ABERTURA"                 text,
                "DESCRIÇÃO OPÇÃO PROBLEMA ABERTURA"            text,
                "DESCRIÇÃO FORNECIDA ABERTURA"                 text,
                "PONTO REFERÊNCIA FORNECIDO ABERTURA"          text,
                "DATA/HORA ABERTURA"                           text,
                "LATITUDE ABERTURA"                            text,
                "LONGITUDE ABERTURA"                           text,
                "ENDEREÇO AUTOMÁTICO ABERTURA"                 text,
                "MARCA APARELHO ABERTURA"                      text,
                "MODELO APARELHO ABERTURA"                     text,
                "IMEI APARELHO ABERTURA"                       text,
                "URL FOTO 1 ABERTURA"                          text,
                "URL FOTO 2 ABERTURA"                          text,
                "URL FOTO 3 ABERTURA"                          text,
                "CÓDIGO COLABORADOR ATENDIMENTO"               text,
                "NOME RESPONSÁVEL ATENDIMENTO"                 text,
                "OBSERVAÇÃO ATENDIMENTO"                       text,
                "TEMPO ENTRE ABERTURA/ATENDIMENTO HH:MM:SS"    text,
                "DATA/HORA ATENDIMENTO"                        text,
                "LATITUDE ATENDIMENTO"                         text,
                "LONGITUDE ATENDIMENTO"                        text,
                "ENDEREÇO AUTOMÁTICO ATENDIMENTO"              text,
                "MARCA APARELHO ATENDIMENTO"                   text,
                "MODELO APARELHO ATENDIMENTO"                  text,
                "IMEI APARELHO ATENDIMENTO"                    text,
                "CÓDIGO COLABORADOR INVALIDAÇÃO"               text,
                "NOME RESPONSÁVEL INVALIDAÇÃO"                 text,
                "MOTIVO INVALIDAÇÃO"                           text,
                "TEMPO ENTRE ABERTURA/INVALIDAÇÃO HH:MM:SS"    text,
                "TEMPO ENTRE ATENDIMENTO/INVALIDAÇÃO HH:MM:SS" text,
                "DATA/HORA INVALIDAÇÃO"                        text,
                "LATITUDE INVALIDAÇÃO"                         text,
                "LONGITUDE INVALIDAÇÃO"                        text,
                "ENDEREÇO AUTOMÁTICO INVALIDAÇÃO"              text,
                "MARCA APARELHO INVALIDAÇÃO"                   text,
                "MODELO APARELHO INVALIDAÇÃO"                  text,
                "IMEI APARELHO INVALIDAÇÃO"                    text,
                "URL FOTO 1 INVALIDAÇÃO"                       text,
                "URL FOTO 2 INVALIDAÇÃO"                       text,
                "URL FOTO 3 INVALIDAÇÃO"                       text,
                "CÓDIGO COLABORADOR FINALIZAÇÃO"               text,
                "NOME RESPONSÁVEL FINALIZAÇÃO"                 text,
                "OBSERVAÇÃO FINALIZAÇÃO"                       text,
                "TEMPO ENTRE ATENDIMENTO/FINALIZAÇÃO HH:MM:SS" text,
                "DATA/HORA FINALIZAÇÃO"                        text,
                "LATITUDE FINALIZAÇÃO"                         text,
                "LONGITUDE FINALIZAÇÃO"                        text,
                "ENDEREÇO AUTOMÁTICO FINALIZAÇÃO"              text,
                "MARCA APARELHO FINALIZAÇÃO"                   text,
                "MODELO APARELHO FINALIZAÇÃO"                  text,
                "IMEI APARELHO FINALIZAÇÃO"                    text,
                "URL FOTO 1 FINALIZAÇÃO"                       text,
                "URL FOTO 2 FINALIZAÇÃO"                       text,
                "URL FOTO 3 FINALIZAÇÃO"                       text
            )
    language plpgsql
as
$$
DECLARE
    F_ARRAY_CONTEM_STATUS_ABERTO         BOOLEAN := CASE
                                                        WHEN ('ABERTO' = ANY (F_STATUS_SOCORRO_ROTA))
                                                            THEN TRUE
                                                        ELSE FALSE END;
    F_ARRAY_CONTEM_STATUS_EM_ATENDIMENTO BOOLEAN := CASE
                                                        WHEN ('EM_ATENDIMENTO' = ANY (F_STATUS_SOCORRO_ROTA))
                                                            THEN TRUE
                                                        ELSE FALSE END;
    F_ARRAY_CONTEM_STATUS_FINALIZADO     BOOLEAN := CASE
                                                        WHEN ('FINALIZADO' = ANY (F_STATUS_SOCORRO_ROTA))
                                                            THEN TRUE
                                                        ELSE FALSE END;
    F_ARRAY_CONTEM_STATUS_INVALIDO       BOOLEAN := CASE
                                                        WHEN ('INVALIDO' = ANY (F_STATUS_SOCORRO_ROTA))
                                                            THEN TRUE
                                                        ELSE FALSE END;
BEGIN
    RETURN QUERY
        SELECT U.NOME :: TEXT                                            AS NOME_UNIDADE,
               COALESCE(
                           TRUNC(
                                   (ST_DISTANCE_SPHERE(
                                            ST_POINT(
                                                    LONGITUDE_UNIDADE::REAL,
                                                    LATITUDE_UNIDADE::REAL),
                                            ST_POINT(
                                                    LONGITUDE_ABERTURA::REAL,
                                                    LATITUDE_ABERTURA::REAL)) / 1000)::NUMERIC, 2)::TEXT || ' KM',
                           'Unidade sem localização definida no Prolog') AS DISTANCIA_ENTRE_UNIDADE_ABERTURA,
               COALESCE(SR.CODIGO ::TEXT, '-')                           AS COD_SOCORRO_ROTA,
               COALESCE(SR.STATUS_ATUAL :: TEXT, '-')                    AS STATUS_SOCORRO_ROTA,
               COALESCE(V.PLACA :: TEXT, '-')                            AS PLACA_VEICULO_ABERTURA,
               COALESCE(SRAB.COD_COLABORADOR_ABERTURA :: TEXT, '-')      AS COD_COLABORADOR_ABERTURA,
               COALESCE(CDAB.NOME :: TEXT, '-')                          AS NOME_RESPONSAVEL_ABERTURA,
               COALESCE(SRAB.KM_VEICULO_ABERTURA ::TEXT, '-')            AS KM_VEICULO_COLETADO_ABERTURA,
               COALESCE(SROP.DESCRICAO :: TEXT, '-')                     AS DESCRICAO_OPCAO_PROBLEMA_ABERTURA,
               COALESCE(SRAB.DESCRICAO_PROBLEMA :: TEXT, '-')            AS DESCRICAO_FORNECIDA_ABERTURA,
               COALESCE(SRAB.PONTO_REFERENCIA :: TEXT, '-')              AS PONTO_REFERENCIA_FORNECIDO_ABERTURA,
               COALESCE((SRAB.DATA_HORA_ABERTURA AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)) ::TEXT,
                        '-')                                             AS DATA_HORA_ABERTURA,
               COALESCE(SRAB.LATITUDE_ABERTURA :: TEXT, '-')             AS LATITUDE_ABERTURA,
               COALESCE(SRAB.LONGITUDE_ABERTURA :: TEXT, '-')            AS LONGITUDE_ABERTURA,
               COALESCE(SRAB.ENDERECO_AUTOMATICO :: TEXT, '-')           AS ENDERECO_AUTOMATICO_ABERTURA,
               COALESCE(SRAB.MARCA_DEVICE_ABERTURA :: TEXT, '-')         AS MARCA_APARELHO_ABERTURA,
               COALESCE(SRAB.MODELO_DEVICE_ABERTURA :: TEXT, '-')        AS MODELO_APARELHO_ABERTURA,
               COALESCE(SRAB.DEVICE_IMEI_ABERTURA :: TEXT, '-')          AS IMEI_APARELHO_ABERTURA,
               COALESCE(SRAB.URL_FOTO_1_ABERTURA :: TEXT, '-')           AS URL_FOTO_1_ABERTURA,
               COALESCE(SRAB.URL_FOTO_2_ABERTURA :: TEXT, '-')           AS URL_FOTO_2_ABERTURA,
               COALESCE(SRAB.URL_FOTO_3_ABERTURA :: TEXT, '-')           AS URL_FOTO_3_ABERTURA,
               COALESCE(SRAT.COD_COLABORADOR_ATENDIMENTO :: TEXT, '-')   AS COD_COLABORADOR_ATENDIMENTO,
               COALESCE(CDAT.NOME :: TEXT, '-')                          AS NOME_RESPONSAVEL_ATENDIMENTO,
               COALESCE(SRAT.OBSERVACAO_ATENDIMENTO :: TEXT, '-')        AS OBSERVACAO_ATENDIMENTO,
               COALESCE(FUNC_CONVERTE_INTERVAL_HHMMSS(
                                SRAT.DATA_HORA_ATENDIMENTO - SRAB.DATA_HORA_ABERTURA),
                        '-')                                             AS TEMPO_ABERTURA_ATENDIMENTO,
               COALESCE((SRAT.DATA_HORA_ATENDIMENTO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)) ::TEXT,
                        '-')                                             AS DATA_HORA_ATENDIMENTO,
               COALESCE(SRAT.LATITUDE_ATENDIMENTO :: TEXT, '-')          AS LATITUDE_ATENDIMENTO,
               COALESCE(SRAT.LONGITUDE_ATENDIMENTO :: TEXT, '-')         AS LONGITUDE_ATENDIMENTO,
               COALESCE(SRAT.ENDERECO_AUTOMATICO :: TEXT, '-')           AS ENDERECO_AUTOMATICO_ATENDIMENTO,
               COALESCE(SRAT.MARCA_DEVICE_ATENDIMENTO :: TEXT, '-')      AS MARCA_APARELHO_ATENDIMENTO,
               COALESCE(SRAT.MODELO_DEVICE_ATENDIMENTO :: TEXT, '-')     AS MODELO_APARELHO_ATENDIMENTO,
               COALESCE(SRAT.DEVICE_IMEI_ATENDIMENTO :: TEXT, '-')       AS IMEI_APARELHO_ATENDIMENTO,
               COALESCE(SRI.COD_COLABORADOR_INVALIDACAO :: TEXT, '-')    AS COD_COLABORADOR_INVALIDACAO,
               COALESCE(CDI.NOME :: TEXT, '-')                           AS NOME_RESPONSAVEL_INVALIDACAO,
               COALESCE(SRI.MOTIVO_INVALIDACAO :: TEXT, '-')             AS MOTIVO_INVALIDACAO,
               COALESCE(CASE
                            WHEN (SRAT.DATA_HORA_ATENDIMENTO IS NULL)
                                THEN FUNC_CONVERTE_INTERVAL_HHMMSS(
                                    SRI.DATA_HORA_INVALIDACAO - SRAB.DATA_HORA_ABERTURA)
                            ELSE '-'
                            END,
                        '-')                                             AS TEMPO_ABERTURA_INVALIDACAO,
               COALESCE(CASE
                            WHEN (SRAT.DATA_HORA_ATENDIMENTO IS NOT NULL)
                                THEN FUNC_CONVERTE_INTERVAL_HHMMSS(
                                    SRI.DATA_HORA_INVALIDACAO - SRAT.DATA_HORA_ATENDIMENTO)
                            ELSE '-'
                            END,
                        '-')                                             AS TEMPO_ATENDIMENTO_INVALIDACAO,
               COALESCE((SRI.DATA_HORA_INVALIDACAO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)) ::TEXT,
                        '-')                                             AS DATA_HORA_INVALIDACAO,
               COALESCE(SRI.LATITUDE_INVALIDACAO :: TEXT, '-')           AS LATITUDE_INVALIDACAO,
               COALESCE(SRI.LONGITUDE_INVALIDACAO :: TEXT, '-')          AS LONGITUDE_INVALIDACAO,
               COALESCE(SRI.ENDERECO_AUTOMATICO :: TEXT, '-')            AS ENDERECO_AUTOMATICO_INVALIDACAO,
               COALESCE(SRI.MARCA_DEVICE_INVALIDACAO :: TEXT, '-')       AS MARCA_APARELHO_INVALIDACAO,
               COALESCE(SRI.MODELO_DEVICE_INVALIDACAO :: TEXT, '-')      AS MODELO_APARELHO_INVALIDACAO,
               COALESCE(SRI.DEVICE_IMEI_INVALIDACAO :: TEXT, '-')        AS IMEI_APARELHO_INVALIDACAO,
               COALESCE(SRI.URL_FOTO_1_INVALIDACAO :: TEXT, '-')         AS URL_FOTO_1_INVALIDACAO,
               COALESCE(SRI.URL_FOTO_2_INVALIDACAO :: TEXT, '-')         AS URL_FOTO_2_INVALIDACAO,
               COALESCE(SRI.URL_FOTO_3_INVALIDACAO :: TEXT, '-')         AS URL_FOTO_3_INVALIDACAO,
               COALESCE(SRF.COD_COLABORADOR_FINALIZACAO :: TEXT, '-')    AS COD_COLABORADOR_FINALIZACAO,
               COALESCE(CDF.NOME :: TEXT, '-')                           AS NOME_RESPONSAVEL_FINALIZACAO,
               COALESCE(SRF.OBSERVACAO_FINALIZACAO :: TEXT, '-')         AS OBSERVACAO_FINALIZACAO,
               COALESCE(FUNC_CONVERTE_INTERVAL_HHMMSS(
                                SRF.DATA_HORA_FINALIZACAO - SRAT.DATA_HORA_ATENDIMENTO),
                        '-')                                             AS TEMPO_ATENDIMENTO_FINALIZACAO,
               COALESCE((SRF.DATA_HORA_FINALIZACAO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)) ::TEXT,
                        '-')                                             AS DATA_HORA_FINALIZACAO,
               COALESCE(SRF.LATITUDE_FINALIZACAO :: TEXT, '-')           AS LATITUDE_FINALIZACAO,
               COALESCE(SRF.LONGITUDE_FINALIZACAO :: TEXT, '-')          AS LONGITUDE_FINALIZACAO,
               COALESCE(SRF.ENDERECO_AUTOMATICO :: TEXT, '-')            AS ENDERECO_AUTOMATICO_FINALIZACAO,
               COALESCE(SRF.MARCA_DEVICE_FINALIZACAO :: TEXT, '-')       AS MARCA_APARELHO_FINALIZACAO,
               COALESCE(SRF.MODELO_DEVICE_FINALIZACAO :: TEXT, '-')      AS MODELO_APARELHO_FINALIZACAO,
               COALESCE(SRF.DEVICE_IMEI_FINALIZACAO :: TEXT, '-')        AS IMEI_APARELHO_FINALIZACAO,
               COALESCE(SRF.URL_FOTO_1_FINALIZACAO :: TEXT, '-')         AS URL_FOTO_1_FINALIZACAO,
               COALESCE(SRF.URL_FOTO_2_FINALIZACAO :: TEXT, '-')         AS URL_FOTO_2_FINALIZACAO,
               COALESCE(SRF.URL_FOTO_3_FINALIZACAO :: TEXT, '-')         AS URL_FOTO_3_FINALIZACAO
        FROM SOCORRO_ROTA SR
                 JOIN UNIDADE U ON SR.COD_UNIDADE = U.CODIGO
                 JOIN SOCORRO_ROTA_ABERTURA SRAB ON SR.
                                                        CODIGO = SRAB.COD_SOCORRO_ROTA
                 JOIN VEICULO_DATA V ON V.
                                            CODIGO = SRAB.COD_VEICULO_PROBLEMA
                 JOIN COLABORADOR_DATA CDAB ON CDAB.
                                                   CODIGO = SRAB.COD_COLABORADOR_ABERTURA
                 JOIN SOCORRO_ROTA_OPCAO_PROBLEMA SROP ON SROP.
                                                              CODIGO = SRAB.COD_PROBLEMA_SOCORRO_ROTA
                 LEFT JOIN SOCORRO_ROTA_ATENDIMENTO SRAT
                           ON SR.STATUS_ATUAL::
                                  TEXT = ANY
                              (ARRAY ['EM_ATENDIMENTO', 'INVALIDO', 'FINALIZADO'])
                               AND
                              SR.
                                  CODIGO = SRAT.COD_SOCORRO_ROTA
                 LEFT JOIN COLABORADOR_DATA CDAT
                           ON SR.STATUS_ATUAL::
                                  TEXT = ANY
                              (ARRAY ['EM_ATENDIMENTO', 'INVALIDO', 'FINALIZADO'])
                               AND
                              CDAT.
                                  CODIGO = SRAT.COD_COLABORADOR_ATENDIMENTO
                 LEFT JOIN SOCORRO_ROTA_INVALIDACAO SRI
                           ON SR.
                                  STATUS_ATUAL = 'INVALIDO' AND SR.CODIGO = SRI.COD_SOCORRO_ROTA
                 LEFT JOIN COLABORADOR_DATA CDI
                           ON SR.
                                  STATUS_ATUAL = 'INVALIDO' AND CDI.CODIGO = SRI.COD_COLABORADOR_INVALIDACAO
                 LEFT JOIN SOCORRO_ROTA_FINALIZACAO SRF
                           ON SR.
                                  STATUS_ATUAL = 'FINALIZADO' AND SR.CODIGO = SRF.COD_SOCORRO_ROTA
                 LEFT JOIN COLABORADOR_DATA CDF
                           ON SR.
                                  STATUS_ATUAL = 'FINALIZADO' AND CDF.CODIGO = SRF.COD_COLABORADOR_FINALIZACAO
        WHERE SR.COD_UNIDADE = ANY (F_COD_UNIDADES)
            AND F_IF(F_ARRAY_CONTEM_STATUS_ABERTO,
                     (SRAB.DATA_HORA_ABERTURA AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE))::DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL,
                     FALSE)
           OR F_IF(F_ARRAY_CONTEM_STATUS_EM_ATENDIMENTO,
                   (SRAT.DATA_HORA_ATENDIMENTO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE))::DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL,
                   FALSE)
           OR F_IF(F_ARRAY_CONTEM_STATUS_FINALIZADO,
                   (SRF.DATA_HORA_FINALIZACAO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE))::DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL,
                   FALSE)
           OR F_IF(F_ARRAY_CONTEM_STATUS_INVALIDO,
                   (SRI.DATA_HORA_INVALIDACAO AT TIME ZONE TZ_UNIDADE(SR.COD_UNIDADE)):: DATE BETWEEN F_DATA_INICIAL AND F_DATA_FINAL,
                   FALSE);
END ;
$$;

create or replace function suporte.func_unidade_altera_latitude_longitude(f_cod_unidade bigint, f_latitude_unidade text,
                                                                          f_longitude_unidade text,
                                                                          OUT aviso text) returns text
    security definer
    language plpgsql
as
$$
BEGIN
    PERFORM FUNC_GARANTE_UNIDADE_EXISTE(F_COD_UNIDADE);

    UPDATE UNIDADE
    SET latitude_unidade  = F_LATITUDE_UNIDADE,
        longitude_unidade = F_LONGITUDE_UNIDADE
    WHERE codigo = F_COD_UNIDADE;

    SELECT 'LATITUDE E LONGITUDE DA UNIDADE '
               || (SELECT U.NOME FROM UNIDADE U WHERE U.CODIGO = F_COD_UNIDADE)
               || ', CÓDIGO UNIDADE: '
               || F_COD_UNIDADE
               || ' ALTERADAS.'
    INTO AVISO;
END ;
$$;


